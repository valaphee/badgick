#![doc = "Peripheral access API for CH583SFR microcontrollers (generated using svd2rust v0.36.1 (untracked))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next] svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.36.1/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 2;
#[doc = r" Interrupt numbers, priority levels, and HART IDs."]
pub mod interrupt {
    #[doc = r" Core interrupts. These interrupts are handled by the core itself."]
    #[riscv :: pac_enum (unsafe CoreInterruptNumber)]
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum CoreInterrupt {
        #[doc = "2 - NonMaskable"]
        NonMaskable = 2,
        #[doc = "3 - Exception"]
        Exception = 3,
        #[doc = "5 - MachineEnvCall"]
        MachineEnvCall = 5,
        #[doc = "8 - UserEnvCall"]
        UserEnvCall = 8,
        #[doc = "9 - Breakpoint"]
        Breakpoint = 9,
        #[doc = "12 - SysTick"]
        SysTick = 12,
        #[doc = "14 - Software"]
        Software = 14,
    }
    pub use riscv::interrupt::Exception;
    #[doc = r" Priority levels in the device"]
    #[riscv :: pac_enum (unsafe PriorityNumber)]
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum Priority {
        #[doc = "0 - P0"]
        P0 = 0,
        #[doc = "16 - P1"]
        P1 = 16,
        #[doc = "32 - P2"]
        P2 = 32,
        #[doc = "48 - P3"]
        P3 = 48,
        #[doc = "64 - P4"]
        P4 = 64,
        #[doc = "80 - P5"]
        P5 = 80,
        #[doc = "96 - P6"]
        P6 = 96,
        #[doc = "112 - P7"]
        P7 = 112,
        #[doc = "128 - P8"]
        P8 = 128,
        #[doc = "144 - P9"]
        P9 = 144,
        #[doc = "160 - P10"]
        P10 = 160,
        #[doc = "176 - P11"]
        P11 = 176,
        #[doc = "192 - P12"]
        P12 = 192,
        #[doc = "208 - P13"]
        P13 = 208,
        #[doc = "224 - P14"]
        P14 = 224,
        #[doc = "240 - P15"]
        P15 = 240,
    }
    pub use riscv::{
        interrupt::{disable, enable, free, nested},
        ExceptionNumber, HartIdNumber, InterruptNumber, PriorityNumber,
    };
    pub type Trap = riscv::interrupt::Trap<CoreInterrupt, Exception>;
    #[doc = r" Retrieves the cause of a trap in the current hart."]
    #[doc = r""]
    #[doc = r" If the raw cause is not a valid interrupt or exception for the target, it returns an error."]
    #[inline]
    pub fn try_cause() -> riscv::result::Result<Trap> {
        riscv::interrupt::try_cause()
    }
    #[doc = r" Retrieves the cause of a trap in the current hart (machine mode)."]
    #[doc = r""]
    #[doc = r" If the raw cause is not a valid interrupt or exception for the target, it panics."]
    #[inline]
    pub fn cause() -> Trap {
        try_cause().unwrap()
    }
    #[doc = r" External interrupts. These interrupts are handled by the external peripherals."]
    #[riscv :: pac_enum (unsafe ExternalInterruptNumber)]
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum ExternalInterrupt {
        #[doc = "16 - TMR0_IRQHandler"]
        TMR0 = 16,
        #[doc = "17 - GPIO_IRQHandler"]
        GPIOA = 17,
        #[doc = "18 - GPIO_IRQHandler"]
        GPIOB = 18,
        #[doc = "19 - SPI0_IRQHandler"]
        SPI0 = 19,
        #[doc = "20 - BB_IRQHandler"]
        BLEB = 20,
        #[doc = "21 - LLE_IRQHandler"]
        BLEL = 21,
        #[doc = "22 - USB_IRQHandler"]
        USB = 22,
        #[doc = "23 - USB2_IRQHandler"]
        USB2 = 23,
        #[doc = "24 - TMR1_IRQHandler"]
        TMR1 = 24,
        #[doc = "25 - TMR2_IRQHandler"]
        TMR2 = 25,
        #[doc = "26 - UART0_IRQHandler"]
        UART0 = 26,
        #[doc = "27 - UART1_IRQHandler"]
        UART1 = 27,
        #[doc = "28 - RTC_IRQHandler"]
        RTC = 28,
        #[doc = "29 - ADC_IRQHandler"]
        ADC = 29,
        #[doc = "30 - I2C_IRQHandler"]
        I2C = 30,
        #[doc = "31 - PPWMX_SPI1_IRQHandler"]
        PWMx = 31,
        #[doc = "32 - TMR3_IRQHandler"]
        TMR3 = 32,
        #[doc = "33 - UART1_IRQHandler"]
        UART2 = 33,
        #[doc = "34 - UART3_IRQHandler"]
        UART3 = 34,
        #[doc = "35 - WDT_IRQHandler"]
        WDOG_BAT = 35,
    }
}
#[doc = "System Control Register"]
pub type Sys = crate::Periph<sys::RegisterBlock, 0x4000_1000>;
impl core::fmt::Debug for Sys {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sys").finish()
    }
}
#[doc = "System Control Register"]
pub mod sys {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x08],
        clk_sys_cfg: ClkSysCfg,
        hfck_pwr_ctrl: HfckPwrCtrl,
        _reserved2: [u8; 0x01],
        slp_clk_off0: SlpClkOff0,
        slp_clk_off1: SlpClkOff1,
        slp_wake_ctrl: SlpWakeCtrl,
        slp_power_ctrl: SlpPowerCtrl,
        _reserved6: [u8; 0x08],
        pin_alternate: PinAlternate,
        pin_analog_ie: PinAnalogIe,
        _reserved8: [u8; 0x04],
        power_plan: PowerPlan,
        aux_power_adj: AuxPowerAdj,
        _reserved10: [u8; 0x01],
        bat_det_ctrl: BatDetCtrl,
        bat_det_cfg: BatDetCfg,
        bat_status: BatStatus,
        _reserved13: [u8; 0x05],
        int32k_tune: Int32kTune,
        xt32k_tune: Xt32kTune,
        ck32k_config: Ck32kConfig,
        rtc_flag_ctrl: RtcFlagCtrl,
        rtc_mode_ctrl: RtcModeCtrl,
        _reserved18: [u8; 0x02],
        rtc_trig: RtcTrig,
        rtc_cnt_32k: RtcCnt32k,
        rtc_cnt_2s: RtcCnt2s,
        rtc_cnt_day: RtcCntDay,
        safe_access_sig: SafeAccessSig,
        chip_id: ChipId,
        safe_access_id: SafeAccessId,
        wdog_count: WdogCount,
        reset_status_r8_glob_rom_cfg: ResetStatusR8GlobRomCfg,
        glob_cfg_info: GlobCfgInfo,
        rst_wdog_ctrl: RstWdogCtrl,
        glob_reset_keep: GlobResetKeep,
        _reserved30: [u8; 0x03],
        pll_config: PllConfig,
        _reserved31: [u8; 0x02],
        xt32m_tune: Xt32mTune,
        _reserved32: [u8; 0x01],
        osc_cal_cnt: OscCalCnt,
        osc_cal_ov_cnt: OscCalOvCnt,
        osc_cal_ctrl: OscCalCtrl,
        tkey_count: TkeyCount,
        _reserved36: [u8; 0x01],
        tkey_convert: TkeyConvert,
        tkey_cfg: TkeyCfg,
        _reserved38: [u8; 0x07af],
        flash_cfg: FlashCfg,
    }
    impl RegisterBlock {
        #[doc = "0x08 - RWA, system clock configuration, SAM"]
        #[inline(always)]
        pub const fn clk_sys_cfg(&self) -> &ClkSysCfg {
            &self.clk_sys_cfg
        }
        #[doc = "0x0a - RWA, high frequency clock module power control, SAM"]
        #[inline(always)]
        pub const fn hfck_pwr_ctrl(&self) -> &HfckPwrCtrl {
            &self.hfck_pwr_ctrl
        }
        #[doc = "0x0c - RWA, sleep clock off control byte 0, SAM"]
        #[inline(always)]
        pub const fn slp_clk_off0(&self) -> &SlpClkOff0 {
            &self.slp_clk_off0
        }
        #[doc = "0x0d - RWA, sleep clock off control byte 1, SAM"]
        #[inline(always)]
        pub const fn slp_clk_off1(&self) -> &SlpClkOff1 {
            &self.slp_clk_off1
        }
        #[doc = "0x0e - RWA, wake control, SAM"]
        #[inline(always)]
        pub const fn slp_wake_ctrl(&self) -> &SlpWakeCtrl {
            &self.slp_wake_ctrl
        }
        #[doc = "0x0f - RWA, peripherals power down control, SAM"]
        #[inline(always)]
        pub const fn slp_power_ctrl(&self) -> &SlpPowerCtrl {
            &self.slp_power_ctrl
        }
        #[doc = "0x18 - RW, function pin alternate configuration"]
        #[inline(always)]
        pub const fn pin_alternate(&self) -> &PinAlternate {
            &self.pin_alternate
        }
        #[doc = "0x1a - RW, analog pin enable and digital input disable"]
        #[inline(always)]
        pub const fn pin_analog_ie(&self) -> &PinAnalogIe {
            &self.pin_analog_ie
        }
        #[doc = "0x20 - RWA, power plan before sleep instruction, SAM"]
        #[inline(always)]
        pub const fn power_plan(&self) -> &PowerPlan {
            &self.power_plan
        }
        #[doc = "0x22 - RWA, aux power adjust control, SAM"]
        #[inline(always)]
        pub const fn aux_power_adj(&self) -> &AuxPowerAdj {
            &self.aux_power_adj
        }
        #[doc = "0x24 - RWA, battery voltage detector control, SAM"]
        #[inline(always)]
        pub const fn bat_det_ctrl(&self) -> &BatDetCtrl {
            &self.bat_det_ctrl
        }
        #[doc = "0x25 - RWA, battery voltage detector configuration, SAM"]
        #[inline(always)]
        pub const fn bat_det_cfg(&self) -> &BatDetCfg {
            &self.bat_det_cfg
        }
        #[doc = "0x26 - RO, battery status"]
        #[inline(always)]
        pub const fn bat_status(&self) -> &BatStatus {
            &self.bat_status
        }
        #[doc = "0x2c - RWA, internal 32KHz oscillator tune control, SAM"]
        #[inline(always)]
        pub const fn int32k_tune(&self) -> &Int32kTune {
            &self.int32k_tune
        }
        #[doc = "0x2e - RWA, external 32KHz oscillator tune control, SAM"]
        #[inline(always)]
        pub const fn xt32k_tune(&self) -> &Xt32kTune {
            &self.xt32k_tune
        }
        #[doc = "0x2f - RWA, 32KHz oscillator configure"]
        #[inline(always)]
        pub const fn ck32k_config(&self) -> &Ck32kConfig {
            &self.ck32k_config
        }
        #[doc = "0x30 - RW, RTC flag and clear control"]
        #[inline(always)]
        pub const fn rtc_flag_ctrl(&self) -> &RtcFlagCtrl {
            &self.rtc_flag_ctrl
        }
        #[doc = "0x31 - RWA, RTC mode control, SAM"]
        #[inline(always)]
        pub const fn rtc_mode_ctrl(&self) -> &RtcModeCtrl {
            &self.rtc_mode_ctrl
        }
        #[doc = "0x34 - RWA, RTC trigger value, SAM"]
        #[inline(always)]
        pub const fn rtc_trig(&self) -> &RtcTrig {
            &self.rtc_trig
        }
        #[doc = "0x38 - RO, RTC count based 32KHz"]
        #[inline(always)]
        pub const fn rtc_cnt_32k(&self) -> &RtcCnt32k {
            &self.rtc_cnt_32k
        }
        #[doc = "0x3a - RO, RTC count based 2 second"]
        #[inline(always)]
        pub const fn rtc_cnt_2s(&self) -> &RtcCnt2s {
            &self.rtc_cnt_2s
        }
        #[doc = "0x3c - RO, RTC count based one day, only low 14 bit"]
        #[inline(always)]
        pub const fn rtc_cnt_day(&self) -> &RtcCntDay {
            &self.rtc_cnt_day
        }
        #[doc = "0x40 - WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode"]
        #[inline(always)]
        pub const fn safe_access_sig(&self) -> &SafeAccessSig {
            &self.safe_access_sig
        }
        #[doc = "0x41 - RF, chip ID register, always is ID_CH58*"]
        #[inline(always)]
        pub const fn chip_id(&self) -> &ChipId {
            &self.chip_id
        }
        #[doc = "0x42 - RF, safe accessing ID register, always 0x0C"]
        #[inline(always)]
        pub const fn safe_access_id(&self) -> &SafeAccessId {
            &self.safe_access_id
        }
        #[doc = "0x43 - RW, watch-dog count, count by clock frequency Fsys/131072"]
        #[inline(always)]
        pub const fn wdog_count(&self) -> &WdogCount {
            &self.wdog_count
        }
        #[doc = "0x44 - RWA, reset status, SAM or flash ROM configuration"]
        #[inline(always)]
        pub const fn reset_status_r8_glob_rom_cfg(&self) -> &ResetStatusR8GlobRomCfg {
            &self.reset_status_r8_glob_rom_cfg
        }
        #[doc = "0x45 - RO, global configuration information and status"]
        #[inline(always)]
        pub const fn glob_cfg_info(&self) -> &GlobCfgInfo {
            &self.glob_cfg_info
        }
        #[doc = "0x46 - RWA, reset and watch-dog control, SAM"]
        #[inline(always)]
        pub const fn rst_wdog_ctrl(&self) -> &RstWdogCtrl {
            &self.rst_wdog_ctrl
        }
        #[doc = "0x47 - RW, value keeper during global reset"]
        #[inline(always)]
        pub const fn glob_reset_keep(&self) -> &GlobResetKeep {
            &self.glob_reset_keep
        }
        #[doc = "0x4b - RWA, PLL configuration control, SAM"]
        #[inline(always)]
        pub const fn pll_config(&self) -> &PllConfig {
            &self.pll_config
        }
        #[doc = "0x4e - RWA, external 32MHz oscillator tune control, SAM"]
        #[inline(always)]
        pub const fn xt32m_tune(&self) -> &Xt32mTune {
            &self.xt32m_tune
        }
        #[doc = "0x50 - RO, system clock count value for 32KHz multi-cycles"]
        #[inline(always)]
        pub const fn osc_cal_cnt(&self) -> &OscCalCnt {
            &self.osc_cal_cnt
        }
        #[doc = "0x52 - RO, oscillator frequency calibration overflow times"]
        #[inline(always)]
        pub const fn osc_cal_ov_cnt(&self) -> &OscCalOvCnt {
            &self.osc_cal_ov_cnt
        }
        #[doc = "0x53 - RWA, oscillator frequency calibration control, SAM"]
        #[inline(always)]
        pub const fn osc_cal_ctrl(&self) -> &OscCalCtrl {
            &self.osc_cal_ctrl
        }
        #[doc = "0x54 - RW, Touchkey charge and discharge count"]
        #[inline(always)]
        pub const fn tkey_count(&self) -> &TkeyCount {
            &self.tkey_count
        }
        #[doc = "0x56 - RW, Touchkey convert start control"]
        #[inline(always)]
        pub const fn tkey_convert(&self) -> &TkeyConvert {
            &self.tkey_convert
        }
        #[doc = "0x57 - RW, Touchkey configure"]
        #[inline(always)]
        pub const fn tkey_cfg(&self) -> &TkeyCfg {
            &self.tkey_cfg
        }
        #[doc = "0x807 - Flash configuration"]
        #[inline(always)]
        pub const fn flash_cfg(&self) -> &FlashCfg {
            &self.flash_cfg
        }
    }
    #[doc = "CLK_SYS_CFG (rw) register accessor: RWA, system clock configuration, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_sys_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_sys_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clk_sys_cfg`] module"]
    #[doc(alias = "CLK_SYS_CFG")]
    pub type ClkSysCfg = crate::Reg<clk_sys_cfg::ClkSysCfgSpec>;
    #[doc = "RWA, system clock configuration, SAM"]
    pub mod clk_sys_cfg {
        #[doc = "Register `CLK_SYS_CFG` reader"]
        pub type R = crate::R<ClkSysCfgSpec>;
        #[doc = "Register `CLK_SYS_CFG` writer"]
        pub type W = crate::W<ClkSysCfgSpec>;
        #[doc = "Field `CLK_PLL_DIV` reader - RWA, output clock divider from PLL or CK32M"]
        pub type ClkPllDivR = crate::FieldReader;
        #[doc = "Field `CLK_PLL_DIV` writer - RWA, output clock divider from PLL or CK32M"]
        pub type ClkPllDivW<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        #[doc = "Field `CLK_SYS_MOD` reader - RWA, system clock source mode: 00=divided from 32MHz, 01=divided from PLL-480MHz, 10=directly from 32MHz, 11=directly from 32KHz"]
        pub type ClkSysModR = crate::FieldReader;
        #[doc = "Field `CLK_SYS_MOD` writer - RWA, system clock source mode: 00=divided from 32MHz, 01=divided from PLL-480MHz, 10=directly from 32MHz, 11=directly from 32KHz"]
        pub type ClkSysModW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            #[doc = "Bits 0:4 - RWA, output clock divider from PLL or CK32M"]
            #[inline(always)]
            pub fn clk_pll_div(&self) -> ClkPllDivR {
                ClkPllDivR::new((self.bits & 0x1f) as u8)
            }
            #[doc = "Bits 6:7 - RWA, system clock source mode: 00=divided from 32MHz, 01=divided from PLL-480MHz, 10=directly from 32MHz, 11=directly from 32KHz"]
            #[inline(always)]
            pub fn clk_sys_mod(&self) -> ClkSysModR {
                ClkSysModR::new(((self.bits >> 6) & 3) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:4 - RWA, output clock divider from PLL or CK32M"]
            #[inline(always)]
            pub fn clk_pll_div(&mut self) -> ClkPllDivW<ClkSysCfgSpec> {
                ClkPllDivW::new(self, 0)
            }
            #[doc = "Bits 6:7 - RWA, system clock source mode: 00=divided from 32MHz, 01=divided from PLL-480MHz, 10=directly from 32MHz, 11=directly from 32KHz"]
            #[inline(always)]
            pub fn clk_sys_mod(&mut self) -> ClkSysModW<ClkSysCfgSpec> {
                ClkSysModW::new(self, 6)
            }
        }
        #[doc = "RWA, system clock configuration, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_sys_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_sys_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ClkSysCfgSpec;
        impl crate::RegisterSpec for ClkSysCfgSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`clk_sys_cfg::R`](R) reader structure"]
        impl crate::Readable for ClkSysCfgSpec {}
        #[doc = "`write(|w| ..)` method takes [`clk_sys_cfg::W`](W) writer structure"]
        impl crate::Writable for ClkSysCfgSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CLK_SYS_CFG to value 0x05"]
        impl crate::Resettable for ClkSysCfgSpec {
            const RESET_VALUE: u16 = 0x05;
        }
    }
    #[doc = "HFCK_PWR_CTRL (rw) register accessor: RWA, high frequency clock module power control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`hfck_pwr_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`hfck_pwr_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hfck_pwr_ctrl`] module"]
    #[doc(alias = "HFCK_PWR_CTRL")]
    pub type HfckPwrCtrl = crate::Reg<hfck_pwr_ctrl::HfckPwrCtrlSpec>;
    #[doc = "RWA, high frequency clock module power control, SAM"]
    pub mod hfck_pwr_ctrl {
        #[doc = "Register `HFCK_PWR_CTRL` reader"]
        pub type R = crate::R<HfckPwrCtrlSpec>;
        #[doc = "Register `HFCK_PWR_CTRL` writer"]
        pub type W = crate::W<HfckPwrCtrlSpec>;
        #[doc = "Field `CLK_XT32M_PON` reader - RWA, external 32MHz oscillator power control: 0=power down, 1-power on"]
        pub type ClkXt32mPonR = crate::BitReader;
        #[doc = "Field `CLK_XT32M_PON` writer - RWA, external 32MHz oscillator power control: 0=power down, 1-power on"]
        pub type ClkXt32mPonW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CLK_XT32M_KEEP` reader - RWA, external 32MHz oscillator power keep under halt mode: 0=auto stop, 1=keep running"]
        pub type ClkXt32mKeepR = crate::BitReader;
        #[doc = "Field `CLK_XT32M_KEEP` writer - RWA, external 32MHz oscillator power keep under halt mode: 0=auto stop, 1=keep running"]
        pub type ClkXt32mKeepW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CLK_PLL_PON` reader - RWA, PLL power control: 0=power down, 1-power on"]
        pub type ClkPllPonR = crate::BitReader;
        #[doc = "Field `CLK_PLL_PON` writer - RWA, PLL power control: 0=power down, 1-power on"]
        pub type ClkPllPonW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 2 - RWA, external 32MHz oscillator power control: 0=power down, 1-power on"]
            #[inline(always)]
            pub fn clk_xt32m_pon(&self) -> ClkXt32mPonR {
                ClkXt32mPonR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RWA, external 32MHz oscillator power keep under halt mode: 0=auto stop, 1=keep running"]
            #[inline(always)]
            pub fn clk_xt32m_keep(&self) -> ClkXt32mKeepR {
                ClkXt32mKeepR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RWA, PLL power control: 0=power down, 1-power on"]
            #[inline(always)]
            pub fn clk_pll_pon(&self) -> ClkPllPonR {
                ClkPllPonR::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 2 - RWA, external 32MHz oscillator power control: 0=power down, 1-power on"]
            #[inline(always)]
            pub fn clk_xt32m_pon(&mut self) -> ClkXt32mPonW<HfckPwrCtrlSpec> {
                ClkXt32mPonW::new(self, 2)
            }
            #[doc = "Bit 3 - RWA, external 32MHz oscillator power keep under halt mode: 0=auto stop, 1=keep running"]
            #[inline(always)]
            pub fn clk_xt32m_keep(&mut self) -> ClkXt32mKeepW<HfckPwrCtrlSpec> {
                ClkXt32mKeepW::new(self, 3)
            }
            #[doc = "Bit 4 - RWA, PLL power control: 0=power down, 1-power on"]
            #[inline(always)]
            pub fn clk_pll_pon(&mut self) -> ClkPllPonW<HfckPwrCtrlSpec> {
                ClkPllPonW::new(self, 4)
            }
        }
        #[doc = "RWA, high frequency clock module power control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`hfck_pwr_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`hfck_pwr_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct HfckPwrCtrlSpec;
        impl crate::RegisterSpec for HfckPwrCtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`hfck_pwr_ctrl::R`](R) reader structure"]
        impl crate::Readable for HfckPwrCtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`hfck_pwr_ctrl::W`](W) writer structure"]
        impl crate::Writable for HfckPwrCtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets HFCK_PWR_CTRL to value 0x14"]
        impl crate::Resettable for HfckPwrCtrlSpec {
            const RESET_VALUE: u8 = 0x14;
        }
    }
    #[doc = "SLP_CLK_OFF0 (rw) register accessor: RWA, sleep clock off control byte 0, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`slp_clk_off0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slp_clk_off0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@slp_clk_off0`] module"]
    #[doc(alias = "SLP_CLK_OFF0")]
    pub type SlpClkOff0 = crate::Reg<slp_clk_off0::SlpClkOff0Spec>;
    #[doc = "RWA, sleep clock off control byte 0, SAM"]
    pub mod slp_clk_off0 {
        #[doc = "Register `SLP_CLK_OFF0` reader"]
        pub type R = crate::R<SlpClkOff0Spec>;
        #[doc = "Register `SLP_CLK_OFF0` writer"]
        pub type W = crate::W<SlpClkOff0Spec>;
        #[doc = "Field `SLP_CLK_TMR0` reader - RWA, close TMR0 clock"]
        pub type SlpClkTmr0R = crate::BitReader;
        #[doc = "Field `SLP_CLK_TMR0` writer - RWA, close TMR0 clock"]
        pub type SlpClkTmr0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SLP_CLK_TMR1` reader - RWA, close TMR1 clock"]
        pub type SlpClkTmr1R = crate::BitReader;
        #[doc = "Field `SLP_CLK_TMR1` writer - RWA, close TMR1 clock"]
        pub type SlpClkTmr1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SLP_CLK_TMR2` reader - RWA, close TMR2 clock"]
        pub type SlpClkTmr2R = crate::BitReader;
        #[doc = "Field `SLP_CLK_TMR2` writer - RWA, close TMR2 clock"]
        pub type SlpClkTmr2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SLP_CLK_TMR3` reader - RWA, close TMR3 clock"]
        pub type SlpClkTmr3R = crate::BitReader;
        #[doc = "Field `SLP_CLK_TMR3` writer - RWA, close TMR3 clock"]
        pub type SlpClkTmr3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SLP_CLK_UART0` reader - RWA, close UART0 clock"]
        pub type SlpClkUart0R = crate::BitReader;
        #[doc = "Field `SLP_CLK_UART0` writer - RWA, close UART0 clock"]
        pub type SlpClkUart0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SLP_CLK_UART1` reader - RWA, close UART1 clock"]
        pub type SlpClkUart1R = crate::BitReader;
        #[doc = "Field `SLP_CLK_UART1` writer - RWA, close UART1 clock"]
        pub type SlpClkUart1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SLP_CLK_UART2` reader - RWA, close UART2 clock"]
        pub type SlpClkUart2R = crate::BitReader;
        #[doc = "Field `SLP_CLK_UART2` writer - RWA, close UART2 clock"]
        pub type SlpClkUart2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SLP_CLK_UART3` reader - RWA, close UART3 clock"]
        pub type SlpClkUart3R = crate::BitReader;
        #[doc = "Field `SLP_CLK_UART3` writer - RWA, close UART3 clock"]
        pub type SlpClkUart3W<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RWA, close TMR0 clock"]
            #[inline(always)]
            pub fn slp_clk_tmr0(&self) -> SlpClkTmr0R {
                SlpClkTmr0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RWA, close TMR1 clock"]
            #[inline(always)]
            pub fn slp_clk_tmr1(&self) -> SlpClkTmr1R {
                SlpClkTmr1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RWA, close TMR2 clock"]
            #[inline(always)]
            pub fn slp_clk_tmr2(&self) -> SlpClkTmr2R {
                SlpClkTmr2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RWA, close TMR3 clock"]
            #[inline(always)]
            pub fn slp_clk_tmr3(&self) -> SlpClkTmr3R {
                SlpClkTmr3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RWA, close UART0 clock"]
            #[inline(always)]
            pub fn slp_clk_uart0(&self) -> SlpClkUart0R {
                SlpClkUart0R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RWA, close UART1 clock"]
            #[inline(always)]
            pub fn slp_clk_uart1(&self) -> SlpClkUart1R {
                SlpClkUart1R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RWA, close UART2 clock"]
            #[inline(always)]
            pub fn slp_clk_uart2(&self) -> SlpClkUart2R {
                SlpClkUart2R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RWA, close UART3 clock"]
            #[inline(always)]
            pub fn slp_clk_uart3(&self) -> SlpClkUart3R {
                SlpClkUart3R::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RWA, close TMR0 clock"]
            #[inline(always)]
            pub fn slp_clk_tmr0(&mut self) -> SlpClkTmr0W<SlpClkOff0Spec> {
                SlpClkTmr0W::new(self, 0)
            }
            #[doc = "Bit 1 - RWA, close TMR1 clock"]
            #[inline(always)]
            pub fn slp_clk_tmr1(&mut self) -> SlpClkTmr1W<SlpClkOff0Spec> {
                SlpClkTmr1W::new(self, 1)
            }
            #[doc = "Bit 2 - RWA, close TMR2 clock"]
            #[inline(always)]
            pub fn slp_clk_tmr2(&mut self) -> SlpClkTmr2W<SlpClkOff0Spec> {
                SlpClkTmr2W::new(self, 2)
            }
            #[doc = "Bit 3 - RWA, close TMR3 clock"]
            #[inline(always)]
            pub fn slp_clk_tmr3(&mut self) -> SlpClkTmr3W<SlpClkOff0Spec> {
                SlpClkTmr3W::new(self, 3)
            }
            #[doc = "Bit 4 - RWA, close UART0 clock"]
            #[inline(always)]
            pub fn slp_clk_uart0(&mut self) -> SlpClkUart0W<SlpClkOff0Spec> {
                SlpClkUart0W::new(self, 4)
            }
            #[doc = "Bit 5 - RWA, close UART1 clock"]
            #[inline(always)]
            pub fn slp_clk_uart1(&mut self) -> SlpClkUart1W<SlpClkOff0Spec> {
                SlpClkUart1W::new(self, 5)
            }
            #[doc = "Bit 6 - RWA, close UART2 clock"]
            #[inline(always)]
            pub fn slp_clk_uart2(&mut self) -> SlpClkUart2W<SlpClkOff0Spec> {
                SlpClkUart2W::new(self, 6)
            }
            #[doc = "Bit 7 - RWA, close UART3 clock"]
            #[inline(always)]
            pub fn slp_clk_uart3(&mut self) -> SlpClkUart3W<SlpClkOff0Spec> {
                SlpClkUart3W::new(self, 7)
            }
        }
        #[doc = "RWA, sleep clock off control byte 0, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`slp_clk_off0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slp_clk_off0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SlpClkOff0Spec;
        impl crate::RegisterSpec for SlpClkOff0Spec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`slp_clk_off0::R`](R) reader structure"]
        impl crate::Readable for SlpClkOff0Spec {}
        #[doc = "`write(|w| ..)` method takes [`slp_clk_off0::W`](W) writer structure"]
        impl crate::Writable for SlpClkOff0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SLP_CLK_OFF0 to value 0"]
        impl crate::Resettable for SlpClkOff0Spec {}
    }
    #[doc = "SLP_CLK_OFF1 (rw) register accessor: RWA, sleep clock off control byte 1, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`slp_clk_off1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slp_clk_off1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@slp_clk_off1`] module"]
    #[doc(alias = "SLP_CLK_OFF1")]
    pub type SlpClkOff1 = crate::Reg<slp_clk_off1::SlpClkOff1Spec>;
    #[doc = "RWA, sleep clock off control byte 1, SAM"]
    pub mod slp_clk_off1 {
        #[doc = "Register `SLP_CLK_OFF1` reader"]
        pub type R = crate::R<SlpClkOff1Spec>;
        #[doc = "Register `SLP_CLK_OFF1` writer"]
        pub type W = crate::W<SlpClkOff1Spec>;
        #[doc = "Field `SLP_CLK_SPI0` reader - RWA, close SPI0 clock"]
        pub type SlpClkSpi0R = crate::BitReader;
        #[doc = "Field `SLP_CLK_SPI0` writer - RWA, close SPI0 clock"]
        pub type SlpClkSpi0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SLP_CLK_SPI1` reader - RWA, close SPI1 clock"]
        pub type SlpClkSpi1R = crate::BitReader;
        #[doc = "Field `SLP_CLK_SPI1` writer - RWA, close SPI1 clock"]
        pub type SlpClkSpi1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SLP_CLK_PWMX` reader - RWA, close PWMx clock"]
        pub type SlpClkPwmxR = crate::BitReader;
        #[doc = "Field `SLP_CLK_PWMX` writer - RWA, close PWMx clock"]
        pub type SlpClkPwmxW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SLP_CLK_I2C` reader - RWA, close I2C clock"]
        pub type SlpClkI2cR = crate::BitReader;
        #[doc = "Field `SLP_CLK_I2C` writer - RWA, close I2C clock"]
        pub type SlpClkI2cW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SLP_CLK_USB` reader - RWA, close USB clock"]
        pub type SlpClkUsbR = crate::BitReader;
        #[doc = "Field `SLP_CLK_USB` writer - RWA, close USB clock"]
        pub type SlpClkUsbW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SLP_CLK_BLE` reader - RWA, close BLE clock"]
        pub type SlpClkBleR = crate::BitReader;
        #[doc = "Field `SLP_CLK_BLE` writer - RWA, close BLE clock"]
        pub type SlpClkBleW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RWA, close SPI0 clock"]
            #[inline(always)]
            pub fn slp_clk_spi0(&self) -> SlpClkSpi0R {
                SlpClkSpi0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RWA, close SPI1 clock"]
            #[inline(always)]
            pub fn slp_clk_spi1(&self) -> SlpClkSpi1R {
                SlpClkSpi1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RWA, close PWMx clock"]
            #[inline(always)]
            pub fn slp_clk_pwmx(&self) -> SlpClkPwmxR {
                SlpClkPwmxR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RWA, close I2C clock"]
            #[inline(always)]
            pub fn slp_clk_i2c(&self) -> SlpClkI2cR {
                SlpClkI2cR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RWA, close USB clock"]
            #[inline(always)]
            pub fn slp_clk_usb(&self) -> SlpClkUsbR {
                SlpClkUsbR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 7 - RWA, close BLE clock"]
            #[inline(always)]
            pub fn slp_clk_ble(&self) -> SlpClkBleR {
                SlpClkBleR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RWA, close SPI0 clock"]
            #[inline(always)]
            pub fn slp_clk_spi0(&mut self) -> SlpClkSpi0W<SlpClkOff1Spec> {
                SlpClkSpi0W::new(self, 0)
            }
            #[doc = "Bit 1 - RWA, close SPI1 clock"]
            #[inline(always)]
            pub fn slp_clk_spi1(&mut self) -> SlpClkSpi1W<SlpClkOff1Spec> {
                SlpClkSpi1W::new(self, 1)
            }
            #[doc = "Bit 2 - RWA, close PWMx clock"]
            #[inline(always)]
            pub fn slp_clk_pwmx(&mut self) -> SlpClkPwmxW<SlpClkOff1Spec> {
                SlpClkPwmxW::new(self, 2)
            }
            #[doc = "Bit 3 - RWA, close I2C clock"]
            #[inline(always)]
            pub fn slp_clk_i2c(&mut self) -> SlpClkI2cW<SlpClkOff1Spec> {
                SlpClkI2cW::new(self, 3)
            }
            #[doc = "Bit 4 - RWA, close USB clock"]
            #[inline(always)]
            pub fn slp_clk_usb(&mut self) -> SlpClkUsbW<SlpClkOff1Spec> {
                SlpClkUsbW::new(self, 4)
            }
            #[doc = "Bit 7 - RWA, close BLE clock"]
            #[inline(always)]
            pub fn slp_clk_ble(&mut self) -> SlpClkBleW<SlpClkOff1Spec> {
                SlpClkBleW::new(self, 7)
            }
        }
        #[doc = "RWA, sleep clock off control byte 1, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`slp_clk_off1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slp_clk_off1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SlpClkOff1Spec;
        impl crate::RegisterSpec for SlpClkOff1Spec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`slp_clk_off1::R`](R) reader structure"]
        impl crate::Readable for SlpClkOff1Spec {}
        #[doc = "`write(|w| ..)` method takes [`slp_clk_off1::W`](W) writer structure"]
        impl crate::Writable for SlpClkOff1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SLP_CLK_OFF1 to value 0"]
        impl crate::Resettable for SlpClkOff1Spec {}
    }
    #[doc = "SLP_WAKE_CTRL (rw) register accessor: RWA, wake control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`slp_wake_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slp_wake_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@slp_wake_ctrl`] module"]
    #[doc(alias = "SLP_WAKE_CTRL")]
    pub type SlpWakeCtrl = crate::Reg<slp_wake_ctrl::SlpWakeCtrlSpec>;
    #[doc = "RWA, wake control, SAM"]
    pub mod slp_wake_ctrl {
        #[doc = "Register `SLP_WAKE_CTRL` reader"]
        pub type R = crate::R<SlpWakeCtrlSpec>;
        #[doc = "Register `SLP_WAKE_CTRL` writer"]
        pub type W = crate::W<SlpWakeCtrlSpec>;
        #[doc = "Field `SLP_USB_WAKE` reader - RWA, enable USB waking"]
        pub type SlpUsbWakeR = crate::BitReader;
        #[doc = "Field `SLP_USB_WAKE` writer - RWA, enable USB waking"]
        pub type SlpUsbWakeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SLP_USB2_WAKE` reader - RWA, enable USB2 waking"]
        pub type SlpUsb2WakeR = crate::BitReader;
        #[doc = "Field `SLP_USB2_WAKE` writer - RWA, enable USB2 waking"]
        pub type SlpUsb2WakeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SLP_RTC_WAKE` reader - RWA, enable RTC waking"]
        pub type SlpRtcWakeR = crate::BitReader;
        #[doc = "Field `SLP_RTC_WAKE` writer - RWA, enable RTC waking"]
        pub type SlpRtcWakeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SLP_GPIO_WAKE` reader - RWA, enable GPIO waking"]
        pub type SlpGpioWakeR = crate::BitReader;
        #[doc = "Field `SLP_GPIO_WAKE` writer - RWA, enable GPIO waking"]
        pub type SlpGpioWakeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SLP_BAT_WAKE` reader - RWA, enable BAT waking"]
        pub type SlpBatWakeR = crate::BitReader;
        #[doc = "Field `SLP_BAT_WAKE` writer - RWA, enable BAT waking"]
        pub type SlpBatWakeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WAKE_EV_MODE` reader - RWA, event wakeup mode"]
        pub type WakeEvModeR = crate::BitReader;
        #[doc = "Field `WAKE_EV_MODE` writer - RWA, event wakeup mode"]
        pub type WakeEvModeW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RWA, enable USB waking"]
            #[inline(always)]
            pub fn slp_usb_wake(&self) -> SlpUsbWakeR {
                SlpUsbWakeR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RWA, enable USB2 waking"]
            #[inline(always)]
            pub fn slp_usb2_wake(&self) -> SlpUsb2WakeR {
                SlpUsb2WakeR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 3 - RWA, enable RTC waking"]
            #[inline(always)]
            pub fn slp_rtc_wake(&self) -> SlpRtcWakeR {
                SlpRtcWakeR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RWA, enable GPIO waking"]
            #[inline(always)]
            pub fn slp_gpio_wake(&self) -> SlpGpioWakeR {
                SlpGpioWakeR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RWA, enable BAT waking"]
            #[inline(always)]
            pub fn slp_bat_wake(&self) -> SlpBatWakeR {
                SlpBatWakeR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RWA, event wakeup mode"]
            #[inline(always)]
            pub fn wake_ev_mode(&self) -> WakeEvModeR {
                WakeEvModeR::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RWA, enable USB waking"]
            #[inline(always)]
            pub fn slp_usb_wake(&mut self) -> SlpUsbWakeW<SlpWakeCtrlSpec> {
                SlpUsbWakeW::new(self, 0)
            }
            #[doc = "Bit 1 - RWA, enable USB2 waking"]
            #[inline(always)]
            pub fn slp_usb2_wake(&mut self) -> SlpUsb2WakeW<SlpWakeCtrlSpec> {
                SlpUsb2WakeW::new(self, 1)
            }
            #[doc = "Bit 3 - RWA, enable RTC waking"]
            #[inline(always)]
            pub fn slp_rtc_wake(&mut self) -> SlpRtcWakeW<SlpWakeCtrlSpec> {
                SlpRtcWakeW::new(self, 3)
            }
            #[doc = "Bit 4 - RWA, enable GPIO waking"]
            #[inline(always)]
            pub fn slp_gpio_wake(&mut self) -> SlpGpioWakeW<SlpWakeCtrlSpec> {
                SlpGpioWakeW::new(self, 4)
            }
            #[doc = "Bit 5 - RWA, enable BAT waking"]
            #[inline(always)]
            pub fn slp_bat_wake(&mut self) -> SlpBatWakeW<SlpWakeCtrlSpec> {
                SlpBatWakeW::new(self, 5)
            }
            #[doc = "Bit 6 - RWA, event wakeup mode"]
            #[inline(always)]
            pub fn wake_ev_mode(&mut self) -> WakeEvModeW<SlpWakeCtrlSpec> {
                WakeEvModeW::new(self, 6)
            }
        }
        #[doc = "RWA, wake control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`slp_wake_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slp_wake_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SlpWakeCtrlSpec;
        impl crate::RegisterSpec for SlpWakeCtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`slp_wake_ctrl::R`](R) reader structure"]
        impl crate::Readable for SlpWakeCtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`slp_wake_ctrl::W`](W) writer structure"]
        impl crate::Writable for SlpWakeCtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SLP_WAKE_CTRL to value 0x20"]
        impl crate::Resettable for SlpWakeCtrlSpec {
            const RESET_VALUE: u8 = 0x20;
        }
    }
    #[doc = "SLP_POWER_CTRL (rw) register accessor: RWA, peripherals power down control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`slp_power_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slp_power_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@slp_power_ctrl`] module"]
    #[doc(alias = "SLP_POWER_CTRL")]
    pub type SlpPowerCtrl = crate::Reg<slp_power_ctrl::SlpPowerCtrlSpec>;
    #[doc = "RWA, peripherals power down control, SAM"]
    pub mod slp_power_ctrl {
        #[doc = "Register `SLP_POWER_CTRL` reader"]
        pub type R = crate::R<SlpPowerCtrlSpec>;
        #[doc = "Register `SLP_POWER_CTRL` writer"]
        pub type W = crate::W<SlpPowerCtrlSpec>;
        #[doc = "Field `WAKE_DLY_MOD` reader - RWA, wakeup delay time selection"]
        pub type WakeDlyModR = crate::FieldReader;
        #[doc = "Field `WAKE_DLY_MOD` writer - RWA, wakeup delay time selection"]
        pub type WakeDlyModW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `SLP_CLK_RAMX` reader - RWA, close main SRAM clock"]
        pub type SlpClkRamxR = crate::BitReader;
        #[doc = "Field `SLP_CLK_RAMX` writer - RWA, close main SRAM clock"]
        pub type SlpClkRamxW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SLP_CLK_RAM2K` reader - RWA, close retention 2KB SRAM clock"]
        pub type SlpClkRam2kR = crate::BitReader;
        #[doc = "Field `SLP_CLK_RAM2K` writer - RWA, close retention 2KB SRAM clock"]
        pub type SlpClkRam2kW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RAM_RET_LV` reader - RWA, SRAM retention voltage selection"]
        pub type RamRetLvR = crate::BitReader;
        #[doc = "Field `RAM_RET_LV` writer - RWA, SRAM retention voltage selection"]
        pub type RamRetLvW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - RWA, wakeup delay time selection"]
            #[inline(always)]
            pub fn wake_dly_mod(&self) -> WakeDlyModR {
                WakeDlyModR::new(self.bits & 3)
            }
            #[doc = "Bit 4 - RWA, close main SRAM clock"]
            #[inline(always)]
            pub fn slp_clk_ramx(&self) -> SlpClkRamxR {
                SlpClkRamxR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RWA, close retention 2KB SRAM clock"]
            #[inline(always)]
            pub fn slp_clk_ram2k(&self) -> SlpClkRam2kR {
                SlpClkRam2kR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RWA, SRAM retention voltage selection"]
            #[inline(always)]
            pub fn ram_ret_lv(&self) -> RamRetLvR {
                RamRetLvR::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - RWA, wakeup delay time selection"]
            #[inline(always)]
            pub fn wake_dly_mod(&mut self) -> WakeDlyModW<SlpPowerCtrlSpec> {
                WakeDlyModW::new(self, 0)
            }
            #[doc = "Bit 4 - RWA, close main SRAM clock"]
            #[inline(always)]
            pub fn slp_clk_ramx(&mut self) -> SlpClkRamxW<SlpPowerCtrlSpec> {
                SlpClkRamxW::new(self, 4)
            }
            #[doc = "Bit 5 - RWA, close retention 2KB SRAM clock"]
            #[inline(always)]
            pub fn slp_clk_ram2k(&mut self) -> SlpClkRam2kW<SlpPowerCtrlSpec> {
                SlpClkRam2kW::new(self, 5)
            }
            #[doc = "Bit 6 - RWA, SRAM retention voltage selection"]
            #[inline(always)]
            pub fn ram_ret_lv(&mut self) -> RamRetLvW<SlpPowerCtrlSpec> {
                RamRetLvW::new(self, 6)
            }
        }
        #[doc = "RWA, peripherals power down control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`slp_power_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slp_power_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SlpPowerCtrlSpec;
        impl crate::RegisterSpec for SlpPowerCtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`slp_power_ctrl::R`](R) reader structure"]
        impl crate::Readable for SlpPowerCtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`slp_power_ctrl::W`](W) writer structure"]
        impl crate::Writable for SlpPowerCtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SLP_POWER_CTRL to value 0"]
        impl crate::Resettable for SlpPowerCtrlSpec {}
    }
    #[doc = "PIN_ALTERNATE (rw) register accessor: RW, function pin alternate configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`pin_alternate::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pin_alternate::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pin_alternate`] module"]
    #[doc(alias = "PIN_ALTERNATE")]
    pub type PinAlternate = crate::Reg<pin_alternate::PinAlternateSpec>;
    #[doc = "RW, function pin alternate configuration"]
    pub mod pin_alternate {
        #[doc = "Register `PIN_ALTERNATE` reader"]
        pub type R = crate::R<PinAlternateSpec>;
        #[doc = "Register `PIN_ALTERNATE` writer"]
        pub type W = crate::W<PinAlternateSpec>;
        #[doc = "Field `PIN_TMR0` reader - RW, TMR0 alternate pin enable"]
        pub type PinTmr0R = crate::BitReader;
        #[doc = "Field `PIN_TMR0` writer - RW, TMR0 alternate pin enable"]
        pub type PinTmr0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_TMR1` reader - RW, TMR1 alternate pin enable"]
        pub type PinTmr1R = crate::BitReader;
        #[doc = "Field `PIN_TMR1` writer - RW, TMR1 alternate pin enable"]
        pub type PinTmr1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_TMR2` reader - RW, TMR2 alternate pin enable"]
        pub type PinTmr2R = crate::BitReader;
        #[doc = "Field `PIN_TMR2` writer - RW, TMR2 alternate pin enable"]
        pub type PinTmr2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_TMR3` reader - RW, TMR3 alternate pin enable"]
        pub type PinTmr3R = crate::BitReader;
        #[doc = "Field `PIN_TMR3` writer - RW, TMR3 alternate pin enable"]
        pub type PinTmr3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_UART0` reader - RW, RXD0/TXD0 alternate pin enable"]
        pub type PinUart0R = crate::BitReader;
        #[doc = "Field `PIN_UART0` writer - RW, RXD0/TXD0 alternate pin enable"]
        pub type PinUart0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_UART1` reader - RW, RXD1/TXD1 alternate pin enable"]
        pub type PinUart1R = crate::BitReader;
        #[doc = "Field `PIN_UART1` writer - RW, RXD1/TXD1 alternate pin enable"]
        pub type PinUart1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_UART2` reader - RW, RXD2/TXD2 alternate pin enable"]
        pub type PinUart2R = crate::BitReader;
        #[doc = "Field `PIN_UART2` writer - RW, RXD2/TXD2 alternate pin enable"]
        pub type PinUart2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_UART3` reader - RW, RXD3/TXD3 alternate pin enable"]
        pub type PinUart3R = crate::BitReader;
        #[doc = "Field `PIN_UART3` writer - RW, RXD3/TXD3 alternate pin enable"]
        pub type PinUart3W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_SPI0` reader - RW, SCS/SCK0/MOSI/MISO alternate pin enable"]
        pub type PinSpi0R = crate::BitReader;
        #[doc = "Field `PIN_SPI0` writer - RW, SCS/SCK0/MOSI/MISO alternate pin enable"]
        pub type PinSpi0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_PWMX` reader - RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable"]
        pub type PinPwmxR = crate::BitReader;
        #[doc = "Field `PIN_PWMX` writer - RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable"]
        pub type PinPwmxW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_I2C` reader - RW, SCL/SDA alternate pin enable"]
        pub type PinI2cR = crate::BitReader;
        #[doc = "Field `PIN_I2C` writer - RW, SCL/SDA alternate pin enable"]
        pub type PinI2cW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_MODEM` reader - RW, DSR/DTR alternate pin enable"]
        pub type PinModemR = crate::BitReader;
        #[doc = "Field `PIN_MODEM` writer - RW, DSR/DTR alternate pin enable"]
        pub type PinModemW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_INTX` reader - RW, interrupt INT24/INT25 alternate pin enable"]
        pub type PinIntxR = crate::BitReader;
        #[doc = "Field `PIN_INTX` writer - RW, interrupt INT24/INT25 alternate pin enable"]
        pub type PinIntxW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_U0_INV` reader - RW, SCL/SDA alternRW, RXD0/RXD0_/TXD0/TXD0_ invert input/output enableate pin enable"]
        pub type PinU0InvR = crate::BitReader;
        #[doc = "Field `PIN_U0_INV` writer - RW, SCL/SDA alternRW, RXD0/RXD0_/TXD0/TXD0_ invert input/output enableate pin enable"]
        pub type PinU0InvW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RF_ANT_SW_EN` reader - RW, RF antenna switch control output enable"]
        pub type RfAntSwEnR = crate::BitReader;
        #[doc = "Field `RF_ANT_SW_EN` writer - RW, RF antenna switch control output enable"]
        pub type RfAntSwEnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, TMR0 alternate pin enable"]
            #[inline(always)]
            pub fn pin_tmr0(&self) -> PinTmr0R {
                PinTmr0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, TMR1 alternate pin enable"]
            #[inline(always)]
            pub fn pin_tmr1(&self) -> PinTmr1R {
                PinTmr1R::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW, TMR2 alternate pin enable"]
            #[inline(always)]
            pub fn pin_tmr2(&self) -> PinTmr2R {
                PinTmr2R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, TMR3 alternate pin enable"]
            #[inline(always)]
            pub fn pin_tmr3(&self) -> PinTmr3R {
                PinTmr3R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, RXD0/TXD0 alternate pin enable"]
            #[inline(always)]
            pub fn pin_uart0(&self) -> PinUart0R {
                PinUart0R::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RW, RXD1/TXD1 alternate pin enable"]
            #[inline(always)]
            pub fn pin_uart1(&self) -> PinUart1R {
                PinUart1R::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RW, RXD2/TXD2 alternate pin enable"]
            #[inline(always)]
            pub fn pin_uart2(&self) -> PinUart2R {
                PinUart2R::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RW, RXD3/TXD3 alternate pin enable"]
            #[inline(always)]
            pub fn pin_uart3(&self) -> PinUart3R {
                PinUart3R::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - RW, SCS/SCK0/MOSI/MISO alternate pin enable"]
            #[inline(always)]
            pub fn pin_spi0(&self) -> PinSpi0R {
                PinSpi0R::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 10 - RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable"]
            #[inline(always)]
            pub fn pin_pwmx(&self) -> PinPwmxR {
                PinPwmxR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - RW, SCL/SDA alternate pin enable"]
            #[inline(always)]
            pub fn pin_i2c(&self) -> PinI2cR {
                PinI2cR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - RW, DSR/DTR alternate pin enable"]
            #[inline(always)]
            pub fn pin_modem(&self) -> PinModemR {
                PinModemR::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - RW, interrupt INT24/INT25 alternate pin enable"]
            #[inline(always)]
            pub fn pin_intx(&self) -> PinIntxR {
                PinIntxR::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - RW, SCL/SDA alternRW, RXD0/RXD0_/TXD0/TXD0_ invert input/output enableate pin enable"]
            #[inline(always)]
            pub fn pin_u0_inv(&self) -> PinU0InvR {
                PinU0InvR::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - RW, RF antenna switch control output enable"]
            #[inline(always)]
            pub fn rf_ant_sw_en(&self) -> RfAntSwEnR {
                RfAntSwEnR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, TMR0 alternate pin enable"]
            #[inline(always)]
            pub fn pin_tmr0(&mut self) -> PinTmr0W<PinAlternateSpec> {
                PinTmr0W::new(self, 0)
            }
            #[doc = "Bit 1 - RW, TMR1 alternate pin enable"]
            #[inline(always)]
            pub fn pin_tmr1(&mut self) -> PinTmr1W<PinAlternateSpec> {
                PinTmr1W::new(self, 1)
            }
            #[doc = "Bit 2 - RW, TMR2 alternate pin enable"]
            #[inline(always)]
            pub fn pin_tmr2(&mut self) -> PinTmr2W<PinAlternateSpec> {
                PinTmr2W::new(self, 2)
            }
            #[doc = "Bit 3 - RW, TMR3 alternate pin enable"]
            #[inline(always)]
            pub fn pin_tmr3(&mut self) -> PinTmr3W<PinAlternateSpec> {
                PinTmr3W::new(self, 3)
            }
            #[doc = "Bit 4 - RW, RXD0/TXD0 alternate pin enable"]
            #[inline(always)]
            pub fn pin_uart0(&mut self) -> PinUart0W<PinAlternateSpec> {
                PinUart0W::new(self, 4)
            }
            #[doc = "Bit 5 - RW, RXD1/TXD1 alternate pin enable"]
            #[inline(always)]
            pub fn pin_uart1(&mut self) -> PinUart1W<PinAlternateSpec> {
                PinUart1W::new(self, 5)
            }
            #[doc = "Bit 6 - RW, RXD2/TXD2 alternate pin enable"]
            #[inline(always)]
            pub fn pin_uart2(&mut self) -> PinUart2W<PinAlternateSpec> {
                PinUart2W::new(self, 6)
            }
            #[doc = "Bit 7 - RW, RXD3/TXD3 alternate pin enable"]
            #[inline(always)]
            pub fn pin_uart3(&mut self) -> PinUart3W<PinAlternateSpec> {
                PinUart3W::new(self, 7)
            }
            #[doc = "Bit 8 - RW, SCS/SCK0/MOSI/MISO alternate pin enable"]
            #[inline(always)]
            pub fn pin_spi0(&mut self) -> PinSpi0W<PinAlternateSpec> {
                PinSpi0W::new(self, 8)
            }
            #[doc = "Bit 10 - RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable"]
            #[inline(always)]
            pub fn pin_pwmx(&mut self) -> PinPwmxW<PinAlternateSpec> {
                PinPwmxW::new(self, 10)
            }
            #[doc = "Bit 11 - RW, SCL/SDA alternate pin enable"]
            #[inline(always)]
            pub fn pin_i2c(&mut self) -> PinI2cW<PinAlternateSpec> {
                PinI2cW::new(self, 11)
            }
            #[doc = "Bit 12 - RW, DSR/DTR alternate pin enable"]
            #[inline(always)]
            pub fn pin_modem(&mut self) -> PinModemW<PinAlternateSpec> {
                PinModemW::new(self, 12)
            }
            #[doc = "Bit 13 - RW, interrupt INT24/INT25 alternate pin enable"]
            #[inline(always)]
            pub fn pin_intx(&mut self) -> PinIntxW<PinAlternateSpec> {
                PinIntxW::new(self, 13)
            }
            #[doc = "Bit 14 - RW, SCL/SDA alternRW, RXD0/RXD0_/TXD0/TXD0_ invert input/output enableate pin enable"]
            #[inline(always)]
            pub fn pin_u0_inv(&mut self) -> PinU0InvW<PinAlternateSpec> {
                PinU0InvW::new(self, 14)
            }
            #[doc = "Bit 15 - RW, RF antenna switch control output enable"]
            #[inline(always)]
            pub fn rf_ant_sw_en(&mut self) -> RfAntSwEnW<PinAlternateSpec> {
                RfAntSwEnW::new(self, 15)
            }
        }
        #[doc = "RW, function pin alternate configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`pin_alternate::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pin_alternate::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PinAlternateSpec;
        impl crate::RegisterSpec for PinAlternateSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`pin_alternate::R`](R) reader structure"]
        impl crate::Readable for PinAlternateSpec {}
        #[doc = "`write(|w| ..)` method takes [`pin_alternate::W`](W) writer structure"]
        impl crate::Writable for PinAlternateSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PIN_ALTERNATE to value 0"]
        impl crate::Resettable for PinAlternateSpec {}
    }
    #[doc = "PIN_ANALOG_IE (rw) register accessor: RW, analog pin enable and digital input disable\n\nYou can [`read`](crate::Reg::read) this register and get [`pin_analog_ie::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pin_analog_ie::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pin_analog_ie`] module"]
    #[doc(alias = "PIN_ANALOG_IE")]
    pub type PinAnalogIe = crate::Reg<pin_analog_ie::PinAnalogIeSpec>;
    #[doc = "RW, analog pin enable and digital input disable"]
    pub mod pin_analog_ie {
        #[doc = "Register `PIN_ANALOG_IE` reader"]
        pub type R = crate::R<PinAnalogIeSpec>;
        #[doc = "Register `PIN_ANALOG_IE` writer"]
        pub type W = crate::W<PinAnalogIeSpec>;
        #[doc = "Field `PIN_ADC8_9_IE` reader - RW, ADC/TouchKey channel 9/8 digital input disable"]
        pub type PinAdc8_9IeR = crate::BitReader;
        #[doc = "Field `PIN_ADC8_9_IE` writer - RW, ADC/TouchKey channel 9/8 digital input disable"]
        pub type PinAdc8_9IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_ADC6_7_IE` reader - RW, ADC/TouchKey channel 7/6 digital input disable"]
        pub type PinAdc6_7IeR = crate::BitReader;
        #[doc = "Field `PIN_ADC6_7_IE` writer - RW, ADC/TouchKey channel 7/6 digital input disable"]
        pub type PinAdc6_7IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_ADC10_IE` reader - RW, ADC/TouchKey channel 10 digital input disable"]
        pub type PinAdc10IeR = crate::BitReader;
        #[doc = "Field `PIN_ADC10_IE` writer - RW, ADC/TouchKey channel 10 digital input disable"]
        pub type PinAdc10IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_ADC11_IE` reader - RW, ADC/TouchKey channel 11 digital input disable"]
        pub type PinAdc11IeR = crate::BitReader;
        #[doc = "Field `PIN_ADC11_IE` writer - RW, ADC/TouchKey channel 11 digital input disable"]
        pub type PinAdc11IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_USB2_DP_PU` reader - RW,USB2 UDP internal pullup resistance enable"]
        pub type PinUsb2DpPuR = crate::BitReader;
        #[doc = "Field `PIN_USB2_DP_PU` writer - RW,USB2 UDP internal pullup resistance enable"]
        pub type PinUsb2DpPuW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_USB2_IE` reader - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable"]
        pub type PinUsb2IeR = crate::BitReader;
        #[doc = "Field `PIN_USB2_IE` writer - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable"]
        pub type PinUsb2IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_USB_DP_PU` reader - RW,USB UDP internal pullup resistance enable"]
        pub type PinUsbDpPuR = crate::BitReader;
        #[doc = "Field `PIN_USB_DP_PU` writer - RW,USB UDP internal pullup resistance enable"]
        pub type PinUsbDpPuW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_USB_IE` reader - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable"]
        pub type PinUsbIeR = crate::BitReader;
        #[doc = "Field `PIN_USB_IE` writer - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable"]
        pub type PinUsbIeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_ADC0_IE` reader - RW, ADC/TouchKey channel0 digital input disable: 0=digital input enable, 1=digital input disable"]
        pub type PinAdc0IeR = crate::BitReader;
        #[doc = "Field `PIN_ADC0_IE` writer - RW, ADC/TouchKey channel0 digital input disable: 0=digital input enable, 1=digital input disable"]
        pub type PinAdc0IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_ADC1_IE` reader - RW, ADC/TouchKey channel1 digital input disable: 0=digital input enable, 1=digital input disable"]
        pub type PinAdc1IeR = crate::BitReader;
        #[doc = "Field `PIN_ADC1_IE` writer - RW, ADC/TouchKey channel1 digital input disable: 0=digital input enable, 1=digital input disable"]
        pub type PinAdc1IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_ADC12_IE` reader - RW, ADC/TouchKey channel12 digital input disable: 0=digital input enable, 1=digital input disable"]
        pub type PinAdc12IeR = crate::BitReader;
        #[doc = "Field `PIN_ADC12_IE` writer - RW, ADC/TouchKey channel12 digital input disable: 0=digital input enable, 1=digital input disable"]
        pub type PinAdc12IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_ADC13_IE` reader - RW, ADC/TouchKey channel13 digital input disable: 0=digital input enable, 1=digital input disable"]
        pub type PinAdc13IeR = crate::BitReader;
        #[doc = "Field `PIN_ADC13_IE` writer - RW, ADC/TouchKey channel13 digital input disable: 0=digital input enable, 1=digital input disable"]
        pub type PinAdc13IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_XT32K_IE` reader - RW, external 32KHz oscillator digital input disable: 0=digital input enable, 1=digital input disable"]
        pub type PinXt32kIeR = crate::BitReader;
        #[doc = "Field `PIN_XT32K_IE` writer - RW, external 32KHz oscillator digital input disable: 0=digital input enable, 1=digital input disable"]
        pub type PinXt32kIeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_ADC2_3_IE` reader - RW, ADC/TouchKey channel 2/3 digital input disable: 0=digital input enable, 1=digital input disable"]
        pub type PinAdc2_3IeR = crate::BitReader;
        #[doc = "Field `PIN_ADC2_3_IE` writer - RW, ADC/TouchKey channel 2/3 digital input disable: 0=digital input enable, 1=digital input disable"]
        pub type PinAdc2_3IeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PIN_ADC4_5_IE` reader - RW, ADC/TouchKey channel 4/5 digital input disable: 0=digital input enable, 1=digital input disable"]
        pub type PinAdc4_5IeR = crate::BitReader;
        #[doc = "Field `PIN_ADC4_5_IE` writer - RW, ADC/TouchKey channel 4/5 digital input disable: 0=digital input enable, 1=digital input disable"]
        pub type PinAdc4_5IeW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, ADC/TouchKey channel 9/8 digital input disable"]
            #[inline(always)]
            pub fn pin_adc8_9_ie(&self) -> PinAdc8_9IeR {
                PinAdc8_9IeR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, ADC/TouchKey channel 7/6 digital input disable"]
            #[inline(always)]
            pub fn pin_adc6_7_ie(&self) -> PinAdc6_7IeR {
                PinAdc6_7IeR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW, ADC/TouchKey channel 10 digital input disable"]
            #[inline(always)]
            pub fn pin_adc10_ie(&self) -> PinAdc10IeR {
                PinAdc10IeR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, ADC/TouchKey channel 11 digital input disable"]
            #[inline(always)]
            pub fn pin_adc11_ie(&self) -> PinAdc11IeR {
                PinAdc11IeR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW,USB2 UDP internal pullup resistance enable"]
            #[inline(always)]
            pub fn pin_usb2_dp_pu(&self) -> PinUsb2DpPuR {
                PinUsb2DpPuR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable"]
            #[inline(always)]
            pub fn pin_usb2_ie(&self) -> PinUsb2IeR {
                PinUsb2IeR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RW,USB UDP internal pullup resistance enable"]
            #[inline(always)]
            pub fn pin_usb_dp_pu(&self) -> PinUsbDpPuR {
                PinUsbDpPuR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable"]
            #[inline(always)]
            pub fn pin_usb_ie(&self) -> PinUsbIeR {
                PinUsbIeR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 9 - RW, ADC/TouchKey channel0 digital input disable: 0=digital input enable, 1=digital input disable"]
            #[inline(always)]
            pub fn pin_adc0_ie(&self) -> PinAdc0IeR {
                PinAdc0IeR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - RW, ADC/TouchKey channel1 digital input disable: 0=digital input enable, 1=digital input disable"]
            #[inline(always)]
            pub fn pin_adc1_ie(&self) -> PinAdc1IeR {
                PinAdc1IeR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - RW, ADC/TouchKey channel12 digital input disable: 0=digital input enable, 1=digital input disable"]
            #[inline(always)]
            pub fn pin_adc12_ie(&self) -> PinAdc12IeR {
                PinAdc12IeR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - RW, ADC/TouchKey channel13 digital input disable: 0=digital input enable, 1=digital input disable"]
            #[inline(always)]
            pub fn pin_adc13_ie(&self) -> PinAdc13IeR {
                PinAdc13IeR::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - RW, external 32KHz oscillator digital input disable: 0=digital input enable, 1=digital input disable"]
            #[inline(always)]
            pub fn pin_xt32k_ie(&self) -> PinXt32kIeR {
                PinXt32kIeR::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 14 - RW, ADC/TouchKey channel 2/3 digital input disable: 0=digital input enable, 1=digital input disable"]
            #[inline(always)]
            pub fn pin_adc2_3_ie(&self) -> PinAdc2_3IeR {
                PinAdc2_3IeR::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - RW, ADC/TouchKey channel 4/5 digital input disable: 0=digital input enable, 1=digital input disable"]
            #[inline(always)]
            pub fn pin_adc4_5_ie(&self) -> PinAdc4_5IeR {
                PinAdc4_5IeR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, ADC/TouchKey channel 9/8 digital input disable"]
            #[inline(always)]
            pub fn pin_adc8_9_ie(&mut self) -> PinAdc8_9IeW<PinAnalogIeSpec> {
                PinAdc8_9IeW::new(self, 0)
            }
            #[doc = "Bit 1 - RW, ADC/TouchKey channel 7/6 digital input disable"]
            #[inline(always)]
            pub fn pin_adc6_7_ie(&mut self) -> PinAdc6_7IeW<PinAnalogIeSpec> {
                PinAdc6_7IeW::new(self, 1)
            }
            #[doc = "Bit 2 - RW, ADC/TouchKey channel 10 digital input disable"]
            #[inline(always)]
            pub fn pin_adc10_ie(&mut self) -> PinAdc10IeW<PinAnalogIeSpec> {
                PinAdc10IeW::new(self, 2)
            }
            #[doc = "Bit 3 - RW, ADC/TouchKey channel 11 digital input disable"]
            #[inline(always)]
            pub fn pin_adc11_ie(&mut self) -> PinAdc11IeW<PinAnalogIeSpec> {
                PinAdc11IeW::new(self, 3)
            }
            #[doc = "Bit 4 - RW,USB2 UDP internal pullup resistance enable"]
            #[inline(always)]
            pub fn pin_usb2_dp_pu(&mut self) -> PinUsb2DpPuW<PinAnalogIeSpec> {
                PinUsb2DpPuW::new(self, 4)
            }
            #[doc = "Bit 5 - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable"]
            #[inline(always)]
            pub fn pin_usb2_ie(&mut self) -> PinUsb2IeW<PinAnalogIeSpec> {
                PinUsb2IeW::new(self, 5)
            }
            #[doc = "Bit 6 - RW,USB UDP internal pullup resistance enable"]
            #[inline(always)]
            pub fn pin_usb_dp_pu(&mut self) -> PinUsbDpPuW<PinAnalogIeSpec> {
                PinUsbDpPuW::new(self, 6)
            }
            #[doc = "Bit 7 - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable"]
            #[inline(always)]
            pub fn pin_usb_ie(&mut self) -> PinUsbIeW<PinAnalogIeSpec> {
                PinUsbIeW::new(self, 7)
            }
            #[doc = "Bit 9 - RW, ADC/TouchKey channel0 digital input disable: 0=digital input enable, 1=digital input disable"]
            #[inline(always)]
            pub fn pin_adc0_ie(&mut self) -> PinAdc0IeW<PinAnalogIeSpec> {
                PinAdc0IeW::new(self, 9)
            }
            #[doc = "Bit 10 - RW, ADC/TouchKey channel1 digital input disable: 0=digital input enable, 1=digital input disable"]
            #[inline(always)]
            pub fn pin_adc1_ie(&mut self) -> PinAdc1IeW<PinAnalogIeSpec> {
                PinAdc1IeW::new(self, 10)
            }
            #[doc = "Bit 11 - RW, ADC/TouchKey channel12 digital input disable: 0=digital input enable, 1=digital input disable"]
            #[inline(always)]
            pub fn pin_adc12_ie(&mut self) -> PinAdc12IeW<PinAnalogIeSpec> {
                PinAdc12IeW::new(self, 11)
            }
            #[doc = "Bit 12 - RW, ADC/TouchKey channel13 digital input disable: 0=digital input enable, 1=digital input disable"]
            #[inline(always)]
            pub fn pin_adc13_ie(&mut self) -> PinAdc13IeW<PinAnalogIeSpec> {
                PinAdc13IeW::new(self, 12)
            }
            #[doc = "Bit 13 - RW, external 32KHz oscillator digital input disable: 0=digital input enable, 1=digital input disable"]
            #[inline(always)]
            pub fn pin_xt32k_ie(&mut self) -> PinXt32kIeW<PinAnalogIeSpec> {
                PinXt32kIeW::new(self, 13)
            }
            #[doc = "Bit 14 - RW, ADC/TouchKey channel 2/3 digital input disable: 0=digital input enable, 1=digital input disable"]
            #[inline(always)]
            pub fn pin_adc2_3_ie(&mut self) -> PinAdc2_3IeW<PinAnalogIeSpec> {
                PinAdc2_3IeW::new(self, 14)
            }
            #[doc = "Bit 15 - RW, ADC/TouchKey channel 4/5 digital input disable: 0=digital input enable, 1=digital input disable"]
            #[inline(always)]
            pub fn pin_adc4_5_ie(&mut self) -> PinAdc4_5IeW<PinAnalogIeSpec> {
                PinAdc4_5IeW::new(self, 15)
            }
        }
        #[doc = "RW, analog pin enable and digital input disable\n\nYou can [`read`](crate::Reg::read) this register and get [`pin_analog_ie::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pin_analog_ie::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PinAnalogIeSpec;
        impl crate::RegisterSpec for PinAnalogIeSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`pin_analog_ie::R`](R) reader structure"]
        impl crate::Readable for PinAnalogIeSpec {}
        #[doc = "`write(|w| ..)` method takes [`pin_analog_ie::W`](W) writer structure"]
        impl crate::Writable for PinAnalogIeSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PIN_ANALOG_IE to value 0"]
        impl crate::Resettable for PinAnalogIeSpec {}
    }
    #[doc = "POWER_PLAN (rw) register accessor: RWA, power plan before sleep instruction, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`power_plan::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`power_plan::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@power_plan`] module"]
    #[doc(alias = "POWER_PLAN")]
    pub type PowerPlan = crate::Reg<power_plan::PowerPlanSpec>;
    #[doc = "RWA, power plan before sleep instruction, SAM"]
    pub mod power_plan {
        #[doc = "Register `POWER_PLAN` reader"]
        pub type R = crate::R<PowerPlanSpec>;
        #[doc = "Register `POWER_PLAN` writer"]
        pub type W = crate::W<PowerPlanSpec>;
        #[doc = "Field `PWR_XROM` reader - RWA, power for retention 2KB SRAM"]
        pub type PwrXromR = crate::BitReader;
        #[doc = "Field `PWR_XROM` writer - RWA, power for retention 2KB SRAM"]
        pub type PwrXromW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWR_RAM2K` reader - RWA, power for retention 2KB SRAM"]
        pub type PwrRam2kR = crate::BitReader;
        #[doc = "Field `PWR_RAM2K` writer - RWA, power for retention 2KB SRAM"]
        pub type PwrRam2kW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWR_CORE` reader - RWA, power retention for core and base peripherals"]
        pub type PwrCoreR = crate::BitReader;
        #[doc = "Field `PWR_CORE` writer - RWA, power retention for core and base peripherals"]
        pub type PwrCoreW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWR_EXTEND` reader - RWA, power retention for USB and BLE"]
        pub type PwrExtendR = crate::BitReader;
        #[doc = "Field `PWR_EXTEND` writer - RWA, power retention for USB and BLE"]
        pub type PwrExtendW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWR_RAM30K` reader - RWA, power for main SRAM"]
        pub type PwrRam30kR = crate::BitReader;
        #[doc = "Field `PWR_RAM30K` writer - RWA, power for main SRAM"]
        pub type PwrRam30kW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWR_SYS_EN` reader - RWA, power for system"]
        pub type PwrSysEnR = crate::BitReader;
        #[doc = "Field `PWR_SYS_EN` writer - RWA, power for system"]
        pub type PwrSysEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWR_DCDC_EN` reader - RWA, DC/DC converter enable: 0=DC/DC disable and bypass, 1=DC/DC enable"]
        pub type PwrDcdcEnR = crate::BitReader;
        #[doc = "Field `PWR_DCDC_EN` writer - RWA, DC/DC converter enable: 0=DC/DC disable and bypass, 1=DC/DC enable"]
        pub type PwrDcdcEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWR_DCDC_PRE` reader - RWA, DC/DC converter pre-enable"]
        pub type PwrDcdcPreR = crate::BitReader;
        #[doc = "Field `PWR_DCDC_PRE` writer - RWA, DC/DC converter pre-enable"]
        pub type PwrDcdcPreW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWR_MUST_0010` reader - RWA, power plan enable, auto clear after sleep executed"]
        pub type PwrMust0010R = crate::FieldReader;
        #[doc = "Field `PWR_PLAN_EN` reader - RWA, must write 0010"]
        pub type PwrPlanEnR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - RWA, power for retention 2KB SRAM"]
            #[inline(always)]
            pub fn pwr_xrom(&self) -> PwrXromR {
                PwrXromR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RWA, power for retention 2KB SRAM"]
            #[inline(always)]
            pub fn pwr_ram2k(&self) -> PwrRam2kR {
                PwrRam2kR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RWA, power retention for core and base peripherals"]
            #[inline(always)]
            pub fn pwr_core(&self) -> PwrCoreR {
                PwrCoreR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RWA, power retention for USB and BLE"]
            #[inline(always)]
            pub fn pwr_extend(&self) -> PwrExtendR {
                PwrExtendR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RWA, power for main SRAM"]
            #[inline(always)]
            pub fn pwr_ram30k(&self) -> PwrRam30kR {
                PwrRam30kR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 7 - RWA, power for system"]
            #[inline(always)]
            pub fn pwr_sys_en(&self) -> PwrSysEnR {
                PwrSysEnR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 9 - RWA, DC/DC converter enable: 0=DC/DC disable and bypass, 1=DC/DC enable"]
            #[inline(always)]
            pub fn pwr_dcdc_en(&self) -> PwrDcdcEnR {
                PwrDcdcEnR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - RWA, DC/DC converter pre-enable"]
            #[inline(always)]
            pub fn pwr_dcdc_pre(&self) -> PwrDcdcPreR {
                PwrDcdcPreR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bits 11:14 - RWA, power plan enable, auto clear after sleep executed"]
            #[inline(always)]
            pub fn pwr_must_0010(&self) -> PwrMust0010R {
                PwrMust0010R::new(((self.bits >> 11) & 0x0f) as u8)
            }
            #[doc = "Bit 15 - RWA, must write 0010"]
            #[inline(always)]
            pub fn pwr_plan_en(&self) -> PwrPlanEnR {
                PwrPlanEnR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RWA, power for retention 2KB SRAM"]
            #[inline(always)]
            pub fn pwr_xrom(&mut self) -> PwrXromW<PowerPlanSpec> {
                PwrXromW::new(self, 0)
            }
            #[doc = "Bit 1 - RWA, power for retention 2KB SRAM"]
            #[inline(always)]
            pub fn pwr_ram2k(&mut self) -> PwrRam2kW<PowerPlanSpec> {
                PwrRam2kW::new(self, 1)
            }
            #[doc = "Bit 2 - RWA, power retention for core and base peripherals"]
            #[inline(always)]
            pub fn pwr_core(&mut self) -> PwrCoreW<PowerPlanSpec> {
                PwrCoreW::new(self, 2)
            }
            #[doc = "Bit 3 - RWA, power retention for USB and BLE"]
            #[inline(always)]
            pub fn pwr_extend(&mut self) -> PwrExtendW<PowerPlanSpec> {
                PwrExtendW::new(self, 3)
            }
            #[doc = "Bit 4 - RWA, power for main SRAM"]
            #[inline(always)]
            pub fn pwr_ram30k(&mut self) -> PwrRam30kW<PowerPlanSpec> {
                PwrRam30kW::new(self, 4)
            }
            #[doc = "Bit 7 - RWA, power for system"]
            #[inline(always)]
            pub fn pwr_sys_en(&mut self) -> PwrSysEnW<PowerPlanSpec> {
                PwrSysEnW::new(self, 7)
            }
            #[doc = "Bit 9 - RWA, DC/DC converter enable: 0=DC/DC disable and bypass, 1=DC/DC enable"]
            #[inline(always)]
            pub fn pwr_dcdc_en(&mut self) -> PwrDcdcEnW<PowerPlanSpec> {
                PwrDcdcEnW::new(self, 9)
            }
            #[doc = "Bit 10 - RWA, DC/DC converter pre-enable"]
            #[inline(always)]
            pub fn pwr_dcdc_pre(&mut self) -> PwrDcdcPreW<PowerPlanSpec> {
                PwrDcdcPreW::new(self, 10)
            }
        }
        #[doc = "RWA, power plan before sleep instruction, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`power_plan::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`power_plan::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PowerPlanSpec;
        impl crate::RegisterSpec for PowerPlanSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`power_plan::R`](R) reader structure"]
        impl crate::Readable for PowerPlanSpec {}
        #[doc = "`write(|w| ..)` method takes [`power_plan::W`](W) writer structure"]
        impl crate::Writable for PowerPlanSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets POWER_PLAN to value 0x11df"]
        impl crate::Resettable for PowerPlanSpec {
            const RESET_VALUE: u16 = 0x11df;
        }
    }
    #[doc = "AUX_POWER_ADJ (rw) register accessor: RWA, aux power adjust control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`aux_power_adj::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`aux_power_adj::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@aux_power_adj`] module"]
    #[doc(alias = "AUX_POWER_ADJ")]
    pub type AuxPowerAdj = crate::Reg<aux_power_adj::AuxPowerAdjSpec>;
    #[doc = "RWA, aux power adjust control, SAM"]
    pub mod aux_power_adj {
        #[doc = "Register `AUX_POWER_ADJ` reader"]
        pub type R = crate::R<AuxPowerAdjSpec>;
        #[doc = "Register `AUX_POWER_ADJ` writer"]
        pub type W = crate::W<AuxPowerAdjSpec>;
        #[doc = "Field `ULPLDO_ADJ` reader - RWA, Ultra-Low-Power LDO voltage adjust"]
        pub type UlpldoAdjR = crate::FieldReader;
        #[doc = "Field `ULPLDO_ADJ` writer - RWA, Ultra-Low-Power LDO voltage adjust"]
        pub type UlpldoAdjW<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        #[doc = "Field `DCDC_CHARGE` reader - RWA, Ultra-Low-Power LDO voltage adjust"]
        pub type DcdcChargeR = crate::BitReader;
        #[doc = "Field `DCDC_CHARGE` writer - RWA, Ultra-Low-Power LDO voltage adjust"]
        pub type DcdcChargeW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:2 - RWA, Ultra-Low-Power LDO voltage adjust"]
            #[inline(always)]
            pub fn ulpldo_adj(&self) -> UlpldoAdjR {
                UlpldoAdjR::new(self.bits & 7)
            }
            #[doc = "Bit 7 - RWA, Ultra-Low-Power LDO voltage adjust"]
            #[inline(always)]
            pub fn dcdc_charge(&self) -> DcdcChargeR {
                DcdcChargeR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - RWA, Ultra-Low-Power LDO voltage adjust"]
            #[inline(always)]
            pub fn ulpldo_adj(&mut self) -> UlpldoAdjW<AuxPowerAdjSpec> {
                UlpldoAdjW::new(self, 0)
            }
            #[doc = "Bit 7 - RWA, Ultra-Low-Power LDO voltage adjust"]
            #[inline(always)]
            pub fn dcdc_charge(&mut self) -> DcdcChargeW<AuxPowerAdjSpec> {
                DcdcChargeW::new(self, 7)
            }
        }
        #[doc = "RWA, aux power adjust control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`aux_power_adj::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`aux_power_adj::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct AuxPowerAdjSpec;
        impl crate::RegisterSpec for AuxPowerAdjSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`aux_power_adj::R`](R) reader structure"]
        impl crate::Readable for AuxPowerAdjSpec {}
        #[doc = "`write(|w| ..)` method takes [`aux_power_adj::W`](W) writer structure"]
        impl crate::Writable for AuxPowerAdjSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets AUX_POWER_ADJ to value 0"]
        impl crate::Resettable for AuxPowerAdjSpec {}
    }
    #[doc = "BAT_DET_CTRL (rw) register accessor: RWA, battery voltage detector control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`bat_det_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bat_det_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bat_det_ctrl`] module"]
    #[doc(alias = "BAT_DET_CTRL")]
    pub type BatDetCtrl = crate::Reg<bat_det_ctrl::BatDetCtrlSpec>;
    #[doc = "RWA, battery voltage detector control, SAM"]
    pub mod bat_det_ctrl {
        #[doc = "Register `BAT_DET_CTRL` reader"]
        pub type R = crate::R<BatDetCtrlSpec>;
        #[doc = "Register `BAT_DET_CTRL` writer"]
        pub type W = crate::W<BatDetCtrlSpec>;
        #[doc = "Field `BAT_DET_EN` reader - RWA, battery voltage detector enable/select monitor threshold voltage"]
        pub type BatDetEnR = crate::BitReader;
        #[doc = "Field `BAT_DET_EN` writer - RWA, battery voltage detector enable/select monitor threshold voltage"]
        pub type BatDetEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `BAT_LOW_VTHX` reader - RWA, battery voltage detector enable/select monitor threshold voltage"]
        pub type BatLowVthxR = crate::BitReader;
        #[doc = "Field `BAT_LOW_VTHX` writer - RWA, battery voltage detector enable/select monitor threshold voltage"]
        pub type BatLowVthxW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `BAT_MON_EN` reader - RWA, battery voltage monitor enable under sleep mode"]
        pub type BatMonEnR = crate::BitReader;
        #[doc = "Field `BAT_MON_EN` writer - RWA, battery voltage monitor enable under sleep mode"]
        pub type BatMonEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `BAT_LOWER_IE` reader - RWA, interrupt enable for battery lower voltage"]
        pub type BatLowerIeR = crate::BitReader;
        #[doc = "Field `BAT_LOWER_IE` writer - RWA, interrupt enable for battery lower voltage"]
        pub type BatLowerIeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `BAT_LOW_IE` reader - RWA, interrupt enable for battery low voltage"]
        pub type BatLowIeR = crate::BitReader;
        #[doc = "Field `BAT_LOW_IE` writer - RWA, interrupt enable for battery low voltage"]
        pub type BatLowIeW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RWA, battery voltage detector enable/select monitor threshold voltage"]
            #[inline(always)]
            pub fn bat_det_en(&self) -> BatDetEnR {
                BatDetEnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 0 - RWA, battery voltage detector enable/select monitor threshold voltage"]
            #[inline(always)]
            pub fn bat_low_vthx(&self) -> BatLowVthxR {
                BatLowVthxR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RWA, battery voltage monitor enable under sleep mode"]
            #[inline(always)]
            pub fn bat_mon_en(&self) -> BatMonEnR {
                BatMonEnR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RWA, interrupt enable for battery lower voltage"]
            #[inline(always)]
            pub fn bat_lower_ie(&self) -> BatLowerIeR {
                BatLowerIeR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RWA, interrupt enable for battery low voltage"]
            #[inline(always)]
            pub fn bat_low_ie(&self) -> BatLowIeR {
                BatLowIeR::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RWA, battery voltage detector enable/select monitor threshold voltage"]
            #[inline(always)]
            pub fn bat_det_en(&mut self) -> BatDetEnW<BatDetCtrlSpec> {
                BatDetEnW::new(self, 0)
            }
            #[doc = "Bit 0 - RWA, battery voltage detector enable/select monitor threshold voltage"]
            #[inline(always)]
            pub fn bat_low_vthx(&mut self) -> BatLowVthxW<BatDetCtrlSpec> {
                BatLowVthxW::new(self, 0)
            }
            #[doc = "Bit 1 - RWA, battery voltage monitor enable under sleep mode"]
            #[inline(always)]
            pub fn bat_mon_en(&mut self) -> BatMonEnW<BatDetCtrlSpec> {
                BatMonEnW::new(self, 1)
            }
            #[doc = "Bit 2 - RWA, interrupt enable for battery lower voltage"]
            #[inline(always)]
            pub fn bat_lower_ie(&mut self) -> BatLowerIeW<BatDetCtrlSpec> {
                BatLowerIeW::new(self, 2)
            }
            #[doc = "Bit 3 - RWA, interrupt enable for battery low voltage"]
            #[inline(always)]
            pub fn bat_low_ie(&mut self) -> BatLowIeW<BatDetCtrlSpec> {
                BatLowIeW::new(self, 3)
            }
        }
        #[doc = "RWA, battery voltage detector control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`bat_det_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bat_det_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct BatDetCtrlSpec;
        impl crate::RegisterSpec for BatDetCtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`bat_det_ctrl::R`](R) reader structure"]
        impl crate::Readable for BatDetCtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`bat_det_ctrl::W`](W) writer structure"]
        impl crate::Writable for BatDetCtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets BAT_DET_CTRL to value 0"]
        impl crate::Resettable for BatDetCtrlSpec {}
    }
    #[doc = "BAT_DET_CFG (rw) register accessor: RWA, battery voltage detector configuration, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`bat_det_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bat_det_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bat_det_cfg`] module"]
    #[doc(alias = "BAT_DET_CFG")]
    pub type BatDetCfg = crate::Reg<bat_det_cfg::BatDetCfgSpec>;
    #[doc = "RWA, battery voltage detector configuration, SAM"]
    pub mod bat_det_cfg {
        #[doc = "Register `BAT_DET_CFG` reader"]
        pub type R = crate::R<BatDetCfgSpec>;
        #[doc = "Register `BAT_DET_CFG` writer"]
        pub type W = crate::W<BatDetCfgSpec>;
        #[doc = "Field `BAT_LOW_VTH` reader - RWA, select threshold voltage of battery voltage low"]
        pub type BatLowVthR = crate::FieldReader;
        #[doc = "Field `BAT_LOW_VTH` writer - RWA, select threshold voltage of battery voltage low"]
        pub type BatLowVthW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            #[doc = "Bits 0:1 - RWA, select threshold voltage of battery voltage low"]
            #[inline(always)]
            pub fn bat_low_vth(&self) -> BatLowVthR {
                BatLowVthR::new(self.bits & 3)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - RWA, select threshold voltage of battery voltage low"]
            #[inline(always)]
            pub fn bat_low_vth(&mut self) -> BatLowVthW<BatDetCfgSpec> {
                BatLowVthW::new(self, 0)
            }
        }
        #[doc = "RWA, battery voltage detector configuration, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`bat_det_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bat_det_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct BatDetCfgSpec;
        impl crate::RegisterSpec for BatDetCfgSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`bat_det_cfg::R`](R) reader structure"]
        impl crate::Readable for BatDetCfgSpec {}
        #[doc = "`write(|w| ..)` method takes [`bat_det_cfg::W`](W) writer structure"]
        impl crate::Writable for BatDetCfgSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets BAT_DET_CFG to value 0x01"]
        impl crate::Resettable for BatDetCfgSpec {
            const RESET_VALUE: u8 = 0x01;
        }
    }
    #[doc = "BAT_STATUS (r) register accessor: RO, battery status\n\nYou can [`read`](crate::Reg::read) this register and get [`bat_status::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bat_status`] module"]
    #[doc(alias = "BAT_STATUS")]
    pub type BatStatus = crate::Reg<bat_status::BatStatusSpec>;
    #[doc = "RO, battery status"]
    pub mod bat_status {
        #[doc = "Register `BAT_STATUS` reader"]
        pub type R = crate::R<BatStatusSpec>;
        #[doc = "Field `BAT_STAT_LOWER` reader - RO, battery lower voltage status, high action"]
        pub type BatStatLowerR = crate::BitReader;
        #[doc = "Field `BAT_STAT_LOW` reader - RO, battery low voltage status, high action"]
        pub type BatStatLowR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - RO, battery lower voltage status, high action"]
            #[inline(always)]
            pub fn bat_stat_lower(&self) -> BatStatLowerR {
                BatStatLowerR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RO, battery low voltage status, high action"]
            #[inline(always)]
            pub fn bat_stat_low(&self) -> BatStatLowR {
                BatStatLowR::new(((self.bits >> 1) & 1) != 0)
            }
        }
        #[doc = "RO, battery status\n\nYou can [`read`](crate::Reg::read) this register and get [`bat_status::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct BatStatusSpec;
        impl crate::RegisterSpec for BatStatusSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`bat_status::R`](R) reader structure"]
        impl crate::Readable for BatStatusSpec {}
        #[doc = "`reset()` method sets BAT_STATUS to value 0"]
        impl crate::Resettable for BatStatusSpec {}
    }
    #[doc = "INT32K_TUNE (rw) register accessor: RWA, internal 32KHz oscillator tune control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`int32k_tune::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int32k_tune::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int32k_tune`] module"]
    #[doc(alias = "INT32K_TUNE")]
    pub type Int32kTune = crate::Reg<int32k_tune::Int32kTuneSpec>;
    #[doc = "RWA, internal 32KHz oscillator tune control, SAM"]
    pub mod int32k_tune {
        #[doc = "Register `INT32K_TUNE` reader"]
        pub type R = crate::R<Int32kTuneSpec>;
        #[doc = "Register `INT32K_TUNE` writer"]
        pub type W = crate::W<Int32kTuneSpec>;
        #[doc = "Field `INT32K_TUNE` reader - RWA, internal 32KHz oscillator frequency tune"]
        pub type Int32kTuneR = crate::FieldReader<u16>;
        #[doc = "Field `INT32K_TUNE` writer - RWA, internal 32KHz oscillator frequency tune"]
        pub type Int32kTuneW<'a, REG> = crate::FieldWriter<'a, REG, 13, u16>;
        impl R {
            #[doc = "Bits 0:12 - RWA, internal 32KHz oscillator frequency tune"]
            #[inline(always)]
            pub fn int32k_tune(&self) -> Int32kTuneR {
                Int32kTuneR::new(self.bits & 0x1fff)
            }
        }
        impl W {
            #[doc = "Bits 0:12 - RWA, internal 32KHz oscillator frequency tune"]
            #[inline(always)]
            pub fn int32k_tune(&mut self) -> Int32kTuneW<Int32kTuneSpec> {
                Int32kTuneW::new(self, 0)
            }
        }
        #[doc = "RWA, internal 32KHz oscillator tune control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`int32k_tune::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int32k_tune::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Int32kTuneSpec;
        impl crate::RegisterSpec for Int32kTuneSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`int32k_tune::R`](R) reader structure"]
        impl crate::Readable for Int32kTuneSpec {}
        #[doc = "`write(|w| ..)` method takes [`int32k_tune::W`](W) writer structure"]
        impl crate::Writable for Int32kTuneSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets INT32K_TUNE to value 0x1011"]
        impl crate::Resettable for Int32kTuneSpec {
            const RESET_VALUE: u16 = 0x1011;
        }
    }
    #[doc = "XT32K_TUNE (rw) register accessor: RWA, external 32KHz oscillator tune control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`xt32k_tune::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`xt32k_tune::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@xt32k_tune`] module"]
    #[doc(alias = "XT32K_TUNE")]
    pub type Xt32kTune = crate::Reg<xt32k_tune::Xt32kTuneSpec>;
    #[doc = "RWA, external 32KHz oscillator tune control, SAM"]
    pub mod xt32k_tune {
        #[doc = "Register `XT32K_TUNE` reader"]
        pub type R = crate::R<Xt32kTuneSpec>;
        #[doc = "Register `XT32K_TUNE` writer"]
        pub type W = crate::W<Xt32kTuneSpec>;
        #[doc = "Field `XT32K_I_TUNE` reader - RWA, external 32KHz oscillator current tune: 00=75% current, 01=standard current, 10=150% current, 11=200% current"]
        pub type Xt32kITuneR = crate::FieldReader;
        #[doc = "Field `XT32K_I_TUNE` writer - RWA, external 32KHz oscillator current tune: 00=75% current, 01=standard current, 10=150% current, 11=200% current"]
        pub type Xt32kITuneW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `XT32K_C_LOAD` reader - RWA, external 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF"]
        pub type Xt32kCLoadR = crate::FieldReader;
        #[doc = "Field `XT32K_C_LOAD` writer - RWA, external 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF"]
        pub type Xt32kCLoadW<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            #[doc = "Bits 0:1 - RWA, external 32KHz oscillator current tune: 00=75% current, 01=standard current, 10=150% current, 11=200% current"]
            #[inline(always)]
            pub fn xt32k_i_tune(&self) -> Xt32kITuneR {
                Xt32kITuneR::new(self.bits & 3)
            }
            #[doc = "Bits 4:7 - RWA, external 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF"]
            #[inline(always)]
            pub fn xt32k_c_load(&self) -> Xt32kCLoadR {
                Xt32kCLoadR::new((self.bits >> 4) & 0x0f)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - RWA, external 32KHz oscillator current tune: 00=75% current, 01=standard current, 10=150% current, 11=200% current"]
            #[inline(always)]
            pub fn xt32k_i_tune(&mut self) -> Xt32kITuneW<Xt32kTuneSpec> {
                Xt32kITuneW::new(self, 0)
            }
            #[doc = "Bits 4:7 - RWA, external 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF"]
            #[inline(always)]
            pub fn xt32k_c_load(&mut self) -> Xt32kCLoadW<Xt32kTuneSpec> {
                Xt32kCLoadW::new(self, 4)
            }
        }
        #[doc = "RWA, external 32KHz oscillator tune control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`xt32k_tune::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`xt32k_tune::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Xt32kTuneSpec;
        impl crate::RegisterSpec for Xt32kTuneSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`xt32k_tune::R`](R) reader structure"]
        impl crate::Readable for Xt32kTuneSpec {}
        #[doc = "`write(|w| ..)` method takes [`xt32k_tune::W`](W) writer structure"]
        impl crate::Writable for Xt32kTuneSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets XT32K_TUNE to value 0xc3"]
        impl crate::Resettable for Xt32kTuneSpec {
            const RESET_VALUE: u8 = 0xc3;
        }
    }
    #[doc = "CK32K_CONFIG (rw) register accessor: RWA, 32KHz oscillator configure\n\nYou can [`read`](crate::Reg::read) this register and get [`ck32k_config::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ck32k_config::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ck32k_config`] module"]
    #[doc(alias = "CK32K_CONFIG")]
    pub type Ck32kConfig = crate::Reg<ck32k_config::Ck32kConfigSpec>;
    #[doc = "RWA, 32KHz oscillator configure"]
    pub mod ck32k_config {
        #[doc = "Register `CK32K_CONFIG` reader"]
        pub type R = crate::R<Ck32kConfigSpec>;
        #[doc = "Register `CK32K_CONFIG` writer"]
        pub type W = crate::W<Ck32kConfigSpec>;
        #[doc = "Field `CLK_XT32K_PON` reader - RWA, external 32KHz oscillator power on"]
        pub type ClkXt32kPonR = crate::BitReader;
        #[doc = "Field `CLK_XT32K_PON` writer - RWA, external 32KHz oscillator power on"]
        pub type ClkXt32kPonW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CLK_INT32K_PON` reader - RWA, internal 32KHz oscillator power on"]
        pub type ClkInt32kPonR = crate::BitReader;
        #[doc = "Field `CLK_INT32K_PON` writer - RWA, internal 32KHz oscillator power on"]
        pub type ClkInt32kPonW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CLK_OSC32K_XT` reader - RWA, 32KHz oscillator source selection: 0=RC, 1=XT"]
        pub type ClkOsc32kXtR = crate::BitReader;
        #[doc = "Field `CLK_OSC32K_XT` writer - RWA, 32KHz oscillator source selection: 0=RC, 1=XT"]
        pub type ClkOsc32kXtW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CLK_OSC32K_FILT` reader - RWA, internal 32KHz oscillator low noise mode enable"]
        pub type ClkOsc32kFiltR = crate::BitReader;
        #[doc = "Field `CLK_OSC32K_FILT` writer - RWA, internal 32KHz oscillator low noise mode enable"]
        pub type ClkOsc32kFiltW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CLK_32K_PIN` reader - RO, 32KHz oscillator clock pin status"]
        pub type Clk32kPinR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - RWA, external 32KHz oscillator power on"]
            #[inline(always)]
            pub fn clk_xt32k_pon(&self) -> ClkXt32kPonR {
                ClkXt32kPonR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RWA, internal 32KHz oscillator power on"]
            #[inline(always)]
            pub fn clk_int32k_pon(&self) -> ClkInt32kPonR {
                ClkInt32kPonR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RWA, 32KHz oscillator source selection: 0=RC, 1=XT"]
            #[inline(always)]
            pub fn clk_osc32k_xt(&self) -> ClkOsc32kXtR {
                ClkOsc32kXtR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RWA, internal 32KHz oscillator low noise mode enable"]
            #[inline(always)]
            pub fn clk_osc32k_filt(&self) -> ClkOsc32kFiltR {
                ClkOsc32kFiltR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 7 - RO, 32KHz oscillator clock pin status"]
            #[inline(always)]
            pub fn clk_32k_pin(&self) -> Clk32kPinR {
                Clk32kPinR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RWA, external 32KHz oscillator power on"]
            #[inline(always)]
            pub fn clk_xt32k_pon(&mut self) -> ClkXt32kPonW<Ck32kConfigSpec> {
                ClkXt32kPonW::new(self, 0)
            }
            #[doc = "Bit 1 - RWA, internal 32KHz oscillator power on"]
            #[inline(always)]
            pub fn clk_int32k_pon(&mut self) -> ClkInt32kPonW<Ck32kConfigSpec> {
                ClkInt32kPonW::new(self, 1)
            }
            #[doc = "Bit 2 - RWA, 32KHz oscillator source selection: 0=RC, 1=XT"]
            #[inline(always)]
            pub fn clk_osc32k_xt(&mut self) -> ClkOsc32kXtW<Ck32kConfigSpec> {
                ClkOsc32kXtW::new(self, 2)
            }
            #[doc = "Bit 3 - RWA, internal 32KHz oscillator low noise mode enable"]
            #[inline(always)]
            pub fn clk_osc32k_filt(&mut self) -> ClkOsc32kFiltW<Ck32kConfigSpec> {
                ClkOsc32kFiltW::new(self, 3)
            }
        }
        #[doc = "RWA, 32KHz oscillator configure\n\nYou can [`read`](crate::Reg::read) this register and get [`ck32k_config::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ck32k_config::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ck32kConfigSpec;
        impl crate::RegisterSpec for Ck32kConfigSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`ck32k_config::R`](R) reader structure"]
        impl crate::Readable for Ck32kConfigSpec {}
        #[doc = "`write(|w| ..)` method takes [`ck32k_config::W`](W) writer structure"]
        impl crate::Writable for Ck32kConfigSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CK32K_CONFIG to value 0x02"]
        impl crate::Resettable for Ck32kConfigSpec {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    #[doc = "RTC_FLAG_CTRL (rw) register accessor: RW, RTC flag and clear control\n\nYou can [`read`](crate::Reg::read) this register and get [`rtc_flag_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtc_flag_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rtc_flag_ctrl`] module"]
    #[doc(alias = "RTC_FLAG_CTRL")]
    pub type RtcFlagCtrl = crate::Reg<rtc_flag_ctrl::RtcFlagCtrlSpec>;
    #[doc = "RW, RTC flag and clear control"]
    pub mod rtc_flag_ctrl {
        #[doc = "Register `RTC_FLAG_CTRL` reader"]
        pub type R = crate::R<RtcFlagCtrlSpec>;
        #[doc = "Register `RTC_FLAG_CTRL` writer"]
        pub type W = crate::W<RtcFlagCtrlSpec>;
        #[doc = "Field `RTC_TMR_CLR` reader - RW, set 1 to clear RTC timer action flag, auto clear"]
        pub type RtcTmrClrR = crate::BitReader;
        #[doc = "Field `RTC_TMR_CLR` writer - RW, set 1 to clear RTC timer action flag, auto clear"]
        pub type RtcTmrClrW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RTC_TRIG_CLR` reader - RW, set 1 to clear RTC trigger action flag, auto clear"]
        pub type RtcTrigClrR = crate::BitReader;
        #[doc = "Field `RTC_TRIG_CLR` writer - RW, set 1 to clear RTC trigger action flag, auto clear"]
        pub type RtcTrigClrW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RTC_TMR_FLAG` reader - RO, RTC timer action flag"]
        pub type RtcTmrFlagR = crate::BitReader;
        #[doc = "Field `RTC_TRIG_FLAG` reader - RO, RTC trigger action flag"]
        pub type RtcTrigFlagR = crate::BitReader;
        impl R {
            #[doc = "Bit 4 - RW, set 1 to clear RTC timer action flag, auto clear"]
            #[inline(always)]
            pub fn rtc_tmr_clr(&self) -> RtcTmrClrR {
                RtcTmrClrR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RW, set 1 to clear RTC trigger action flag, auto clear"]
            #[inline(always)]
            pub fn rtc_trig_clr(&self) -> RtcTrigClrR {
                RtcTrigClrR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RO, RTC timer action flag"]
            #[inline(always)]
            pub fn rtc_tmr_flag(&self) -> RtcTmrFlagR {
                RtcTmrFlagR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RO, RTC trigger action flag"]
            #[inline(always)]
            pub fn rtc_trig_flag(&self) -> RtcTrigFlagR {
                RtcTrigFlagR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 4 - RW, set 1 to clear RTC timer action flag, auto clear"]
            #[inline(always)]
            pub fn rtc_tmr_clr(&mut self) -> RtcTmrClrW<RtcFlagCtrlSpec> {
                RtcTmrClrW::new(self, 4)
            }
            #[doc = "Bit 5 - RW, set 1 to clear RTC trigger action flag, auto clear"]
            #[inline(always)]
            pub fn rtc_trig_clr(&mut self) -> RtcTrigClrW<RtcFlagCtrlSpec> {
                RtcTrigClrW::new(self, 5)
            }
        }
        #[doc = "RW, RTC flag and clear control\n\nYou can [`read`](crate::Reg::read) this register and get [`rtc_flag_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtc_flag_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RtcFlagCtrlSpec;
        impl crate::RegisterSpec for RtcFlagCtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`rtc_flag_ctrl::R`](R) reader structure"]
        impl crate::Readable for RtcFlagCtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`rtc_flag_ctrl::W`](W) writer structure"]
        impl crate::Writable for RtcFlagCtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets RTC_FLAG_CTRL to value 0x30"]
        impl crate::Resettable for RtcFlagCtrlSpec {
            const RESET_VALUE: u8 = 0x30;
        }
    }
    #[doc = "RTC_MODE_CTRL (rw) register accessor: RWA, RTC mode control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`rtc_mode_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtc_mode_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rtc_mode_ctrl`] module"]
    #[doc(alias = "RTC_MODE_CTRL")]
    pub type RtcModeCtrl = crate::Reg<rtc_mode_ctrl::RtcModeCtrlSpec>;
    #[doc = "RWA, RTC mode control, SAM"]
    pub mod rtc_mode_ctrl {
        #[doc = "Register `RTC_MODE_CTRL` reader"]
        pub type R = crate::R<RtcModeCtrlSpec>;
        #[doc = "Register `RTC_MODE_CTRL` writer"]
        pub type W = crate::W<RtcModeCtrlSpec>;
        #[doc = "Field `RTC_TMR_MODE` reader - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S"]
        pub type RtcTmrModeR = crate::FieldReader;
        #[doc = "Field `RTC_TMR_MODE` writer - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S"]
        pub type RtcTmrModeW<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        #[doc = "Field `RTC_IGNORE_B0` reader - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0"]
        pub type RtcIgnoreB0R = crate::BitReader;
        #[doc = "Field `RTC_IGNORE_B0` writer - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0"]
        pub type RtcIgnoreB0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RTC_TMR_EN` reader - RWA, RTC timer mode enable"]
        pub type RtcTmrEnR = crate::BitReader;
        #[doc = "Field `RTC_TMR_EN` writer - RWA, RTC timer mode enable"]
        pub type RtcTmrEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RTC_TRIG_EN` reader - RWA, RTC trigger mode enable"]
        pub type RtcTrigEnR = crate::BitReader;
        #[doc = "Field `RTC_TRIG_EN` writer - RWA, RTC trigger mode enable"]
        pub type RtcTrigEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RTC_LOAD_LO` reader - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded"]
        pub type RtcLoadLoR = crate::BitReader;
        #[doc = "Field `RTC_LOAD_LO` writer - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded"]
        pub type RtcLoadLoW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `RTC_LOAD_HI` reader - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded"]
        pub type RtcLoadHiR = crate::BitReader;
        #[doc = "Field `RTC_LOAD_HI` writer - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded"]
        pub type RtcLoadHiW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:2 - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S"]
            #[inline(always)]
            pub fn rtc_tmr_mode(&self) -> RtcTmrModeR {
                RtcTmrModeR::new(self.bits & 7)
            }
            #[doc = "Bit 3 - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0"]
            #[inline(always)]
            pub fn rtc_ignore_b0(&self) -> RtcIgnoreB0R {
                RtcIgnoreB0R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RWA, RTC timer mode enable"]
            #[inline(always)]
            pub fn rtc_tmr_en(&self) -> RtcTmrEnR {
                RtcTmrEnR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RWA, RTC trigger mode enable"]
            #[inline(always)]
            pub fn rtc_trig_en(&self) -> RtcTrigEnR {
                RtcTrigEnR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded"]
            #[inline(always)]
            pub fn rtc_load_lo(&self) -> RtcLoadLoR {
                RtcLoadLoR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded"]
            #[inline(always)]
            pub fn rtc_load_hi(&self) -> RtcLoadHiR {
                RtcLoadHiR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S"]
            #[inline(always)]
            pub fn rtc_tmr_mode(&mut self) -> RtcTmrModeW<RtcModeCtrlSpec> {
                RtcTmrModeW::new(self, 0)
            }
            #[doc = "Bit 3 - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0"]
            #[inline(always)]
            pub fn rtc_ignore_b0(&mut self) -> RtcIgnoreB0W<RtcModeCtrlSpec> {
                RtcIgnoreB0W::new(self, 3)
            }
            #[doc = "Bit 4 - RWA, RTC timer mode enable"]
            #[inline(always)]
            pub fn rtc_tmr_en(&mut self) -> RtcTmrEnW<RtcModeCtrlSpec> {
                RtcTmrEnW::new(self, 4)
            }
            #[doc = "Bit 5 - RWA, RTC trigger mode enable"]
            #[inline(always)]
            pub fn rtc_trig_en(&mut self) -> RtcTrigEnW<RtcModeCtrlSpec> {
                RtcTrigEnW::new(self, 5)
            }
            #[doc = "Bit 6 - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded"]
            #[inline(always)]
            pub fn rtc_load_lo(&mut self) -> RtcLoadLoW<RtcModeCtrlSpec> {
                RtcLoadLoW::new(self, 6)
            }
            #[doc = "Bit 7 - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded"]
            #[inline(always)]
            pub fn rtc_load_hi(&mut self) -> RtcLoadHiW<RtcModeCtrlSpec> {
                RtcLoadHiW::new(self, 7)
            }
        }
        #[doc = "RWA, RTC mode control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`rtc_mode_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtc_mode_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RtcModeCtrlSpec;
        impl crate::RegisterSpec for RtcModeCtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`rtc_mode_ctrl::R`](R) reader structure"]
        impl crate::Readable for RtcModeCtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`rtc_mode_ctrl::W`](W) writer structure"]
        impl crate::Writable for RtcModeCtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets RTC_MODE_CTRL to value 0x02"]
        impl crate::Resettable for RtcModeCtrlSpec {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    #[doc = "RTC_TRIG (rw) register accessor: RWA, RTC trigger value, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`rtc_trig::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtc_trig::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rtc_trig`] module"]
    #[doc(alias = "RTC_TRIG")]
    pub type RtcTrig = crate::Reg<rtc_trig::RtcTrigSpec>;
    #[doc = "RWA, RTC trigger value, SAM"]
    pub mod rtc_trig {
        #[doc = "Register `RTC_TRIG` reader"]
        pub type R = crate::R<RtcTrigSpec>;
        #[doc = "Register `RTC_TRIG` writer"]
        pub type W = crate::W<RtcTrigSpec>;
        #[doc = "Field `RTC_TRIG` reader - RWA, RTC trigger value"]
        pub type RtcTrigR = crate::FieldReader<u32>;
        #[doc = "Field `RTC_TRIG` writer - RWA, RTC trigger value"]
        pub type RtcTrigW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RWA, RTC trigger value"]
            #[inline(always)]
            pub fn rtc_trig(&self) -> RtcTrigR {
                RtcTrigR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RWA, RTC trigger value"]
            #[inline(always)]
            pub fn rtc_trig(&mut self) -> RtcTrigW<RtcTrigSpec> {
                RtcTrigW::new(self, 0)
            }
        }
        #[doc = "RWA, RTC trigger value, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`rtc_trig::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtc_trig::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RtcTrigSpec;
        impl crate::RegisterSpec for RtcTrigSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rtc_trig::R`](R) reader structure"]
        impl crate::Readable for RtcTrigSpec {}
        #[doc = "`write(|w| ..)` method takes [`rtc_trig::W`](W) writer structure"]
        impl crate::Writable for RtcTrigSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets RTC_TRIG to value 0"]
        impl crate::Resettable for RtcTrigSpec {}
    }
    #[doc = "RTC_CNT_32K (r) register accessor: RO, RTC count based 32KHz\n\nYou can [`read`](crate::Reg::read) this register and get [`rtc_cnt_32k::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rtc_cnt_32k`] module"]
    #[doc(alias = "RTC_CNT_32K")]
    pub type RtcCnt32k = crate::Reg<rtc_cnt_32k::RtcCnt32kSpec>;
    #[doc = "RO, RTC count based 32KHz"]
    pub mod rtc_cnt_32k {
        #[doc = "Register `RTC_CNT_32K` reader"]
        pub type R = crate::R<RtcCnt32kSpec>;
        #[doc = "Field `RTC_CNT_32K` reader - RWA,RTC count based 32KHz"]
        pub type RtcCnt32kR = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:15 - RWA,RTC count based 32KHz"]
            #[inline(always)]
            pub fn rtc_cnt_32k(&self) -> RtcCnt32kR {
                RtcCnt32kR::new(self.bits)
            }
        }
        #[doc = "RO, RTC count based 32KHz\n\nYou can [`read`](crate::Reg::read) this register and get [`rtc_cnt_32k::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RtcCnt32kSpec;
        impl crate::RegisterSpec for RtcCnt32kSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`rtc_cnt_32k::R`](R) reader structure"]
        impl crate::Readable for RtcCnt32kSpec {}
        #[doc = "`reset()` method sets RTC_CNT_32K to value 0"]
        impl crate::Resettable for RtcCnt32kSpec {}
    }
    #[doc = "RTC_CNT_2S (r) register accessor: RO, RTC count based 2 second\n\nYou can [`read`](crate::Reg::read) this register and get [`rtc_cnt_2s::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rtc_cnt_2s`] module"]
    #[doc(alias = "RTC_CNT_2S")]
    pub type RtcCnt2s = crate::Reg<rtc_cnt_2s::RtcCnt2sSpec>;
    #[doc = "RO, RTC count based 2 second"]
    pub mod rtc_cnt_2s {
        #[doc = "Register `RTC_CNT_2S` reader"]
        pub type R = crate::R<RtcCnt2sSpec>;
        #[doc = "Field `RTC_CNT_2S` reader - RO, RTC count based 2 second"]
        pub type RtcCnt2sR = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:15 - RO, RTC count based 2 second"]
            #[inline(always)]
            pub fn rtc_cnt_2s(&self) -> RtcCnt2sR {
                RtcCnt2sR::new(self.bits)
            }
        }
        #[doc = "RO, RTC count based 2 second\n\nYou can [`read`](crate::Reg::read) this register and get [`rtc_cnt_2s::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RtcCnt2sSpec;
        impl crate::RegisterSpec for RtcCnt2sSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`rtc_cnt_2s::R`](R) reader structure"]
        impl crate::Readable for RtcCnt2sSpec {}
        #[doc = "`reset()` method sets RTC_CNT_2S to value 0"]
        impl crate::Resettable for RtcCnt2sSpec {}
    }
    #[doc = "RTC_CNT_DAY (r) register accessor: RO, RTC count based one day, only low 14 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`rtc_cnt_day::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rtc_cnt_day`] module"]
    #[doc(alias = "RTC_CNT_DAY")]
    pub type RtcCntDay = crate::Reg<rtc_cnt_day::RtcCntDaySpec>;
    #[doc = "RO, RTC count based one day, only low 14 bit"]
    pub mod rtc_cnt_day {
        #[doc = "Register `RTC_CNT_DAY` reader"]
        pub type R = crate::R<RtcCntDaySpec>;
        #[doc = "Field `RTC_CNT_DAY` reader - RWA,RTC count based one day"]
        pub type RtcCntDayR = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:13 - RWA,RTC count based one day"]
            #[inline(always)]
            pub fn rtc_cnt_day(&self) -> RtcCntDayR {
                RtcCntDayR::new((self.bits & 0x3fff) as u16)
            }
        }
        #[doc = "RO, RTC count based one day, only low 14 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`rtc_cnt_day::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RtcCntDaySpec;
        impl crate::RegisterSpec for RtcCntDaySpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`rtc_cnt_day::R`](R) reader structure"]
        impl crate::Readable for RtcCntDaySpec {}
        #[doc = "`reset()` method sets RTC_CNT_DAY to value 0"]
        impl crate::Resettable for RtcCntDaySpec {}
    }
    #[doc = "SAFE_ACCESS_SIG (rw) register accessor: WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode\n\nYou can [`read`](crate::Reg::read) this register and get [`safe_access_sig::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`safe_access_sig::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@safe_access_sig`] module"]
    #[doc(alias = "SAFE_ACCESS_SIG")]
    pub type SafeAccessSig = crate::Reg<safe_access_sig::SafeAccessSigSpec>;
    #[doc = "WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode"]
    pub mod safe_access_sig {
        #[doc = "Register `SAFE_ACCESS_SIG` reader"]
        pub type R = crate::R<SafeAccessSigSpec>;
        #[doc = "Register `SAFE_ACCESS_SIG` writer"]
        pub type W = crate::W<SafeAccessSigSpec>;
        #[doc = "Field `SAFE_ACC_MODE` reader - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)"]
        pub type SafeAccModeR = crate::FieldReader;
        #[doc = "Field `SAFE_ACC_MODE` writer - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)"]
        pub type SafeAccModeW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `SAFE_ACCESS_SIG` reader - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode"]
        pub type SafeAccessSigR = crate::FieldReader;
        #[doc = "Field `SAFE_ACCESS_SIG` writer - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode"]
        pub type SafeAccessSigW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `SAFE_ACC_ACT` reader - RO, indicate safe accessing status now: 0=locked, read only, 1=safe/unlocked (SAM), write enabled"]
        pub type SafeAccActR = crate::BitReader;
        #[doc = "Field `SAFE_ACC_ACT` writer - RO, indicate safe accessing status now: 0=locked, read only, 1=safe/unlocked (SAM), write enabled"]
        pub type SafeAccActW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SAFE_ACC_TIMER` reader - RO, safe accessing timer bit mask (16*clock number)"]
        pub type SafeAccTimerR = crate::FieldReader;
        #[doc = "Field `SAFE_ACC_TIMER` writer - RO, safe accessing timer bit mask (16*clock number)"]
        pub type SafeAccTimerW<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        impl R {
            #[doc = "Bits 0:1 - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)"]
            #[inline(always)]
            pub fn safe_acc_mode(&self) -> SafeAccModeR {
                SafeAccModeR::new(self.bits & 3)
            }
            #[doc = "Bits 0:7 - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode"]
            #[inline(always)]
            pub fn safe_access_sig(&self) -> SafeAccessSigR {
                SafeAccessSigR::new(self.bits)
            }
            #[doc = "Bit 3 - RO, indicate safe accessing status now: 0=locked, read only, 1=safe/unlocked (SAM), write enabled"]
            #[inline(always)]
            pub fn safe_acc_act(&self) -> SafeAccActR {
                SafeAccActR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:6 - RO, safe accessing timer bit mask (16*clock number)"]
            #[inline(always)]
            pub fn safe_acc_timer(&self) -> SafeAccTimerR {
                SafeAccTimerR::new((self.bits >> 4) & 7)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)"]
            #[inline(always)]
            pub fn safe_acc_mode(&mut self) -> SafeAccModeW<SafeAccessSigSpec> {
                SafeAccModeW::new(self, 0)
            }
            #[doc = "Bits 0:7 - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode"]
            #[inline(always)]
            pub fn safe_access_sig(&mut self) -> SafeAccessSigW<SafeAccessSigSpec> {
                SafeAccessSigW::new(self, 0)
            }
            #[doc = "Bit 3 - RO, indicate safe accessing status now: 0=locked, read only, 1=safe/unlocked (SAM), write enabled"]
            #[inline(always)]
            pub fn safe_acc_act(&mut self) -> SafeAccActW<SafeAccessSigSpec> {
                SafeAccActW::new(self, 3)
            }
            #[doc = "Bits 4:6 - RO, safe accessing timer bit mask (16*clock number)"]
            #[inline(always)]
            pub fn safe_acc_timer(&mut self) -> SafeAccTimerW<SafeAccessSigSpec> {
                SafeAccTimerW::new(self, 4)
            }
        }
        #[doc = "WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode\n\nYou can [`read`](crate::Reg::read) this register and get [`safe_access_sig::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`safe_access_sig::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SafeAccessSigSpec;
        impl crate::RegisterSpec for SafeAccessSigSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`safe_access_sig::R`](R) reader structure"]
        impl crate::Readable for SafeAccessSigSpec {}
        #[doc = "`write(|w| ..)` method takes [`safe_access_sig::W`](W) writer structure"]
        impl crate::Writable for SafeAccessSigSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SAFE_ACCESS_SIG to value 0"]
        impl crate::Resettable for SafeAccessSigSpec {}
    }
    #[doc = "CHIP_ID (r) register accessor: RF, chip ID register, always is ID_CH58*\n\nYou can [`read`](crate::Reg::read) this register and get [`chip_id::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@chip_id`] module"]
    #[doc(alias = "CHIP_ID")]
    pub type ChipId = crate::Reg<chip_id::ChipIdSpec>;
    #[doc = "RF, chip ID register, always is ID_CH58*"]
    pub mod chip_id {
        #[doc = "Register `CHIP_ID` reader"]
        pub type R = crate::R<ChipIdSpec>;
        #[doc = "Field `CHIP_ID` reader - RF,chip ID register"]
        pub type ChipIdR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RF,chip ID register"]
            #[inline(always)]
            pub fn chip_id(&self) -> ChipIdR {
                ChipIdR::new(self.bits)
            }
        }
        #[doc = "RF, chip ID register, always is ID_CH58*\n\nYou can [`read`](crate::Reg::read) this register and get [`chip_id::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ChipIdSpec;
        impl crate::RegisterSpec for ChipIdSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`chip_id::R`](R) reader structure"]
        impl crate::Readable for ChipIdSpec {}
        #[doc = "`reset()` method sets CHIP_ID to value 0x83"]
        impl crate::Resettable for ChipIdSpec {
            const RESET_VALUE: u8 = 0x83;
        }
    }
    #[doc = "SAFE_ACCESS_ID (r) register accessor: RF, safe accessing ID register, always 0x0C\n\nYou can [`read`](crate::Reg::read) this register and get [`safe_access_id::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@safe_access_id`] module"]
    #[doc(alias = "SAFE_ACCESS_ID")]
    pub type SafeAccessId = crate::Reg<safe_access_id::SafeAccessIdSpec>;
    #[doc = "RF, safe accessing ID register, always 0x0C"]
    pub mod safe_access_id {
        #[doc = "Register `SAFE_ACCESS_ID` reader"]
        pub type R = crate::R<SafeAccessIdSpec>;
        #[doc = "Field `SAFE_ACCESS_ID` reader - RF,safe accessing ID register"]
        pub type SafeAccessIdR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RF,safe accessing ID register"]
            #[inline(always)]
            pub fn safe_access_id(&self) -> SafeAccessIdR {
                SafeAccessIdR::new(self.bits)
            }
        }
        #[doc = "RF, safe accessing ID register, always 0x0C\n\nYou can [`read`](crate::Reg::read) this register and get [`safe_access_id::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SafeAccessIdSpec;
        impl crate::RegisterSpec for SafeAccessIdSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`safe_access_id::R`](R) reader structure"]
        impl crate::Readable for SafeAccessIdSpec {}
        #[doc = "`reset()` method sets SAFE_ACCESS_ID to value 0x0c"]
        impl crate::Resettable for SafeAccessIdSpec {
            const RESET_VALUE: u8 = 0x0c;
        }
    }
    #[doc = "WDOG_COUNT (rw) register accessor: RW, watch-dog count, count by clock frequency Fsys/131072\n\nYou can [`read`](crate::Reg::read) this register and get [`wdog_count::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`wdog_count::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@wdog_count`] module"]
    #[doc(alias = "WDOG_COUNT")]
    pub type WdogCount = crate::Reg<wdog_count::WdogCountSpec>;
    #[doc = "RW, watch-dog count, count by clock frequency Fsys/131072"]
    pub mod wdog_count {
        #[doc = "Register `WDOG_COUNT` reader"]
        pub type R = crate::R<WdogCountSpec>;
        #[doc = "Register `WDOG_COUNT` writer"]
        pub type W = crate::W<WdogCountSpec>;
        #[doc = "Field `WDOG_COUNT` reader - RF,watch-dog count, count by clock frequency Fsys/131072"]
        pub type WdogCountR = crate::FieldReader;
        #[doc = "Field `WDOG_COUNT` writer - RF,watch-dog count, count by clock frequency Fsys/131072"]
        pub type WdogCountW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RF,watch-dog count, count by clock frequency Fsys/131072"]
            #[inline(always)]
            pub fn wdog_count(&self) -> WdogCountR {
                WdogCountR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RF,watch-dog count, count by clock frequency Fsys/131072"]
            #[inline(always)]
            pub fn wdog_count(&mut self) -> WdogCountW<WdogCountSpec> {
                WdogCountW::new(self, 0)
            }
        }
        #[doc = "RW, watch-dog count, count by clock frequency Fsys/131072\n\nYou can [`read`](crate::Reg::read) this register and get [`wdog_count::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`wdog_count::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct WdogCountSpec;
        impl crate::RegisterSpec for WdogCountSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`wdog_count::R`](R) reader structure"]
        impl crate::Readable for WdogCountSpec {}
        #[doc = "`write(|w| ..)` method takes [`wdog_count::W`](W) writer structure"]
        impl crate::Writable for WdogCountSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets WDOG_COUNT to value 0"]
        impl crate::Resettable for WdogCountSpec {}
    }
    #[doc = "RESET_STATUS_R8_GLOB_ROM_CFG (r) register accessor: RWA, reset status, SAM or flash ROM configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`reset_status_r8_glob_rom_cfg::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reset_status_r8_glob_rom_cfg`] module"]
    #[doc(alias = "RESET_STATUS_R8_GLOB_ROM_CFG")]
    pub type ResetStatusR8GlobRomCfg =
        crate::Reg<reset_status_r8_glob_rom_cfg::ResetStatusR8GlobRomCfgSpec>;
    #[doc = "RWA, reset status, SAM or flash ROM configuration"]
    pub mod reset_status_r8_glob_rom_cfg {
        #[doc = "Register `RESET_STATUS_R8_GLOB_ROM_CFG` reader"]
        pub type R = crate::R<ResetStatusR8GlobRomCfgSpec>;
        #[doc = "Field `RESET_FLAG` reader - RO, recent reset flag"]
        pub type ResetFlagR = crate::FieldReader;
        #[doc = "Field `ROM_CODE_OFS` reader - RWA, code offset address selection in Flash ROM: 0=start address 0x000000, 1=start address 0x008000"]
        pub type RomCodeOfsR = crate::BitReader;
        #[doc = "Field `ROM_CTRL_EN` reader - RWA, enable flash ROM control interface enable"]
        pub type RomCtrlEnR = crate::BitReader;
        #[doc = "Field `ROM_DATA_WE` reader - RWA,enable flash ROM data and code area being erase/write"]
        pub type RomDataWeR = crate::BitReader;
        #[doc = "Field `ROM_CODE_WE` reader - RWA, enable flash ROM code area being erase or write"]
        pub type RomCodeWeR = crate::BitReader;
        impl R {
            #[doc = "Bits 0:2 - RO, recent reset flag"]
            #[inline(always)]
            pub fn reset_flag(&self) -> ResetFlagR {
                ResetFlagR::new(self.bits & 7)
            }
            #[doc = "Bit 4 - RWA, code offset address selection in Flash ROM: 0=start address 0x000000, 1=start address 0x008000"]
            #[inline(always)]
            pub fn rom_code_ofs(&self) -> RomCodeOfsR {
                RomCodeOfsR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RWA, enable flash ROM control interface enable"]
            #[inline(always)]
            pub fn rom_ctrl_en(&self) -> RomCtrlEnR {
                RomCtrlEnR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RWA,enable flash ROM data and code area being erase/write"]
            #[inline(always)]
            pub fn rom_data_we(&self) -> RomDataWeR {
                RomDataWeR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RWA, enable flash ROM code area being erase or write"]
            #[inline(always)]
            pub fn rom_code_we(&self) -> RomCodeWeR {
                RomCodeWeR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        #[doc = "RWA, reset status, SAM or flash ROM configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`reset_status_r8_glob_rom_cfg::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ResetStatusR8GlobRomCfgSpec;
        impl crate::RegisterSpec for ResetStatusR8GlobRomCfgSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`reset_status_r8_glob_rom_cfg::R`](R) reader structure"]
        impl crate::Readable for ResetStatusR8GlobRomCfgSpec {}
        #[doc = "`reset()` method sets RESET_STATUS_R8_GLOB_ROM_CFG to value 0x01"]
        impl crate::Resettable for ResetStatusR8GlobRomCfgSpec {
            const RESET_VALUE: u8 = 0x01;
        }
    }
    #[doc = "GLOB_CFG_INFO (r) register accessor: RO, global configuration information and status\n\nYou can [`read`](crate::Reg::read) this register and get [`glob_cfg_info::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@glob_cfg_info`] module"]
    #[doc(alias = "GLOB_CFG_INFO")]
    pub type GlobCfgInfo = crate::Reg<glob_cfg_info::GlobCfgInfoSpec>;
    #[doc = "RO, global configuration information and status"]
    pub mod glob_cfg_info {
        #[doc = "Register `GLOB_CFG_INFO` reader"]
        pub type R = crate::R<GlobCfgInfoSpec>;
        #[doc = "Field `CFG_ROM_READ` reader - RO, indicate protected status of Flash ROM code and data: 0=reading protect, 1=enable read by external programmer"]
        pub type CfgRomReadR = crate::BitReader;
        #[doc = "Field `CFG_RESET_EN` reader - RO, manual reset input enable status"]
        pub type CfgResetEnR = crate::BitReader;
        #[doc = "Field `CFG_BOOT_EN` reader - RO, boot-loader enable status"]
        pub type CfgBootEnR = crate::BitReader;
        #[doc = "Field `CFG_DEBUG_EN` reader - RO, debug enable status"]
        pub type CfgDebugEnR = crate::BitReader;
        #[doc = "Field `BOOT_LOADER` reader - RO, indicate boot loader status: 0=application status (by software reset), 1=boot loader status"]
        pub type BootLoaderR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - RO, indicate protected status of Flash ROM code and data: 0=reading protect, 1=enable read by external programmer"]
            #[inline(always)]
            pub fn cfg_rom_read(&self) -> CfgRomReadR {
                CfgRomReadR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 2 - RO, manual reset input enable status"]
            #[inline(always)]
            pub fn cfg_reset_en(&self) -> CfgResetEnR {
                CfgResetEnR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RO, boot-loader enable status"]
            #[inline(always)]
            pub fn cfg_boot_en(&self) -> CfgBootEnR {
                CfgBootEnR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RO, debug enable status"]
            #[inline(always)]
            pub fn cfg_debug_en(&self) -> CfgDebugEnR {
                CfgDebugEnR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RO, indicate boot loader status: 0=application status (by software reset), 1=boot loader status"]
            #[inline(always)]
            pub fn boot_loader(&self) -> BootLoaderR {
                BootLoaderR::new(((self.bits >> 5) & 1) != 0)
            }
        }
        #[doc = "RO, global configuration information and status\n\nYou can [`read`](crate::Reg::read) this register and get [`glob_cfg_info::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GlobCfgInfoSpec;
        impl crate::RegisterSpec for GlobCfgInfoSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`glob_cfg_info::R`](R) reader structure"]
        impl crate::Readable for GlobCfgInfoSpec {}
        #[doc = "`reset()` method sets GLOB_CFG_INFO to value 0xe0"]
        impl crate::Resettable for GlobCfgInfoSpec {
            const RESET_VALUE: u8 = 0xe0;
        }
    }
    #[doc = "RST_WDOG_CTRL (rw) register accessor: RWA, reset and watch-dog control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`rst_wdog_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rst_wdog_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rst_wdog_ctrl`] module"]
    #[doc(alias = "RST_WDOG_CTRL")]
    pub type RstWdogCtrl = crate::Reg<rst_wdog_ctrl::RstWdogCtrlSpec>;
    #[doc = "RWA, reset and watch-dog control, SAM"]
    pub mod rst_wdog_ctrl {
        #[doc = "Register `RST_WDOG_CTRL` reader"]
        pub type R = crate::R<RstWdogCtrlSpec>;
        #[doc = "Register `RST_WDOG_CTRL` writer"]
        pub type W = crate::W<RstWdogCtrlSpec>;
        #[doc = "Field `SOFTWARE_RESET` reader - WA or WZ, global software reset, high action, auto clear"]
        pub type SoftwareResetR = crate::BitReader;
        #[doc = "Field `SOFTWARE_RESET` writer - WA or WZ, global software reset, high action, auto clear"]
        pub type SoftwareResetW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WDOG_RST_EN` reader - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow"]
        pub type WdogRstEnR = crate::BitReader;
        #[doc = "Field `WDOG_RST_EN` writer - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow"]
        pub type WdogRstEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WDOG_INT_EN` reader - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable"]
        pub type WdogIntEnR = crate::BitReader;
        #[doc = "Field `WDOG_INT_EN` writer - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable"]
        pub type WdogIntEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WDOG_INT_FLAG` reader - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)"]
        pub type WdogIntFlagR = crate::BitReader;
        #[doc = "Field `WDOG_INT_FLAG` writer - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)"]
        pub type WdogIntFlagW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - WA or WZ, global software reset, high action, auto clear"]
            #[inline(always)]
            pub fn software_reset(&self) -> SoftwareResetR {
                SoftwareResetR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow"]
            #[inline(always)]
            pub fn wdog_rst_en(&self) -> WdogRstEnR {
                WdogRstEnR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable"]
            #[inline(always)]
            pub fn wdog_int_en(&self) -> WdogIntEnR {
                WdogIntEnR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 4 - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)"]
            #[inline(always)]
            pub fn wdog_int_flag(&self) -> WdogIntFlagR {
                WdogIntFlagR::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - WA or WZ, global software reset, high action, auto clear"]
            #[inline(always)]
            pub fn software_reset(&mut self) -> SoftwareResetW<RstWdogCtrlSpec> {
                SoftwareResetW::new(self, 0)
            }
            #[doc = "Bit 1 - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow"]
            #[inline(always)]
            pub fn wdog_rst_en(&mut self) -> WdogRstEnW<RstWdogCtrlSpec> {
                WdogRstEnW::new(self, 1)
            }
            #[doc = "Bit 2 - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable"]
            #[inline(always)]
            pub fn wdog_int_en(&mut self) -> WdogIntEnW<RstWdogCtrlSpec> {
                WdogIntEnW::new(self, 2)
            }
            #[doc = "Bit 4 - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)"]
            #[inline(always)]
            pub fn wdog_int_flag(&mut self) -> WdogIntFlagW<RstWdogCtrlSpec> {
                WdogIntFlagW::new(self, 4)
            }
        }
        #[doc = "RWA, reset and watch-dog control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`rst_wdog_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rst_wdog_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RstWdogCtrlSpec;
        impl crate::RegisterSpec for RstWdogCtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`rst_wdog_ctrl::R`](R) reader structure"]
        impl crate::Readable for RstWdogCtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`rst_wdog_ctrl::W`](W) writer structure"]
        impl crate::Writable for RstWdogCtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets RST_WDOG_CTRL to value 0"]
        impl crate::Resettable for RstWdogCtrlSpec {}
    }
    #[doc = "GLOB_RESET_KEEP (rw) register accessor: RW, value keeper during global reset\n\nYou can [`read`](crate::Reg::read) this register and get [`glob_reset_keep::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`glob_reset_keep::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@glob_reset_keep`] module"]
    #[doc(alias = "GLOB_RESET_KEEP")]
    pub type GlobResetKeep = crate::Reg<glob_reset_keep::GlobResetKeepSpec>;
    #[doc = "RW, value keeper during global reset"]
    pub mod glob_reset_keep {
        #[doc = "Register `GLOB_RESET_KEEP` reader"]
        pub type R = crate::R<GlobResetKeepSpec>;
        #[doc = "Register `GLOB_RESET_KEEP` writer"]
        pub type W = crate::W<GlobResetKeepSpec>;
        #[doc = "Field `GLOB_RESET_KEEP` reader - RW, value keeper during global reset"]
        pub type GlobResetKeepR = crate::FieldReader;
        #[doc = "Field `GLOB_RESET_KEEP` writer - RW, value keeper during global reset"]
        pub type GlobResetKeepW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW, value keeper during global reset"]
            #[inline(always)]
            pub fn glob_reset_keep(&self) -> GlobResetKeepR {
                GlobResetKeepR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW, value keeper during global reset"]
            #[inline(always)]
            pub fn glob_reset_keep(&mut self) -> GlobResetKeepW<GlobResetKeepSpec> {
                GlobResetKeepW::new(self, 0)
            }
        }
        #[doc = "RW, value keeper during global reset\n\nYou can [`read`](crate::Reg::read) this register and get [`glob_reset_keep::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`glob_reset_keep::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GlobResetKeepSpec;
        impl crate::RegisterSpec for GlobResetKeepSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`glob_reset_keep::R`](R) reader structure"]
        impl crate::Readable for GlobResetKeepSpec {}
        #[doc = "`write(|w| ..)` method takes [`glob_reset_keep::W`](W) writer structure"]
        impl crate::Writable for GlobResetKeepSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets GLOB_RESET_KEEP to value 0"]
        impl crate::Resettable for GlobResetKeepSpec {}
    }
    #[doc = "PLL_CONFIG (rw) register accessor: RWA, PLL configuration control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`pll_config::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pll_config::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pll_config`] module"]
    #[doc(alias = "PLL_CONFIG")]
    pub type PllConfig = crate::Reg<pll_config::PllConfigSpec>;
    #[doc = "RWA, PLL configuration control, SAM"]
    pub mod pll_config {
        #[doc = "Register `PLL_CONFIG` reader"]
        pub type R = crate::R<PllConfigSpec>;
        #[doc = "Register `PLL_CONFIG` writer"]
        pub type W = crate::W<PllConfigSpec>;
        #[doc = "Field `PLL_CFG_DAT` reader - RWA, PLL configure data"]
        pub type PllCfgDatR = crate::FieldReader;
        #[doc = "Field `PLL_CFG_DAT` writer - RWA, PLL configure data"]
        pub type PllCfgDatW<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        #[doc = "Field `FLASH_IO_MOD` reader - RWA, flash ROM interface mode"]
        pub type FlashIoModR = crate::BitReader;
        #[doc = "Field `FLASH_IO_MOD` writer - RWA, flash ROM interface mode"]
        pub type FlashIoModW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:6 - RWA, PLL configure data"]
            #[inline(always)]
            pub fn pll_cfg_dat(&self) -> PllCfgDatR {
                PllCfgDatR::new(self.bits & 0x7f)
            }
            #[doc = "Bit 7 - RWA, flash ROM interface mode"]
            #[inline(always)]
            pub fn flash_io_mod(&self) -> FlashIoModR {
                FlashIoModR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:6 - RWA, PLL configure data"]
            #[inline(always)]
            pub fn pll_cfg_dat(&mut self) -> PllCfgDatW<PllConfigSpec> {
                PllCfgDatW::new(self, 0)
            }
            #[doc = "Bit 7 - RWA, flash ROM interface mode"]
            #[inline(always)]
            pub fn flash_io_mod(&mut self) -> FlashIoModW<PllConfigSpec> {
                FlashIoModW::new(self, 7)
            }
        }
        #[doc = "RWA, PLL configuration control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`pll_config::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pll_config::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PllConfigSpec;
        impl crate::RegisterSpec for PllConfigSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`pll_config::R`](R) reader structure"]
        impl crate::Readable for PllConfigSpec {}
        #[doc = "`write(|w| ..)` method takes [`pll_config::W`](W) writer structure"]
        impl crate::Writable for PllConfigSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PLL_CONFIG to value 0x4a"]
        impl crate::Resettable for PllConfigSpec {
            const RESET_VALUE: u8 = 0x4a;
        }
    }
    #[doc = "XT32M_TUNE (rw) register accessor: RWA, external 32MHz oscillator tune control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`xt32m_tune::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`xt32m_tune::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@xt32m_tune`] module"]
    #[doc(alias = "XT32M_TUNE")]
    pub type Xt32mTune = crate::Reg<xt32m_tune::Xt32mTuneSpec>;
    #[doc = "RWA, external 32MHz oscillator tune control, SAM"]
    pub mod xt32m_tune {
        #[doc = "Register `XT32M_TUNE` reader"]
        pub type R = crate::R<Xt32mTuneSpec>;
        #[doc = "Register `XT32M_TUNE` writer"]
        pub type W = crate::W<Xt32mTuneSpec>;
        #[doc = "Field `XT32M_I_BIAS` reader - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current"]
        pub type Xt32mIBiasR = crate::FieldReader;
        #[doc = "Field `XT32M_I_BIAS` writer - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current"]
        pub type Xt32mIBiasW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `XT32M_C_LOAD` reader - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF"]
        pub type Xt32mCLoadR = crate::FieldReader;
        #[doc = "Field `XT32M_C_LOAD` writer - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF"]
        pub type Xt32mCLoadW<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        impl R {
            #[doc = "Bits 0:1 - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current"]
            #[inline(always)]
            pub fn xt32m_i_bias(&self) -> Xt32mIBiasR {
                Xt32mIBiasR::new(self.bits & 3)
            }
            #[doc = "Bits 4:6 - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF"]
            #[inline(always)]
            pub fn xt32m_c_load(&self) -> Xt32mCLoadR {
                Xt32mCLoadR::new((self.bits >> 4) & 7)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current"]
            #[inline(always)]
            pub fn xt32m_i_bias(&mut self) -> Xt32mIBiasW<Xt32mTuneSpec> {
                Xt32mIBiasW::new(self, 0)
            }
            #[doc = "Bits 4:6 - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF"]
            #[inline(always)]
            pub fn xt32m_c_load(&mut self) -> Xt32mCLoadW<Xt32mTuneSpec> {
                Xt32mCLoadW::new(self, 4)
            }
        }
        #[doc = "RWA, external 32MHz oscillator tune control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`xt32m_tune::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`xt32m_tune::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Xt32mTuneSpec;
        impl crate::RegisterSpec for Xt32mTuneSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`xt32m_tune::R`](R) reader structure"]
        impl crate::Readable for Xt32mTuneSpec {}
        #[doc = "`write(|w| ..)` method takes [`xt32m_tune::W`](W) writer structure"]
        impl crate::Writable for Xt32mTuneSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets XT32M_TUNE to value 0x32"]
        impl crate::Resettable for Xt32mTuneSpec {
            const RESET_VALUE: u8 = 0x32;
        }
    }
    #[doc = "OSC_CAL_CNT (r) register accessor: RO, system clock count value for 32KHz multi-cycles\n\nYou can [`read`](crate::Reg::read) this register and get [`osc_cal_cnt::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@osc_cal_cnt`] module"]
    #[doc(alias = "OSC_CAL_CNT")]
    pub type OscCalCnt = crate::Reg<osc_cal_cnt::OscCalCntSpec>;
    #[doc = "RO, system clock count value for 32KHz multi-cycles"]
    pub mod osc_cal_cnt {
        #[doc = "Register `OSC_CAL_CNT` reader"]
        pub type R = crate::R<OscCalCntSpec>;
        #[doc = "Field `OSC_CAL_CNT` reader - RO, system clock count value for 32KHz multi-cycles"]
        pub type OscCalCntR = crate::FieldReader<u16>;
        #[doc = "Field `OSC_CAL_OV_CLR` reader - RW1, indicate R8_OSC_CAL_OV_CNT not zero, set 1 to clear R8_OSC_CAL_OV_CNT"]
        pub type OscCalOvClrR = crate::BitReader;
        #[doc = "Field `OSC_CAL_IF` reader - RW1, interrupt flag for oscillator capture end, set 1 to clear"]
        pub type OscCalIfR = crate::BitReader;
        impl R {
            #[doc = "Bits 0:13 - RO, system clock count value for 32KHz multi-cycles"]
            #[inline(always)]
            pub fn osc_cal_cnt(&self) -> OscCalCntR {
                OscCalCntR::new(self.bits & 0x3fff)
            }
            #[doc = "Bit 14 - RW1, indicate R8_OSC_CAL_OV_CNT not zero, set 1 to clear R8_OSC_CAL_OV_CNT"]
            #[inline(always)]
            pub fn osc_cal_ov_clr(&self) -> OscCalOvClrR {
                OscCalOvClrR::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - RW1, interrupt flag for oscillator capture end, set 1 to clear"]
            #[inline(always)]
            pub fn osc_cal_if(&self) -> OscCalIfR {
                OscCalIfR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        #[doc = "RO, system clock count value for 32KHz multi-cycles\n\nYou can [`read`](crate::Reg::read) this register and get [`osc_cal_cnt::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct OscCalCntSpec;
        impl crate::RegisterSpec for OscCalCntSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`osc_cal_cnt::R`](R) reader structure"]
        impl crate::Readable for OscCalCntSpec {}
        #[doc = "`reset()` method sets OSC_CAL_CNT to value 0"]
        impl crate::Resettable for OscCalCntSpec {}
    }
    #[doc = "OSC_CAL_CTRL (rw) register accessor: RWA, oscillator frequency calibration control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`osc_cal_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`osc_cal_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@osc_cal_ctrl`] module"]
    #[doc(alias = "OSC_CAL_CTRL")]
    pub type OscCalCtrl = crate::Reg<osc_cal_ctrl::OscCalCtrlSpec>;
    #[doc = "RWA, oscillator frequency calibration control, SAM"]
    pub mod osc_cal_ctrl {
        #[doc = "Register `OSC_CAL_CTRL` reader"]
        pub type R = crate::R<OscCalCtrlSpec>;
        #[doc = "Register `OSC_CAL_CTRL` writer"]
        pub type W = crate::W<OscCalCtrlSpec>;
        #[doc = "Field `OSC_CNT_TOTAL` reader - RWA, total cycles mode for oscillator capture"]
        pub type OscCntTotalR = crate::FieldReader;
        #[doc = "Field `OSC_CNT_TOTAL` writer - RWA, total cycles mode for oscillator capture"]
        pub type OscCntTotalW<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        #[doc = "Field `OSC_CNT_HALT` reader - RO, calibration counter halt status: 0=counting, 1=halt for reading count value"]
        pub type OscCntHaltR = crate::BitReader;
        #[doc = "Field `OSC_CAL_IE` reader - RWA, interrupt enable for oscillator capture end"]
        pub type OscCalIeR = crate::BitReader;
        #[doc = "Field `OSC_CAL_IE` writer - RWA, interrupt enable for oscillator capture end"]
        pub type OscCalIeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `OSC_CNT_EN` reader - RWA, calibration counter enable"]
        pub type OscCntEnR = crate::BitReader;
        #[doc = "Field `OSC_CNT_EN` writer - RWA, calibration counter enable"]
        pub type OscCntEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `OSC_CNT_END` reader - RWA, select oscillator capture end mode: 0=normal, 1=append 2 cycles"]
        pub type OscCntEndR = crate::BitReader;
        #[doc = "Field `OSC_CNT_END` writer - RWA, select oscillator capture end mode: 0=normal, 1=append 2 cycles"]
        pub type OscCntEndW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:2 - RWA, total cycles mode for oscillator capture"]
            #[inline(always)]
            pub fn osc_cnt_total(&self) -> OscCntTotalR {
                OscCntTotalR::new(self.bits & 7)
            }
            #[doc = "Bit 3 - RO, calibration counter halt status: 0=counting, 1=halt for reading count value"]
            #[inline(always)]
            pub fn osc_cnt_halt(&self) -> OscCntHaltR {
                OscCntHaltR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RWA, interrupt enable for oscillator capture end"]
            #[inline(always)]
            pub fn osc_cal_ie(&self) -> OscCalIeR {
                OscCalIeR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RWA, calibration counter enable"]
            #[inline(always)]
            pub fn osc_cnt_en(&self) -> OscCntEnR {
                OscCntEnR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RWA, select oscillator capture end mode: 0=normal, 1=append 2 cycles"]
            #[inline(always)]
            pub fn osc_cnt_end(&self) -> OscCntEndR {
                OscCntEndR::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:2 - RWA, total cycles mode for oscillator capture"]
            #[inline(always)]
            pub fn osc_cnt_total(&mut self) -> OscCntTotalW<OscCalCtrlSpec> {
                OscCntTotalW::new(self, 0)
            }
            #[doc = "Bit 4 - RWA, interrupt enable for oscillator capture end"]
            #[inline(always)]
            pub fn osc_cal_ie(&mut self) -> OscCalIeW<OscCalCtrlSpec> {
                OscCalIeW::new(self, 4)
            }
            #[doc = "Bit 5 - RWA, calibration counter enable"]
            #[inline(always)]
            pub fn osc_cnt_en(&mut self) -> OscCntEnW<OscCalCtrlSpec> {
                OscCntEnW::new(self, 5)
            }
            #[doc = "Bit 6 - RWA, select oscillator capture end mode: 0=normal, 1=append 2 cycles"]
            #[inline(always)]
            pub fn osc_cnt_end(&mut self) -> OscCntEndW<OscCalCtrlSpec> {
                OscCntEndW::new(self, 6)
            }
        }
        #[doc = "RWA, oscillator frequency calibration control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`osc_cal_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`osc_cal_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct OscCalCtrlSpec;
        impl crate::RegisterSpec for OscCalCtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`osc_cal_ctrl::R`](R) reader structure"]
        impl crate::Readable for OscCalCtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`osc_cal_ctrl::W`](W) writer structure"]
        impl crate::Writable for OscCalCtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets OSC_CAL_CTRL to value 0x09"]
        impl crate::Resettable for OscCalCtrlSpec {
            const RESET_VALUE: u8 = 0x09;
        }
    }
    #[doc = "OSC_CAL_OV_CNT (r) register accessor: RO, oscillator frequency calibration overflow times\n\nYou can [`read`](crate::Reg::read) this register and get [`osc_cal_ov_cnt::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@osc_cal_ov_cnt`] module"]
    #[doc(alias = "OSC_CAL_OV_CNT")]
    pub type OscCalOvCnt = crate::Reg<osc_cal_ov_cnt::OscCalOvCntSpec>;
    #[doc = "RO, oscillator frequency calibration overflow times"]
    pub mod osc_cal_ov_cnt {
        #[doc = "Register `OSC_CAL_OV_CNT` reader"]
        pub type R = crate::R<OscCalOvCntSpec>;
        #[doc = "Field `OSC_CAL_OV_CNT` reader - RO, oscillator frequency calibration overflow times"]
        pub type OscCalOvCntR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RO, oscillator frequency calibration overflow times"]
            #[inline(always)]
            pub fn osc_cal_ov_cnt(&self) -> OscCalOvCntR {
                OscCalOvCntR::new(self.bits)
            }
        }
        #[doc = "RO, oscillator frequency calibration overflow times\n\nYou can [`read`](crate::Reg::read) this register and get [`osc_cal_ov_cnt::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct OscCalOvCntSpec;
        impl crate::RegisterSpec for OscCalOvCntSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`osc_cal_ov_cnt::R`](R) reader structure"]
        impl crate::Readable for OscCalOvCntSpec {}
        #[doc = "`reset()` method sets OSC_CAL_OV_CNT to value 0"]
        impl crate::Resettable for OscCalOvCntSpec {}
    }
    #[doc = "TKEY_COUNT (rw) register accessor: RW, Touchkey charge and discharge count\n\nYou can [`read`](crate::Reg::read) this register and get [`tkey_count::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tkey_count::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tkey_count`] module"]
    #[doc(alias = "TKEY_COUNT")]
    pub type TkeyCount = crate::Reg<tkey_count::TkeyCountSpec>;
    #[doc = "RW, Touchkey charge and discharge count"]
    pub mod tkey_count {
        #[doc = "Register `TKEY_COUNT` reader"]
        pub type R = crate::R<TkeyCountSpec>;
        #[doc = "Register `TKEY_COUNT` writer"]
        pub type W = crate::W<TkeyCountSpec>;
        #[doc = "Field `TKEY_CHARG_CNT` reader - RW, Touchkey charge count"]
        pub type TkeyChargCntR = crate::FieldReader;
        #[doc = "Field `TKEY_CHARG_CNT` writer - RW, Touchkey charge count"]
        pub type TkeyChargCntW<'a, REG> = crate::FieldWriter<'a, REG, 5>;
        #[doc = "Field `TKEY_DISCH_CNT` reader - RW, Touchkey discharge count"]
        pub type TkeyDischCntR = crate::FieldReader;
        #[doc = "Field `TKEY_DISCH_CNT` writer - RW, Touchkey discharge count"]
        pub type TkeyDischCntW<'a, REG> = crate::FieldWriter<'a, REG, 3>;
        impl R {
            #[doc = "Bits 0:4 - RW, Touchkey charge count"]
            #[inline(always)]
            pub fn tkey_charg_cnt(&self) -> TkeyChargCntR {
                TkeyChargCntR::new(self.bits & 0x1f)
            }
            #[doc = "Bits 5:7 - RW, Touchkey discharge count"]
            #[inline(always)]
            pub fn tkey_disch_cnt(&self) -> TkeyDischCntR {
                TkeyDischCntR::new((self.bits >> 5) & 7)
            }
        }
        impl W {
            #[doc = "Bits 0:4 - RW, Touchkey charge count"]
            #[inline(always)]
            pub fn tkey_charg_cnt(&mut self) -> TkeyChargCntW<TkeyCountSpec> {
                TkeyChargCntW::new(self, 0)
            }
            #[doc = "Bits 5:7 - RW, Touchkey discharge count"]
            #[inline(always)]
            pub fn tkey_disch_cnt(&mut self) -> TkeyDischCntW<TkeyCountSpec> {
                TkeyDischCntW::new(self, 5)
            }
        }
        #[doc = "RW, Touchkey charge and discharge count\n\nYou can [`read`](crate::Reg::read) this register and get [`tkey_count::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tkey_count::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TkeyCountSpec;
        impl crate::RegisterSpec for TkeyCountSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`tkey_count::R`](R) reader structure"]
        impl crate::Readable for TkeyCountSpec {}
        #[doc = "`write(|w| ..)` method takes [`tkey_count::W`](W) writer structure"]
        impl crate::Writable for TkeyCountSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TKEY_COUNT to value 0"]
        impl crate::Resettable for TkeyCountSpec {}
    }
    #[doc = "TKEY_CONVERT (rw) register accessor: RW, Touchkey convert start control\n\nYou can [`read`](crate::Reg::read) this register and get [`tkey_convert::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tkey_convert::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tkey_convert`] module"]
    #[doc(alias = "TKEY_CONVERT")]
    pub type TkeyConvert = crate::Reg<tkey_convert::TkeyConvertSpec>;
    #[doc = "RW, Touchkey convert start control"]
    pub mod tkey_convert {
        #[doc = "Register `TKEY_CONVERT` reader"]
        pub type R = crate::R<TkeyConvertSpec>;
        #[doc = "Register `TKEY_CONVERT` writer"]
        pub type W = crate::W<TkeyConvertSpec>;
        #[doc = "Field `TKEY_START` reader - RW, Touchkey convert start control"]
        pub type TkeyStartR = crate::BitReader;
        #[doc = "Field `TKEY_START` writer - RW, Touchkey convert start control"]
        pub type TkeyStartW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, Touchkey convert start control"]
            #[inline(always)]
            pub fn tkey_start(&self) -> TkeyStartR {
                TkeyStartR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, Touchkey convert start control"]
            #[inline(always)]
            pub fn tkey_start(&mut self) -> TkeyStartW<TkeyConvertSpec> {
                TkeyStartW::new(self, 0)
            }
        }
        #[doc = "RW, Touchkey convert start control\n\nYou can [`read`](crate::Reg::read) this register and get [`tkey_convert::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tkey_convert::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TkeyConvertSpec;
        impl crate::RegisterSpec for TkeyConvertSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`tkey_convert::R`](R) reader structure"]
        impl crate::Readable for TkeyConvertSpec {}
        #[doc = "`write(|w| ..)` method takes [`tkey_convert::W`](W) writer structure"]
        impl crate::Writable for TkeyConvertSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TKEY_CONVERT to value 0"]
        impl crate::Resettable for TkeyConvertSpec {}
    }
    #[doc = "TKEY_CFG (rw) register accessor: RW, Touchkey configure\n\nYou can [`read`](crate::Reg::read) this register and get [`tkey_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tkey_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tkey_cfg`] module"]
    #[doc(alias = "TKEY_CFG")]
    pub type TkeyCfg = crate::Reg<tkey_cfg::TkeyCfgSpec>;
    #[doc = "RW, Touchkey configure"]
    pub mod tkey_cfg {
        #[doc = "Register `TKEY_CFG` reader"]
        pub type R = crate::R<TkeyCfgSpec>;
        #[doc = "Register `TKEY_CFG` writer"]
        pub type W = crate::W<TkeyCfgSpec>;
        #[doc = "Field `TKEY_PWR_ON` reader - RW, Touchkey power on"]
        pub type TkeyPwrOnR = crate::BitReader;
        #[doc = "Field `TKEY_PWR_ON` writer - RW, Touchkey power on"]
        pub type TkeyPwrOnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TKEY_CURRENT` reader - RW, Touchkey charge current selection"]
        pub type TkeyCurrentR = crate::BitReader;
        #[doc = "Field `TKEY_CURRENT` writer - RW, Touchkey charge current selection"]
        pub type TkeyCurrentW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TKEY_DRV_EN` reader - RW, Touchkey drive shield enable"]
        pub type TkeyDrvEnR = crate::BitReader;
        #[doc = "Field `TKEY_DRV_EN` writer - RW, Touchkey drive shield enable"]
        pub type TkeyDrvEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `TKEY_PGA_ADJ` reader - RW, ADC input PGA speed selection"]
        pub type TkeyPgaAdjR = crate::BitReader;
        #[doc = "Field `TKEY_PGA_ADJ` writer - RW, ADC input PGA speed selection"]
        pub type TkeyPgaAdjW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, Touchkey power on"]
            #[inline(always)]
            pub fn tkey_pwr_on(&self) -> TkeyPwrOnR {
                TkeyPwrOnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, Touchkey charge current selection"]
            #[inline(always)]
            pub fn tkey_current(&self) -> TkeyCurrentR {
                TkeyCurrentR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW, Touchkey drive shield enable"]
            #[inline(always)]
            pub fn tkey_drv_en(&self) -> TkeyDrvEnR {
                TkeyDrvEnR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, ADC input PGA speed selection"]
            #[inline(always)]
            pub fn tkey_pga_adj(&self) -> TkeyPgaAdjR {
                TkeyPgaAdjR::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, Touchkey power on"]
            #[inline(always)]
            pub fn tkey_pwr_on(&mut self) -> TkeyPwrOnW<TkeyCfgSpec> {
                TkeyPwrOnW::new(self, 0)
            }
            #[doc = "Bit 1 - RW, Touchkey charge current selection"]
            #[inline(always)]
            pub fn tkey_current(&mut self) -> TkeyCurrentW<TkeyCfgSpec> {
                TkeyCurrentW::new(self, 1)
            }
            #[doc = "Bit 2 - RW, Touchkey drive shield enable"]
            #[inline(always)]
            pub fn tkey_drv_en(&mut self) -> TkeyDrvEnW<TkeyCfgSpec> {
                TkeyDrvEnW::new(self, 2)
            }
            #[doc = "Bit 3 - RW, ADC input PGA speed selection"]
            #[inline(always)]
            pub fn tkey_pga_adj(&mut self) -> TkeyPgaAdjW<TkeyCfgSpec> {
                TkeyPgaAdjW::new(self, 3)
            }
        }
        #[doc = "RW, Touchkey configure\n\nYou can [`read`](crate::Reg::read) this register and get [`tkey_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tkey_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TkeyCfgSpec;
        impl crate::RegisterSpec for TkeyCfgSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`tkey_cfg::R`](R) reader structure"]
        impl crate::Readable for TkeyCfgSpec {}
        #[doc = "`write(|w| ..)` method takes [`tkey_cfg::W`](W) writer structure"]
        impl crate::Writable for TkeyCfgSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TKEY_CFG to value 0"]
        impl crate::Resettable for TkeyCfgSpec {}
    }
    #[doc = "FLASH_CFG (rw) register accessor: Flash configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`flash_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`flash_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@flash_cfg`] module"]
    #[doc(alias = "FLASH_CFG")]
    pub type FlashCfg = crate::Reg<flash_cfg::FlashCfgSpec>;
    #[doc = "Flash configuration"]
    pub mod flash_cfg {
        #[doc = "Register `FLASH_CFG` reader"]
        pub type R = crate::R<FlashCfgSpec>;
        #[doc = "Register `FLASH_CFG` writer"]
        pub type W = crate::W<FlashCfgSpec>;
        impl core::fmt::Debug for R {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                write!(f, "{}", self.bits())
            }
        }
        impl W {}
        #[doc = "Flash configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`flash_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`flash_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FlashCfgSpec;
        impl crate::RegisterSpec for FlashCfgSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`flash_cfg::R`](R) reader structure"]
        impl crate::Readable for FlashCfgSpec {}
        #[doc = "`write(|w| ..)` method takes [`flash_cfg::W`](W) writer structure"]
        impl crate::Writable for FlashCfgSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FLASH_CFG to value 0"]
        impl crate::Resettable for FlashCfgSpec {}
    }
}
#[doc = "System Control Register"]
pub type Adc = crate::Periph<adc::RegisterBlock, 0x4000_1000>;
impl core::fmt::Debug for Adc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Adc").finish()
    }
}
#[doc = "System Control Register"]
pub mod adc {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x58],
        channel: Channel,
        cfg: Cfg,
        convert: Convert,
        tem_sensor: TemSensor,
        data: Data,
        int_flag: IntFlag,
        _reserved6: [u8; 0x01],
        dma_ctrl: DmaCtrl,
        ctrl_dma: CtrlDma,
        dma_if: DmaIf,
        auto_cycle: AutoCycle,
        dma_now: DmaNow,
        _reserved11: [u8; 0x03],
        dma_beg: DmaBeg,
        _reserved12: [u8; 0x03],
        dma_end: DmaEnd,
    }
    impl RegisterBlock {
        #[doc = "0x58 - RW, ADC input channel selection"]
        #[inline(always)]
        pub const fn channel(&self) -> &Channel {
            &self.channel
        }
        #[doc = "0x59 - RW, ADC configure"]
        #[inline(always)]
        pub const fn cfg(&self) -> &Cfg {
            &self.cfg
        }
        #[doc = "0x5a - RW, ADC convert control"]
        #[inline(always)]
        pub const fn convert(&self) -> &Convert {
            &self.convert
        }
        #[doc = "0x5b - RW, temperature sensor control"]
        #[inline(always)]
        pub const fn tem_sensor(&self) -> &TemSensor {
            &self.tem_sensor
        }
        #[doc = "0x5c - RO, ADC data"]
        #[inline(always)]
        pub const fn data(&self) -> &Data {
            &self.data
        }
        #[doc = "0x5e - RO, ADC interrupt flag register"]
        #[inline(always)]
        pub const fn int_flag(&self) -> &IntFlag {
            &self.int_flag
        }
        #[doc = "0x60 - RO, ADC DMA control and status register"]
        #[inline(always)]
        pub const fn dma_ctrl(&self) -> &DmaCtrl {
            &self.dma_ctrl
        }
        #[doc = "0x61 - RW, ADC DMA control"]
        #[inline(always)]
        pub const fn ctrl_dma(&self) -> &CtrlDma {
            &self.ctrl_dma
        }
        #[doc = "0x62 - RO, ADC interrupt flag"]
        #[inline(always)]
        pub const fn dma_if(&self) -> &DmaIf {
            &self.dma_if
        }
        #[doc = "0x63 - RO, ADC interrupt flag"]
        #[inline(always)]
        pub const fn auto_cycle(&self) -> &AutoCycle {
            &self.auto_cycle
        }
        #[doc = "0x64 - RO, ADC DMA current address"]
        #[inline(always)]
        pub const fn dma_now(&self) -> &DmaNow {
            &self.dma_now
        }
        #[doc = "0x68 - RW, ADC DMA begin address"]
        #[inline(always)]
        pub const fn dma_beg(&self) -> &DmaBeg {
            &self.dma_beg
        }
        #[doc = "0x6c - RW, ADC DMA end address"]
        #[inline(always)]
        pub const fn dma_end(&self) -> &DmaEnd {
            &self.dma_end
        }
    }
    #[doc = "CHANNEL (rw) register accessor: RW, ADC input channel selection\n\nYou can [`read`](crate::Reg::read) this register and get [`channel::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`channel::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@channel`] module"]
    #[doc(alias = "CHANNEL")]
    pub type Channel = crate::Reg<channel::ChannelSpec>;
    #[doc = "RW, ADC input channel selection"]
    pub mod channel {
        #[doc = "Register `CHANNEL` reader"]
        pub type R = crate::R<ChannelSpec>;
        #[doc = "Register `CHANNEL` writer"]
        pub type W = crate::W<ChannelSpec>;
        #[doc = "Field `CH_INX` reader - RW, ADC input channel index"]
        pub type ChInxR = crate::FieldReader;
        #[doc = "Field `CH_INX` writer - RW, ADC input channel index"]
        pub type ChInxW<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            #[doc = "Bits 0:3 - RW, ADC input channel index"]
            #[inline(always)]
            pub fn ch_inx(&self) -> ChInxR {
                ChInxR::new(self.bits & 0x0f)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - RW, ADC input channel index"]
            #[inline(always)]
            pub fn ch_inx(&mut self) -> ChInxW<ChannelSpec> {
                ChInxW::new(self, 0)
            }
        }
        #[doc = "RW, ADC input channel selection\n\nYou can [`read`](crate::Reg::read) this register and get [`channel::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`channel::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ChannelSpec;
        impl crate::RegisterSpec for ChannelSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`channel::R`](R) reader structure"]
        impl crate::Readable for ChannelSpec {}
        #[doc = "`write(|w| ..)` method takes [`channel::W`](W) writer structure"]
        impl crate::Writable for ChannelSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CHANNEL to value 0x0f"]
        impl crate::Resettable for ChannelSpec {
            const RESET_VALUE: u8 = 0x0f;
        }
    }
    #[doc = "CFG (rw) register accessor: RW, ADC configure\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfg`] module"]
    #[doc(alias = "CFG")]
    pub type Cfg = crate::Reg<cfg::CfgSpec>;
    #[doc = "RW, ADC configure"]
    pub mod cfg {
        #[doc = "Register `CFG` reader"]
        pub type R = crate::R<CfgSpec>;
        #[doc = "Register `CFG` writer"]
        pub type W = crate::W<CfgSpec>;
        #[doc = "Field `POWER_ON` reader - RW, ADC power control: 0=power down, 1=power on"]
        pub type PowerOnR = crate::BitReader;
        #[doc = "Field `POWER_ON` writer - RW, ADC power control: 0=power down, 1=power on"]
        pub type PowerOnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `BUF_EN` reader - RW, ADC input buffer enable"]
        pub type BufEnR = crate::BitReader;
        #[doc = "Field `BUF_EN` writer - RW, ADC input buffer enable"]
        pub type BufEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `DIFF_EN` reader - RW, ADC input channel mode: 0=single-end, 1=differnetial"]
        pub type DiffEnR = crate::BitReader;
        #[doc = "Field `DIFF_EN` writer - RW, ADC input channel mode: 0=single-end, 1=differnetial"]
        pub type DiffEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `OFS_TEST` reader - RW, enable ADC offset test mode: 0=normal mode, 1=short to test offset"]
        pub type OfsTestR = crate::BitReader;
        #[doc = "Field `OFS_TEST` writer - RW, enable ADC offset test mode: 0=normal mode, 1=short to test offset"]
        pub type OfsTestW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PGA_GAIN` reader - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB"]
        pub type PgaGainR = crate::FieldReader;
        #[doc = "Field `PGA_GAIN` writer - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB"]
        pub type PgaGainW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `CLK_DIV` reader - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz"]
        pub type ClkDivR = crate::FieldReader;
        #[doc = "Field `CLK_DIV` writer - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz"]
        pub type ClkDivW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            #[doc = "Bit 0 - RW, ADC power control: 0=power down, 1=power on"]
            #[inline(always)]
            pub fn power_on(&self) -> PowerOnR {
                PowerOnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, ADC input buffer enable"]
            #[inline(always)]
            pub fn buf_en(&self) -> BufEnR {
                BufEnR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW, ADC input channel mode: 0=single-end, 1=differnetial"]
            #[inline(always)]
            pub fn diff_en(&self) -> DiffEnR {
                DiffEnR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, enable ADC offset test mode: 0=normal mode, 1=short to test offset"]
            #[inline(always)]
            pub fn ofs_test(&self) -> OfsTestR {
                OfsTestR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:5 - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB"]
            #[inline(always)]
            pub fn pga_gain(&self) -> PgaGainR {
                PgaGainR::new((self.bits >> 4) & 3)
            }
            #[doc = "Bits 6:7 - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz"]
            #[inline(always)]
            pub fn clk_div(&self) -> ClkDivR {
                ClkDivR::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, ADC power control: 0=power down, 1=power on"]
            #[inline(always)]
            pub fn power_on(&mut self) -> PowerOnW<CfgSpec> {
                PowerOnW::new(self, 0)
            }
            #[doc = "Bit 1 - RW, ADC input buffer enable"]
            #[inline(always)]
            pub fn buf_en(&mut self) -> BufEnW<CfgSpec> {
                BufEnW::new(self, 1)
            }
            #[doc = "Bit 2 - RW, ADC input channel mode: 0=single-end, 1=differnetial"]
            #[inline(always)]
            pub fn diff_en(&mut self) -> DiffEnW<CfgSpec> {
                DiffEnW::new(self, 2)
            }
            #[doc = "Bit 3 - RW, enable ADC offset test mode: 0=normal mode, 1=short to test offset"]
            #[inline(always)]
            pub fn ofs_test(&mut self) -> OfsTestW<CfgSpec> {
                OfsTestW::new(self, 3)
            }
            #[doc = "Bits 4:5 - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB"]
            #[inline(always)]
            pub fn pga_gain(&mut self) -> PgaGainW<CfgSpec> {
                PgaGainW::new(self, 4)
            }
            #[doc = "Bits 6:7 - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz"]
            #[inline(always)]
            pub fn clk_div(&mut self) -> ClkDivW<CfgSpec> {
                ClkDivW::new(self, 6)
            }
        }
        #[doc = "RW, ADC configure\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CfgSpec;
        impl crate::RegisterSpec for CfgSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`cfg::R`](R) reader structure"]
        impl crate::Readable for CfgSpec {}
        #[doc = "`write(|w| ..)` method takes [`cfg::W`](W) writer structure"]
        impl crate::Writable for CfgSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CFG to value 0xa0"]
        impl crate::Resettable for CfgSpec {
            const RESET_VALUE: u8 = 0xa0;
        }
    }
    #[doc = "CONVERT (rw) register accessor: RW, ADC convert control\n\nYou can [`read`](crate::Reg::read) this register and get [`convert::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`convert::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@convert`] module"]
    #[doc(alias = "CONVERT")]
    pub type Convert = crate::Reg<convert::ConvertSpec>;
    #[doc = "RW, ADC convert control"]
    pub mod convert {
        #[doc = "Register `CONVERT` reader"]
        pub type R = crate::R<ConvertSpec>;
        #[doc = "Register `CONVERT` writer"]
        pub type W = crate::W<ConvertSpec>;
        #[doc = "Field `START` reader - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear"]
        pub type StartR = crate::BitReader;
        #[doc = "Field `START` writer - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear"]
        pub type StartW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `EOC_X` reader - RO, end of ADC conversion flag"]
        pub type EocXR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear"]
            #[inline(always)]
            pub fn start(&self) -> StartR {
                StartR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 7 - RO, end of ADC conversion flag"]
            #[inline(always)]
            pub fn eoc_x(&self) -> EocXR {
                EocXR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear"]
            #[inline(always)]
            pub fn start(&mut self) -> StartW<ConvertSpec> {
                StartW::new(self, 0)
            }
        }
        #[doc = "RW, ADC convert control\n\nYou can [`read`](crate::Reg::read) this register and get [`convert::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`convert::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ConvertSpec;
        impl crate::RegisterSpec for ConvertSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`convert::R`](R) reader structure"]
        impl crate::Readable for ConvertSpec {}
        #[doc = "`write(|w| ..)` method takes [`convert::W`](W) writer structure"]
        impl crate::Writable for ConvertSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CONVERT to value 0"]
        impl crate::Resettable for ConvertSpec {}
    }
    #[doc = "TEM_SENSOR (rw) register accessor: RW, temperature sensor control\n\nYou can [`read`](crate::Reg::read) this register and get [`tem_sensor::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tem_sensor::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tem_sensor`] module"]
    #[doc(alias = "TEM_SENSOR")]
    pub type TemSensor = crate::Reg<tem_sensor::TemSensorSpec>;
    #[doc = "RW, temperature sensor control"]
    pub mod tem_sensor {
        #[doc = "Register `TEM_SENSOR` reader"]
        pub type R = crate::R<TemSensorSpec>;
        #[doc = "Register `TEM_SENSOR` writer"]
        pub type W = crate::W<TemSensorSpec>;
        #[doc = "Field `TEM_SEN_PWR_ON` reader - RW, temperature sensor power control: 0=power down, 1=power on"]
        pub type TemSenPwrOnR = crate::BitReader;
        #[doc = "Field `TEM_SEN_PWR_ON` writer - RW, temperature sensor power control: 0=power down, 1=power on"]
        pub type TemSenPwrOnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 7 - RW, temperature sensor power control: 0=power down, 1=power on"]
            #[inline(always)]
            pub fn tem_sen_pwr_on(&self) -> TemSenPwrOnR {
                TemSenPwrOnR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 7 - RW, temperature sensor power control: 0=power down, 1=power on"]
            #[inline(always)]
            pub fn tem_sen_pwr_on(&mut self) -> TemSenPwrOnW<TemSensorSpec> {
                TemSenPwrOnW::new(self, 7)
            }
        }
        #[doc = "RW, temperature sensor control\n\nYou can [`read`](crate::Reg::read) this register and get [`tem_sensor::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tem_sensor::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TemSensorSpec;
        impl crate::RegisterSpec for TemSensorSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`tem_sensor::R`](R) reader structure"]
        impl crate::Readable for TemSensorSpec {}
        #[doc = "`write(|w| ..)` method takes [`tem_sensor::W`](W) writer structure"]
        impl crate::Writable for TemSensorSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TEM_SENSOR to value 0"]
        impl crate::Resettable for TemSensorSpec {}
    }
    #[doc = "DATA (r) register accessor: RO, ADC data\n\nYou can [`read`](crate::Reg::read) this register and get [`data::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@data`] module"]
    #[doc(alias = "DATA")]
    pub type Data = crate::Reg<data::DataSpec>;
    #[doc = "RO, ADC data"]
    pub mod data {
        #[doc = "Register `DATA` reader"]
        pub type R = crate::R<DataSpec>;
        #[doc = "Field `DATA` reader - RO, ADC conversion data"]
        pub type DataR = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:11 - RO, ADC conversion data"]
            #[inline(always)]
            pub fn data(&self) -> DataR {
                DataR::new(self.bits & 0x0fff)
            }
        }
        #[doc = "RO, ADC data\n\nYou can [`read`](crate::Reg::read) this register and get [`data::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DataSpec;
        impl crate::RegisterSpec for DataSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`data::R`](R) reader structure"]
        impl crate::Readable for DataSpec {}
        #[doc = "`reset()` method sets DATA to value 0"]
        impl crate::Resettable for DataSpec {}
    }
    #[doc = "INT_FLAG (r) register accessor: RO, ADC interrupt flag register\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_flag`] module"]
    #[doc(alias = "INT_FLAG")]
    pub type IntFlag = crate::Reg<int_flag::IntFlagSpec>;
    #[doc = "RO, ADC interrupt flag register"]
    pub mod int_flag {
        #[doc = "Register `INT_FLAG` reader"]
        pub type R = crate::R<IntFlagSpec>;
        #[doc = "Field `IF_EOC` reader - RO, ADC conversion interrupt flag: 0=free or converting, 1=end of conversion, interrupt action, write R8_ADC_CONVERT to clear flag"]
        pub type IfEocR = crate::BitReader;
        impl R {
            #[doc = "Bit 7 - RO, ADC conversion interrupt flag: 0=free or converting, 1=end of conversion, interrupt action, write R8_ADC_CONVERT to clear flag"]
            #[inline(always)]
            pub fn if_eoc(&self) -> IfEocR {
                IfEocR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        #[doc = "RO, ADC interrupt flag register\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IntFlagSpec;
        impl crate::RegisterSpec for IntFlagSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`int_flag::R`](R) reader structure"]
        impl crate::Readable for IntFlagSpec {}
        #[doc = "`reset()` method sets INT_FLAG to value 0"]
        impl crate::Resettable for IntFlagSpec {}
    }
    #[doc = "DMA_CTRL (rw) register accessor: RO, ADC DMA control and status register\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_ctrl`] module"]
    #[doc(alias = "DMA_CTRL")]
    pub type DmaCtrl = crate::Reg<dma_ctrl::DmaCtrlSpec>;
    #[doc = "RO, ADC DMA control and status register"]
    pub mod dma_ctrl {
        #[doc = "Register `DMA_CTRL` reader"]
        pub type R = crate::R<DmaCtrlSpec>;
        #[doc = "Register `DMA_CTRL` writer"]
        pub type W = crate::W<DmaCtrlSpec>;
        #[doc = "Field `DMA_CTRL` reader - RW, ADC DMA enable"]
        pub type DmaCtrlR = crate::FieldReader;
        #[doc = "Field `DMA_CTRL` writer - RW, ADC DMA enable"]
        pub type DmaCtrlW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW, ADC DMA enable"]
            #[inline(always)]
            pub fn dma_ctrl(&self) -> DmaCtrlR {
                DmaCtrlR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW, ADC DMA enable"]
            #[inline(always)]
            pub fn dma_ctrl(&mut self) -> DmaCtrlW<DmaCtrlSpec> {
                DmaCtrlW::new(self, 0)
            }
        }
        #[doc = "RO, ADC DMA control and status register\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DmaCtrlSpec;
        impl crate::RegisterSpec for DmaCtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`dma_ctrl::R`](R) reader structure"]
        impl crate::Readable for DmaCtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`dma_ctrl::W`](W) writer structure"]
        impl crate::Writable for DmaCtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DMA_CTRL to value 0"]
        impl crate::Resettable for DmaCtrlSpec {}
    }
    #[doc = "CTRL_DMA (rw) register accessor: RW, ADC DMA control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl_dma`] module"]
    #[doc(alias = "CTRL_DMA")]
    pub type CtrlDma = crate::Reg<ctrl_dma::CtrlDmaSpec>;
    #[doc = "RW, ADC DMA control"]
    pub mod ctrl_dma {
        #[doc = "Register `CTRL_DMA` reader"]
        pub type R = crate::R<CtrlDmaSpec>;
        #[doc = "Register `CTRL_DMA` writer"]
        pub type W = crate::W<CtrlDmaSpec>;
        #[doc = "Field `DMA_ENABLE` reader - RW, ADC DMA enable"]
        pub type DmaEnableR = crate::BitReader;
        #[doc = "Field `DMA_ENABLE` writer - RW, ADC DMA enable"]
        pub type DmaEnableW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `DMA_LOOP` reader - RW, ADC DMA address loop enable"]
        pub type DmaLoopR = crate::BitReader;
        #[doc = "Field `DMA_LOOP` writer - RW, ADC DMA address loop enable"]
        pub type DmaLoopW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IE_DMA_END` reader - RW, enable interrupt for ADC DMA completion"]
        pub type IeDmaEndR = crate::BitReader;
        #[doc = "Field `IE_DMA_END` writer - RW, enable interrupt for ADC DMA completion"]
        pub type IeDmaEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IE_EOC` reader - RW, enable interrupt for end of ADC conversion"]
        pub type IeEocR = crate::BitReader;
        #[doc = "Field `IE_EOC` writer - RW, enable interrupt for end of ADC conversion"]
        pub type IeEocW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CONT_EN` reader - RW, enable contineous conversion ADC"]
        pub type ContEnR = crate::BitReader;
        #[doc = "Field `CONT_EN` writer - RW, enable contineous conversion ADC"]
        pub type ContEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `AUTO_EN` reader - RW, enable auto continuing ADC for DMA"]
        pub type AutoEnR = crate::BitReader;
        #[doc = "Field `AUTO_EN` writer - RW, enable auto continuing ADC for DMA"]
        pub type AutoEnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, ADC DMA enable"]
            #[inline(always)]
            pub fn dma_enable(&self) -> DmaEnableR {
                DmaEnableR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 2 - RW, ADC DMA address loop enable"]
            #[inline(always)]
            pub fn dma_loop(&self) -> DmaLoopR {
                DmaLoopR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, enable interrupt for ADC DMA completion"]
            #[inline(always)]
            pub fn ie_dma_end(&self) -> IeDmaEndR {
                IeDmaEndR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, enable interrupt for end of ADC conversion"]
            #[inline(always)]
            pub fn ie_eoc(&self) -> IeEocR {
                IeEocR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - RW, enable contineous conversion ADC"]
            #[inline(always)]
            pub fn cont_en(&self) -> ContEnR {
                ContEnR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RW, enable auto continuing ADC for DMA"]
            #[inline(always)]
            pub fn auto_en(&self) -> AutoEnR {
                AutoEnR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, ADC DMA enable"]
            #[inline(always)]
            pub fn dma_enable(&mut self) -> DmaEnableW<CtrlDmaSpec> {
                DmaEnableW::new(self, 0)
            }
            #[doc = "Bit 2 - RW, ADC DMA address loop enable"]
            #[inline(always)]
            pub fn dma_loop(&mut self) -> DmaLoopW<CtrlDmaSpec> {
                DmaLoopW::new(self, 2)
            }
            #[doc = "Bit 3 - RW, enable interrupt for ADC DMA completion"]
            #[inline(always)]
            pub fn ie_dma_end(&mut self) -> IeDmaEndW<CtrlDmaSpec> {
                IeDmaEndW::new(self, 3)
            }
            #[doc = "Bit 4 - RW, enable interrupt for end of ADC conversion"]
            #[inline(always)]
            pub fn ie_eoc(&mut self) -> IeEocW<CtrlDmaSpec> {
                IeEocW::new(self, 4)
            }
            #[doc = "Bit 6 - RW, enable contineous conversion ADC"]
            #[inline(always)]
            pub fn cont_en(&mut self) -> ContEnW<CtrlDmaSpec> {
                ContEnW::new(self, 6)
            }
            #[doc = "Bit 7 - RW, enable auto continuing ADC for DMA"]
            #[inline(always)]
            pub fn auto_en(&mut self) -> AutoEnW<CtrlDmaSpec> {
                AutoEnW::new(self, 7)
            }
        }
        #[doc = "RW, ADC DMA control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CtrlDmaSpec;
        impl crate::RegisterSpec for CtrlDmaSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`ctrl_dma::R`](R) reader structure"]
        impl crate::Readable for CtrlDmaSpec {}
        #[doc = "`write(|w| ..)` method takes [`ctrl_dma::W`](W) writer structure"]
        impl crate::Writable for CtrlDmaSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CTRL_DMA to value 0"]
        impl crate::Resettable for CtrlDmaSpec {}
    }
    #[doc = "DMA_IF (rw) register accessor: RO, ADC interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_if::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_if::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_if`] module"]
    #[doc(alias = "DMA_IF")]
    pub type DmaIf = crate::Reg<dma_if::DmaIfSpec>;
    #[doc = "RO, ADC interrupt flag"]
    pub mod dma_if {
        #[doc = "Register `DMA_IF` reader"]
        pub type R = crate::R<DmaIfSpec>;
        #[doc = "Register `DMA_IF` writer"]
        pub type W = crate::W<DmaIfSpec>;
        #[doc = "Field `IF_DMA_END` reader - interrupt flag for ADC DMA completion"]
        pub type IfDmaEndR = crate::BitReader;
        #[doc = "Field `IF_DMA_END` writer - interrupt flag for ADC DMA completion"]
        pub type IfDmaEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IF_END_ADC` reader - interrupt flag for end of ADC conversion"]
        pub type IfEndAdcR = crate::BitReader;
        #[doc = "Field `IF_END_ADC` writer - interrupt flag for end of ADC conversion"]
        pub type IfEndAdcW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 3 - interrupt flag for ADC DMA completion"]
            #[inline(always)]
            pub fn if_dma_end(&self) -> IfDmaEndR {
                IfDmaEndR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - interrupt flag for end of ADC conversion"]
            #[inline(always)]
            pub fn if_end_adc(&self) -> IfEndAdcR {
                IfEndAdcR::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 3 - interrupt flag for ADC DMA completion"]
            #[inline(always)]
            pub fn if_dma_end(&mut self) -> IfDmaEndW<DmaIfSpec> {
                IfDmaEndW::new(self, 3)
            }
            #[doc = "Bit 4 - interrupt flag for end of ADC conversion"]
            #[inline(always)]
            pub fn if_end_adc(&mut self) -> IfEndAdcW<DmaIfSpec> {
                IfEndAdcW::new(self, 4)
            }
        }
        #[doc = "RO, ADC interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_if::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_if::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DmaIfSpec;
        impl crate::RegisterSpec for DmaIfSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`dma_if::R`](R) reader structure"]
        impl crate::Readable for DmaIfSpec {}
        #[doc = "`write(|w| ..)` method takes [`dma_if::W`](W) writer structure"]
        impl crate::Writable for DmaIfSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DMA_IF to value 0"]
        impl crate::Resettable for DmaIfSpec {}
    }
    #[doc = "AUTO_CYCLE (rw) register accessor: RO, ADC interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`auto_cycle::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`auto_cycle::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@auto_cycle`] module"]
    #[doc(alias = "AUTO_CYCLE")]
    pub type AutoCycle = crate::Reg<auto_cycle::AutoCycleSpec>;
    #[doc = "RO, ADC interrupt flag"]
    pub mod auto_cycle {
        #[doc = "Register `AUTO_CYCLE` reader"]
        pub type R = crate::R<AutoCycleSpec>;
        #[doc = "Register `AUTO_CYCLE` writer"]
        pub type W = crate::W<AutoCycleSpec>;
        #[doc = "Field `AUTO_CYCLE` reader - auto ADC cycle value, unit is 16 Fsys"]
        pub type AutoCycleR = crate::FieldReader;
        #[doc = "Field `AUTO_CYCLE` writer - auto ADC cycle value, unit is 16 Fsys"]
        pub type AutoCycleW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - auto ADC cycle value, unit is 16 Fsys"]
            #[inline(always)]
            pub fn auto_cycle(&self) -> AutoCycleR {
                AutoCycleR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - auto ADC cycle value, unit is 16 Fsys"]
            #[inline(always)]
            pub fn auto_cycle(&mut self) -> AutoCycleW<AutoCycleSpec> {
                AutoCycleW::new(self, 0)
            }
        }
        #[doc = "RO, ADC interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`auto_cycle::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`auto_cycle::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct AutoCycleSpec;
        impl crate::RegisterSpec for AutoCycleSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`auto_cycle::R`](R) reader structure"]
        impl crate::Readable for AutoCycleSpec {}
        #[doc = "`write(|w| ..)` method takes [`auto_cycle::W`](W) writer structure"]
        impl crate::Writable for AutoCycleSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets AUTO_CYCLE to value 0"]
        impl crate::Resettable for AutoCycleSpec {}
    }
    #[doc = "DMA_NOW (r) register accessor: RO, ADC DMA current address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_now::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_now`] module"]
    #[doc(alias = "DMA_NOW")]
    pub type DmaNow = crate::Reg<dma_now::DmaNowSpec>;
    #[doc = "RO, ADC DMA current address"]
    pub mod dma_now {
        #[doc = "Register `DMA_NOW` reader"]
        pub type R = crate::R<DmaNowSpec>;
        #[doc = "Field `DMA_NOW` reader - ADC DMA current address"]
        pub type DmaNowR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - ADC DMA current address"]
            #[inline(always)]
            pub fn dma_now(&self) -> DmaNowR {
                DmaNowR::new(self.bits)
            }
        }
        #[doc = "RO, ADC DMA current address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_now::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DmaNowSpec;
        impl crate::RegisterSpec for DmaNowSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`dma_now::R`](R) reader structure"]
        impl crate::Readable for DmaNowSpec {}
        #[doc = "`reset()` method sets DMA_NOW to value 0"]
        impl crate::Resettable for DmaNowSpec {}
    }
    #[doc = "DMA_BEG (rw) register accessor: RW, ADC DMA begin address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_beg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_beg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_beg`] module"]
    #[doc(alias = "DMA_BEG")]
    pub type DmaBeg = crate::Reg<dma_beg::DmaBegSpec>;
    #[doc = "RW, ADC DMA begin address"]
    pub mod dma_beg {
        #[doc = "Register `DMA_BEG` reader"]
        pub type R = crate::R<DmaBegSpec>;
        #[doc = "Register `DMA_BEG` writer"]
        pub type W = crate::W<DmaBegSpec>;
        #[doc = "Field `DMA_BEG` reader - ADC DMA begin address"]
        pub type DmaBegR = crate::FieldReader;
        #[doc = "Field `DMA_BEG` writer - ADC DMA begin address"]
        pub type DmaBegW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - ADC DMA begin address"]
            #[inline(always)]
            pub fn dma_beg(&self) -> DmaBegR {
                DmaBegR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - ADC DMA begin address"]
            #[inline(always)]
            pub fn dma_beg(&mut self) -> DmaBegW<DmaBegSpec> {
                DmaBegW::new(self, 0)
            }
        }
        #[doc = "RW, ADC DMA begin address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_beg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_beg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DmaBegSpec;
        impl crate::RegisterSpec for DmaBegSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`dma_beg::R`](R) reader structure"]
        impl crate::Readable for DmaBegSpec {}
        #[doc = "`write(|w| ..)` method takes [`dma_beg::W`](W) writer structure"]
        impl crate::Writable for DmaBegSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DMA_BEG to value 0"]
        impl crate::Resettable for DmaBegSpec {}
    }
    #[doc = "DMA_END (rw) register accessor: RW, ADC DMA end address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_end::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_end::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_end`] module"]
    #[doc(alias = "DMA_END")]
    pub type DmaEnd = crate::Reg<dma_end::DmaEndSpec>;
    #[doc = "RW, ADC DMA end address"]
    pub mod dma_end {
        #[doc = "Register `DMA_END` reader"]
        pub type R = crate::R<DmaEndSpec>;
        #[doc = "Register `DMA_END` writer"]
        pub type W = crate::W<DmaEndSpec>;
        #[doc = "Field `DMA_END` reader - ADC DMA end address"]
        pub type DmaEndR = crate::FieldReader;
        #[doc = "Field `DMA_END` writer - ADC DMA end address"]
        pub type DmaEndW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - ADC DMA end address"]
            #[inline(always)]
            pub fn dma_end(&self) -> DmaEndR {
                DmaEndR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - ADC DMA end address"]
            #[inline(always)]
            pub fn dma_end(&mut self) -> DmaEndW<DmaEndSpec> {
                DmaEndW::new(self, 0)
            }
        }
        #[doc = "RW, ADC DMA end address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_end::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_end::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DmaEndSpec;
        impl crate::RegisterSpec for DmaEndSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`dma_end::R`](R) reader structure"]
        impl crate::Readable for DmaEndSpec {}
        #[doc = "`write(|w| ..)` method takes [`dma_end::W`](W) writer structure"]
        impl crate::Writable for DmaEndSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DMA_END to value 0"]
        impl crate::Resettable for DmaEndSpec {}
    }
}
#[doc = "System Control Register"]
pub type Gpioa = crate::Periph<gpioa::RegisterBlock, 0x4000_1000>;
impl core::fmt::Debug for Gpioa {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpioa").finish()
    }
}
#[doc = "System Control Register"]
pub mod gpioa {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x90],
        int_en: IntEn,
        _reserved1: [u8; 0x02],
        int_mode: IntMode,
        _reserved2: [u8; 0x06],
        int_if: IntIf,
        _reserved3: [u8; 0x02],
        dir: Dir,
        pin: Pin,
        out: Out,
        clr: Clr,
        pu: Pu,
        pd_drv: PdDrv,
    }
    impl RegisterBlock {
        #[doc = "0x90 - RW, GPIO PA interrupt enable"]
        #[inline(always)]
        pub const fn int_en(&self) -> &IntEn {
            &self.int_en
        }
        #[doc = "0x94 - RW, GPIO PA interrupt mode: 0=level action, 1=edge action"]
        #[inline(always)]
        pub const fn int_mode(&self) -> &IntMode {
            &self.int_mode
        }
        #[doc = "0x9c - RW1, GPIO PA interrupt flag"]
        #[inline(always)]
        pub const fn int_if(&self) -> &IntIf {
            &self.int_if
        }
        #[doc = "0xa0 - RW, GPIO PA I/O direction: 0=in, 1=out"]
        #[inline(always)]
        pub const fn dir(&self) -> &Dir {
            &self.dir
        }
        #[doc = "0xa4 - RO, GPIO PA input"]
        #[inline(always)]
        pub const fn pin(&self) -> &Pin {
            &self.pin
        }
        #[doc = "0xa8 - RW, GPIO PA output"]
        #[inline(always)]
        pub const fn out(&self) -> &Out {
            &self.out
        }
        #[doc = "0xac - WZ, GPIO PA clear output: 0=keep, 1=clear"]
        #[inline(always)]
        pub const fn clr(&self) -> &Clr {
            &self.clr
        }
        #[doc = "0xb0 - RW, GPIO PA pullup resistance enable"]
        #[inline(always)]
        pub const fn pu(&self) -> &Pu {
            &self.pu
        }
        #[doc = "0xb4 - RW, PA pulldown for input or PA driving capability for output"]
        #[inline(always)]
        pub const fn pd_drv(&self) -> &PdDrv {
            &self.pd_drv
        }
    }
    #[doc = "INT_EN (rw) register accessor: RW, GPIO PA interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`int_en::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_en::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_en`] module"]
    #[doc(alias = "INT_EN")]
    pub type IntEn = crate::Reg<int_en::IntEnSpec>;
    #[doc = "RW, GPIO PA interrupt enable"]
    pub mod int_en {
        #[doc = "Register `INT_EN` reader"]
        pub type R = crate::R<IntEnSpec>;
        #[doc = "Register `INT_EN` writer"]
        pub type W = crate::W<IntEnSpec>;
        #[doc = "Field `INT_EN` reader - GPIO PA interrupt enable"]
        pub type IntEnR = crate::FieldReader<u16>;
        #[doc = "Field `INT_EN` writer - GPIO PA interrupt enable"]
        pub type IntEnW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - GPIO PA interrupt enable"]
            #[inline(always)]
            pub fn int_en(&self) -> IntEnR {
                IntEnR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - GPIO PA interrupt enable"]
            #[inline(always)]
            pub fn int_en(&mut self) -> IntEnW<IntEnSpec> {
                IntEnW::new(self, 0)
            }
        }
        #[doc = "RW, GPIO PA interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`int_en::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_en::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IntEnSpec;
        impl crate::RegisterSpec for IntEnSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`int_en::R`](R) reader structure"]
        impl crate::Readable for IntEnSpec {}
        #[doc = "`write(|w| ..)` method takes [`int_en::W`](W) writer structure"]
        impl crate::Writable for IntEnSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets INT_EN to value 0"]
        impl crate::Resettable for IntEnSpec {}
    }
    #[doc = "INT_MODE (rw) register accessor: RW, GPIO PA interrupt mode: 0=level action, 1=edge action\n\nYou can [`read`](crate::Reg::read) this register and get [`int_mode::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_mode::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_mode`] module"]
    #[doc(alias = "INT_MODE")]
    pub type IntMode = crate::Reg<int_mode::IntModeSpec>;
    #[doc = "RW, GPIO PA interrupt mode: 0=level action, 1=edge action"]
    pub mod int_mode {
        #[doc = "Register `INT_MODE` reader"]
        pub type R = crate::R<IntModeSpec>;
        #[doc = "Register `INT_MODE` writer"]
        pub type W = crate::W<IntModeSpec>;
        #[doc = "Field `INT_MODE` reader - GPIO PA interrupt mode"]
        pub type IntModeR = crate::FieldReader<u16>;
        #[doc = "Field `INT_MODE` writer - GPIO PA interrupt mode"]
        pub type IntModeW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - GPIO PA interrupt mode"]
            #[inline(always)]
            pub fn int_mode(&self) -> IntModeR {
                IntModeR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - GPIO PA interrupt mode"]
            #[inline(always)]
            pub fn int_mode(&mut self) -> IntModeW<IntModeSpec> {
                IntModeW::new(self, 0)
            }
        }
        #[doc = "RW, GPIO PA interrupt mode: 0=level action, 1=edge action\n\nYou can [`read`](crate::Reg::read) this register and get [`int_mode::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_mode::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IntModeSpec;
        impl crate::RegisterSpec for IntModeSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`int_mode::R`](R) reader structure"]
        impl crate::Readable for IntModeSpec {}
        #[doc = "`write(|w| ..)` method takes [`int_mode::W`](W) writer structure"]
        impl crate::Writable for IntModeSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets INT_MODE to value 0"]
        impl crate::Resettable for IntModeSpec {}
    }
    #[doc = "INT_IF (rw) register accessor: RW1, GPIO PA interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_if::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_if::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_if`] module"]
    #[doc(alias = "INT_IF")]
    pub type IntIf = crate::Reg<int_if::IntIfSpec>;
    #[doc = "RW1, GPIO PA interrupt flag"]
    pub mod int_if {
        #[doc = "Register `INT_IF` reader"]
        pub type R = crate::R<IntIfSpec>;
        #[doc = "Register `INT_IF` writer"]
        pub type W = crate::W<IntIfSpec>;
        #[doc = "Field `INT_IF` reader - GPIO PA interrupt flag"]
        pub type IntIfR = crate::FieldReader<u16>;
        #[doc = "Field `INT_IF` writer - GPIO PA interrupt flag"]
        pub type IntIfW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - GPIO PA interrupt flag"]
            #[inline(always)]
            pub fn int_if(&self) -> IntIfR {
                IntIfR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - GPIO PA interrupt flag"]
            #[inline(always)]
            pub fn int_if(&mut self) -> IntIfW<IntIfSpec> {
                IntIfW::new(self, 0)
            }
        }
        #[doc = "RW1, GPIO PA interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_if::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_if::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IntIfSpec;
        impl crate::RegisterSpec for IntIfSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`int_if::R`](R) reader structure"]
        impl crate::Readable for IntIfSpec {}
        #[doc = "`write(|w| ..)` method takes [`int_if::W`](W) writer structure"]
        impl crate::Writable for IntIfSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets INT_IF to value 0"]
        impl crate::Resettable for IntIfSpec {}
    }
    #[doc = "DIR (rw) register accessor: RW, GPIO PA I/O direction: 0=in, 1=out\n\nYou can [`read`](crate::Reg::read) this register and get [`dir::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dir::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dir`] module"]
    #[doc(alias = "DIR")]
    pub type Dir = crate::Reg<dir::DirSpec>;
    #[doc = "RW, GPIO PA I/O direction: 0=in, 1=out"]
    pub mod dir {
        #[doc = "Register `DIR` reader"]
        pub type R = crate::R<DirSpec>;
        #[doc = "Register `DIR` writer"]
        pub type W = crate::W<DirSpec>;
        #[doc = "Field `DIR_0` reader - GPIO PA I/O direction byte 0"]
        pub type Dir0R = crate::FieldReader;
        #[doc = "Field `DIR_0` writer - GPIO PA I/O direction byte 0"]
        pub type Dir0W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `DIR_1` reader - GPIO PA I/O direction byte 1"]
        pub type Dir1R = crate::FieldReader;
        #[doc = "Field `DIR_1` writer - GPIO PA I/O direction byte 1"]
        pub type Dir1W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - GPIO PA I/O direction byte 0"]
            #[inline(always)]
            pub fn dir_0(&self) -> Dir0R {
                Dir0R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - GPIO PA I/O direction byte 1"]
            #[inline(always)]
            pub fn dir_1(&self) -> Dir1R {
                Dir1R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - GPIO PA I/O direction byte 0"]
            #[inline(always)]
            pub fn dir_0(&mut self) -> Dir0W<DirSpec> {
                Dir0W::new(self, 0)
            }
            #[doc = "Bits 8:15 - GPIO PA I/O direction byte 1"]
            #[inline(always)]
            pub fn dir_1(&mut self) -> Dir1W<DirSpec> {
                Dir1W::new(self, 8)
            }
        }
        #[doc = "RW, GPIO PA I/O direction: 0=in, 1=out\n\nYou can [`read`](crate::Reg::read) this register and get [`dir::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dir::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DirSpec;
        impl crate::RegisterSpec for DirSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dir::R`](R) reader structure"]
        impl crate::Readable for DirSpec {}
        #[doc = "`write(|w| ..)` method takes [`dir::W`](W) writer structure"]
        impl crate::Writable for DirSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DIR to value 0"]
        impl crate::Resettable for DirSpec {}
    }
    #[doc = "PIN (r) register accessor: RO, GPIO PA input\n\nYou can [`read`](crate::Reg::read) this register and get [`pin::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pin`] module"]
    #[doc(alias = "PIN")]
    pub type Pin = crate::Reg<pin::PinSpec>;
    #[doc = "RO, GPIO PA input"]
    pub mod pin {
        #[doc = "Register `PIN` reader"]
        pub type R = crate::R<PinSpec>;
        #[doc = "Field `PIN_0` reader - GPIO PA input byte 0"]
        pub type Pin0R = crate::FieldReader;
        #[doc = "Field `PIN_1` reader - GPIO PA input byte 1"]
        pub type Pin1R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - GPIO PA input byte 0"]
            #[inline(always)]
            pub fn pin_0(&self) -> Pin0R {
                Pin0R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - GPIO PA input byte 1"]
            #[inline(always)]
            pub fn pin_1(&self) -> Pin1R {
                Pin1R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        #[doc = "RO, GPIO PA input\n\nYou can [`read`](crate::Reg::read) this register and get [`pin::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PinSpec;
        impl crate::RegisterSpec for PinSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pin::R`](R) reader structure"]
        impl crate::Readable for PinSpec {}
        #[doc = "`reset()` method sets PIN to value 0"]
        impl crate::Resettable for PinSpec {}
    }
    #[doc = "OUT (rw) register accessor: RW, GPIO PA output\n\nYou can [`read`](crate::Reg::read) this register and get [`out::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`out::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@out`] module"]
    #[doc(alias = "OUT")]
    pub type Out = crate::Reg<out::OutSpec>;
    #[doc = "RW, GPIO PA output"]
    pub mod out {
        #[doc = "Register `OUT` reader"]
        pub type R = crate::R<OutSpec>;
        #[doc = "Register `OUT` writer"]
        pub type W = crate::W<OutSpec>;
        #[doc = "Field `OUT_0` reader - GPIO PA output byte 0"]
        pub type Out0R = crate::FieldReader;
        #[doc = "Field `OUT_0` writer - GPIO PA output byte 0"]
        pub type Out0W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `OUT_1` reader - GPIO PA output byte 1"]
        pub type Out1R = crate::FieldReader;
        #[doc = "Field `OUT_1` writer - GPIO PA output byte 1"]
        pub type Out1W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - GPIO PA output byte 0"]
            #[inline(always)]
            pub fn out_0(&self) -> Out0R {
                Out0R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - GPIO PA output byte 1"]
            #[inline(always)]
            pub fn out_1(&self) -> Out1R {
                Out1R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - GPIO PA output byte 0"]
            #[inline(always)]
            pub fn out_0(&mut self) -> Out0W<OutSpec> {
                Out0W::new(self, 0)
            }
            #[doc = "Bits 8:15 - GPIO PA output byte 1"]
            #[inline(always)]
            pub fn out_1(&mut self) -> Out1W<OutSpec> {
                Out1W::new(self, 8)
            }
        }
        #[doc = "RW, GPIO PA output\n\nYou can [`read`](crate::Reg::read) this register and get [`out::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`out::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct OutSpec;
        impl crate::RegisterSpec for OutSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`out::R`](R) reader structure"]
        impl crate::Readable for OutSpec {}
        #[doc = "`write(|w| ..)` method takes [`out::W`](W) writer structure"]
        impl crate::Writable for OutSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets OUT to value 0"]
        impl crate::Resettable for OutSpec {}
    }
    #[doc = "CLR (rw) register accessor: WZ, GPIO PA clear output: 0=keep, 1=clear\n\nYou can [`read`](crate::Reg::read) this register and get [`clr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clr`] module"]
    #[doc(alias = "CLR")]
    pub type Clr = crate::Reg<clr::ClrSpec>;
    #[doc = "WZ, GPIO PA clear output: 0=keep, 1=clear"]
    pub mod clr {
        #[doc = "Register `CLR` reader"]
        pub type R = crate::R<ClrSpec>;
        #[doc = "Register `CLR` writer"]
        pub type W = crate::W<ClrSpec>;
        #[doc = "Field `CLR_0` reader - GPIO PA clear output byte 0"]
        pub type Clr0R = crate::FieldReader;
        #[doc = "Field `CLR_0` writer - GPIO PA clear output byte 0"]
        pub type Clr0W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `CLR_1` reader - GPIO PA clear output byte 1"]
        pub type Clr1R = crate::FieldReader;
        #[doc = "Field `CLR_1` writer - GPIO PA clear output byte 1"]
        pub type Clr1W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - GPIO PA clear output byte 0"]
            #[inline(always)]
            pub fn clr_0(&self) -> Clr0R {
                Clr0R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - GPIO PA clear output byte 1"]
            #[inline(always)]
            pub fn clr_1(&self) -> Clr1R {
                Clr1R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - GPIO PA clear output byte 0"]
            #[inline(always)]
            pub fn clr_0(&mut self) -> Clr0W<ClrSpec> {
                Clr0W::new(self, 0)
            }
            #[doc = "Bits 8:15 - GPIO PA clear output byte 1"]
            #[inline(always)]
            pub fn clr_1(&mut self) -> Clr1W<ClrSpec> {
                Clr1W::new(self, 8)
            }
        }
        #[doc = "WZ, GPIO PA clear output: 0=keep, 1=clear\n\nYou can [`read`](crate::Reg::read) this register and get [`clr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ClrSpec;
        impl crate::RegisterSpec for ClrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`clr::R`](R) reader structure"]
        impl crate::Readable for ClrSpec {}
        #[doc = "`write(|w| ..)` method takes [`clr::W`](W) writer structure"]
        impl crate::Writable for ClrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CLR to value 0"]
        impl crate::Resettable for ClrSpec {}
    }
    #[doc = "PU (rw) register accessor: RW, GPIO PA pullup resistance enable\n\nYou can [`read`](crate::Reg::read) this register and get [`pu::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pu::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pu`] module"]
    #[doc(alias = "PU")]
    pub type Pu = crate::Reg<pu::PuSpec>;
    #[doc = "RW, GPIO PA pullup resistance enable"]
    pub mod pu {
        #[doc = "Register `PU` reader"]
        pub type R = crate::R<PuSpec>;
        #[doc = "Register `PU` writer"]
        pub type W = crate::W<PuSpec>;
        #[doc = "Field `PU_0` reader - GPIO PA pullup resistance enable byte 0"]
        pub type Pu0R = crate::FieldReader;
        #[doc = "Field `PU_0` writer - GPIO PA pullup resistance enable byte 0"]
        pub type Pu0W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `PU_1` reader - GPIO PA pullup resistance enable byte 0"]
        pub type Pu1R = crate::FieldReader;
        #[doc = "Field `PU_1` writer - GPIO PA pullup resistance enable byte 0"]
        pub type Pu1W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - GPIO PA pullup resistance enable byte 0"]
            #[inline(always)]
            pub fn pu_0(&self) -> Pu0R {
                Pu0R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - GPIO PA pullup resistance enable byte 0"]
            #[inline(always)]
            pub fn pu_1(&self) -> Pu1R {
                Pu1R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - GPIO PA pullup resistance enable byte 0"]
            #[inline(always)]
            pub fn pu_0(&mut self) -> Pu0W<PuSpec> {
                Pu0W::new(self, 0)
            }
            #[doc = "Bits 8:15 - GPIO PA pullup resistance enable byte 0"]
            #[inline(always)]
            pub fn pu_1(&mut self) -> Pu1W<PuSpec> {
                Pu1W::new(self, 8)
            }
        }
        #[doc = "RW, GPIO PA pullup resistance enable\n\nYou can [`read`](crate::Reg::read) this register and get [`pu::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pu::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PuSpec;
        impl crate::RegisterSpec for PuSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pu::R`](R) reader structure"]
        impl crate::Readable for PuSpec {}
        #[doc = "`write(|w| ..)` method takes [`pu::W`](W) writer structure"]
        impl crate::Writable for PuSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PU to value 0"]
        impl crate::Resettable for PuSpec {}
    }
    #[doc = "PD_DRV (rw) register accessor: RW, PA pulldown for input or PA driving capability for output\n\nYou can [`read`](crate::Reg::read) this register and get [`pd_drv::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pd_drv::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pd_drv`] module"]
    #[doc(alias = "PD_DRV")]
    pub type PdDrv = crate::Reg<pd_drv::PdDrvSpec>;
    #[doc = "RW, PA pulldown for input or PA driving capability for output"]
    pub mod pd_drv {
        #[doc = "Register `PD_DRV` reader"]
        pub type R = crate::R<PdDrvSpec>;
        #[doc = "Register `PD_DRV` writer"]
        pub type W = crate::W<PdDrvSpec>;
        #[doc = "Field `PD_DRV_0` reader - PA pulldown for input or PA driving capability for output byte 0"]
        pub type PdDrv0R = crate::FieldReader;
        #[doc = "Field `PD_DRV_0` writer - PA pulldown for input or PA driving capability for output byte 0"]
        pub type PdDrv0W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `PD_DRV_1` reader - PA pulldown for input or PA driving capability for output byte 1"]
        pub type PdDrv1R = crate::FieldReader;
        #[doc = "Field `PD_DRV_1` writer - PA pulldown for input or PA driving capability for output byte 1"]
        pub type PdDrv1W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - PA pulldown for input or PA driving capability for output byte 0"]
            #[inline(always)]
            pub fn pd_drv_0(&self) -> PdDrv0R {
                PdDrv0R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - PA pulldown for input or PA driving capability for output byte 1"]
            #[inline(always)]
            pub fn pd_drv_1(&self) -> PdDrv1R {
                PdDrv1R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - PA pulldown for input or PA driving capability for output byte 0"]
            #[inline(always)]
            pub fn pd_drv_0(&mut self) -> PdDrv0W<PdDrvSpec> {
                PdDrv0W::new(self, 0)
            }
            #[doc = "Bits 8:15 - PA pulldown for input or PA driving capability for output byte 1"]
            #[inline(always)]
            pub fn pd_drv_1(&mut self) -> PdDrv1W<PdDrvSpec> {
                PdDrv1W::new(self, 8)
            }
        }
        #[doc = "RW, PA pulldown for input or PA driving capability for output\n\nYou can [`read`](crate::Reg::read) this register and get [`pd_drv::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pd_drv::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PdDrvSpec;
        impl crate::RegisterSpec for PdDrvSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pd_drv::R`](R) reader structure"]
        impl crate::Readable for PdDrvSpec {}
        #[doc = "`write(|w| ..)` method takes [`pd_drv::W`](W) writer structure"]
        impl crate::Writable for PdDrvSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PD_DRV to value 0"]
        impl crate::Resettable for PdDrvSpec {}
    }
}
#[doc = "System Control Register"]
pub type Gpiob = crate::Periph<gpiob::RegisterBlock, 0x4000_1000>;
impl core::fmt::Debug for Gpiob {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpiob").finish()
    }
}
#[doc = "System Control Register"]
pub mod gpiob {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        _reserved0: [u8; 0x92],
        int_en: IntEn,
        _reserved1: [u8; 0x02],
        int_mode: IntMode,
        _reserved2: [u8; 0x06],
        int_if: IntIf,
        _reserved3: [u8; 0x20],
        dir: Dir,
        pin: Pin,
        out: Out,
        clr: Clr,
        pu: Pu,
        pd_drv: PdDrv,
    }
    impl RegisterBlock {
        #[doc = "0x92 - RW, GPIO PB interrupt enable"]
        #[inline(always)]
        pub const fn int_en(&self) -> &IntEn {
            &self.int_en
        }
        #[doc = "0x96 - RW, GPIO PB interrupt mode: 0=level action, 1=edge action"]
        #[inline(always)]
        pub const fn int_mode(&self) -> &IntMode {
            &self.int_mode
        }
        #[doc = "0x9e - RW1, GPIO PB interrupt flag"]
        #[inline(always)]
        pub const fn int_if(&self) -> &IntIf {
            &self.int_if
        }
        #[doc = "0xc0 - RW, GPIO PB I/O direction: 0=in, 1=out"]
        #[inline(always)]
        pub const fn dir(&self) -> &Dir {
            &self.dir
        }
        #[doc = "0xc4 - RO, GPIO PB input"]
        #[inline(always)]
        pub const fn pin(&self) -> &Pin {
            &self.pin
        }
        #[doc = "0xc8 - RW, GPIO PB output"]
        #[inline(always)]
        pub const fn out(&self) -> &Out {
            &self.out
        }
        #[doc = "0xcc - WZ, GPIO PB clear output: 0=keep, 1=clear"]
        #[inline(always)]
        pub const fn clr(&self) -> &Clr {
            &self.clr
        }
        #[doc = "0xd0 - RW, GPIO PB pullup resistance enable"]
        #[inline(always)]
        pub const fn pu(&self) -> &Pu {
            &self.pu
        }
        #[doc = "0xd4 - RW, PB pulldown for input or PB driving capability for output"]
        #[inline(always)]
        pub const fn pd_drv(&self) -> &PdDrv {
            &self.pd_drv
        }
    }
    #[doc = "INT_EN (rw) register accessor: RW, GPIO PB interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`int_en::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_en::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_en`] module"]
    #[doc(alias = "INT_EN")]
    pub type IntEn = crate::Reg<int_en::IntEnSpec>;
    #[doc = "RW, GPIO PB interrupt enable"]
    pub mod int_en {
        #[doc = "Register `INT_EN` reader"]
        pub type R = crate::R<IntEnSpec>;
        #[doc = "Register `INT_EN` writer"]
        pub type W = crate::W<IntEnSpec>;
        #[doc = "Field `INT_EN` reader - GPIO PB interrupt enable"]
        pub type IntEnR = crate::FieldReader<u16>;
        #[doc = "Field `INT_EN` writer - GPIO PB interrupt enable"]
        pub type IntEnW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - GPIO PB interrupt enable"]
            #[inline(always)]
            pub fn int_en(&self) -> IntEnR {
                IntEnR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - GPIO PB interrupt enable"]
            #[inline(always)]
            pub fn int_en(&mut self) -> IntEnW<IntEnSpec> {
                IntEnW::new(self, 0)
            }
        }
        #[doc = "RW, GPIO PB interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`int_en::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_en::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IntEnSpec;
        impl crate::RegisterSpec for IntEnSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`int_en::R`](R) reader structure"]
        impl crate::Readable for IntEnSpec {}
        #[doc = "`write(|w| ..)` method takes [`int_en::W`](W) writer structure"]
        impl crate::Writable for IntEnSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets INT_EN to value 0"]
        impl crate::Resettable for IntEnSpec {}
    }
    #[doc = "INT_MODE (rw) register accessor: RW, GPIO PB interrupt mode: 0=level action, 1=edge action\n\nYou can [`read`](crate::Reg::read) this register and get [`int_mode::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_mode::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_mode`] module"]
    #[doc(alias = "INT_MODE")]
    pub type IntMode = crate::Reg<int_mode::IntModeSpec>;
    #[doc = "RW, GPIO PB interrupt mode: 0=level action, 1=edge action"]
    pub mod int_mode {
        #[doc = "Register `INT_MODE` reader"]
        pub type R = crate::R<IntModeSpec>;
        #[doc = "Register `INT_MODE` writer"]
        pub type W = crate::W<IntModeSpec>;
        #[doc = "Field `INT_MODE` reader - GPIO PB interrupt mode"]
        pub type IntModeR = crate::FieldReader<u16>;
        #[doc = "Field `INT_MODE` writer - GPIO PB interrupt mode"]
        pub type IntModeW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - GPIO PB interrupt mode"]
            #[inline(always)]
            pub fn int_mode(&self) -> IntModeR {
                IntModeR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - GPIO PB interrupt mode"]
            #[inline(always)]
            pub fn int_mode(&mut self) -> IntModeW<IntModeSpec> {
                IntModeW::new(self, 0)
            }
        }
        #[doc = "RW, GPIO PB interrupt mode: 0=level action, 1=edge action\n\nYou can [`read`](crate::Reg::read) this register and get [`int_mode::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_mode::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IntModeSpec;
        impl crate::RegisterSpec for IntModeSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`int_mode::R`](R) reader structure"]
        impl crate::Readable for IntModeSpec {}
        #[doc = "`write(|w| ..)` method takes [`int_mode::W`](W) writer structure"]
        impl crate::Writable for IntModeSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets INT_MODE to value 0"]
        impl crate::Resettable for IntModeSpec {}
    }
    #[doc = "INT_IF (rw) register accessor: RW1, GPIO PB interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_if::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_if::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_if`] module"]
    #[doc(alias = "INT_IF")]
    pub type IntIf = crate::Reg<int_if::IntIfSpec>;
    #[doc = "RW1, GPIO PB interrupt flag"]
    pub mod int_if {
        #[doc = "Register `INT_IF` reader"]
        pub type R = crate::R<IntIfSpec>;
        #[doc = "Register `INT_IF` writer"]
        pub type W = crate::W<IntIfSpec>;
        #[doc = "Field `INT_IF` reader - GPIO PB interrupt flag"]
        pub type IntIfR = crate::FieldReader<u16>;
        #[doc = "Field `INT_IF` writer - GPIO PB interrupt flag"]
        pub type IntIfW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - GPIO PB interrupt flag"]
            #[inline(always)]
            pub fn int_if(&self) -> IntIfR {
                IntIfR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - GPIO PB interrupt flag"]
            #[inline(always)]
            pub fn int_if(&mut self) -> IntIfW<IntIfSpec> {
                IntIfW::new(self, 0)
            }
        }
        #[doc = "RW1, GPIO PB interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_if::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_if::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IntIfSpec;
        impl crate::RegisterSpec for IntIfSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`int_if::R`](R) reader structure"]
        impl crate::Readable for IntIfSpec {}
        #[doc = "`write(|w| ..)` method takes [`int_if::W`](W) writer structure"]
        impl crate::Writable for IntIfSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets INT_IF to value 0"]
        impl crate::Resettable for IntIfSpec {}
    }
    #[doc = "DIR (rw) register accessor: RW, GPIO PB I/O direction: 0=in, 1=out\n\nYou can [`read`](crate::Reg::read) this register and get [`dir::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dir::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dir`] module"]
    #[doc(alias = "DIR")]
    pub type Dir = crate::Reg<dir::DirSpec>;
    #[doc = "RW, GPIO PB I/O direction: 0=in, 1=out"]
    pub mod dir {
        #[doc = "Register `DIR` reader"]
        pub type R = crate::R<DirSpec>;
        #[doc = "Register `DIR` writer"]
        pub type W = crate::W<DirSpec>;
        #[doc = "Field `DIR_0` reader - GPIO PB I/O direction byte 0"]
        pub type Dir0R = crate::FieldReader;
        #[doc = "Field `DIR_0` writer - GPIO PB I/O direction byte 0"]
        pub type Dir0W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `DIR_1` reader - GPIO PB I/O direction byte 1"]
        pub type Dir1R = crate::FieldReader;
        #[doc = "Field `DIR_1` writer - GPIO PB I/O direction byte 1"]
        pub type Dir1W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `DIR_2` reader - GPIO PB I/O direction byte 2"]
        pub type Dir2R = crate::FieldReader;
        #[doc = "Field `DIR_2` writer - GPIO PB I/O direction byte 2"]
        pub type Dir2W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - GPIO PB I/O direction byte 0"]
            #[inline(always)]
            pub fn dir_0(&self) -> Dir0R {
                Dir0R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - GPIO PB I/O direction byte 1"]
            #[inline(always)]
            pub fn dir_1(&self) -> Dir1R {
                Dir1R::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bits 16:23 - GPIO PB I/O direction byte 2"]
            #[inline(always)]
            pub fn dir_2(&self) -> Dir2R {
                Dir2R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - GPIO PB I/O direction byte 0"]
            #[inline(always)]
            pub fn dir_0(&mut self) -> Dir0W<DirSpec> {
                Dir0W::new(self, 0)
            }
            #[doc = "Bits 8:15 - GPIO PB I/O direction byte 1"]
            #[inline(always)]
            pub fn dir_1(&mut self) -> Dir1W<DirSpec> {
                Dir1W::new(self, 8)
            }
            #[doc = "Bits 16:23 - GPIO PB I/O direction byte 2"]
            #[inline(always)]
            pub fn dir_2(&mut self) -> Dir2W<DirSpec> {
                Dir2W::new(self, 16)
            }
        }
        #[doc = "RW, GPIO PB I/O direction: 0=in, 1=out\n\nYou can [`read`](crate::Reg::read) this register and get [`dir::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dir::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DirSpec;
        impl crate::RegisterSpec for DirSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`dir::R`](R) reader structure"]
        impl crate::Readable for DirSpec {}
        #[doc = "`write(|w| ..)` method takes [`dir::W`](W) writer structure"]
        impl crate::Writable for DirSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DIR to value 0"]
        impl crate::Resettable for DirSpec {}
    }
    #[doc = "PIN (r) register accessor: RO, GPIO PB input\n\nYou can [`read`](crate::Reg::read) this register and get [`pin::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pin`] module"]
    #[doc(alias = "PIN")]
    pub type Pin = crate::Reg<pin::PinSpec>;
    #[doc = "RO, GPIO PB input"]
    pub mod pin {
        #[doc = "Register `PIN` reader"]
        pub type R = crate::R<PinSpec>;
        #[doc = "Field `PIN_0` reader - GPIO PB input byte 0"]
        pub type Pin0R = crate::FieldReader;
        #[doc = "Field `PIN_1` reader - GPIO PB input byte 1"]
        pub type Pin1R = crate::FieldReader;
        #[doc = "Field `PIN_2` reader - GPIO PB input byte 2"]
        pub type Pin2R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - GPIO PB input byte 0"]
            #[inline(always)]
            pub fn pin_0(&self) -> Pin0R {
                Pin0R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - GPIO PB input byte 1"]
            #[inline(always)]
            pub fn pin_1(&self) -> Pin1R {
                Pin1R::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bits 16:23 - GPIO PB input byte 2"]
            #[inline(always)]
            pub fn pin_2(&self) -> Pin2R {
                Pin2R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        #[doc = "RO, GPIO PB input\n\nYou can [`read`](crate::Reg::read) this register and get [`pin::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PinSpec;
        impl crate::RegisterSpec for PinSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pin::R`](R) reader structure"]
        impl crate::Readable for PinSpec {}
        #[doc = "`reset()` method sets PIN to value 0"]
        impl crate::Resettable for PinSpec {}
    }
    #[doc = "OUT (rw) register accessor: RW, GPIO PB output\n\nYou can [`read`](crate::Reg::read) this register and get [`out::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`out::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@out`] module"]
    #[doc(alias = "OUT")]
    pub type Out = crate::Reg<out::OutSpec>;
    #[doc = "RW, GPIO PB output"]
    pub mod out {
        #[doc = "Register `OUT` reader"]
        pub type R = crate::R<OutSpec>;
        #[doc = "Register `OUT` writer"]
        pub type W = crate::W<OutSpec>;
        #[doc = "Field `OUT_0` reader - GPIO PB output byte 0"]
        pub type Out0R = crate::FieldReader;
        #[doc = "Field `OUT_0` writer - GPIO PB output byte 0"]
        pub type Out0W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `OUT_1` reader - GPIO PB output byte 1"]
        pub type Out1R = crate::FieldReader;
        #[doc = "Field `OUT_1` writer - GPIO PB output byte 1"]
        pub type Out1W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `OUT_2` reader - GPIO PB output byte 2"]
        pub type Out2R = crate::FieldReader;
        #[doc = "Field `OUT_2` writer - GPIO PB output byte 2"]
        pub type Out2W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - GPIO PB output byte 0"]
            #[inline(always)]
            pub fn out_0(&self) -> Out0R {
                Out0R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - GPIO PB output byte 1"]
            #[inline(always)]
            pub fn out_1(&self) -> Out1R {
                Out1R::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bits 16:23 - GPIO PB output byte 2"]
            #[inline(always)]
            pub fn out_2(&self) -> Out2R {
                Out2R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - GPIO PB output byte 0"]
            #[inline(always)]
            pub fn out_0(&mut self) -> Out0W<OutSpec> {
                Out0W::new(self, 0)
            }
            #[doc = "Bits 8:15 - GPIO PB output byte 1"]
            #[inline(always)]
            pub fn out_1(&mut self) -> Out1W<OutSpec> {
                Out1W::new(self, 8)
            }
            #[doc = "Bits 16:23 - GPIO PB output byte 2"]
            #[inline(always)]
            pub fn out_2(&mut self) -> Out2W<OutSpec> {
                Out2W::new(self, 16)
            }
        }
        #[doc = "RW, GPIO PB output\n\nYou can [`read`](crate::Reg::read) this register and get [`out::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`out::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct OutSpec;
        impl crate::RegisterSpec for OutSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`out::R`](R) reader structure"]
        impl crate::Readable for OutSpec {}
        #[doc = "`write(|w| ..)` method takes [`out::W`](W) writer structure"]
        impl crate::Writable for OutSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets OUT to value 0"]
        impl crate::Resettable for OutSpec {}
    }
    #[doc = "CLR (rw) register accessor: WZ, GPIO PB clear output: 0=keep, 1=clear\n\nYou can [`read`](crate::Reg::read) this register and get [`clr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clr`] module"]
    #[doc(alias = "CLR")]
    pub type Clr = crate::Reg<clr::ClrSpec>;
    #[doc = "WZ, GPIO PB clear output: 0=keep, 1=clear"]
    pub mod clr {
        #[doc = "Register `CLR` reader"]
        pub type R = crate::R<ClrSpec>;
        #[doc = "Register `CLR` writer"]
        pub type W = crate::W<ClrSpec>;
        #[doc = "Field `CLR_0` reader - GPIO PB clear output byte 0"]
        pub type Clr0R = crate::FieldReader;
        #[doc = "Field `CLR_0` writer - GPIO PB clear output byte 0"]
        pub type Clr0W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `CLR_1` reader - GPIO PB clear output byte 1"]
        pub type Clr1R = crate::FieldReader;
        #[doc = "Field `CLR_1` writer - GPIO PB clear output byte 1"]
        pub type Clr1W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `CLR_2` reader - GPIO PB clear output byte 2"]
        pub type Clr2R = crate::FieldReader;
        #[doc = "Field `CLR_2` writer - GPIO PB clear output byte 2"]
        pub type Clr2W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - GPIO PB clear output byte 0"]
            #[inline(always)]
            pub fn clr_0(&self) -> Clr0R {
                Clr0R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - GPIO PB clear output byte 1"]
            #[inline(always)]
            pub fn clr_1(&self) -> Clr1R {
                Clr1R::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bits 16:23 - GPIO PB clear output byte 2"]
            #[inline(always)]
            pub fn clr_2(&self) -> Clr2R {
                Clr2R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - GPIO PB clear output byte 0"]
            #[inline(always)]
            pub fn clr_0(&mut self) -> Clr0W<ClrSpec> {
                Clr0W::new(self, 0)
            }
            #[doc = "Bits 8:15 - GPIO PB clear output byte 1"]
            #[inline(always)]
            pub fn clr_1(&mut self) -> Clr1W<ClrSpec> {
                Clr1W::new(self, 8)
            }
            #[doc = "Bits 16:23 - GPIO PB clear output byte 2"]
            #[inline(always)]
            pub fn clr_2(&mut self) -> Clr2W<ClrSpec> {
                Clr2W::new(self, 16)
            }
        }
        #[doc = "WZ, GPIO PB clear output: 0=keep, 1=clear\n\nYou can [`read`](crate::Reg::read) this register and get [`clr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ClrSpec;
        impl crate::RegisterSpec for ClrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`clr::R`](R) reader structure"]
        impl crate::Readable for ClrSpec {}
        #[doc = "`write(|w| ..)` method takes [`clr::W`](W) writer structure"]
        impl crate::Writable for ClrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CLR to value 0"]
        impl crate::Resettable for ClrSpec {}
    }
    #[doc = "PU (rw) register accessor: RW, GPIO PB pullup resistance enable\n\nYou can [`read`](crate::Reg::read) this register and get [`pu::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pu::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pu`] module"]
    #[doc(alias = "PU")]
    pub type Pu = crate::Reg<pu::PuSpec>;
    #[doc = "RW, GPIO PB pullup resistance enable"]
    pub mod pu {
        #[doc = "Register `PU` reader"]
        pub type R = crate::R<PuSpec>;
        #[doc = "Register `PU` writer"]
        pub type W = crate::W<PuSpec>;
        #[doc = "Field `PU_0` reader - GPIO PB pullup resistance enable byte 0"]
        pub type Pu0R = crate::FieldReader;
        #[doc = "Field `PU_0` writer - GPIO PB pullup resistance enable byte 0"]
        pub type Pu0W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `PU_1` reader - GPIO PB pullup resistance enable byte 1"]
        pub type Pu1R = crate::FieldReader;
        #[doc = "Field `PU_1` writer - GPIO PB pullup resistance enable byte 1"]
        pub type Pu1W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `PU_2` reader - GPIO PB pullup resistance enable byte 2"]
        pub type Pu2R = crate::FieldReader;
        #[doc = "Field `PU_2` writer - GPIO PB pullup resistance enable byte 2"]
        pub type Pu2W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - GPIO PB pullup resistance enable byte 0"]
            #[inline(always)]
            pub fn pu_0(&self) -> Pu0R {
                Pu0R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - GPIO PB pullup resistance enable byte 1"]
            #[inline(always)]
            pub fn pu_1(&self) -> Pu1R {
                Pu1R::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bits 16:23 - GPIO PB pullup resistance enable byte 2"]
            #[inline(always)]
            pub fn pu_2(&self) -> Pu2R {
                Pu2R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - GPIO PB pullup resistance enable byte 0"]
            #[inline(always)]
            pub fn pu_0(&mut self) -> Pu0W<PuSpec> {
                Pu0W::new(self, 0)
            }
            #[doc = "Bits 8:15 - GPIO PB pullup resistance enable byte 1"]
            #[inline(always)]
            pub fn pu_1(&mut self) -> Pu1W<PuSpec> {
                Pu1W::new(self, 8)
            }
            #[doc = "Bits 16:23 - GPIO PB pullup resistance enable byte 2"]
            #[inline(always)]
            pub fn pu_2(&mut self) -> Pu2W<PuSpec> {
                Pu2W::new(self, 16)
            }
        }
        #[doc = "RW, GPIO PB pullup resistance enable\n\nYou can [`read`](crate::Reg::read) this register and get [`pu::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pu::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PuSpec;
        impl crate::RegisterSpec for PuSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pu::R`](R) reader structure"]
        impl crate::Readable for PuSpec {}
        #[doc = "`write(|w| ..)` method takes [`pu::W`](W) writer structure"]
        impl crate::Writable for PuSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PU to value 0"]
        impl crate::Resettable for PuSpec {}
    }
    #[doc = "PD_DRV (rw) register accessor: RW, PB pulldown for input or PB driving capability for output\n\nYou can [`read`](crate::Reg::read) this register and get [`pd_drv::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pd_drv::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pd_drv`] module"]
    #[doc(alias = "PD_DRV")]
    pub type PdDrv = crate::Reg<pd_drv::PdDrvSpec>;
    #[doc = "RW, PB pulldown for input or PB driving capability for output"]
    pub mod pd_drv {
        #[doc = "Register `PD_DRV` reader"]
        pub type R = crate::R<PdDrvSpec>;
        #[doc = "Register `PD_DRV` writer"]
        pub type W = crate::W<PdDrvSpec>;
        #[doc = "Field `PD_DRV_0` reader - PB pulldown for input or PB driving capability for output byte 0"]
        pub type PdDrv0R = crate::FieldReader;
        #[doc = "Field `PD_DRV_0` writer - PB pulldown for input or PB driving capability for output byte 0"]
        pub type PdDrv0W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `PD_DRV_1` reader - PB pulldown for input or PB driving capability for output byte 0"]
        pub type PdDrv1R = crate::FieldReader;
        #[doc = "Field `PD_DRV_1` writer - PB pulldown for input or PB driving capability for output byte 0"]
        pub type PdDrv1W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `PD_DRV_2` reader - PB pulldown for input or PB driving capability for output byte 0"]
        pub type PdDrv2R = crate::FieldReader;
        #[doc = "Field `PD_DRV_2` writer - PB pulldown for input or PB driving capability for output byte 0"]
        pub type PdDrv2W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - PB pulldown for input or PB driving capability for output byte 0"]
            #[inline(always)]
            pub fn pd_drv_0(&self) -> PdDrv0R {
                PdDrv0R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - PB pulldown for input or PB driving capability for output byte 0"]
            #[inline(always)]
            pub fn pd_drv_1(&self) -> PdDrv1R {
                PdDrv1R::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bits 16:23 - PB pulldown for input or PB driving capability for output byte 0"]
            #[inline(always)]
            pub fn pd_drv_2(&self) -> PdDrv2R {
                PdDrv2R::new(((self.bits >> 16) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - PB pulldown for input or PB driving capability for output byte 0"]
            #[inline(always)]
            pub fn pd_drv_0(&mut self) -> PdDrv0W<PdDrvSpec> {
                PdDrv0W::new(self, 0)
            }
            #[doc = "Bits 8:15 - PB pulldown for input or PB driving capability for output byte 0"]
            #[inline(always)]
            pub fn pd_drv_1(&mut self) -> PdDrv1W<PdDrvSpec> {
                PdDrv1W::new(self, 8)
            }
            #[doc = "Bits 16:23 - PB pulldown for input or PB driving capability for output byte 0"]
            #[inline(always)]
            pub fn pd_drv_2(&mut self) -> PdDrv2W<PdDrvSpec> {
                PdDrv2W::new(self, 16)
            }
        }
        #[doc = "RW, PB pulldown for input or PB driving capability for output\n\nYou can [`read`](crate::Reg::read) this register and get [`pd_drv::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pd_drv::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PdDrvSpec;
        impl crate::RegisterSpec for PdDrvSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`pd_drv::R`](R) reader structure"]
        impl crate::Readable for PdDrvSpec {}
        #[doc = "`write(|w| ..)` method takes [`pd_drv::W`](W) writer structure"]
        impl crate::Writable for PdDrvSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PD_DRV to value 0"]
        impl crate::Resettable for PdDrvSpec {}
    }
}
#[doc = "Timer0 register"]
pub type Tmr0 = crate::Periph<tmr0::RegisterBlock, 0x4000_2000>;
impl core::fmt::Debug for Tmr0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tmr0").finish()
    }
}
#[doc = "Timer0 register"]
pub mod tmr0 {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        ctrl_mod: CtrlMod,
        _reserved1: [u8; 0x01],
        inter_en: InterEn,
        _reserved2: [u8; 0x03],
        int_flag: IntFlag,
        fifo_count: FifoCount,
        count: Count,
        cnt_end: CntEnd,
        fifo: Fifo,
    }
    impl RegisterBlock {
        #[doc = "0x00 - RW, TMR0 mode control"]
        #[inline(always)]
        pub const fn ctrl_mod(&self) -> &CtrlMod {
            &self.ctrl_mod
        }
        #[doc = "0x02 - RW, TMR0 interrupt enable"]
        #[inline(always)]
        pub const fn inter_en(&self) -> &InterEn {
            &self.inter_en
        }
        #[doc = "0x06 - RW1, TMR0 interrupt flag"]
        #[inline(always)]
        pub const fn int_flag(&self) -> &IntFlag {
            &self.int_flag
        }
        #[doc = "0x07 - RO, TMR0 FIFO count status"]
        #[inline(always)]
        pub const fn fifo_count(&self) -> &FifoCount {
            &self.fifo_count
        }
        #[doc = "0x08 - RO, TMR0 current count"]
        #[inline(always)]
        pub const fn count(&self) -> &Count {
            &self.count
        }
        #[doc = "0x0c - RW, TMR0 end count value, only low 26 bit"]
        #[inline(always)]
        pub const fn cnt_end(&self) -> &CntEnd {
            &self.cnt_end
        }
        #[doc = "0x10 - RO/WO, TMR0 FIFO register, only low 26 bit"]
        #[inline(always)]
        pub const fn fifo(&self) -> &Fifo {
            &self.fifo
        }
    }
    #[doc = "CTRL_MOD (rw) register accessor: RW, TMR0 mode control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl_mod`] module"]
    #[doc(alias = "CTRL_MOD")]
    pub type CtrlMod = crate::Reg<ctrl_mod::CtrlModSpec>;
    #[doc = "RW, TMR0 mode control"]
    pub mod ctrl_mod {
        #[doc = "Register `CTRL_MOD` reader"]
        pub type R = crate::R<CtrlModSpec>;
        #[doc = "Register `CTRL_MOD` writer"]
        pub type W = crate::W<CtrlModSpec>;
        #[doc = "Field `ODE_IN` reader - RW, timer in mode: 0=timer/PWM, 1=capture/count"]
        pub type OdeInR = crate::BitReader;
        #[doc = "Field `ODE_IN` writer - RW, timer in mode: 0=timer/PWM, 1=capture/count"]
        pub type OdeInW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LL_CLEAR` reader - RW, force clear timer FIFO and count"]
        pub type LlClearR = crate::BitReader;
        #[doc = "Field `LL_CLEAR` writer - RW, force clear timer FIFO and count"]
        pub type LlClearW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `OUNT_EN` reader - RW, timer count enable"]
        pub type OuntEnR = crate::BitReader;
        #[doc = "Field `OUNT_EN` writer - RW, timer count enable"]
        pub type OuntEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UT_EN` reader - RW, timer output enable"]
        pub type UtEnR = crate::BitReader;
        #[doc = "Field `UT_EN` writer - RW, timer output enable"]
        pub type UtEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UT_POLAR` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"]
        pub type UtPolarR = crate::BitReader;
        #[doc = "Field `UT_POLAR` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"]
        pub type UtPolarW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `AP_COUNT` reader - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"]
        pub type ApCountR = crate::BitReader;
        #[doc = "Field `AP_COUNT` writer - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"]
        pub type ApCountW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WM_REPEAT` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"]
        pub type WmRepeatR = crate::FieldReader;
        #[doc = "Field `WM_REPEAT` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"]
        pub type WmRepeatW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `AP_EDGE` reader - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"]
        pub type ApEdgeR = crate::FieldReader;
        #[doc = "Field `AP_EDGE` writer - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"]
        pub type ApEdgeW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            #[doc = "Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count"]
            #[inline(always)]
            pub fn ode_in(&self) -> OdeInR {
                OdeInR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, force clear timer FIFO and count"]
            #[inline(always)]
            pub fn ll_clear(&self) -> LlClearR {
                LlClearR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW, timer count enable"]
            #[inline(always)]
            pub fn ount_en(&self) -> OuntEnR {
                OuntEnR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, timer output enable"]
            #[inline(always)]
            pub fn ut_en(&self) -> UtEnR {
                UtEnR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"]
            #[inline(always)]
            pub fn ut_polar(&self) -> UtPolarR {
                UtPolarR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"]
            #[inline(always)]
            pub fn ap_count(&self) -> ApCountR {
                ApCountR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"]
            #[inline(always)]
            pub fn wm_repeat(&self) -> WmRepeatR {
                WmRepeatR::new((self.bits >> 6) & 3)
            }
            #[doc = "Bits 6:7 - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"]
            #[inline(always)]
            pub fn ap_edge(&self) -> ApEdgeR {
                ApEdgeR::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count"]
            #[inline(always)]
            pub fn ode_in(&mut self) -> OdeInW<CtrlModSpec> {
                OdeInW::new(self, 0)
            }
            #[doc = "Bit 1 - RW, force clear timer FIFO and count"]
            #[inline(always)]
            pub fn ll_clear(&mut self) -> LlClearW<CtrlModSpec> {
                LlClearW::new(self, 1)
            }
            #[doc = "Bit 2 - RW, timer count enable"]
            #[inline(always)]
            pub fn ount_en(&mut self) -> OuntEnW<CtrlModSpec> {
                OuntEnW::new(self, 2)
            }
            #[doc = "Bit 3 - RW, timer output enable"]
            #[inline(always)]
            pub fn ut_en(&mut self) -> UtEnW<CtrlModSpec> {
                UtEnW::new(self, 3)
            }
            #[doc = "Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"]
            #[inline(always)]
            pub fn ut_polar(&mut self) -> UtPolarW<CtrlModSpec> {
                UtPolarW::new(self, 4)
            }
            #[doc = "Bit 4 - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"]
            #[inline(always)]
            pub fn ap_count(&mut self) -> ApCountW<CtrlModSpec> {
                ApCountW::new(self, 4)
            }
            #[doc = "Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"]
            #[inline(always)]
            pub fn wm_repeat(&mut self) -> WmRepeatW<CtrlModSpec> {
                WmRepeatW::new(self, 6)
            }
            #[doc = "Bits 6:7 - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"]
            #[inline(always)]
            pub fn ap_edge(&mut self) -> ApEdgeW<CtrlModSpec> {
                ApEdgeW::new(self, 6)
            }
        }
        #[doc = "RW, TMR0 mode control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CtrlModSpec;
        impl crate::RegisterSpec for CtrlModSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`ctrl_mod::R`](R) reader structure"]
        impl crate::Readable for CtrlModSpec {}
        #[doc = "`write(|w| ..)` method takes [`ctrl_mod::W`](W) writer structure"]
        impl crate::Writable for CtrlModSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CTRL_MOD to value 0x02"]
        impl crate::Resettable for CtrlModSpec {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    #[doc = "INTER_EN (rw) register accessor: RW, TMR0 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`inter_en::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inter_en::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@inter_en`] module"]
    #[doc(alias = "INTER_EN")]
    pub type InterEn = crate::Reg<inter_en::InterEnSpec>;
    #[doc = "RW, TMR0 interrupt enable"]
    pub mod inter_en {
        #[doc = "Register `INTER_EN` reader"]
        pub type R = crate::R<InterEnSpec>;
        #[doc = "Register `INTER_EN` writer"]
        pub type W = crate::W<InterEnSpec>;
        #[doc = "Field `E_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end"]
        pub type ECycEndR = crate::BitReader;
        #[doc = "Field `E_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end"]
        pub type ECycEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger"]
        pub type EDataActR = crate::BitReader;
        #[doc = "Field `E_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger"]
        pub type EDataActW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"]
        pub type EFifoHfR = crate::BitReader;
        #[doc = "Field `E_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"]
        pub type EFifoHfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion"]
        pub type EDmaEndR = crate::BitReader;
        #[doc = "Field `E_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion"]
        pub type EDmaEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow"]
        pub type EFifoOvR = crate::BitReader;
        #[doc = "Field `E_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow"]
        pub type EFifoOvW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end"]
            #[inline(always)]
            pub fn e_cyc_end(&self) -> ECycEndR {
                ECycEndR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger"]
            #[inline(always)]
            pub fn e_data_act(&self) -> EDataActR {
                EDataActR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"]
            #[inline(always)]
            pub fn e_fifo_hf(&self) -> EFifoHfR {
                EFifoHfR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, enable interrupt for timer1/2 DMA completion"]
            #[inline(always)]
            pub fn e_dma_end(&self) -> EDmaEndR {
                EDmaEndR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, enable interrupt for timer FIFO overflow"]
            #[inline(always)]
            pub fn e_fifo_ov(&self) -> EFifoOvR {
                EFifoOvR::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end"]
            #[inline(always)]
            pub fn e_cyc_end(&mut self) -> ECycEndW<InterEnSpec> {
                ECycEndW::new(self, 0)
            }
            #[doc = "Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger"]
            #[inline(always)]
            pub fn e_data_act(&mut self) -> EDataActW<InterEnSpec> {
                EDataActW::new(self, 1)
            }
            #[doc = "Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"]
            #[inline(always)]
            pub fn e_fifo_hf(&mut self) -> EFifoHfW<InterEnSpec> {
                EFifoHfW::new(self, 2)
            }
            #[doc = "Bit 3 - RW, enable interrupt for timer1/2 DMA completion"]
            #[inline(always)]
            pub fn e_dma_end(&mut self) -> EDmaEndW<InterEnSpec> {
                EDmaEndW::new(self, 3)
            }
            #[doc = "Bit 4 - RW, enable interrupt for timer FIFO overflow"]
            #[inline(always)]
            pub fn e_fifo_ov(&mut self) -> EFifoOvW<InterEnSpec> {
                EFifoOvW::new(self, 4)
            }
        }
        #[doc = "RW, TMR0 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`inter_en::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inter_en::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct InterEnSpec;
        impl crate::RegisterSpec for InterEnSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`inter_en::R`](R) reader structure"]
        impl crate::Readable for InterEnSpec {}
        #[doc = "`write(|w| ..)` method takes [`inter_en::W`](W) writer structure"]
        impl crate::Writable for InterEnSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets INTER_EN to value 0"]
        impl crate::Resettable for InterEnSpec {}
    }
    #[doc = "INT_FLAG (rw) register accessor: RW1, TMR0 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_flag`] module"]
    #[doc(alias = "INT_FLAG")]
    pub type IntFlag = crate::Reg<int_flag::IntFlagSpec>;
    #[doc = "RW1, TMR0 interrupt flag"]
    pub mod int_flag {
        #[doc = "Register `INT_FLAG` reader"]
        pub type R = crate::R<IntFlagSpec>;
        #[doc = "Register `INT_FLAG` writer"]
        pub type W = crate::W<IntFlagSpec>;
        #[doc = "Field `F_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end"]
        pub type FCycEndR = crate::BitReader;
        #[doc = "Field `F_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end"]
        pub type FCycEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger"]
        pub type FDataActR = crate::BitReader;
        #[doc = "Field `F_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger"]
        pub type FDataActW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"]
        pub type FFifoHfR = crate::BitReader;
        #[doc = "Field `F_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"]
        pub type FFifoHfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion"]
        pub type FDmaEndR = crate::BitReader;
        #[doc = "Field `F_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion"]
        pub type FDmaEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow"]
        pub type FFifoOvR = crate::BitReader;
        #[doc = "Field `F_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow"]
        pub type FFifoOvW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end"]
            #[inline(always)]
            pub fn f_cyc_end(&self) -> FCycEndR {
                FCycEndR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger"]
            #[inline(always)]
            pub fn f_data_act(&self) -> FDataActR {
                FDataActR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"]
            #[inline(always)]
            pub fn f_fifo_hf(&self) -> FFifoHfR {
                FFifoHfR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW1, interrupt flag for timer1/2 DMA completion"]
            #[inline(always)]
            pub fn f_dma_end(&self) -> FDmaEndR {
                FDmaEndR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW1, interrupt flag for timer FIFO overflow"]
            #[inline(always)]
            pub fn f_fifo_ov(&self) -> FFifoOvR {
                FFifoOvR::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end"]
            #[inline(always)]
            pub fn f_cyc_end(&mut self) -> FCycEndW<IntFlagSpec> {
                FCycEndW::new(self, 0)
            }
            #[doc = "Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger"]
            #[inline(always)]
            pub fn f_data_act(&mut self) -> FDataActW<IntFlagSpec> {
                FDataActW::new(self, 1)
            }
            #[doc = "Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"]
            #[inline(always)]
            pub fn f_fifo_hf(&mut self) -> FFifoHfW<IntFlagSpec> {
                FFifoHfW::new(self, 2)
            }
            #[doc = "Bit 3 - RW1, interrupt flag for timer1/2 DMA completion"]
            #[inline(always)]
            pub fn f_dma_end(&mut self) -> FDmaEndW<IntFlagSpec> {
                FDmaEndW::new(self, 3)
            }
            #[doc = "Bit 4 - RW1, interrupt flag for timer FIFO overflow"]
            #[inline(always)]
            pub fn f_fifo_ov(&mut self) -> FFifoOvW<IntFlagSpec> {
                FFifoOvW::new(self, 4)
            }
        }
        #[doc = "RW1, TMR0 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IntFlagSpec;
        impl crate::RegisterSpec for IntFlagSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`int_flag::R`](R) reader structure"]
        impl crate::Readable for IntFlagSpec {}
        #[doc = "`write(|w| ..)` method takes [`int_flag::W`](W) writer structure"]
        impl crate::Writable for IntFlagSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets INT_FLAG to value 0"]
        impl crate::Resettable for IntFlagSpec {}
    }
    #[doc = "FIFO_COUNT (r) register accessor: RO, TMR0 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo_count`] module"]
    #[doc(alias = "FIFO_COUNT")]
    pub type FifoCount = crate::Reg<fifo_count::FifoCountSpec>;
    #[doc = "RO, TMR0 FIFO count status"]
    pub mod fifo_count {
        #[doc = "Register `FIFO_COUNT` reader"]
        pub type R = crate::R<FifoCountSpec>;
        #[doc = "Field `FIFO_COUNT` reader - RW1,TMR0 FIFO count status"]
        pub type FifoCountR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RW1,TMR0 FIFO count status"]
            #[inline(always)]
            pub fn fifo_count(&self) -> FifoCountR {
                FifoCountR::new(self.bits)
            }
        }
        #[doc = "RO, TMR0 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FifoCountSpec;
        impl crate::RegisterSpec for FifoCountSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`fifo_count::R`](R) reader structure"]
        impl crate::Readable for FifoCountSpec {}
        #[doc = "`reset()` method sets FIFO_COUNT to value 0"]
        impl crate::Resettable for FifoCountSpec {}
    }
    #[doc = "COUNT (r) register accessor: RO, TMR0 current count\n\nYou can [`read`](crate::Reg::read) this register and get [`count::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count`] module"]
    #[doc(alias = "COUNT")]
    pub type Count = crate::Reg<count::CountSpec>;
    #[doc = "RO, TMR0 current count"]
    pub mod count {
        #[doc = "Register `COUNT` reader"]
        pub type R = crate::R<CountSpec>;
        #[doc = "Field `COUNT` reader - RW1,TMR0 current count"]
        pub type CountR = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - RW1,TMR0 current count"]
            #[inline(always)]
            pub fn count(&self) -> CountR {
                CountR::new(self.bits)
            }
        }
        #[doc = "RO, TMR0 current count\n\nYou can [`read`](crate::Reg::read) this register and get [`count::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CountSpec;
        impl crate::RegisterSpec for CountSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`count::R`](R) reader structure"]
        impl crate::Readable for CountSpec {}
        #[doc = "`reset()` method sets COUNT to value 0"]
        impl crate::Resettable for CountSpec {}
    }
    #[doc = "CNT_END (rw) register accessor: RW, TMR0 end count value, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt_end::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt_end::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt_end`] module"]
    #[doc(alias = "CNT_END")]
    pub type CntEnd = crate::Reg<cnt_end::CntEndSpec>;
    #[doc = "RW, TMR0 end count value, only low 26 bit"]
    pub mod cnt_end {
        #[doc = "Register `CNT_END` reader"]
        pub type R = crate::R<CntEndSpec>;
        #[doc = "Register `CNT_END` writer"]
        pub type W = crate::W<CntEndSpec>;
        #[doc = "Field `CNT_END` reader - RW1,TMR0 end count value"]
        pub type CntEndR = crate::FieldReader<u32>;
        #[doc = "Field `CNT_END` writer - RW1,TMR0 end count value"]
        pub type CntEndW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW1,TMR0 end count value"]
            #[inline(always)]
            pub fn cnt_end(&self) -> CntEndR {
                CntEndR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW1,TMR0 end count value"]
            #[inline(always)]
            pub fn cnt_end(&mut self) -> CntEndW<CntEndSpec> {
                CntEndW::new(self, 0)
            }
        }
        #[doc = "RW, TMR0 end count value, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt_end::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt_end::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CntEndSpec;
        impl crate::RegisterSpec for CntEndSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cnt_end::R`](R) reader structure"]
        impl crate::Readable for CntEndSpec {}
        #[doc = "`write(|w| ..)` method takes [`cnt_end::W`](W) writer structure"]
        impl crate::Writable for CntEndSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CNT_END to value 0"]
        impl crate::Resettable for CntEndSpec {}
    }
    #[doc = "FIFO (r) register accessor: RO/WO, TMR0 FIFO register, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo`] module"]
    #[doc(alias = "FIFO")]
    pub type Fifo = crate::Reg<fifo::FifoSpec>;
    #[doc = "RO/WO, TMR0 FIFO register, only low 26 bit"]
    pub mod fifo {
        #[doc = "Register `FIFO` reader"]
        pub type R = crate::R<FifoSpec>;
        #[doc = "Field `FIFO` reader - RW1,TMR0 FIFO register"]
        pub type FifoR = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - RW1,TMR0 FIFO register"]
            #[inline(always)]
            pub fn fifo(&self) -> FifoR {
                FifoR::new(self.bits)
            }
        }
        #[doc = "RO/WO, TMR0 FIFO register, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FifoSpec;
        impl crate::RegisterSpec for FifoSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`fifo::R`](R) reader structure"]
        impl crate::Readable for FifoSpec {}
        #[doc = "`reset()` method sets FIFO to value 0"]
        impl crate::Resettable for FifoSpec {}
    }
}
#[doc = "Timer1 register"]
pub type Tmr1 = crate::Periph<tmr1::RegisterBlock, 0x4000_2400>;
impl core::fmt::Debug for Tmr1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tmr1").finish()
    }
}
#[doc = "Timer1 register"]
pub mod tmr1 {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        ctrl_mod: CtrlMod,
        ctrl_dma: CtrlDma,
        inter_en: InterEn,
        _reserved3: [u8; 0x03],
        int_flag: IntFlag,
        fifo_count: FifoCount,
        count: Count,
        cnt_end: CntEnd,
        fifo: Fifo,
        dma_now: DmaNow,
        _reserved9: [u8; 0x02],
        dma_beg: DmaBeg,
        _reserved10: [u8; 0x02],
        dma_end: DmaEnd,
    }
    impl RegisterBlock {
        #[doc = "0x00 - RW, TMR1 mode control"]
        #[inline(always)]
        pub const fn ctrl_mod(&self) -> &CtrlMod {
            &self.ctrl_mod
        }
        #[doc = "0x01 - RW, TMR1 DMA control"]
        #[inline(always)]
        pub const fn ctrl_dma(&self) -> &CtrlDma {
            &self.ctrl_dma
        }
        #[doc = "0x02 - RW, TMR1 interrupt enable"]
        #[inline(always)]
        pub const fn inter_en(&self) -> &InterEn {
            &self.inter_en
        }
        #[doc = "0x06 - RW1, TMR1 interrupt flag"]
        #[inline(always)]
        pub const fn int_flag(&self) -> &IntFlag {
            &self.int_flag
        }
        #[doc = "0x07 - RO, TMR1 FIFO count status"]
        #[inline(always)]
        pub const fn fifo_count(&self) -> &FifoCount {
            &self.fifo_count
        }
        #[doc = "0x08 - RO, TMR1 current count"]
        #[inline(always)]
        pub const fn count(&self) -> &Count {
            &self.count
        }
        #[doc = "0x0c - RW, TMR1 end count value, only low 26 bit"]
        #[inline(always)]
        pub const fn cnt_end(&self) -> &CntEnd {
            &self.cnt_end
        }
        #[doc = "0x10 - RO, TMR1 FIFO register, only low 26 bit"]
        #[inline(always)]
        pub const fn fifo(&self) -> &Fifo {
            &self.fifo
        }
        #[doc = "0x14 - RO, TMR1 DMA current address"]
        #[inline(always)]
        pub const fn dma_now(&self) -> &DmaNow {
            &self.dma_now
        }
        #[doc = "0x18 - RW, TMR1 DMA begin address"]
        #[inline(always)]
        pub const fn dma_beg(&self) -> &DmaBeg {
            &self.dma_beg
        }
        #[doc = "0x1c - RW, TMR1 DMA end address"]
        #[inline(always)]
        pub const fn dma_end(&self) -> &DmaEnd {
            &self.dma_end
        }
    }
    #[doc = "CTRL_MOD (rw) register accessor: RW, TMR1 mode control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl_mod`] module"]
    #[doc(alias = "CTRL_MOD")]
    pub type CtrlMod = crate::Reg<ctrl_mod::CtrlModSpec>;
    #[doc = "RW, TMR1 mode control"]
    pub mod ctrl_mod {
        #[doc = "Register `CTRL_MOD` reader"]
        pub type R = crate::R<CtrlModSpec>;
        #[doc = "Register `CTRL_MOD` writer"]
        pub type W = crate::W<CtrlModSpec>;
        #[doc = "Field `ODE_IN` reader - RW, timer in mode: 0=timer/PWM, 1=capture/count"]
        pub type OdeInR = crate::BitReader;
        #[doc = "Field `ODE_IN` writer - RW, timer in mode: 0=timer/PWM, 1=capture/count"]
        pub type OdeInW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LL_CLEAR` reader - RW, force clear timer FIFO and count"]
        pub type LlClearR = crate::BitReader;
        #[doc = "Field `LL_CLEAR` writer - RW, force clear timer FIFO and count"]
        pub type LlClearW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `OUNT_EN` reader - RW, timer count enable"]
        pub type OuntEnR = crate::BitReader;
        #[doc = "Field `OUNT_EN` writer - RW, timer count enable"]
        pub type OuntEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UT_EN` reader - RW, timer output enable"]
        pub type UtEnR = crate::BitReader;
        #[doc = "Field `UT_EN` writer - RW, timer output enable"]
        pub type UtEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UT_POLAR` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"]
        pub type UtPolarR = crate::BitReader;
        #[doc = "Field `UT_POLAR` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"]
        pub type UtPolarW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `AP_COUNT` reader - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"]
        pub type ApCountR = crate::BitReader;
        #[doc = "Field `AP_COUNT` writer - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"]
        pub type ApCountW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WM_REPEAT` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"]
        pub type WmRepeatR = crate::FieldReader;
        #[doc = "Field `WM_REPEAT` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"]
        pub type WmRepeatW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `AP_EDGE` reader - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"]
        pub type ApEdgeR = crate::FieldReader;
        #[doc = "Field `AP_EDGE` writer - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"]
        pub type ApEdgeW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            #[doc = "Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count"]
            #[inline(always)]
            pub fn ode_in(&self) -> OdeInR {
                OdeInR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, force clear timer FIFO and count"]
            #[inline(always)]
            pub fn ll_clear(&self) -> LlClearR {
                LlClearR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW, timer count enable"]
            #[inline(always)]
            pub fn ount_en(&self) -> OuntEnR {
                OuntEnR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, timer output enable"]
            #[inline(always)]
            pub fn ut_en(&self) -> UtEnR {
                UtEnR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"]
            #[inline(always)]
            pub fn ut_polar(&self) -> UtPolarR {
                UtPolarR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"]
            #[inline(always)]
            pub fn ap_count(&self) -> ApCountR {
                ApCountR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"]
            #[inline(always)]
            pub fn wm_repeat(&self) -> WmRepeatR {
                WmRepeatR::new((self.bits >> 6) & 3)
            }
            #[doc = "Bits 6:7 - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"]
            #[inline(always)]
            pub fn ap_edge(&self) -> ApEdgeR {
                ApEdgeR::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count"]
            #[inline(always)]
            pub fn ode_in(&mut self) -> OdeInW<CtrlModSpec> {
                OdeInW::new(self, 0)
            }
            #[doc = "Bit 1 - RW, force clear timer FIFO and count"]
            #[inline(always)]
            pub fn ll_clear(&mut self) -> LlClearW<CtrlModSpec> {
                LlClearW::new(self, 1)
            }
            #[doc = "Bit 2 - RW, timer count enable"]
            #[inline(always)]
            pub fn ount_en(&mut self) -> OuntEnW<CtrlModSpec> {
                OuntEnW::new(self, 2)
            }
            #[doc = "Bit 3 - RW, timer output enable"]
            #[inline(always)]
            pub fn ut_en(&mut self) -> UtEnW<CtrlModSpec> {
                UtEnW::new(self, 3)
            }
            #[doc = "Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"]
            #[inline(always)]
            pub fn ut_polar(&mut self) -> UtPolarW<CtrlModSpec> {
                UtPolarW::new(self, 4)
            }
            #[doc = "Bit 4 - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"]
            #[inline(always)]
            pub fn ap_count(&mut self) -> ApCountW<CtrlModSpec> {
                ApCountW::new(self, 4)
            }
            #[doc = "Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"]
            #[inline(always)]
            pub fn wm_repeat(&mut self) -> WmRepeatW<CtrlModSpec> {
                WmRepeatW::new(self, 6)
            }
            #[doc = "Bits 6:7 - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"]
            #[inline(always)]
            pub fn ap_edge(&mut self) -> ApEdgeW<CtrlModSpec> {
                ApEdgeW::new(self, 6)
            }
        }
        #[doc = "RW, TMR1 mode control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CtrlModSpec;
        impl crate::RegisterSpec for CtrlModSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`ctrl_mod::R`](R) reader structure"]
        impl crate::Readable for CtrlModSpec {}
        #[doc = "`write(|w| ..)` method takes [`ctrl_mod::W`](W) writer structure"]
        impl crate::Writable for CtrlModSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CTRL_MOD to value 0x02"]
        impl crate::Resettable for CtrlModSpec {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    #[doc = "CTRL_DMA (rw) register accessor: RW, TMR1 DMA control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl_dma`] module"]
    #[doc(alias = "CTRL_DMA")]
    pub type CtrlDma = crate::Reg<ctrl_dma::CtrlDmaSpec>;
    #[doc = "RW, TMR1 DMA control"]
    pub mod ctrl_dma {
        #[doc = "Register `CTRL_DMA` reader"]
        pub type R = crate::R<CtrlDmaSpec>;
        #[doc = "Register `CTRL_DMA` writer"]
        pub type W = crate::W<CtrlDmaSpec>;
        #[doc = "Field `MA_ENABLE` reader - RW, timer1/2 DMA enable"]
        pub type MaEnableR = crate::BitReader;
        #[doc = "Field `MA_ENABLE` writer - RW, timer1/2 DMA enable"]
        pub type MaEnableW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MA_LOOP` reader - RW, timer1/2 DMA address loop enable"]
        pub type MaLoopR = crate::BitReader;
        #[doc = "Field `MA_LOOP` writer - RW, timer1/2 DMA address loop enable"]
        pub type MaLoopW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, timer1/2 DMA enable"]
            #[inline(always)]
            pub fn ma_enable(&self) -> MaEnableR {
                MaEnableR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 2 - RW, timer1/2 DMA address loop enable"]
            #[inline(always)]
            pub fn ma_loop(&self) -> MaLoopR {
                MaLoopR::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, timer1/2 DMA enable"]
            #[inline(always)]
            pub fn ma_enable(&mut self) -> MaEnableW<CtrlDmaSpec> {
                MaEnableW::new(self, 0)
            }
            #[doc = "Bit 2 - RW, timer1/2 DMA address loop enable"]
            #[inline(always)]
            pub fn ma_loop(&mut self) -> MaLoopW<CtrlDmaSpec> {
                MaLoopW::new(self, 2)
            }
        }
        #[doc = "RW, TMR1 DMA control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CtrlDmaSpec;
        impl crate::RegisterSpec for CtrlDmaSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`ctrl_dma::R`](R) reader structure"]
        impl crate::Readable for CtrlDmaSpec {}
        #[doc = "`write(|w| ..)` method takes [`ctrl_dma::W`](W) writer structure"]
        impl crate::Writable for CtrlDmaSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CTRL_DMA to value 0"]
        impl crate::Resettable for CtrlDmaSpec {}
    }
    #[doc = "INTER_EN (rw) register accessor: RW, TMR1 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`inter_en::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inter_en::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@inter_en`] module"]
    #[doc(alias = "INTER_EN")]
    pub type InterEn = crate::Reg<inter_en::InterEnSpec>;
    #[doc = "RW, TMR1 interrupt enable"]
    pub mod inter_en {
        #[doc = "Register `INTER_EN` reader"]
        pub type R = crate::R<InterEnSpec>;
        #[doc = "Register `INTER_EN` writer"]
        pub type W = crate::W<InterEnSpec>;
        #[doc = "Field `E_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end"]
        pub type ECycEndR = crate::BitReader;
        #[doc = "Field `E_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end"]
        pub type ECycEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger"]
        pub type EDataActR = crate::BitReader;
        #[doc = "Field `E_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger"]
        pub type EDataActW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"]
        pub type EFifoHfR = crate::BitReader;
        #[doc = "Field `E_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"]
        pub type EFifoHfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion"]
        pub type EDmaEndR = crate::BitReader;
        #[doc = "Field `E_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion"]
        pub type EDmaEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow"]
        pub type EFifoOvR = crate::BitReader;
        #[doc = "Field `E_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow"]
        pub type EFifoOvW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end"]
            #[inline(always)]
            pub fn e_cyc_end(&self) -> ECycEndR {
                ECycEndR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger"]
            #[inline(always)]
            pub fn e_data_act(&self) -> EDataActR {
                EDataActR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"]
            #[inline(always)]
            pub fn e_fifo_hf(&self) -> EFifoHfR {
                EFifoHfR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, enable interrupt for timer1/2 DMA completion"]
            #[inline(always)]
            pub fn e_dma_end(&self) -> EDmaEndR {
                EDmaEndR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, enable interrupt for timer FIFO overflow"]
            #[inline(always)]
            pub fn e_fifo_ov(&self) -> EFifoOvR {
                EFifoOvR::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end"]
            #[inline(always)]
            pub fn e_cyc_end(&mut self) -> ECycEndW<InterEnSpec> {
                ECycEndW::new(self, 0)
            }
            #[doc = "Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger"]
            #[inline(always)]
            pub fn e_data_act(&mut self) -> EDataActW<InterEnSpec> {
                EDataActW::new(self, 1)
            }
            #[doc = "Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"]
            #[inline(always)]
            pub fn e_fifo_hf(&mut self) -> EFifoHfW<InterEnSpec> {
                EFifoHfW::new(self, 2)
            }
            #[doc = "Bit 3 - RW, enable interrupt for timer1/2 DMA completion"]
            #[inline(always)]
            pub fn e_dma_end(&mut self) -> EDmaEndW<InterEnSpec> {
                EDmaEndW::new(self, 3)
            }
            #[doc = "Bit 4 - RW, enable interrupt for timer FIFO overflow"]
            #[inline(always)]
            pub fn e_fifo_ov(&mut self) -> EFifoOvW<InterEnSpec> {
                EFifoOvW::new(self, 4)
            }
        }
        #[doc = "RW, TMR1 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`inter_en::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inter_en::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct InterEnSpec;
        impl crate::RegisterSpec for InterEnSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`inter_en::R`](R) reader structure"]
        impl crate::Readable for InterEnSpec {}
        #[doc = "`write(|w| ..)` method takes [`inter_en::W`](W) writer structure"]
        impl crate::Writable for InterEnSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets INTER_EN to value 0"]
        impl crate::Resettable for InterEnSpec {}
    }
    #[doc = "INT_FLAG (rw) register accessor: RW1, TMR1 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_flag`] module"]
    #[doc(alias = "INT_FLAG")]
    pub type IntFlag = crate::Reg<int_flag::IntFlagSpec>;
    #[doc = "RW1, TMR1 interrupt flag"]
    pub mod int_flag {
        #[doc = "Register `INT_FLAG` reader"]
        pub type R = crate::R<IntFlagSpec>;
        #[doc = "Register `INT_FLAG` writer"]
        pub type W = crate::W<IntFlagSpec>;
        #[doc = "Field `F_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end"]
        pub type FCycEndR = crate::BitReader;
        #[doc = "Field `F_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end"]
        pub type FCycEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger"]
        pub type FDataActR = crate::BitReader;
        #[doc = "Field `F_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger"]
        pub type FDataActW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"]
        pub type FFifoHfR = crate::BitReader;
        #[doc = "Field `F_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"]
        pub type FFifoHfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion"]
        pub type FDmaEndR = crate::BitReader;
        #[doc = "Field `F_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion"]
        pub type FDmaEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow"]
        pub type FFifoOvR = crate::BitReader;
        #[doc = "Field `F_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow"]
        pub type FFifoOvW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end"]
            #[inline(always)]
            pub fn f_cyc_end(&self) -> FCycEndR {
                FCycEndR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger"]
            #[inline(always)]
            pub fn f_data_act(&self) -> FDataActR {
                FDataActR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"]
            #[inline(always)]
            pub fn f_fifo_hf(&self) -> FFifoHfR {
                FFifoHfR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW1, interrupt flag for timer1/2 DMA completion"]
            #[inline(always)]
            pub fn f_dma_end(&self) -> FDmaEndR {
                FDmaEndR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW1, interrupt flag for timer FIFO overflow"]
            #[inline(always)]
            pub fn f_fifo_ov(&self) -> FFifoOvR {
                FFifoOvR::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end"]
            #[inline(always)]
            pub fn f_cyc_end(&mut self) -> FCycEndW<IntFlagSpec> {
                FCycEndW::new(self, 0)
            }
            #[doc = "Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger"]
            #[inline(always)]
            pub fn f_data_act(&mut self) -> FDataActW<IntFlagSpec> {
                FDataActW::new(self, 1)
            }
            #[doc = "Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"]
            #[inline(always)]
            pub fn f_fifo_hf(&mut self) -> FFifoHfW<IntFlagSpec> {
                FFifoHfW::new(self, 2)
            }
            #[doc = "Bit 3 - RW1, interrupt flag for timer1/2 DMA completion"]
            #[inline(always)]
            pub fn f_dma_end(&mut self) -> FDmaEndW<IntFlagSpec> {
                FDmaEndW::new(self, 3)
            }
            #[doc = "Bit 4 - RW1, interrupt flag for timer FIFO overflow"]
            #[inline(always)]
            pub fn f_fifo_ov(&mut self) -> FFifoOvW<IntFlagSpec> {
                FFifoOvW::new(self, 4)
            }
        }
        #[doc = "RW1, TMR1 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IntFlagSpec;
        impl crate::RegisterSpec for IntFlagSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`int_flag::R`](R) reader structure"]
        impl crate::Readable for IntFlagSpec {}
        #[doc = "`write(|w| ..)` method takes [`int_flag::W`](W) writer structure"]
        impl crate::Writable for IntFlagSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets INT_FLAG to value 0"]
        impl crate::Resettable for IntFlagSpec {}
    }
    #[doc = "FIFO_COUNT (r) register accessor: RO, TMR1 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo_count`] module"]
    #[doc(alias = "FIFO_COUNT")]
    pub type FifoCount = crate::Reg<fifo_count::FifoCountSpec>;
    #[doc = "RO, TMR1 FIFO count status"]
    pub mod fifo_count {
        #[doc = "Register `FIFO_COUNT` reader"]
        pub type R = crate::R<FifoCountSpec>;
        #[doc = "Field `FIFO_COUNT` reader - RW1, TMR1 FIFO count status"]
        pub type FifoCountR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RW1, TMR1 FIFO count status"]
            #[inline(always)]
            pub fn fifo_count(&self) -> FifoCountR {
                FifoCountR::new(self.bits)
            }
        }
        #[doc = "RO, TMR1 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FifoCountSpec;
        impl crate::RegisterSpec for FifoCountSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`fifo_count::R`](R) reader structure"]
        impl crate::Readable for FifoCountSpec {}
        #[doc = "`reset()` method sets FIFO_COUNT to value 0"]
        impl crate::Resettable for FifoCountSpec {}
    }
    #[doc = "COUNT (r) register accessor: RO, TMR1 current count\n\nYou can [`read`](crate::Reg::read) this register and get [`count::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count`] module"]
    #[doc(alias = "COUNT")]
    pub type Count = crate::Reg<count::CountSpec>;
    #[doc = "RO, TMR1 current count"]
    pub mod count {
        #[doc = "Register `COUNT` reader"]
        pub type R = crate::R<CountSpec>;
        #[doc = "Field `COUNT` reader - RW1,TMR1 current count"]
        pub type CountR = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - RW1,TMR1 current count"]
            #[inline(always)]
            pub fn count(&self) -> CountR {
                CountR::new(self.bits)
            }
        }
        #[doc = "RO, TMR1 current count\n\nYou can [`read`](crate::Reg::read) this register and get [`count::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CountSpec;
        impl crate::RegisterSpec for CountSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`count::R`](R) reader structure"]
        impl crate::Readable for CountSpec {}
        #[doc = "`reset()` method sets COUNT to value 0"]
        impl crate::Resettable for CountSpec {}
    }
    #[doc = "CNT_END (rw) register accessor: RW, TMR1 end count value, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt_end::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt_end::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt_end`] module"]
    #[doc(alias = "CNT_END")]
    pub type CntEnd = crate::Reg<cnt_end::CntEndSpec>;
    #[doc = "RW, TMR1 end count value, only low 26 bit"]
    pub mod cnt_end {
        #[doc = "Register `CNT_END` reader"]
        pub type R = crate::R<CntEndSpec>;
        #[doc = "Register `CNT_END` writer"]
        pub type W = crate::W<CntEndSpec>;
        #[doc = "Field `CNT_END` reader - RW1,TMR1 end count value,"]
        pub type CntEndR = crate::FieldReader<u32>;
        #[doc = "Field `CNT_END` writer - RW1,TMR1 end count value,"]
        pub type CntEndW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW1,TMR1 end count value,"]
            #[inline(always)]
            pub fn cnt_end(&self) -> CntEndR {
                CntEndR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW1,TMR1 end count value,"]
            #[inline(always)]
            pub fn cnt_end(&mut self) -> CntEndW<CntEndSpec> {
                CntEndW::new(self, 0)
            }
        }
        #[doc = "RW, TMR1 end count value, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt_end::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt_end::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CntEndSpec;
        impl crate::RegisterSpec for CntEndSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cnt_end::R`](R) reader structure"]
        impl crate::Readable for CntEndSpec {}
        #[doc = "`write(|w| ..)` method takes [`cnt_end::W`](W) writer structure"]
        impl crate::Writable for CntEndSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CNT_END to value 0"]
        impl crate::Resettable for CntEndSpec {}
    }
    #[doc = "FIFO (r) register accessor: RO, TMR1 FIFO register, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo`] module"]
    #[doc(alias = "FIFO")]
    pub type Fifo = crate::Reg<fifo::FifoSpec>;
    #[doc = "RO, TMR1 FIFO register, only low 26 bit"]
    pub mod fifo {
        #[doc = "Register `FIFO` reader"]
        pub type R = crate::R<FifoSpec>;
        #[doc = "Field `FIFO` reader - RW1,TMR1 FIFO register"]
        pub type FifoR = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - RW1,TMR1 FIFO register"]
            #[inline(always)]
            pub fn fifo(&self) -> FifoR {
                FifoR::new(self.bits)
            }
        }
        #[doc = "RO, TMR1 FIFO register, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FifoSpec;
        impl crate::RegisterSpec for FifoSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`fifo::R`](R) reader structure"]
        impl crate::Readable for FifoSpec {}
        #[doc = "`reset()` method sets FIFO to value 0"]
        impl crate::Resettable for FifoSpec {}
    }
    #[doc = "DMA_NOW (r) register accessor: RO, TMR1 DMA current address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_now::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_now`] module"]
    #[doc(alias = "DMA_NOW")]
    pub type DmaNow = crate::Reg<dma_now::DmaNowSpec>;
    #[doc = "RO, TMR1 DMA current address"]
    pub mod dma_now {
        #[doc = "Register `DMA_NOW` reader"]
        pub type R = crate::R<DmaNowSpec>;
        #[doc = "Field `DMA_NOW` reader - RW1,TMR1 FIFO register"]
        pub type DmaNowR = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:15 - RW1,TMR1 FIFO register"]
            #[inline(always)]
            pub fn dma_now(&self) -> DmaNowR {
                DmaNowR::new(self.bits)
            }
        }
        #[doc = "RO, TMR1 DMA current address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_now::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DmaNowSpec;
        impl crate::RegisterSpec for DmaNowSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`dma_now::R`](R) reader structure"]
        impl crate::Readable for DmaNowSpec {}
        #[doc = "`reset()` method sets DMA_NOW to value 0"]
        impl crate::Resettable for DmaNowSpec {}
    }
    #[doc = "DMA_BEG (rw) register accessor: RW, TMR1 DMA begin address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_beg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_beg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_beg`] module"]
    #[doc(alias = "DMA_BEG")]
    pub type DmaBeg = crate::Reg<dma_beg::DmaBegSpec>;
    #[doc = "RW, TMR1 DMA begin address"]
    pub mod dma_beg {
        #[doc = "Register `DMA_BEG` reader"]
        pub type R = crate::R<DmaBegSpec>;
        #[doc = "Register `DMA_BEG` writer"]
        pub type W = crate::W<DmaBegSpec>;
        #[doc = "Field `DMA_BEG` reader - RW1,TMR1 FIFO register"]
        pub type DmaBegR = crate::FieldReader<u16>;
        #[doc = "Field `DMA_BEG` writer - RW1,TMR1 FIFO register"]
        pub type DmaBegW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW1,TMR1 FIFO register"]
            #[inline(always)]
            pub fn dma_beg(&self) -> DmaBegR {
                DmaBegR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW1,TMR1 FIFO register"]
            #[inline(always)]
            pub fn dma_beg(&mut self) -> DmaBegW<DmaBegSpec> {
                DmaBegW::new(self, 0)
            }
        }
        #[doc = "RW, TMR1 DMA begin address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_beg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_beg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DmaBegSpec;
        impl crate::RegisterSpec for DmaBegSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`dma_beg::R`](R) reader structure"]
        impl crate::Readable for DmaBegSpec {}
        #[doc = "`write(|w| ..)` method takes [`dma_beg::W`](W) writer structure"]
        impl crate::Writable for DmaBegSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DMA_BEG to value 0"]
        impl crate::Resettable for DmaBegSpec {}
    }
    #[doc = "DMA_END (rw) register accessor: RW, TMR1 DMA end address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_end::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_end::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_end`] module"]
    #[doc(alias = "DMA_END")]
    pub type DmaEnd = crate::Reg<dma_end::DmaEndSpec>;
    #[doc = "RW, TMR1 DMA end address"]
    pub mod dma_end {
        #[doc = "Register `DMA_END` reader"]
        pub type R = crate::R<DmaEndSpec>;
        #[doc = "Register `DMA_END` writer"]
        pub type W = crate::W<DmaEndSpec>;
        #[doc = "Field `DMA_END` reader - RW1,TMR1 FIFO register"]
        pub type DmaEndR = crate::FieldReader<u16>;
        #[doc = "Field `DMA_END` writer - RW1,TMR1 FIFO register"]
        pub type DmaEndW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW1,TMR1 FIFO register"]
            #[inline(always)]
            pub fn dma_end(&self) -> DmaEndR {
                DmaEndR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW1,TMR1 FIFO register"]
            #[inline(always)]
            pub fn dma_end(&mut self) -> DmaEndW<DmaEndSpec> {
                DmaEndW::new(self, 0)
            }
        }
        #[doc = "RW, TMR1 DMA end address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_end::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_end::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DmaEndSpec;
        impl crate::RegisterSpec for DmaEndSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`dma_end::R`](R) reader structure"]
        impl crate::Readable for DmaEndSpec {}
        #[doc = "`write(|w| ..)` method takes [`dma_end::W`](W) writer structure"]
        impl crate::Writable for DmaEndSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DMA_END to value 0"]
        impl crate::Resettable for DmaEndSpec {}
    }
}
#[doc = "Timer2 register"]
pub type Tmr2 = crate::Periph<tmr2::RegisterBlock, 0x4000_2800>;
impl core::fmt::Debug for Tmr2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tmr2").finish()
    }
}
#[doc = "Timer2 register"]
pub mod tmr2 {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        ctrl_mod: CtrlMod,
        ctrl_dma: CtrlDma,
        inter_en: InterEn,
        _reserved3: [u8; 0x03],
        int_flag: IntFlag,
        fifo_count: FifoCount,
        count: Count,
        cnt_end: CntEnd,
        fifo: Fifo,
        dma_now: DmaNow,
        _reserved9: [u8; 0x02],
        dma_beg: DmaBeg,
        _reserved10: [u8; 0x02],
        dma_end: DmaEnd,
    }
    impl RegisterBlock {
        #[doc = "0x00 - RW, TMR2 mode control"]
        #[inline(always)]
        pub const fn ctrl_mod(&self) -> &CtrlMod {
            &self.ctrl_mod
        }
        #[doc = "0x01 - RW, TMR2 DMA control"]
        #[inline(always)]
        pub const fn ctrl_dma(&self) -> &CtrlDma {
            &self.ctrl_dma
        }
        #[doc = "0x02 - RW, TMR2 interrupt enable"]
        #[inline(always)]
        pub const fn inter_en(&self) -> &InterEn {
            &self.inter_en
        }
        #[doc = "0x06 - RW1, TMR2 interrupt flag"]
        #[inline(always)]
        pub const fn int_flag(&self) -> &IntFlag {
            &self.int_flag
        }
        #[doc = "0x07 - RO, TMR2 FIFO count status"]
        #[inline(always)]
        pub const fn fifo_count(&self) -> &FifoCount {
            &self.fifo_count
        }
        #[doc = "0x08 - RO, TMR2 current count"]
        #[inline(always)]
        pub const fn count(&self) -> &Count {
            &self.count
        }
        #[doc = "0x0c - RW, TMR2 end count value, only low 26 bit"]
        #[inline(always)]
        pub const fn cnt_end(&self) -> &CntEnd {
            &self.cnt_end
        }
        #[doc = "0x10 - RO, TMR2 FIFO register, only low 26 bit"]
        #[inline(always)]
        pub const fn fifo(&self) -> &Fifo {
            &self.fifo
        }
        #[doc = "0x14 - RO, TMR2 DMA current address"]
        #[inline(always)]
        pub const fn dma_now(&self) -> &DmaNow {
            &self.dma_now
        }
        #[doc = "0x18 - RW, TMR2 DMA begin address"]
        #[inline(always)]
        pub const fn dma_beg(&self) -> &DmaBeg {
            &self.dma_beg
        }
        #[doc = "0x1c - RW, TMR2 DMA end address"]
        #[inline(always)]
        pub const fn dma_end(&self) -> &DmaEnd {
            &self.dma_end
        }
    }
    #[doc = "CTRL_MOD (rw) register accessor: RW, TMR2 mode control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl_mod`] module"]
    #[doc(alias = "CTRL_MOD")]
    pub type CtrlMod = crate::Reg<ctrl_mod::CtrlModSpec>;
    #[doc = "RW, TMR2 mode control"]
    pub mod ctrl_mod {
        #[doc = "Register `CTRL_MOD` reader"]
        pub type R = crate::R<CtrlModSpec>;
        #[doc = "Register `CTRL_MOD` writer"]
        pub type W = crate::W<CtrlModSpec>;
        #[doc = "Field `ODE_IN` reader - RW, timer in mode: 0=timer_PWM, 1=capture_count"]
        pub type OdeInR = crate::BitReader;
        #[doc = "Field `ODE_IN` writer - RW, timer in mode: 0=timer_PWM, 1=capture_count"]
        pub type OdeInW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LL_CLEAR` reader - RW, force clear timer FIFO and count"]
        pub type LlClearR = crate::BitReader;
        #[doc = "Field `LL_CLEAR` writer - RW, force clear timer FIFO and count"]
        pub type LlClearW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `OUNT_EN` reader - RW, timer count enable"]
        pub type OuntEnR = crate::BitReader;
        #[doc = "Field `OUNT_EN` writer - RW, timer count enable"]
        pub type OuntEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UT_EN` reader - RW, timer output enable"]
        pub type UtEnR = crate::BitReader;
        #[doc = "Field `UT_EN` writer - RW, timer output enable"]
        pub type UtEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UT_POLAR` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"]
        pub type UtPolarR = crate::BitReader;
        #[doc = "Field `UT_POLAR` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"]
        pub type UtPolarW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `AP_COUNT` reader - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"]
        pub type ApCountR = crate::BitReader;
        #[doc = "Field `AP_COUNT` writer - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"]
        pub type ApCountW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WM_REPEAT` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"]
        pub type WmRepeatR = crate::FieldReader;
        #[doc = "Field `WM_REPEAT` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"]
        pub type WmRepeatW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `AP_EDGE` reader - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"]
        pub type ApEdgeR = crate::FieldReader;
        #[doc = "Field `AP_EDGE` writer - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"]
        pub type ApEdgeW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            #[doc = "Bit 0 - RW, timer in mode: 0=timer_PWM, 1=capture_count"]
            #[inline(always)]
            pub fn ode_in(&self) -> OdeInR {
                OdeInR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, force clear timer FIFO and count"]
            #[inline(always)]
            pub fn ll_clear(&self) -> LlClearR {
                LlClearR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW, timer count enable"]
            #[inline(always)]
            pub fn ount_en(&self) -> OuntEnR {
                OuntEnR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, timer output enable"]
            #[inline(always)]
            pub fn ut_en(&self) -> UtEnR {
                UtEnR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"]
            #[inline(always)]
            pub fn ut_polar(&self) -> UtPolarR {
                UtPolarR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"]
            #[inline(always)]
            pub fn ap_count(&self) -> ApCountR {
                ApCountR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"]
            #[inline(always)]
            pub fn wm_repeat(&self) -> WmRepeatR {
                WmRepeatR::new((self.bits >> 6) & 3)
            }
            #[doc = "Bits 6:7 - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"]
            #[inline(always)]
            pub fn ap_edge(&self) -> ApEdgeR {
                ApEdgeR::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, timer in mode: 0=timer_PWM, 1=capture_count"]
            #[inline(always)]
            pub fn ode_in(&mut self) -> OdeInW<CtrlModSpec> {
                OdeInW::new(self, 0)
            }
            #[doc = "Bit 1 - RW, force clear timer FIFO and count"]
            #[inline(always)]
            pub fn ll_clear(&mut self) -> LlClearW<CtrlModSpec> {
                LlClearW::new(self, 1)
            }
            #[doc = "Bit 2 - RW, timer count enable"]
            #[inline(always)]
            pub fn ount_en(&mut self) -> OuntEnW<CtrlModSpec> {
                OuntEnW::new(self, 2)
            }
            #[doc = "Bit 3 - RW, timer output enable"]
            #[inline(always)]
            pub fn ut_en(&mut self) -> UtEnW<CtrlModSpec> {
                UtEnW::new(self, 3)
            }
            #[doc = "Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"]
            #[inline(always)]
            pub fn ut_polar(&mut self) -> UtPolarW<CtrlModSpec> {
                UtPolarW::new(self, 4)
            }
            #[doc = "Bit 4 - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"]
            #[inline(always)]
            pub fn ap_count(&mut self) -> ApCountW<CtrlModSpec> {
                ApCountW::new(self, 4)
            }
            #[doc = "Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"]
            #[inline(always)]
            pub fn wm_repeat(&mut self) -> WmRepeatW<CtrlModSpec> {
                WmRepeatW::new(self, 6)
            }
            #[doc = "Bits 6:7 - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"]
            #[inline(always)]
            pub fn ap_edge(&mut self) -> ApEdgeW<CtrlModSpec> {
                ApEdgeW::new(self, 6)
            }
        }
        #[doc = "RW, TMR2 mode control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CtrlModSpec;
        impl crate::RegisterSpec for CtrlModSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`ctrl_mod::R`](R) reader structure"]
        impl crate::Readable for CtrlModSpec {}
        #[doc = "`write(|w| ..)` method takes [`ctrl_mod::W`](W) writer structure"]
        impl crate::Writable for CtrlModSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CTRL_MOD to value 0x02"]
        impl crate::Resettable for CtrlModSpec {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    #[doc = "CTRL_DMA (rw) register accessor: RW, TMR2 DMA control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl_dma`] module"]
    #[doc(alias = "CTRL_DMA")]
    pub type CtrlDma = crate::Reg<ctrl_dma::CtrlDmaSpec>;
    #[doc = "RW, TMR2 DMA control"]
    pub mod ctrl_dma {
        #[doc = "Register `CTRL_DMA` reader"]
        pub type R = crate::R<CtrlDmaSpec>;
        #[doc = "Register `CTRL_DMA` writer"]
        pub type W = crate::W<CtrlDmaSpec>;
        #[doc = "Field `MA_ENABLE` reader - RW, timer1_2 DMA enable"]
        pub type MaEnableR = crate::BitReader;
        #[doc = "Field `MA_ENABLE` writer - RW, timer1_2 DMA enable"]
        pub type MaEnableW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MA_LOOP` reader - RW, timer1_2 DMA address loop enable"]
        pub type MaLoopR = crate::BitReader;
        #[doc = "Field `MA_LOOP` writer - RW, timer1_2 DMA address loop enable"]
        pub type MaLoopW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, timer1_2 DMA enable"]
            #[inline(always)]
            pub fn ma_enable(&self) -> MaEnableR {
                MaEnableR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 2 - RW, timer1_2 DMA address loop enable"]
            #[inline(always)]
            pub fn ma_loop(&self) -> MaLoopR {
                MaLoopR::new(((self.bits >> 2) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, timer1_2 DMA enable"]
            #[inline(always)]
            pub fn ma_enable(&mut self) -> MaEnableW<CtrlDmaSpec> {
                MaEnableW::new(self, 0)
            }
            #[doc = "Bit 2 - RW, timer1_2 DMA address loop enable"]
            #[inline(always)]
            pub fn ma_loop(&mut self) -> MaLoopW<CtrlDmaSpec> {
                MaLoopW::new(self, 2)
            }
        }
        #[doc = "RW, TMR2 DMA control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CtrlDmaSpec;
        impl crate::RegisterSpec for CtrlDmaSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`ctrl_dma::R`](R) reader structure"]
        impl crate::Readable for CtrlDmaSpec {}
        #[doc = "`write(|w| ..)` method takes [`ctrl_dma::W`](W) writer structure"]
        impl crate::Writable for CtrlDmaSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CTRL_DMA to value 0"]
        impl crate::Resettable for CtrlDmaSpec {}
    }
    #[doc = "INTER_EN (rw) register accessor: RW, TMR2 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`inter_en::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inter_en::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@inter_en`] module"]
    #[doc(alias = "INTER_EN")]
    pub type InterEn = crate::Reg<inter_en::InterEnSpec>;
    #[doc = "RW, TMR2 interrupt enable"]
    pub mod inter_en {
        #[doc = "Register `INTER_EN` reader"]
        pub type R = crate::R<InterEnSpec>;
        #[doc = "Register `INTER_EN` writer"]
        pub type W = crate::W<InterEnSpec>;
        #[doc = "Field `E_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end"]
        pub type ECycEndR = crate::BitReader;
        #[doc = "Field `E_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end"]
        pub type ECycEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger"]
        pub type EDataActR = crate::BitReader;
        #[doc = "Field `E_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger"]
        pub type EDataActW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"]
        pub type EFifoHfR = crate::BitReader;
        #[doc = "Field `E_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"]
        pub type EFifoHfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion"]
        pub type EDmaEndR = crate::BitReader;
        #[doc = "Field `E_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion"]
        pub type EDmaEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow"]
        pub type EFifoOvR = crate::BitReader;
        #[doc = "Field `E_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow"]
        pub type EFifoOvW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end"]
            #[inline(always)]
            pub fn e_cyc_end(&self) -> ECycEndR {
                ECycEndR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger"]
            #[inline(always)]
            pub fn e_data_act(&self) -> EDataActR {
                EDataActR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"]
            #[inline(always)]
            pub fn e_fifo_hf(&self) -> EFifoHfR {
                EFifoHfR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, enable interrupt for timer1/2 DMA completion"]
            #[inline(always)]
            pub fn e_dma_end(&self) -> EDmaEndR {
                EDmaEndR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, enable interrupt for timer FIFO overflow"]
            #[inline(always)]
            pub fn e_fifo_ov(&self) -> EFifoOvR {
                EFifoOvR::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end"]
            #[inline(always)]
            pub fn e_cyc_end(&mut self) -> ECycEndW<InterEnSpec> {
                ECycEndW::new(self, 0)
            }
            #[doc = "Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger"]
            #[inline(always)]
            pub fn e_data_act(&mut self) -> EDataActW<InterEnSpec> {
                EDataActW::new(self, 1)
            }
            #[doc = "Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"]
            #[inline(always)]
            pub fn e_fifo_hf(&mut self) -> EFifoHfW<InterEnSpec> {
                EFifoHfW::new(self, 2)
            }
            #[doc = "Bit 3 - RW, enable interrupt for timer1/2 DMA completion"]
            #[inline(always)]
            pub fn e_dma_end(&mut self) -> EDmaEndW<InterEnSpec> {
                EDmaEndW::new(self, 3)
            }
            #[doc = "Bit 4 - RW, enable interrupt for timer FIFO overflow"]
            #[inline(always)]
            pub fn e_fifo_ov(&mut self) -> EFifoOvW<InterEnSpec> {
                EFifoOvW::new(self, 4)
            }
        }
        #[doc = "RW, TMR2 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`inter_en::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inter_en::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct InterEnSpec;
        impl crate::RegisterSpec for InterEnSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`inter_en::R`](R) reader structure"]
        impl crate::Readable for InterEnSpec {}
        #[doc = "`write(|w| ..)` method takes [`inter_en::W`](W) writer structure"]
        impl crate::Writable for InterEnSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets INTER_EN to value 0"]
        impl crate::Resettable for InterEnSpec {}
    }
    #[doc = "INT_FLAG (rw) register accessor: RW1, TMR2 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_flag`] module"]
    #[doc(alias = "INT_FLAG")]
    pub type IntFlag = crate::Reg<int_flag::IntFlagSpec>;
    #[doc = "RW1, TMR2 interrupt flag"]
    pub mod int_flag {
        #[doc = "Register `INT_FLAG` reader"]
        pub type R = crate::R<IntFlagSpec>;
        #[doc = "Register `INT_FLAG` writer"]
        pub type W = crate::W<IntFlagSpec>;
        #[doc = "Field `F_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end"]
        pub type FCycEndR = crate::BitReader;
        #[doc = "Field `F_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end"]
        pub type FCycEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger"]
        pub type FDataActR = crate::BitReader;
        #[doc = "Field `F_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger"]
        pub type FDataActW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"]
        pub type FFifoHfR = crate::BitReader;
        #[doc = "Field `F_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"]
        pub type FFifoHfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion"]
        pub type FDmaEndR = crate::BitReader;
        #[doc = "Field `F_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion"]
        pub type FDmaEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow"]
        pub type FFifoOvR = crate::BitReader;
        #[doc = "Field `F_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow"]
        pub type FFifoOvW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end"]
            #[inline(always)]
            pub fn f_cyc_end(&self) -> FCycEndR {
                FCycEndR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger"]
            #[inline(always)]
            pub fn f_data_act(&self) -> FDataActR {
                FDataActR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"]
            #[inline(always)]
            pub fn f_fifo_hf(&self) -> FFifoHfR {
                FFifoHfR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW1, interrupt flag for timer1/2 DMA completion"]
            #[inline(always)]
            pub fn f_dma_end(&self) -> FDmaEndR {
                FDmaEndR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW1, interrupt flag for timer FIFO overflow"]
            #[inline(always)]
            pub fn f_fifo_ov(&self) -> FFifoOvR {
                FFifoOvR::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end"]
            #[inline(always)]
            pub fn f_cyc_end(&mut self) -> FCycEndW<IntFlagSpec> {
                FCycEndW::new(self, 0)
            }
            #[doc = "Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger"]
            #[inline(always)]
            pub fn f_data_act(&mut self) -> FDataActW<IntFlagSpec> {
                FDataActW::new(self, 1)
            }
            #[doc = "Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"]
            #[inline(always)]
            pub fn f_fifo_hf(&mut self) -> FFifoHfW<IntFlagSpec> {
                FFifoHfW::new(self, 2)
            }
            #[doc = "Bit 3 - RW1, interrupt flag for timer1/2 DMA completion"]
            #[inline(always)]
            pub fn f_dma_end(&mut self) -> FDmaEndW<IntFlagSpec> {
                FDmaEndW::new(self, 3)
            }
            #[doc = "Bit 4 - RW1, interrupt flag for timer FIFO overflow"]
            #[inline(always)]
            pub fn f_fifo_ov(&mut self) -> FFifoOvW<IntFlagSpec> {
                FFifoOvW::new(self, 4)
            }
        }
        #[doc = "RW1, TMR2 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IntFlagSpec;
        impl crate::RegisterSpec for IntFlagSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`int_flag::R`](R) reader structure"]
        impl crate::Readable for IntFlagSpec {}
        #[doc = "`write(|w| ..)` method takes [`int_flag::W`](W) writer structure"]
        impl crate::Writable for IntFlagSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets INT_FLAG to value 0"]
        impl crate::Resettable for IntFlagSpec {}
    }
    #[doc = "FIFO_COUNT (r) register accessor: RO, TMR2 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo_count`] module"]
    #[doc(alias = "FIFO_COUNT")]
    pub type FifoCount = crate::Reg<fifo_count::FifoCountSpec>;
    #[doc = "RO, TMR2 FIFO count status"]
    pub mod fifo_count {
        #[doc = "Register `FIFO_COUNT` reader"]
        pub type R = crate::R<FifoCountSpec>;
        #[doc = "Field `FIFO_COUNT` reader - RW, TMR2 FIFO count status"]
        pub type FifoCountR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RW, TMR2 FIFO count status"]
            #[inline(always)]
            pub fn fifo_count(&self) -> FifoCountR {
                FifoCountR::new(self.bits)
            }
        }
        #[doc = "RO, TMR2 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FifoCountSpec;
        impl crate::RegisterSpec for FifoCountSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`fifo_count::R`](R) reader structure"]
        impl crate::Readable for FifoCountSpec {}
        #[doc = "`reset()` method sets FIFO_COUNT to value 0"]
        impl crate::Resettable for FifoCountSpec {}
    }
    #[doc = "COUNT (r) register accessor: RO, TMR2 current count\n\nYou can [`read`](crate::Reg::read) this register and get [`count::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count`] module"]
    #[doc(alias = "COUNT")]
    pub type Count = crate::Reg<count::CountSpec>;
    #[doc = "RO, TMR2 current count"]
    pub mod count {
        #[doc = "Register `COUNT` reader"]
        pub type R = crate::R<CountSpec>;
        #[doc = "Field `COUNT` reader - RW, TMR2 current count"]
        pub type CountR = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - RW, TMR2 current count"]
            #[inline(always)]
            pub fn count(&self) -> CountR {
                CountR::new(self.bits)
            }
        }
        #[doc = "RO, TMR2 current count\n\nYou can [`read`](crate::Reg::read) this register and get [`count::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CountSpec;
        impl crate::RegisterSpec for CountSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`count::R`](R) reader structure"]
        impl crate::Readable for CountSpec {}
        #[doc = "`reset()` method sets COUNT to value 0"]
        impl crate::Resettable for CountSpec {}
    }
    #[doc = "CNT_END (rw) register accessor: RW, TMR2 end count value, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt_end::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt_end::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt_end`] module"]
    #[doc(alias = "CNT_END")]
    pub type CntEnd = crate::Reg<cnt_end::CntEndSpec>;
    #[doc = "RW, TMR2 end count value, only low 26 bit"]
    pub mod cnt_end {
        #[doc = "Register `CNT_END` reader"]
        pub type R = crate::R<CntEndSpec>;
        #[doc = "Register `CNT_END` writer"]
        pub type W = crate::W<CntEndSpec>;
        #[doc = "Field `CNT_END` reader - RW, TMR2 current count"]
        pub type CntEndR = crate::FieldReader<u32>;
        #[doc = "Field `CNT_END` writer - RW, TMR2 current count"]
        pub type CntEndW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW, TMR2 current count"]
            #[inline(always)]
            pub fn cnt_end(&self) -> CntEndR {
                CntEndR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW, TMR2 current count"]
            #[inline(always)]
            pub fn cnt_end(&mut self) -> CntEndW<CntEndSpec> {
                CntEndW::new(self, 0)
            }
        }
        #[doc = "RW, TMR2 end count value, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt_end::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt_end::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CntEndSpec;
        impl crate::RegisterSpec for CntEndSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cnt_end::R`](R) reader structure"]
        impl crate::Readable for CntEndSpec {}
        #[doc = "`write(|w| ..)` method takes [`cnt_end::W`](W) writer structure"]
        impl crate::Writable for CntEndSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CNT_END to value 0"]
        impl crate::Resettable for CntEndSpec {}
    }
    #[doc = "FIFO (rw) register accessor: RO, TMR2 FIFO register, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fifo::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo`] module"]
    #[doc(alias = "FIFO")]
    pub type Fifo = crate::Reg<fifo::FifoSpec>;
    #[doc = "RO, TMR2 FIFO register, only low 26 bit"]
    pub mod fifo {
        #[doc = "Register `FIFO` reader"]
        pub type R = crate::R<FifoSpec>;
        #[doc = "Register `FIFO` writer"]
        pub type W = crate::W<FifoSpec>;
        #[doc = "Field `FIFO` reader - RW, TMR2 current count"]
        pub type FifoR = crate::FieldReader<u32>;
        #[doc = "Field `FIFO` writer - RW, TMR2 current count"]
        pub type FifoW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW, TMR2 current count"]
            #[inline(always)]
            pub fn fifo(&self) -> FifoR {
                FifoR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW, TMR2 current count"]
            #[inline(always)]
            pub fn fifo(&mut self) -> FifoW<FifoSpec> {
                FifoW::new(self, 0)
            }
        }
        #[doc = "RO, TMR2 FIFO register, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fifo::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FifoSpec;
        impl crate::RegisterSpec for FifoSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`fifo::R`](R) reader structure"]
        impl crate::Readable for FifoSpec {}
        #[doc = "`write(|w| ..)` method takes [`fifo::W`](W) writer structure"]
        impl crate::Writable for FifoSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FIFO to value 0"]
        impl crate::Resettable for FifoSpec {}
    }
    #[doc = "DMA_NOW (r) register accessor: RO, TMR2 DMA current address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_now::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_now`] module"]
    #[doc(alias = "DMA_NOW")]
    pub type DmaNow = crate::Reg<dma_now::DmaNowSpec>;
    #[doc = "RO, TMR2 DMA current address"]
    pub mod dma_now {
        #[doc = "Register `DMA_NOW` reader"]
        pub type R = crate::R<DmaNowSpec>;
        #[doc = "Field `DMA_NOW` reader - RW, TMR2 current count"]
        pub type DmaNowR = crate::FieldReader<u16>;
        impl R {
            #[doc = "Bits 0:15 - RW, TMR2 current count"]
            #[inline(always)]
            pub fn dma_now(&self) -> DmaNowR {
                DmaNowR::new(self.bits)
            }
        }
        #[doc = "RO, TMR2 DMA current address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_now::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DmaNowSpec;
        impl crate::RegisterSpec for DmaNowSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`dma_now::R`](R) reader structure"]
        impl crate::Readable for DmaNowSpec {}
        #[doc = "`reset()` method sets DMA_NOW to value 0"]
        impl crate::Resettable for DmaNowSpec {}
    }
    #[doc = "DMA_BEG (rw) register accessor: RW, TMR2 DMA begin address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_beg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_beg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_beg`] module"]
    #[doc(alias = "DMA_BEG")]
    pub type DmaBeg = crate::Reg<dma_beg::DmaBegSpec>;
    #[doc = "RW, TMR2 DMA begin address"]
    pub mod dma_beg {
        #[doc = "Register `DMA_BEG` reader"]
        pub type R = crate::R<DmaBegSpec>;
        #[doc = "Register `DMA_BEG` writer"]
        pub type W = crate::W<DmaBegSpec>;
        #[doc = "Field `DMA_BEG` reader - RW, TMR2 DMA begin address"]
        pub type DmaBegR = crate::FieldReader<u16>;
        #[doc = "Field `DMA_BEG` writer - RW, TMR2 DMA begin address"]
        pub type DmaBegW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW, TMR2 DMA begin address"]
            #[inline(always)]
            pub fn dma_beg(&self) -> DmaBegR {
                DmaBegR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW, TMR2 DMA begin address"]
            #[inline(always)]
            pub fn dma_beg(&mut self) -> DmaBegW<DmaBegSpec> {
                DmaBegW::new(self, 0)
            }
        }
        #[doc = "RW, TMR2 DMA begin address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_beg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_beg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DmaBegSpec;
        impl crate::RegisterSpec for DmaBegSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`dma_beg::R`](R) reader structure"]
        impl crate::Readable for DmaBegSpec {}
        #[doc = "`write(|w| ..)` method takes [`dma_beg::W`](W) writer structure"]
        impl crate::Writable for DmaBegSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DMA_BEG to value 0"]
        impl crate::Resettable for DmaBegSpec {}
    }
    #[doc = "DMA_END (rw) register accessor: RW, TMR2 DMA end address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_end::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_end::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_end`] module"]
    #[doc(alias = "DMA_END")]
    pub type DmaEnd = crate::Reg<dma_end::DmaEndSpec>;
    #[doc = "RW, TMR2 DMA end address"]
    pub mod dma_end {
        #[doc = "Register `DMA_END` reader"]
        pub type R = crate::R<DmaEndSpec>;
        #[doc = "Register `DMA_END` writer"]
        pub type W = crate::W<DmaEndSpec>;
        #[doc = "Field `DMA_END` reader - RW, TMR2 DMA end address"]
        pub type DmaEndR = crate::FieldReader<u16>;
        #[doc = "Field `DMA_END` writer - RW, TMR2 DMA end address"]
        pub type DmaEndW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW, TMR2 DMA end address"]
            #[inline(always)]
            pub fn dma_end(&self) -> DmaEndR {
                DmaEndR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW, TMR2 DMA end address"]
            #[inline(always)]
            pub fn dma_end(&mut self) -> DmaEndW<DmaEndSpec> {
                DmaEndW::new(self, 0)
            }
        }
        #[doc = "RW, TMR2 DMA end address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_end::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_end::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DmaEndSpec;
        impl crate::RegisterSpec for DmaEndSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`dma_end::R`](R) reader structure"]
        impl crate::Readable for DmaEndSpec {}
        #[doc = "`write(|w| ..)` method takes [`dma_end::W`](W) writer structure"]
        impl crate::Writable for DmaEndSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DMA_END to value 0"]
        impl crate::Resettable for DmaEndSpec {}
    }
}
#[doc = "Timer3 register"]
pub type Tmr3 = crate::Periph<tmr3::RegisterBlock, 0x4000_2c00>;
impl core::fmt::Debug for Tmr3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tmr3").finish()
    }
}
#[doc = "Timer3 register"]
pub mod tmr3 {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        ctrl_mod: CtrlMod,
        _reserved1: [u8; 0x01],
        inter_en: InterEn,
        _reserved2: [u8; 0x03],
        int_flag: IntFlag,
        fifo_count: FifoCount,
        count: Count,
        cnt_end: CntEnd,
        fifo: Fifo,
    }
    impl RegisterBlock {
        #[doc = "0x00 - RW, TMR3 mode control"]
        #[inline(always)]
        pub const fn ctrl_mod(&self) -> &CtrlMod {
            &self.ctrl_mod
        }
        #[doc = "0x02 - RW, TMR3 interrupt enable"]
        #[inline(always)]
        pub const fn inter_en(&self) -> &InterEn {
            &self.inter_en
        }
        #[doc = "0x06 - RW1, TMR3 interrupt flag"]
        #[inline(always)]
        pub const fn int_flag(&self) -> &IntFlag {
            &self.int_flag
        }
        #[doc = "0x07 - RO, TMR3 FIFO count status"]
        #[inline(always)]
        pub const fn fifo_count(&self) -> &FifoCount {
            &self.fifo_count
        }
        #[doc = "0x08 - RO, TMR3 current count"]
        #[inline(always)]
        pub const fn count(&self) -> &Count {
            &self.count
        }
        #[doc = "0x0c - RW, TMR3 end count value, only low 26 bit"]
        #[inline(always)]
        pub const fn cnt_end(&self) -> &CntEnd {
            &self.cnt_end
        }
        #[doc = "0x10 - RO/WO, TMR3 FIFO register, only low 26 bit"]
        #[inline(always)]
        pub const fn fifo(&self) -> &Fifo {
            &self.fifo
        }
    }
    #[doc = "CTRL_MOD (rw) register accessor: RW, TMR3 mode control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl_mod`] module"]
    #[doc(alias = "CTRL_MOD")]
    pub type CtrlMod = crate::Reg<ctrl_mod::CtrlModSpec>;
    #[doc = "RW, TMR3 mode control"]
    pub mod ctrl_mod {
        #[doc = "Register `CTRL_MOD` reader"]
        pub type R = crate::R<CtrlModSpec>;
        #[doc = "Register `CTRL_MOD` writer"]
        pub type W = crate::W<CtrlModSpec>;
        #[doc = "Field `ODE_IN` reader - RW, timer in mode: 0=timer/PWM, 1=capture/count"]
        pub type OdeInR = crate::BitReader;
        #[doc = "Field `ODE_IN` writer - RW, timer in mode: 0=timer/PWM, 1=capture/count"]
        pub type OdeInW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LL_CLEAR` reader - RW, force clear timer FIFO and count"]
        pub type LlClearR = crate::BitReader;
        #[doc = "Field `LL_CLEAR` writer - RW, force clear timer FIFO and count"]
        pub type LlClearW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `OUNT_EN` reader - RW, timer count enable"]
        pub type OuntEnR = crate::BitReader;
        #[doc = "Field `OUNT_EN` writer - RW, timer count enable"]
        pub type OuntEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UT_EN` reader - RW, timer output enable"]
        pub type UtEnR = crate::BitReader;
        #[doc = "Field `UT_EN` writer - RW, timer output enable"]
        pub type UtEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UT_POLAR` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"]
        pub type UtPolarR = crate::BitReader;
        #[doc = "Field `UT_POLAR` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"]
        pub type UtPolarW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `AP_COUNT` reader - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"]
        pub type ApCountR = crate::BitReader;
        #[doc = "Field `AP_COUNT` writer - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"]
        pub type ApCountW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WM_REPEAT` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"]
        pub type WmRepeatR = crate::FieldReader;
        #[doc = "Field `WM_REPEAT` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"]
        pub type WmRepeatW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `AP_EDGE` reader - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"]
        pub type ApEdgeR = crate::FieldReader;
        #[doc = "Field `AP_EDGE` writer - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"]
        pub type ApEdgeW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            #[doc = "Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count"]
            #[inline(always)]
            pub fn ode_in(&self) -> OdeInR {
                OdeInR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, force clear timer FIFO and count"]
            #[inline(always)]
            pub fn ll_clear(&self) -> LlClearR {
                LlClearR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW, timer count enable"]
            #[inline(always)]
            pub fn ount_en(&self) -> OuntEnR {
                OuntEnR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, timer output enable"]
            #[inline(always)]
            pub fn ut_en(&self) -> UtEnR {
                UtEnR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"]
            #[inline(always)]
            pub fn ut_polar(&self) -> UtPolarR {
                UtPolarR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"]
            #[inline(always)]
            pub fn ap_count(&self) -> ApCountR {
                ApCountR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"]
            #[inline(always)]
            pub fn wm_repeat(&self) -> WmRepeatR {
                WmRepeatR::new((self.bits >> 6) & 3)
            }
            #[doc = "Bits 6:7 - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"]
            #[inline(always)]
            pub fn ap_edge(&self) -> ApEdgeR {
                ApEdgeR::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count"]
            #[inline(always)]
            pub fn ode_in(&mut self) -> OdeInW<CtrlModSpec> {
                OdeInW::new(self, 0)
            }
            #[doc = "Bit 1 - RW, force clear timer FIFO and count"]
            #[inline(always)]
            pub fn ll_clear(&mut self) -> LlClearW<CtrlModSpec> {
                LlClearW::new(self, 1)
            }
            #[doc = "Bit 2 - RW, timer count enable"]
            #[inline(always)]
            pub fn ount_en(&mut self) -> OuntEnW<CtrlModSpec> {
                OuntEnW::new(self, 2)
            }
            #[doc = "Bit 3 - RW, timer output enable"]
            #[inline(always)]
            pub fn ut_en(&mut self) -> UtEnW<CtrlModSpec> {
                UtEnW::new(self, 3)
            }
            #[doc = "Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"]
            #[inline(always)]
            pub fn ut_polar(&mut self) -> UtPolarW<CtrlModSpec> {
                UtPolarW::new(self, 4)
            }
            #[doc = "Bit 4 - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"]
            #[inline(always)]
            pub fn ap_count(&mut self) -> ApCountW<CtrlModSpec> {
                ApCountW::new(self, 4)
            }
            #[doc = "Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"]
            #[inline(always)]
            pub fn wm_repeat(&mut self) -> WmRepeatW<CtrlModSpec> {
                WmRepeatW::new(self, 6)
            }
            #[doc = "Bits 6:7 - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"]
            #[inline(always)]
            pub fn ap_edge(&mut self) -> ApEdgeW<CtrlModSpec> {
                ApEdgeW::new(self, 6)
            }
        }
        #[doc = "RW, TMR3 mode control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CtrlModSpec;
        impl crate::RegisterSpec for CtrlModSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`ctrl_mod::R`](R) reader structure"]
        impl crate::Readable for CtrlModSpec {}
        #[doc = "`write(|w| ..)` method takes [`ctrl_mod::W`](W) writer structure"]
        impl crate::Writable for CtrlModSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CTRL_MOD to value 0x02"]
        impl crate::Resettable for CtrlModSpec {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    #[doc = "INTER_EN (rw) register accessor: RW, TMR3 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`inter_en::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inter_en::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@inter_en`] module"]
    #[doc(alias = "INTER_EN")]
    pub type InterEn = crate::Reg<inter_en::InterEnSpec>;
    #[doc = "RW, TMR3 interrupt enable"]
    pub mod inter_en {
        #[doc = "Register `INTER_EN` reader"]
        pub type R = crate::R<InterEnSpec>;
        #[doc = "Register `INTER_EN` writer"]
        pub type W = crate::W<InterEnSpec>;
        #[doc = "Field `E_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end"]
        pub type ECycEndR = crate::BitReader;
        #[doc = "Field `E_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end"]
        pub type ECycEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger"]
        pub type EDataActR = crate::BitReader;
        #[doc = "Field `E_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger"]
        pub type EDataActW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"]
        pub type EFifoHfR = crate::BitReader;
        #[doc = "Field `E_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"]
        pub type EFifoHfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion"]
        pub type EDmaEndR = crate::BitReader;
        #[doc = "Field `E_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion"]
        pub type EDmaEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow"]
        pub type EFifoOvR = crate::BitReader;
        #[doc = "Field `E_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow"]
        pub type EFifoOvW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end"]
            #[inline(always)]
            pub fn e_cyc_end(&self) -> ECycEndR {
                ECycEndR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger"]
            #[inline(always)]
            pub fn e_data_act(&self) -> EDataActR {
                EDataActR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"]
            #[inline(always)]
            pub fn e_fifo_hf(&self) -> EFifoHfR {
                EFifoHfR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, enable interrupt for timer1/2 DMA completion"]
            #[inline(always)]
            pub fn e_dma_end(&self) -> EDmaEndR {
                EDmaEndR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, enable interrupt for timer FIFO overflow"]
            #[inline(always)]
            pub fn e_fifo_ov(&self) -> EFifoOvR {
                EFifoOvR::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end"]
            #[inline(always)]
            pub fn e_cyc_end(&mut self) -> ECycEndW<InterEnSpec> {
                ECycEndW::new(self, 0)
            }
            #[doc = "Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger"]
            #[inline(always)]
            pub fn e_data_act(&mut self) -> EDataActW<InterEnSpec> {
                EDataActW::new(self, 1)
            }
            #[doc = "Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"]
            #[inline(always)]
            pub fn e_fifo_hf(&mut self) -> EFifoHfW<InterEnSpec> {
                EFifoHfW::new(self, 2)
            }
            #[doc = "Bit 3 - RW, enable interrupt for timer1/2 DMA completion"]
            #[inline(always)]
            pub fn e_dma_end(&mut self) -> EDmaEndW<InterEnSpec> {
                EDmaEndW::new(self, 3)
            }
            #[doc = "Bit 4 - RW, enable interrupt for timer FIFO overflow"]
            #[inline(always)]
            pub fn e_fifo_ov(&mut self) -> EFifoOvW<InterEnSpec> {
                EFifoOvW::new(self, 4)
            }
        }
        #[doc = "RW, TMR3 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`inter_en::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inter_en::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct InterEnSpec;
        impl crate::RegisterSpec for InterEnSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`inter_en::R`](R) reader structure"]
        impl crate::Readable for InterEnSpec {}
        #[doc = "`write(|w| ..)` method takes [`inter_en::W`](W) writer structure"]
        impl crate::Writable for InterEnSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets INTER_EN to value 0"]
        impl crate::Resettable for InterEnSpec {}
    }
    #[doc = "INT_FLAG (rw) register accessor: RW1, TMR3 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_flag`] module"]
    #[doc(alias = "INT_FLAG")]
    pub type IntFlag = crate::Reg<int_flag::IntFlagSpec>;
    #[doc = "RW1, TMR3 interrupt flag"]
    pub mod int_flag {
        #[doc = "Register `INT_FLAG` reader"]
        pub type R = crate::R<IntFlagSpec>;
        #[doc = "Register `INT_FLAG` writer"]
        pub type W = crate::W<IntFlagSpec>;
        #[doc = "Field `F_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end"]
        pub type FCycEndR = crate::BitReader;
        #[doc = "Field `F_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end"]
        pub type FCycEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger"]
        pub type FDataActR = crate::BitReader;
        #[doc = "Field `F_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger"]
        pub type FDataActW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"]
        pub type FFifoHfR = crate::BitReader;
        #[doc = "Field `F_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"]
        pub type FFifoHfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion"]
        pub type FDmaEndR = crate::BitReader;
        #[doc = "Field `F_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion"]
        pub type FDmaEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow"]
        pub type FFifoOvR = crate::BitReader;
        #[doc = "Field `F_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow"]
        pub type FFifoOvW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end"]
            #[inline(always)]
            pub fn f_cyc_end(&self) -> FCycEndR {
                FCycEndR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger"]
            #[inline(always)]
            pub fn f_data_act(&self) -> FDataActR {
                FDataActR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"]
            #[inline(always)]
            pub fn f_fifo_hf(&self) -> FFifoHfR {
                FFifoHfR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW1, interrupt flag for timer1/2 DMA completion"]
            #[inline(always)]
            pub fn f_dma_end(&self) -> FDmaEndR {
                FDmaEndR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW1, interrupt flag for timer FIFO overflow"]
            #[inline(always)]
            pub fn f_fifo_ov(&self) -> FFifoOvR {
                FFifoOvR::new(((self.bits >> 4) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end"]
            #[inline(always)]
            pub fn f_cyc_end(&mut self) -> FCycEndW<IntFlagSpec> {
                FCycEndW::new(self, 0)
            }
            #[doc = "Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger"]
            #[inline(always)]
            pub fn f_data_act(&mut self) -> FDataActW<IntFlagSpec> {
                FDataActW::new(self, 1)
            }
            #[doc = "Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"]
            #[inline(always)]
            pub fn f_fifo_hf(&mut self) -> FFifoHfW<IntFlagSpec> {
                FFifoHfW::new(self, 2)
            }
            #[doc = "Bit 3 - RW1, interrupt flag for timer1/2 DMA completion"]
            #[inline(always)]
            pub fn f_dma_end(&mut self) -> FDmaEndW<IntFlagSpec> {
                FDmaEndW::new(self, 3)
            }
            #[doc = "Bit 4 - RW1, interrupt flag for timer FIFO overflow"]
            #[inline(always)]
            pub fn f_fifo_ov(&mut self) -> FFifoOvW<IntFlagSpec> {
                FFifoOvW::new(self, 4)
            }
        }
        #[doc = "RW1, TMR3 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IntFlagSpec;
        impl crate::RegisterSpec for IntFlagSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`int_flag::R`](R) reader structure"]
        impl crate::Readable for IntFlagSpec {}
        #[doc = "`write(|w| ..)` method takes [`int_flag::W`](W) writer structure"]
        impl crate::Writable for IntFlagSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets INT_FLAG to value 0"]
        impl crate::Resettable for IntFlagSpec {}
    }
    #[doc = "FIFO_COUNT (r) register accessor: RO, TMR3 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo_count`] module"]
    #[doc(alias = "FIFO_COUNT")]
    pub type FifoCount = crate::Reg<fifo_count::FifoCountSpec>;
    #[doc = "RO, TMR3 FIFO count status"]
    pub mod fifo_count {
        #[doc = "Register `FIFO_COUNT` reader"]
        pub type R = crate::R<FifoCountSpec>;
        #[doc = "Field `FIFO_COUNT` reader - R0, TMR3 FIFO count status"]
        pub type FifoCountR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - R0, TMR3 FIFO count status"]
            #[inline(always)]
            pub fn fifo_count(&self) -> FifoCountR {
                FifoCountR::new(self.bits)
            }
        }
        #[doc = "RO, TMR3 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FifoCountSpec;
        impl crate::RegisterSpec for FifoCountSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`fifo_count::R`](R) reader structure"]
        impl crate::Readable for FifoCountSpec {}
        #[doc = "`reset()` method sets FIFO_COUNT to value 0"]
        impl crate::Resettable for FifoCountSpec {}
    }
    #[doc = "COUNT (r) register accessor: RO, TMR3 current count\n\nYou can [`read`](crate::Reg::read) this register and get [`count::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count`] module"]
    #[doc(alias = "COUNT")]
    pub type Count = crate::Reg<count::CountSpec>;
    #[doc = "RO, TMR3 current count"]
    pub mod count {
        #[doc = "Register `COUNT` reader"]
        pub type R = crate::R<CountSpec>;
        #[doc = "Field `COUNT` reader - R0, TMR3 current count"]
        pub type CountR = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 0:31 - R0, TMR3 current count"]
            #[inline(always)]
            pub fn count(&self) -> CountR {
                CountR::new(self.bits)
            }
        }
        #[doc = "RO, TMR3 current count\n\nYou can [`read`](crate::Reg::read) this register and get [`count::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CountSpec;
        impl crate::RegisterSpec for CountSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`count::R`](R) reader structure"]
        impl crate::Readable for CountSpec {}
        #[doc = "`reset()` method sets COUNT to value 0"]
        impl crate::Resettable for CountSpec {}
    }
    #[doc = "CNT_END (rw) register accessor: RW, TMR3 end count value, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt_end::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt_end::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt_end`] module"]
    #[doc(alias = "CNT_END")]
    pub type CntEnd = crate::Reg<cnt_end::CntEndSpec>;
    #[doc = "RW, TMR3 end count value, only low 26 bit"]
    pub mod cnt_end {
        #[doc = "Register `CNT_END` reader"]
        pub type R = crate::R<CntEndSpec>;
        #[doc = "Register `CNT_END` writer"]
        pub type W = crate::W<CntEndSpec>;
        #[doc = "Field `CNT_END` reader - RW, TMR3 end count value, only low 26 bit"]
        pub type CntEndR = crate::FieldReader<u32>;
        #[doc = "Field `CNT_END` writer - RW, TMR3 end count value, only low 26 bit"]
        pub type CntEndW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW, TMR3 end count value, only low 26 bit"]
            #[inline(always)]
            pub fn cnt_end(&self) -> CntEndR {
                CntEndR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW, TMR3 end count value, only low 26 bit"]
            #[inline(always)]
            pub fn cnt_end(&mut self) -> CntEndW<CntEndSpec> {
                CntEndW::new(self, 0)
            }
        }
        #[doc = "RW, TMR3 end count value, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt_end::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt_end::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CntEndSpec;
        impl crate::RegisterSpec for CntEndSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`cnt_end::R`](R) reader structure"]
        impl crate::Readable for CntEndSpec {}
        #[doc = "`write(|w| ..)` method takes [`cnt_end::W`](W) writer structure"]
        impl crate::Writable for CntEndSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CNT_END to value 0"]
        impl crate::Resettable for CntEndSpec {}
    }
    #[doc = "FIFO (rw) register accessor: RO/WO, TMR3 FIFO register, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fifo::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo`] module"]
    #[doc(alias = "FIFO")]
    pub type Fifo = crate::Reg<fifo::FifoSpec>;
    #[doc = "RO/WO, TMR3 FIFO register, only low 26 bit"]
    pub mod fifo {
        #[doc = "Register `FIFO` reader"]
        pub type R = crate::R<FifoSpec>;
        #[doc = "Register `FIFO` writer"]
        pub type W = crate::W<FifoSpec>;
        #[doc = "Field `FIFO` reader - RO/WO, TMR3 FIFO register, only low 26 bit"]
        pub type FifoR = crate::FieldReader<u32>;
        #[doc = "Field `FIFO` writer - RO/WO, TMR3 FIFO register, only low 26 bit"]
        pub type FifoW<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RO/WO, TMR3 FIFO register, only low 26 bit"]
            #[inline(always)]
            pub fn fifo(&self) -> FifoR {
                FifoR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RO/WO, TMR3 FIFO register, only low 26 bit"]
            #[inline(always)]
            pub fn fifo(&mut self) -> FifoW<FifoSpec> {
                FifoW::new(self, 0)
            }
        }
        #[doc = "RO/WO, TMR3 FIFO register, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fifo::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FifoSpec;
        impl crate::RegisterSpec for FifoSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`fifo::R`](R) reader structure"]
        impl crate::Readable for FifoSpec {}
        #[doc = "`write(|w| ..)` method takes [`fifo::W`](W) writer structure"]
        impl crate::Writable for FifoSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FIFO to value 0"]
        impl crate::Resettable for FifoSpec {}
    }
}
#[doc = "UART0 register"]
pub type Uart0 = crate::Periph<uart0::RegisterBlock, 0x4000_3000>;
impl core::fmt::Debug for Uart0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart0").finish()
    }
}
#[doc = "UART0 register"]
pub mod uart0 {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        mcr: Mcr,
        ier: Ier,
        fcr: Fcr,
        lcr: Lcr,
        iir: Iir,
        lsr: Lsr,
        msr: Msr,
        _reserved7: [u8; 0x01],
        _reserved_7_rbr: [u8; 0x01],
        _reserved8: [u8; 0x01],
        rfc: Rfc,
        tfc: Tfc,
        dl: Dl,
        div: Div,
        adr: Adr,
    }
    impl RegisterBlock {
        #[doc = "0x00 - RW, UART0 modem control"]
        #[inline(always)]
        pub const fn mcr(&self) -> &Mcr {
            &self.mcr
        }
        #[doc = "0x01 - RW, UART0 interrupt enable"]
        #[inline(always)]
        pub const fn ier(&self) -> &Ier {
            &self.ier
        }
        #[doc = "0x02 - RW, UART0 FIFO control"]
        #[inline(always)]
        pub const fn fcr(&self) -> &Fcr {
            &self.fcr
        }
        #[doc = "0x03 - RW, UART0 line control"]
        #[inline(always)]
        pub const fn lcr(&self) -> &Lcr {
            &self.lcr
        }
        #[doc = "0x04 - RO, UART0 interrupt identification"]
        #[inline(always)]
        pub const fn iir(&self) -> &Iir {
            &self.iir
        }
        #[doc = "0x05 - RO, UART0 line status"]
        #[inline(always)]
        pub const fn lsr(&self) -> &Lsr {
            &self.lsr
        }
        #[doc = "0x06 - RO, UART0 modem status"]
        #[inline(always)]
        pub const fn msr(&self) -> &Msr {
            &self.msr
        }
        #[doc = "0x08 - WO, UART0 transmitter holding, transmittal byte"]
        #[inline(always)]
        pub const fn thr(&self) -> &Thr {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(8).cast() }
        }
        #[doc = "0x08 - RO, UART0 receiver buffer, receiving byte"]
        #[inline(always)]
        pub const fn rbr(&self) -> &Rbr {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(8).cast() }
        }
        #[doc = "0x0a - RO, UART0 receiver FIFO count"]
        #[inline(always)]
        pub const fn rfc(&self) -> &Rfc {
            &self.rfc
        }
        #[doc = "0x0b - RO, UART0 transmitter FIFO count"]
        #[inline(always)]
        pub const fn tfc(&self) -> &Tfc {
            &self.tfc
        }
        #[doc = "0x0c - RW, UART0 divisor latch"]
        #[inline(always)]
        pub const fn dl(&self) -> &Dl {
            &self.dl
        }
        #[doc = "0x0e - RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128"]
        #[inline(always)]
        pub const fn div(&self) -> &Div {
            &self.div
        }
        #[doc = "0x0f - RW, UART0 slave address: 0xFF=disable, other=enable"]
        #[inline(always)]
        pub const fn adr(&self) -> &Adr {
            &self.adr
        }
    }
    #[doc = "MCR (rw) register accessor: RW, UART0 modem control\n\nYou can [`read`](crate::Reg::read) this register and get [`mcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mcr`] module"]
    #[doc(alias = "MCR")]
    pub type Mcr = crate::Reg<mcr::McrSpec>;
    #[doc = "RW, UART0 modem control"]
    pub mod mcr {
        #[doc = "Register `MCR` reader"]
        pub type R = crate::R<McrSpec>;
        #[doc = "Register `MCR` writer"]
        pub type W = crate::W<McrSpec>;
        #[doc = "Field `MCR_DTR` reader - RW, UART0 control DTR"]
        pub type McrDtrR = crate::BitReader;
        #[doc = "Field `MCR_DTR` writer - RW, UART0 control DTR"]
        pub type McrDtrW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MCR_RTS` reader - RW, UART0 control RTS"]
        pub type McrRtsR = crate::BitReader;
        #[doc = "Field `MCR_RTS` writer - RW, UART0 control RTS"]
        pub type McrRtsW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MCR_OUT1` reader - RW, UART0 control OUT1"]
        pub type McrOut1R = crate::BitReader;
        #[doc = "Field `MCR_OUT1` writer - RW, UART0 control OUT1"]
        pub type McrOut1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MCR_OUT2` reader - RW, UART control OUT2"]
        pub type McrOut2R = crate::BitReader;
        #[doc = "Field `MCR_OUT2` writer - RW, UART control OUT2"]
        pub type McrOut2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MCR_INT_OE` reader - RW, UART interrupt output enable"]
        pub type McrIntOeR = crate::BitReader;
        #[doc = "Field `MCR_INT_OE` writer - RW, UART interrupt output enable"]
        pub type McrIntOeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MCR_LOOP` reader - RW, UART0 enable local loop back"]
        pub type McrLoopR = crate::BitReader;
        #[doc = "Field `MCR_LOOP` writer - RW, UART0 enable local loop back"]
        pub type McrLoopW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MCR_AU_FLOW_EN` reader - RW, UART0 enable autoflow control"]
        pub type McrAuFlowEnR = crate::BitReader;
        #[doc = "Field `MCR_AU_FLOW_EN` writer - RW, UART0 enable autoflow control"]
        pub type McrAuFlowEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MCR_TNOW` reader - RW, UART0 enable TNOW output on DTR pin"]
        pub type McrTnowR = crate::BitReader;
        #[doc = "Field `MCR_TNOW` writer - RW, UART0 enable TNOW output on DTR pin"]
        pub type McrTnowW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MCR_HALF` reader - RW, UART0 enable half-duplex"]
        pub type McrHalfR = crate::BitReader;
        #[doc = "Field `MCR_HALF` writer - RW, UART0 enable half-duplex"]
        pub type McrHalfW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, UART0 control DTR"]
            #[inline(always)]
            pub fn mcr_dtr(&self) -> McrDtrR {
                McrDtrR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, UART0 control RTS"]
            #[inline(always)]
            pub fn mcr_rts(&self) -> McrRtsR {
                McrRtsR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW, UART0 control OUT1"]
            #[inline(always)]
            pub fn mcr_out1(&self) -> McrOut1R {
                McrOut1R::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, UART control OUT2"]
            #[inline(always)]
            pub fn mcr_out2(&self) -> McrOut2R {
                McrOut2R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, UART interrupt output enable"]
            #[inline(always)]
            pub fn mcr_int_oe(&self) -> McrIntOeR {
                McrIntOeR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, UART0 enable local loop back"]
            #[inline(always)]
            pub fn mcr_loop(&self) -> McrLoopR {
                McrLoopR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RW, UART0 enable autoflow control"]
            #[inline(always)]
            pub fn mcr_au_flow_en(&self) -> McrAuFlowEnR {
                McrAuFlowEnR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RW, UART0 enable TNOW output on DTR pin"]
            #[inline(always)]
            pub fn mcr_tnow(&self) -> McrTnowR {
                McrTnowR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RW, UART0 enable half-duplex"]
            #[inline(always)]
            pub fn mcr_half(&self) -> McrHalfR {
                McrHalfR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, UART0 control DTR"]
            #[inline(always)]
            pub fn mcr_dtr(&mut self) -> McrDtrW<McrSpec> {
                McrDtrW::new(self, 0)
            }
            #[doc = "Bit 1 - RW, UART0 control RTS"]
            #[inline(always)]
            pub fn mcr_rts(&mut self) -> McrRtsW<McrSpec> {
                McrRtsW::new(self, 1)
            }
            #[doc = "Bit 2 - RW, UART0 control OUT1"]
            #[inline(always)]
            pub fn mcr_out1(&mut self) -> McrOut1W<McrSpec> {
                McrOut1W::new(self, 2)
            }
            #[doc = "Bit 3 - RW, UART control OUT2"]
            #[inline(always)]
            pub fn mcr_out2(&mut self) -> McrOut2W<McrSpec> {
                McrOut2W::new(self, 3)
            }
            #[doc = "Bit 3 - RW, UART interrupt output enable"]
            #[inline(always)]
            pub fn mcr_int_oe(&mut self) -> McrIntOeW<McrSpec> {
                McrIntOeW::new(self, 3)
            }
            #[doc = "Bit 4 - RW, UART0 enable local loop back"]
            #[inline(always)]
            pub fn mcr_loop(&mut self) -> McrLoopW<McrSpec> {
                McrLoopW::new(self, 4)
            }
            #[doc = "Bit 5 - RW, UART0 enable autoflow control"]
            #[inline(always)]
            pub fn mcr_au_flow_en(&mut self) -> McrAuFlowEnW<McrSpec> {
                McrAuFlowEnW::new(self, 5)
            }
            #[doc = "Bit 6 - RW, UART0 enable TNOW output on DTR pin"]
            #[inline(always)]
            pub fn mcr_tnow(&mut self) -> McrTnowW<McrSpec> {
                McrTnowW::new(self, 6)
            }
            #[doc = "Bit 7 - RW, UART0 enable half-duplex"]
            #[inline(always)]
            pub fn mcr_half(&mut self) -> McrHalfW<McrSpec> {
                McrHalfW::new(self, 7)
            }
        }
        #[doc = "RW, UART0 modem control\n\nYou can [`read`](crate::Reg::read) this register and get [`mcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct McrSpec;
        impl crate::RegisterSpec for McrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`mcr::R`](R) reader structure"]
        impl crate::Readable for McrSpec {}
        #[doc = "`write(|w| ..)` method takes [`mcr::W`](W) writer structure"]
        impl crate::Writable for McrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets MCR to value 0"]
        impl crate::Resettable for McrSpec {}
    }
    #[doc = "IER (rw) register accessor: RW, UART0 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ier`] module"]
    #[doc(alias = "IER")]
    pub type Ier = crate::Reg<ier::IerSpec>;
    #[doc = "RW, UART0 interrupt enable"]
    pub mod ier {
        #[doc = "Register `IER` reader"]
        pub type R = crate::R<IerSpec>;
        #[doc = "Register `IER` writer"]
        pub type W = crate::W<IerSpec>;
        #[doc = "Field `IER_RECV_RDY` reader - RW, UART interrupt enable for receiver data ready"]
        pub type IerRecvRdyR = crate::BitReader;
        #[doc = "Field `IER_RECV_RDY` writer - RW, UART interrupt enable for receiver data ready"]
        pub type IerRecvRdyW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IER_THR_EMPTY` reader - RW, UART interrupt enable for THR empty"]
        pub type IerThrEmptyR = crate::BitReader;
        #[doc = "Field `IER_THR_EMPTY` writer - RW, UART interrupt enable for THR empty"]
        pub type IerThrEmptyW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IER_LINE_STAT` reader - RW, UART interrupt enable for receiver line status"]
        pub type IerLineStatR = crate::BitReader;
        #[doc = "Field `IER_LINE_STAT` writer - RW, UART interrupt enable for receiver line status"]
        pub type IerLineStatW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IER_MODEM_CHG` reader - RW, UART0 interrupt enable for modem status change"]
        pub type IerModemChgR = crate::BitReader;
        #[doc = "Field `IER_MODEM_CHG` writer - RW, UART0 interrupt enable for modem status change"]
        pub type IerModemChgW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IER_DTR_EN` reader - RW, UART0 DTR/TNOW output pin enable"]
        pub type IerDtrEnR = crate::BitReader;
        #[doc = "Field `IER_DTR_EN` writer - RW, UART0 DTR/TNOW output pin enable"]
        pub type IerDtrEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IER_RTS_EN` reader - RW, UART0 RTS output pin enable"]
        pub type IerRtsEnR = crate::BitReader;
        #[doc = "Field `IER_RTS_EN` writer - RW, UART0 RTS output pin enable"]
        pub type IerRtsEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IER_TXD_EN` reader - RW, UART TXD pin enable"]
        pub type IerTxdEnR = crate::BitReader;
        #[doc = "Field `IER_TXD_EN` writer - RW, UART TXD pin enable"]
        pub type IerTxdEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IER_RESET` reader - WZ, UART software reset control, high action, auto clear"]
        pub type IerResetR = crate::BitReader;
        #[doc = "Field `IER_RESET` writer - WZ, UART software reset control, high action, auto clear"]
        pub type IerResetW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, UART interrupt enable for receiver data ready"]
            #[inline(always)]
            pub fn ier_recv_rdy(&self) -> IerRecvRdyR {
                IerRecvRdyR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, UART interrupt enable for THR empty"]
            #[inline(always)]
            pub fn ier_thr_empty(&self) -> IerThrEmptyR {
                IerThrEmptyR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW, UART interrupt enable for receiver line status"]
            #[inline(always)]
            pub fn ier_line_stat(&self) -> IerLineStatR {
                IerLineStatR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, UART0 interrupt enable for modem status change"]
            #[inline(always)]
            pub fn ier_modem_chg(&self) -> IerModemChgR {
                IerModemChgR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, UART0 DTR/TNOW output pin enable"]
            #[inline(always)]
            pub fn ier_dtr_en(&self) -> IerDtrEnR {
                IerDtrEnR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RW, UART0 RTS output pin enable"]
            #[inline(always)]
            pub fn ier_rts_en(&self) -> IerRtsEnR {
                IerRtsEnR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RW, UART TXD pin enable"]
            #[inline(always)]
            pub fn ier_txd_en(&self) -> IerTxdEnR {
                IerTxdEnR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - WZ, UART software reset control, high action, auto clear"]
            #[inline(always)]
            pub fn ier_reset(&self) -> IerResetR {
                IerResetR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, UART interrupt enable for receiver data ready"]
            #[inline(always)]
            pub fn ier_recv_rdy(&mut self) -> IerRecvRdyW<IerSpec> {
                IerRecvRdyW::new(self, 0)
            }
            #[doc = "Bit 1 - RW, UART interrupt enable for THR empty"]
            #[inline(always)]
            pub fn ier_thr_empty(&mut self) -> IerThrEmptyW<IerSpec> {
                IerThrEmptyW::new(self, 1)
            }
            #[doc = "Bit 2 - RW, UART interrupt enable for receiver line status"]
            #[inline(always)]
            pub fn ier_line_stat(&mut self) -> IerLineStatW<IerSpec> {
                IerLineStatW::new(self, 2)
            }
            #[doc = "Bit 3 - RW, UART0 interrupt enable for modem status change"]
            #[inline(always)]
            pub fn ier_modem_chg(&mut self) -> IerModemChgW<IerSpec> {
                IerModemChgW::new(self, 3)
            }
            #[doc = "Bit 4 - RW, UART0 DTR/TNOW output pin enable"]
            #[inline(always)]
            pub fn ier_dtr_en(&mut self) -> IerDtrEnW<IerSpec> {
                IerDtrEnW::new(self, 4)
            }
            #[doc = "Bit 5 - RW, UART0 RTS output pin enable"]
            #[inline(always)]
            pub fn ier_rts_en(&mut self) -> IerRtsEnW<IerSpec> {
                IerRtsEnW::new(self, 5)
            }
            #[doc = "Bit 6 - RW, UART TXD pin enable"]
            #[inline(always)]
            pub fn ier_txd_en(&mut self) -> IerTxdEnW<IerSpec> {
                IerTxdEnW::new(self, 6)
            }
            #[doc = "Bit 7 - WZ, UART software reset control, high action, auto clear"]
            #[inline(always)]
            pub fn ier_reset(&mut self) -> IerResetW<IerSpec> {
                IerResetW::new(self, 7)
            }
        }
        #[doc = "RW, UART0 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IerSpec;
        impl crate::RegisterSpec for IerSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`ier::R`](R) reader structure"]
        impl crate::Readable for IerSpec {}
        #[doc = "`write(|w| ..)` method takes [`ier::W`](W) writer structure"]
        impl crate::Writable for IerSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IER to value 0"]
        impl crate::Resettable for IerSpec {}
    }
    #[doc = "FCR (rw) register accessor: RW, UART0 FIFO control\n\nYou can [`read`](crate::Reg::read) this register and get [`fcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fcr`] module"]
    #[doc(alias = "FCR")]
    pub type Fcr = crate::Reg<fcr::FcrSpec>;
    #[doc = "RW, UART0 FIFO control"]
    pub mod fcr {
        #[doc = "Register `FCR` reader"]
        pub type R = crate::R<FcrSpec>;
        #[doc = "Register `FCR` writer"]
        pub type W = crate::W<FcrSpec>;
        #[doc = "Field `FCR_FIFO_EN` reader - RW, UART FIFO enable"]
        pub type FcrFifoEnR = crate::BitReader;
        #[doc = "Field `FCR_FIFO_EN` writer - RW, UART FIFO enable"]
        pub type FcrFifoEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FCR_RX_FIFO_CLR` reader - WZ, clear UART receiver FIFO, high action, auto clear"]
        pub type FcrRxFifoClrR = crate::BitReader;
        #[doc = "Field `FCR_RX_FIFO_CLR` writer - WZ, clear UART receiver FIFO, high action, auto clear"]
        pub type FcrRxFifoClrW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FCR_TX_FIFO_CLR` reader - WZ, clear UART transmitter FIFO, high action, auto clear"]
        pub type FcrTxFifoClrR = crate::BitReader;
        #[doc = "Field `FCR_TX_FIFO_CLR` writer - WZ, clear UART transmitter FIFO, high action, auto clear"]
        pub type FcrTxFifoClrW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FCR_FIFO_TRIG` reader - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"]
        pub type FcrFifoTrigR = crate::FieldReader;
        #[doc = "Field `FCR_FIFO_TRIG` writer - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"]
        pub type FcrFifoTrigW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            #[doc = "Bit 0 - RW, UART FIFO enable"]
            #[inline(always)]
            pub fn fcr_fifo_en(&self) -> FcrFifoEnR {
                FcrFifoEnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear"]
            #[inline(always)]
            pub fn fcr_rx_fifo_clr(&self) -> FcrRxFifoClrR {
                FcrRxFifoClrR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear"]
            #[inline(always)]
            pub fn fcr_tx_fifo_clr(&self) -> FcrTxFifoClrR {
                FcrTxFifoClrR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"]
            #[inline(always)]
            pub fn fcr_fifo_trig(&self) -> FcrFifoTrigR {
                FcrFifoTrigR::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, UART FIFO enable"]
            #[inline(always)]
            pub fn fcr_fifo_en(&mut self) -> FcrFifoEnW<FcrSpec> {
                FcrFifoEnW::new(self, 0)
            }
            #[doc = "Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear"]
            #[inline(always)]
            pub fn fcr_rx_fifo_clr(&mut self) -> FcrRxFifoClrW<FcrSpec> {
                FcrRxFifoClrW::new(self, 1)
            }
            #[doc = "Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear"]
            #[inline(always)]
            pub fn fcr_tx_fifo_clr(&mut self) -> FcrTxFifoClrW<FcrSpec> {
                FcrTxFifoClrW::new(self, 2)
            }
            #[doc = "Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"]
            #[inline(always)]
            pub fn fcr_fifo_trig(&mut self) -> FcrFifoTrigW<FcrSpec> {
                FcrFifoTrigW::new(self, 6)
            }
        }
        #[doc = "RW, UART0 FIFO control\n\nYou can [`read`](crate::Reg::read) this register and get [`fcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FcrSpec;
        impl crate::RegisterSpec for FcrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`fcr::R`](R) reader structure"]
        impl crate::Readable for FcrSpec {}
        #[doc = "`write(|w| ..)` method takes [`fcr::W`](W) writer structure"]
        impl crate::Writable for FcrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FCR to value 0"]
        impl crate::Resettable for FcrSpec {}
    }
    #[doc = "LCR (rw) register accessor: RW, UART0 line control\n\nYou can [`read`](crate::Reg::read) this register and get [`lcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lcr`] module"]
    #[doc(alias = "LCR")]
    pub type Lcr = crate::Reg<lcr::LcrSpec>;
    #[doc = "RW, UART0 line control"]
    pub mod lcr {
        #[doc = "Register `LCR` reader"]
        pub type R = crate::R<LcrSpec>;
        #[doc = "Register `LCR` writer"]
        pub type W = crate::W<LcrSpec>;
        #[doc = "Field `LCR_WORD_SZ` reader - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"]
        pub type LcrWordSzR = crate::FieldReader;
        #[doc = "Field `LCR_WORD_SZ` writer - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"]
        pub type LcrWordSzW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `LCR_STOP_BIT` reader - RW, UART stop bit length: 0-1bit, 1-2bit"]
        pub type LcrStopBitR = crate::BitReader;
        #[doc = "Field `LCR_STOP_BIT` writer - RW, UART stop bit length: 0-1bit, 1-2bit"]
        pub type LcrStopBitW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LCR_PAR_EN` reader - RW, UART parity enable"]
        pub type LcrParEnR = crate::BitReader;
        #[doc = "Field `LCR_PAR_EN` writer - RW, UART parity enable"]
        pub type LcrParEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LCR_PAR_MOD` reader - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"]
        pub type LcrParModR = crate::FieldReader;
        #[doc = "Field `LCR_PAR_MOD` writer - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"]
        pub type LcrParModW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `LCR_BREAK_EN` reader - RW, UART break control enable"]
        pub type LcrBreakEnR = crate::BitReader;
        #[doc = "Field `LCR_BREAK_EN` writer - RW, UART break control enable"]
        pub type LcrBreakEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LCR_GP_BIT` reader - RW, UART general purpose bit"]
        pub type LcrGpBitR = crate::BitReader;
        #[doc = "Field `LCR_GP_BIT` writer - RW, UART general purpose bit"]
        pub type LcrGpBitW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LCR_DLAB` reader - RW, UART reserved bit"]
        pub type LcrDlabR = crate::BitReader;
        #[doc = "Field `LCR_DLAB` writer - RW, UART reserved bit"]
        pub type LcrDlabW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"]
            #[inline(always)]
            pub fn lcr_word_sz(&self) -> LcrWordSzR {
                LcrWordSzR::new(self.bits & 3)
            }
            #[doc = "Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit"]
            #[inline(always)]
            pub fn lcr_stop_bit(&self) -> LcrStopBitR {
                LcrStopBitR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, UART parity enable"]
            #[inline(always)]
            pub fn lcr_par_en(&self) -> LcrParEnR {
                LcrParEnR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"]
            #[inline(always)]
            pub fn lcr_par_mod(&self) -> LcrParModR {
                LcrParModR::new((self.bits >> 4) & 3)
            }
            #[doc = "Bit 6 - RW, UART break control enable"]
            #[inline(always)]
            pub fn lcr_break_en(&self) -> LcrBreakEnR {
                LcrBreakEnR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RW, UART general purpose bit"]
            #[inline(always)]
            pub fn lcr_gp_bit(&self) -> LcrGpBitR {
                LcrGpBitR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 7 - RW, UART reserved bit"]
            #[inline(always)]
            pub fn lcr_dlab(&self) -> LcrDlabR {
                LcrDlabR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"]
            #[inline(always)]
            pub fn lcr_word_sz(&mut self) -> LcrWordSzW<LcrSpec> {
                LcrWordSzW::new(self, 0)
            }
            #[doc = "Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit"]
            #[inline(always)]
            pub fn lcr_stop_bit(&mut self) -> LcrStopBitW<LcrSpec> {
                LcrStopBitW::new(self, 2)
            }
            #[doc = "Bit 3 - RW, UART parity enable"]
            #[inline(always)]
            pub fn lcr_par_en(&mut self) -> LcrParEnW<LcrSpec> {
                LcrParEnW::new(self, 3)
            }
            #[doc = "Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"]
            #[inline(always)]
            pub fn lcr_par_mod(&mut self) -> LcrParModW<LcrSpec> {
                LcrParModW::new(self, 4)
            }
            #[doc = "Bit 6 - RW, UART break control enable"]
            #[inline(always)]
            pub fn lcr_break_en(&mut self) -> LcrBreakEnW<LcrSpec> {
                LcrBreakEnW::new(self, 6)
            }
            #[doc = "Bit 7 - RW, UART general purpose bit"]
            #[inline(always)]
            pub fn lcr_gp_bit(&mut self) -> LcrGpBitW<LcrSpec> {
                LcrGpBitW::new(self, 7)
            }
            #[doc = "Bit 7 - RW, UART reserved bit"]
            #[inline(always)]
            pub fn lcr_dlab(&mut self) -> LcrDlabW<LcrSpec> {
                LcrDlabW::new(self, 7)
            }
        }
        #[doc = "RW, UART0 line control\n\nYou can [`read`](crate::Reg::read) this register and get [`lcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct LcrSpec;
        impl crate::RegisterSpec for LcrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`lcr::R`](R) reader structure"]
        impl crate::Readable for LcrSpec {}
        #[doc = "`write(|w| ..)` method takes [`lcr::W`](W) writer structure"]
        impl crate::Writable for LcrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets LCR to value 0"]
        impl crate::Resettable for LcrSpec {}
    }
    #[doc = "IIR (r) register accessor: RO, UART0 interrupt identification\n\nYou can [`read`](crate::Reg::read) this register and get [`iir::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iir`] module"]
    #[doc(alias = "IIR")]
    pub type Iir = crate::Reg<iir::IirSpec>;
    #[doc = "RO, UART0 interrupt identification"]
    pub mod iir {
        #[doc = "Register `IIR` reader"]
        pub type R = crate::R<IirSpec>;
        #[doc = "Field `IIR_NO_INT` reader - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt"]
        pub type IirNoIntR = crate::BitReader;
        #[doc = "Field `IIR_INT_MASK` reader - RO, UART interrupt flag bit mask"]
        pub type IirIntMaskR = crate::FieldReader;
        #[doc = "Field `IIR_FIFO_ID` reader - RO, UART FIFO enabled flag"]
        pub type IirFifoIdR = crate::FieldReader;
        impl R {
            #[doc = "Bit 0 - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt"]
            #[inline(always)]
            pub fn iir_no_int(&self) -> IirNoIntR {
                IirNoIntR::new((self.bits & 1) != 0)
            }
            #[doc = "Bits 0:3 - RO, UART interrupt flag bit mask"]
            #[inline(always)]
            pub fn iir_int_mask(&self) -> IirIntMaskR {
                IirIntMaskR::new(self.bits & 0x0f)
            }
            #[doc = "Bits 6:7 - RO, UART FIFO enabled flag"]
            #[inline(always)]
            pub fn iir_fifo_id(&self) -> IirFifoIdR {
                IirFifoIdR::new((self.bits >> 6) & 3)
            }
        }
        #[doc = "RO, UART0 interrupt identification\n\nYou can [`read`](crate::Reg::read) this register and get [`iir::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IirSpec;
        impl crate::RegisterSpec for IirSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`iir::R`](R) reader structure"]
        impl crate::Readable for IirSpec {}
        #[doc = "`reset()` method sets IIR to value 0x01"]
        impl crate::Resettable for IirSpec {
            const RESET_VALUE: u8 = 0x01;
        }
    }
    #[doc = "LSR (r) register accessor: RO, UART0 line status\n\nYou can [`read`](crate::Reg::read) this register and get [`lsr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lsr`] module"]
    #[doc(alias = "LSR")]
    pub type Lsr = crate::Reg<lsr::LsrSpec>;
    #[doc = "RO, UART0 line status"]
    pub mod lsr {
        #[doc = "Register `LSR` reader"]
        pub type R = crate::R<LsrSpec>;
        #[doc = "Field `LSR_DATA_RDY` reader - RO, UART receiver fifo data ready status"]
        pub type LsrDataRdyR = crate::BitReader;
        #[doc = "Field `LSR_OVER_ERR` reader - RZ, UART receiver overrun error"]
        pub type LsrOverErrR = crate::BitReader;
        #[doc = "Field `LSR_PAR_ERR` reader - RZ, UART receiver parity error"]
        pub type LsrParErrR = crate::BitReader;
        #[doc = "Field `LSR_FRAME_ERR` reader - RZ, UART receiver frame error"]
        pub type LsrFrameErrR = crate::BitReader;
        #[doc = "Field `LSR_BREAK_ERR` reader - RZ, UART receiver break error"]
        pub type LsrBreakErrR = crate::BitReader;
        #[doc = "Field `LSR_TX_FIFO_EMP` reader - RO, UART transmitter fifo empty status"]
        pub type LsrTxFifoEmpR = crate::BitReader;
        #[doc = "Field `LSR_TX_ALL_EMP` reader - RO, UART transmitter all empty status"]
        pub type LsrTxAllEmpR = crate::BitReader;
        #[doc = "Field `LSR_ERR_RX_FIFO` reader - RO, indicate error in UART receiver fifo"]
        pub type LsrErrRxFifoR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - RO, UART receiver fifo data ready status"]
            #[inline(always)]
            pub fn lsr_data_rdy(&self) -> LsrDataRdyR {
                LsrDataRdyR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RZ, UART receiver overrun error"]
            #[inline(always)]
            pub fn lsr_over_err(&self) -> LsrOverErrR {
                LsrOverErrR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RZ, UART receiver parity error"]
            #[inline(always)]
            pub fn lsr_par_err(&self) -> LsrParErrR {
                LsrParErrR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RZ, UART receiver frame error"]
            #[inline(always)]
            pub fn lsr_frame_err(&self) -> LsrFrameErrR {
                LsrFrameErrR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RZ, UART receiver break error"]
            #[inline(always)]
            pub fn lsr_break_err(&self) -> LsrBreakErrR {
                LsrBreakErrR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RO, UART transmitter fifo empty status"]
            #[inline(always)]
            pub fn lsr_tx_fifo_emp(&self) -> LsrTxFifoEmpR {
                LsrTxFifoEmpR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RO, UART transmitter all empty status"]
            #[inline(always)]
            pub fn lsr_tx_all_emp(&self) -> LsrTxAllEmpR {
                LsrTxAllEmpR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RO, indicate error in UART receiver fifo"]
            #[inline(always)]
            pub fn lsr_err_rx_fifo(&self) -> LsrErrRxFifoR {
                LsrErrRxFifoR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        #[doc = "RO, UART0 line status\n\nYou can [`read`](crate::Reg::read) this register and get [`lsr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct LsrSpec;
        impl crate::RegisterSpec for LsrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`lsr::R`](R) reader structure"]
        impl crate::Readable for LsrSpec {}
        #[doc = "`reset()` method sets LSR to value 0x60"]
        impl crate::Resettable for LsrSpec {
            const RESET_VALUE: u8 = 0x60;
        }
    }
    #[doc = "MSR (r) register accessor: RO, UART0 modem status\n\nYou can [`read`](crate::Reg::read) this register and get [`msr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@msr`] module"]
    #[doc(alias = "MSR")]
    pub type Msr = crate::Reg<msr::MsrSpec>;
    #[doc = "RO, UART0 modem status"]
    pub mod msr {
        #[doc = "Register `MSR` reader"]
        pub type R = crate::R<MsrSpec>;
        #[doc = "Field `MSR_CTS_CHG` reader - RZ, UART0 CTS changed status, high action"]
        pub type MsrCtsChgR = crate::BitReader;
        #[doc = "Field `MSR_DSR_CHG` reader - RZ, UART0 DSR changed status, high action"]
        pub type MsrDsrChgR = crate::BitReader;
        #[doc = "Field `MSR_RI_CHG` reader - RZ, UART0 RI changed status, high action"]
        pub type MsrRiChgR = crate::BitReader;
        #[doc = "Field `MSR_DCD_CHG` reader - RZ, UART0 DCD changed status, high action"]
        pub type MsrDcdChgR = crate::BitReader;
        #[doc = "Field `MSR_CTS` reader - RO, UART0 CTS action status"]
        pub type MsrCtsR = crate::BitReader;
        #[doc = "Field `MSR_DSR` reader - RO, UART0 DSR action statusv"]
        pub type MsrDsrR = crate::BitReader;
        #[doc = "Field `MSR_RI` reader - RO, UART0 RI action status"]
        pub type MsrRiR = crate::BitReader;
        #[doc = "Field `MSR_DCD` reader - RO, UART0 DCD action status"]
        pub type MsrDcdR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - RZ, UART0 CTS changed status, high action"]
            #[inline(always)]
            pub fn msr_cts_chg(&self) -> MsrCtsChgR {
                MsrCtsChgR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RZ, UART0 DSR changed status, high action"]
            #[inline(always)]
            pub fn msr_dsr_chg(&self) -> MsrDsrChgR {
                MsrDsrChgR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RZ, UART0 RI changed status, high action"]
            #[inline(always)]
            pub fn msr_ri_chg(&self) -> MsrRiChgR {
                MsrRiChgR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RZ, UART0 DCD changed status, high action"]
            #[inline(always)]
            pub fn msr_dcd_chg(&self) -> MsrDcdChgR {
                MsrDcdChgR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RO, UART0 CTS action status"]
            #[inline(always)]
            pub fn msr_cts(&self) -> MsrCtsR {
                MsrCtsR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RO, UART0 DSR action statusv"]
            #[inline(always)]
            pub fn msr_dsr(&self) -> MsrDsrR {
                MsrDsrR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RO, UART0 RI action status"]
            #[inline(always)]
            pub fn msr_ri(&self) -> MsrRiR {
                MsrRiR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RO, UART0 DCD action status"]
            #[inline(always)]
            pub fn msr_dcd(&self) -> MsrDcdR {
                MsrDcdR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        #[doc = "RO, UART0 modem status\n\nYou can [`read`](crate::Reg::read) this register and get [`msr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct MsrSpec;
        impl crate::RegisterSpec for MsrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`msr::R`](R) reader structure"]
        impl crate::Readable for MsrSpec {}
        #[doc = "`reset()` method sets MSR to value 0"]
        impl crate::Resettable for MsrSpec {}
    }
    #[doc = "RBR (r) register accessor: RO, UART0 receiver buffer, receiving byte\n\nYou can [`read`](crate::Reg::read) this register and get [`rbr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rbr`] module"]
    #[doc(alias = "RBR")]
    pub type Rbr = crate::Reg<rbr::RbrSpec>;
    #[doc = "RO, UART0 receiver buffer, receiving byte"]
    pub mod rbr {
        #[doc = "Register `RBR` reader"]
        pub type R = crate::R<RbrSpec>;
        #[doc = "Field `RBR` reader - RO, UART0 receiver buffer, receiving byte"]
        pub type RbrR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RO, UART0 receiver buffer, receiving byte"]
            #[inline(always)]
            pub fn rbr(&self) -> RbrR {
                RbrR::new(self.bits)
            }
        }
        #[doc = "RO, UART0 receiver buffer, receiving byte\n\nYou can [`read`](crate::Reg::read) this register and get [`rbr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RbrSpec;
        impl crate::RegisterSpec for RbrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`rbr::R`](R) reader structure"]
        impl crate::Readable for RbrSpec {}
        #[doc = "`reset()` method sets RBR to value 0"]
        impl crate::Resettable for RbrSpec {}
    }
    #[doc = "THR (w) register accessor: WO, UART0 transmitter holding, transmittal byte\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`thr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@thr`] module"]
    #[doc(alias = "THR")]
    pub type Thr = crate::Reg<thr::ThrSpec>;
    #[doc = "WO, UART0 transmitter holding, transmittal byte"]
    pub mod thr {
        #[doc = "Register `THR` writer"]
        pub type W = crate::W<ThrSpec>;
        #[doc = "Field `THR` writer - RO, UART0 transmitter holding, transmittal byte"]
        pub type ThrW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl W {
            #[doc = "Bits 0:7 - RO, UART0 transmitter holding, transmittal byte"]
            #[inline(always)]
            pub fn thr(&mut self) -> ThrW<ThrSpec> {
                ThrW::new(self, 0)
            }
        }
        #[doc = "WO, UART0 transmitter holding, transmittal byte\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`thr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ThrSpec;
        impl crate::RegisterSpec for ThrSpec {
            type Ux = u8;
        }
        #[doc = "`write(|w| ..)` method takes [`thr::W`](W) writer structure"]
        impl crate::Writable for ThrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets THR to value 0"]
        impl crate::Resettable for ThrSpec {}
    }
    #[doc = "RFC (r) register accessor: RO, UART0 receiver FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`rfc::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rfc`] module"]
    #[doc(alias = "RFC")]
    pub type Rfc = crate::Reg<rfc::RfcSpec>;
    #[doc = "RO, UART0 receiver FIFO count"]
    pub mod rfc {
        #[doc = "Register `RFC` reader"]
        pub type R = crate::R<RfcSpec>;
        #[doc = "Field `RFC` reader - RO, UART0 receiver FIFO count"]
        pub type RfcR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RO, UART0 receiver FIFO count"]
            #[inline(always)]
            pub fn rfc(&self) -> RfcR {
                RfcR::new(self.bits)
            }
        }
        #[doc = "RO, UART0 receiver FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`rfc::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RfcSpec;
        impl crate::RegisterSpec for RfcSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`rfc::R`](R) reader structure"]
        impl crate::Readable for RfcSpec {}
        #[doc = "`reset()` method sets RFC to value 0"]
        impl crate::Resettable for RfcSpec {}
    }
    #[doc = "TFC (r) register accessor: RO, UART0 transmitter FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`tfc::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tfc`] module"]
    #[doc(alias = "TFC")]
    pub type Tfc = crate::Reg<tfc::TfcSpec>;
    #[doc = "RO, UART0 transmitter FIFO count"]
    pub mod tfc {
        #[doc = "Register `TFC` reader"]
        pub type R = crate::R<TfcSpec>;
        #[doc = "Field `TFC` reader - RO, UART0 transmitter FIFO count"]
        pub type TfcR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RO, UART0 transmitter FIFO count"]
            #[inline(always)]
            pub fn tfc(&self) -> TfcR {
                TfcR::new(self.bits)
            }
        }
        #[doc = "RO, UART0 transmitter FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`tfc::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TfcSpec;
        impl crate::RegisterSpec for TfcSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`tfc::R`](R) reader structure"]
        impl crate::Readable for TfcSpec {}
        #[doc = "`reset()` method sets TFC to value 0"]
        impl crate::Resettable for TfcSpec {}
    }
    #[doc = "DL (rw) register accessor: RW, UART0 divisor latch\n\nYou can [`read`](crate::Reg::read) this register and get [`dl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dl`] module"]
    #[doc(alias = "DL")]
    pub type Dl = crate::Reg<dl::DlSpec>;
    #[doc = "RW, UART0 divisor latch"]
    pub mod dl {
        #[doc = "Register `DL` reader"]
        pub type R = crate::R<DlSpec>;
        #[doc = "Register `DL` writer"]
        pub type W = crate::W<DlSpec>;
        #[doc = "Field `DL` reader - RW, UART0 divisor latch"]
        pub type DlR = crate::FieldReader<u16>;
        #[doc = "Field `DL` writer - RW, UART0 divisor latch"]
        pub type DlW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW, UART0 divisor latch"]
            #[inline(always)]
            pub fn dl(&self) -> DlR {
                DlR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW, UART0 divisor latch"]
            #[inline(always)]
            pub fn dl(&mut self) -> DlW<DlSpec> {
                DlW::new(self, 0)
            }
        }
        #[doc = "RW, UART0 divisor latch\n\nYou can [`read`](crate::Reg::read) this register and get [`dl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DlSpec;
        impl crate::RegisterSpec for DlSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`dl::R`](R) reader structure"]
        impl crate::Readable for DlSpec {}
        #[doc = "`write(|w| ..)` method takes [`dl::W`](W) writer structure"]
        impl crate::Writable for DlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DL to value 0"]
        impl crate::Resettable for DlSpec {}
    }
    #[doc = "DIV (rw) register accessor: RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128\n\nYou can [`read`](crate::Reg::read) this register and get [`div::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@div`] module"]
    #[doc(alias = "DIV")]
    pub type Div = crate::Reg<div::DivSpec>;
    #[doc = "RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128"]
    pub mod div {
        #[doc = "Register `DIV` reader"]
        pub type R = crate::R<DivSpec>;
        #[doc = "Register `DIV` writer"]
        pub type W = crate::W<DivSpec>;
        #[doc = "Field `DIV` reader - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128"]
        pub type DivR = crate::FieldReader;
        #[doc = "Field `DIV` writer - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128"]
        pub type DivW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128"]
            #[inline(always)]
            pub fn div(&self) -> DivR {
                DivR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128"]
            #[inline(always)]
            pub fn div(&mut self) -> DivW<DivSpec> {
                DivW::new(self, 0)
            }
        }
        #[doc = "RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128\n\nYou can [`read`](crate::Reg::read) this register and get [`div::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DivSpec;
        impl crate::RegisterSpec for DivSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`div::R`](R) reader structure"]
        impl crate::Readable for DivSpec {}
        #[doc = "`write(|w| ..)` method takes [`div::W`](W) writer structure"]
        impl crate::Writable for DivSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DIV to value 0"]
        impl crate::Resettable for DivSpec {}
    }
    #[doc = "ADR (rw) register accessor: RW, UART0 slave address: 0xFF=disable, other=enable\n\nYou can [`read`](crate::Reg::read) this register and get [`adr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@adr`] module"]
    #[doc(alias = "ADR")]
    pub type Adr = crate::Reg<adr::AdrSpec>;
    #[doc = "RW, UART0 slave address: 0xFF=disable, other=enable"]
    pub mod adr {
        #[doc = "Register `ADR` reader"]
        pub type R = crate::R<AdrSpec>;
        #[doc = "Register `ADR` writer"]
        pub type W = crate::W<AdrSpec>;
        #[doc = "Field `ADR` reader - RW,UART0 slave address: 0xFF=disable, other=enable"]
        pub type AdrR = crate::FieldReader;
        #[doc = "Field `ADR` writer - RW,UART0 slave address: 0xFF=disable, other=enable"]
        pub type AdrW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW,UART0 slave address: 0xFF=disable, other=enable"]
            #[inline(always)]
            pub fn adr(&self) -> AdrR {
                AdrR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW,UART0 slave address: 0xFF=disable, other=enable"]
            #[inline(always)]
            pub fn adr(&mut self) -> AdrW<AdrSpec> {
                AdrW::new(self, 0)
            }
        }
        #[doc = "RW, UART0 slave address: 0xFF=disable, other=enable\n\nYou can [`read`](crate::Reg::read) this register and get [`adr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct AdrSpec;
        impl crate::RegisterSpec for AdrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`adr::R`](R) reader structure"]
        impl crate::Readable for AdrSpec {}
        #[doc = "`write(|w| ..)` method takes [`adr::W`](W) writer structure"]
        impl crate::Writable for AdrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets ADR to value 0xff"]
        impl crate::Resettable for AdrSpec {
            const RESET_VALUE: u8 = 0xff;
        }
    }
}
#[doc = "UART1 register"]
pub type Uart1 = crate::Periph<uart1::RegisterBlock, 0x4000_3400>;
impl core::fmt::Debug for Uart1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart1").finish()
    }
}
#[doc = "UART1 register"]
pub mod uart1 {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        mcr: Mcr,
        ier: Ier,
        fcr: Fcr,
        lcr: Lcr,
        iir: Iir,
        lsr: Lsr,
        _reserved6: [u8; 0x02],
        _reserved_6_rbr: [u8; 0x01],
        _reserved7: [u8; 0x01],
        rfc: Rfc,
        tfc: Tfc,
        dl: Dl,
        div: Div,
    }
    impl RegisterBlock {
        #[doc = "0x00 - RW, UART1 modem control"]
        #[inline(always)]
        pub const fn mcr(&self) -> &Mcr {
            &self.mcr
        }
        #[doc = "0x01 - RW, UART1 interrupt enable"]
        #[inline(always)]
        pub const fn ier(&self) -> &Ier {
            &self.ier
        }
        #[doc = "0x02 - RW, UART1 FIFO control"]
        #[inline(always)]
        pub const fn fcr(&self) -> &Fcr {
            &self.fcr
        }
        #[doc = "0x03 - RW, UART1 line control"]
        #[inline(always)]
        pub const fn lcr(&self) -> &Lcr {
            &self.lcr
        }
        #[doc = "0x04 - RO, UART1 interrupt identification"]
        #[inline(always)]
        pub const fn iir(&self) -> &Iir {
            &self.iir
        }
        #[doc = "0x05 - RO, UART1 line status"]
        #[inline(always)]
        pub const fn lsr(&self) -> &Lsr {
            &self.lsr
        }
        #[doc = "0x08 - WO, UART1 transmitter holding, transmittal byte"]
        #[inline(always)]
        pub const fn thr(&self) -> &Thr {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(8).cast() }
        }
        #[doc = "0x08 - RO, UART1 receiver buffer, receiving byte"]
        #[inline(always)]
        pub const fn rbr(&self) -> &Rbr {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(8).cast() }
        }
        #[doc = "0x0a - RO, UART1 receiver FIFO count"]
        #[inline(always)]
        pub const fn rfc(&self) -> &Rfc {
            &self.rfc
        }
        #[doc = "0x0b - RO, UART1 transmitter FIFO count"]
        #[inline(always)]
        pub const fn tfc(&self) -> &Tfc {
            &self.tfc
        }
        #[doc = "0x0c - RW, UART1 divisor latch"]
        #[inline(always)]
        pub const fn dl(&self) -> &Dl {
            &self.dl
        }
        #[doc = "0x0e - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
        #[inline(always)]
        pub const fn div(&self) -> &Div {
            &self.div
        }
    }
    #[doc = "MCR (rw) register accessor: RW, UART1 modem control\n\nYou can [`read`](crate::Reg::read) this register and get [`mcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mcr`] module"]
    #[doc(alias = "MCR")]
    pub type Mcr = crate::Reg<mcr::McrSpec>;
    #[doc = "RW, UART1 modem control"]
    pub mod mcr {
        #[doc = "Register `MCR` reader"]
        pub type R = crate::R<McrSpec>;
        #[doc = "Register `MCR` writer"]
        pub type W = crate::W<McrSpec>;
        #[doc = "Field `MCR_OUT2` reader - RW, UART control OUT2"]
        pub type McrOut2R = crate::BitReader;
        #[doc = "Field `MCR_OUT2` writer - RW, UART control OUT2"]
        pub type McrOut2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MCR_INT_OE` reader - RW, UART interrupt output enable"]
        pub type McrIntOeR = crate::BitReader;
        #[doc = "Field `MCR_INT_OE` writer - RW, UART interrupt output enable"]
        pub type McrIntOeW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 3 - RW, UART control OUT2"]
            #[inline(always)]
            pub fn mcr_out2(&self) -> McrOut2R {
                McrOut2R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, UART interrupt output enable"]
            #[inline(always)]
            pub fn mcr_int_oe(&self) -> McrIntOeR {
                McrIntOeR::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 3 - RW, UART control OUT2"]
            #[inline(always)]
            pub fn mcr_out2(&mut self) -> McrOut2W<McrSpec> {
                McrOut2W::new(self, 3)
            }
            #[doc = "Bit 3 - RW, UART interrupt output enable"]
            #[inline(always)]
            pub fn mcr_int_oe(&mut self) -> McrIntOeW<McrSpec> {
                McrIntOeW::new(self, 3)
            }
        }
        #[doc = "RW, UART1 modem control\n\nYou can [`read`](crate::Reg::read) this register and get [`mcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct McrSpec;
        impl crate::RegisterSpec for McrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`mcr::R`](R) reader structure"]
        impl crate::Readable for McrSpec {}
        #[doc = "`write(|w| ..)` method takes [`mcr::W`](W) writer structure"]
        impl crate::Writable for McrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets MCR to value 0"]
        impl crate::Resettable for McrSpec {}
    }
    #[doc = "IER (rw) register accessor: RW, UART1 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ier`] module"]
    #[doc(alias = "IER")]
    pub type Ier = crate::Reg<ier::IerSpec>;
    #[doc = "RW, UART1 interrupt enable"]
    pub mod ier {
        #[doc = "Register `IER` reader"]
        pub type R = crate::R<IerSpec>;
        #[doc = "Register `IER` writer"]
        pub type W = crate::W<IerSpec>;
        #[doc = "Field `IER_RECV_RDY` reader - RW, UART interrupt enable for receiver data ready"]
        pub type IerRecvRdyR = crate::BitReader;
        #[doc = "Field `IER_RECV_RDY` writer - RW, UART interrupt enable for receiver data ready"]
        pub type IerRecvRdyW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IER_THR_EMPTY` reader - RW, UART interrupt enable for THR empty"]
        pub type IerThrEmptyR = crate::BitReader;
        #[doc = "Field `IER_THR_EMPTY` writer - RW, UART interrupt enable for THR empty"]
        pub type IerThrEmptyW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IER_LINE_STAT` reader - RW, UART interrupt enable for receiver line status"]
        pub type IerLineStatR = crate::BitReader;
        #[doc = "Field `IER_LINE_STAT` writer - RW, UART interrupt enable for receiver line status"]
        pub type IerLineStatW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IER_TXD_EN` reader - RW, UART TXD pin enable"]
        pub type IerTxdEnR = crate::BitReader;
        #[doc = "Field `IER_TXD_EN` writer - RW, UART TXD pin enable"]
        pub type IerTxdEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IER_RESET` reader - WZ, UART software reset control, high action, auto clear"]
        pub type IerResetR = crate::BitReader;
        #[doc = "Field `IER_RESET` writer - WZ, UART software reset control, high action, auto clear"]
        pub type IerResetW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, UART interrupt enable for receiver data ready"]
            #[inline(always)]
            pub fn ier_recv_rdy(&self) -> IerRecvRdyR {
                IerRecvRdyR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, UART interrupt enable for THR empty"]
            #[inline(always)]
            pub fn ier_thr_empty(&self) -> IerThrEmptyR {
                IerThrEmptyR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW, UART interrupt enable for receiver line status"]
            #[inline(always)]
            pub fn ier_line_stat(&self) -> IerLineStatR {
                IerLineStatR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 6 - RW, UART TXD pin enable"]
            #[inline(always)]
            pub fn ier_txd_en(&self) -> IerTxdEnR {
                IerTxdEnR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - WZ, UART software reset control, high action, auto clear"]
            #[inline(always)]
            pub fn ier_reset(&self) -> IerResetR {
                IerResetR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, UART interrupt enable for receiver data ready"]
            #[inline(always)]
            pub fn ier_recv_rdy(&mut self) -> IerRecvRdyW<IerSpec> {
                IerRecvRdyW::new(self, 0)
            }
            #[doc = "Bit 1 - RW, UART interrupt enable for THR empty"]
            #[inline(always)]
            pub fn ier_thr_empty(&mut self) -> IerThrEmptyW<IerSpec> {
                IerThrEmptyW::new(self, 1)
            }
            #[doc = "Bit 2 - RW, UART interrupt enable for receiver line status"]
            #[inline(always)]
            pub fn ier_line_stat(&mut self) -> IerLineStatW<IerSpec> {
                IerLineStatW::new(self, 2)
            }
            #[doc = "Bit 6 - RW, UART TXD pin enable"]
            #[inline(always)]
            pub fn ier_txd_en(&mut self) -> IerTxdEnW<IerSpec> {
                IerTxdEnW::new(self, 6)
            }
            #[doc = "Bit 7 - WZ, UART software reset control, high action, auto clear"]
            #[inline(always)]
            pub fn ier_reset(&mut self) -> IerResetW<IerSpec> {
                IerResetW::new(self, 7)
            }
        }
        #[doc = "RW, UART1 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IerSpec;
        impl crate::RegisterSpec for IerSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`ier::R`](R) reader structure"]
        impl crate::Readable for IerSpec {}
        #[doc = "`write(|w| ..)` method takes [`ier::W`](W) writer structure"]
        impl crate::Writable for IerSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IER to value 0"]
        impl crate::Resettable for IerSpec {}
    }
    #[doc = "FCR (rw) register accessor: RW, UART1 FIFO control\n\nYou can [`read`](crate::Reg::read) this register and get [`fcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fcr`] module"]
    #[doc(alias = "FCR")]
    pub type Fcr = crate::Reg<fcr::FcrSpec>;
    #[doc = "RW, UART1 FIFO control"]
    pub mod fcr {
        #[doc = "Register `FCR` reader"]
        pub type R = crate::R<FcrSpec>;
        #[doc = "Register `FCR` writer"]
        pub type W = crate::W<FcrSpec>;
        #[doc = "Field `FCR_FIFO_EN` reader - RW, UART FIFO enable"]
        pub type FcrFifoEnR = crate::BitReader;
        #[doc = "Field `FCR_FIFO_EN` writer - RW, UART FIFO enable"]
        pub type FcrFifoEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FCR_RX_FIFO_CLR` reader - WZ, clear UART receiver FIFO, high action, auto clear"]
        pub type FcrRxFifoClrR = crate::BitReader;
        #[doc = "Field `FCR_RX_FIFO_CLR` writer - WZ, clear UART receiver FIFO, high action, auto clear"]
        pub type FcrRxFifoClrW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FCR_TX_FIFO_CLR` reader - WZ, clear UART transmitter FIFO, high action, auto clear"]
        pub type FcrTxFifoClrR = crate::BitReader;
        #[doc = "Field `FCR_TX_FIFO_CLR` writer - WZ, clear UART transmitter FIFO, high action, auto clear"]
        pub type FcrTxFifoClrW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FCR_FIFO_TRIG` reader - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"]
        pub type FcrFifoTrigR = crate::FieldReader;
        #[doc = "Field `FCR_FIFO_TRIG` writer - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"]
        pub type FcrFifoTrigW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            #[doc = "Bit 0 - RW, UART FIFO enable"]
            #[inline(always)]
            pub fn fcr_fifo_en(&self) -> FcrFifoEnR {
                FcrFifoEnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear"]
            #[inline(always)]
            pub fn fcr_rx_fifo_clr(&self) -> FcrRxFifoClrR {
                FcrRxFifoClrR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear"]
            #[inline(always)]
            pub fn fcr_tx_fifo_clr(&self) -> FcrTxFifoClrR {
                FcrTxFifoClrR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"]
            #[inline(always)]
            pub fn fcr_fifo_trig(&self) -> FcrFifoTrigR {
                FcrFifoTrigR::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, UART FIFO enable"]
            #[inline(always)]
            pub fn fcr_fifo_en(&mut self) -> FcrFifoEnW<FcrSpec> {
                FcrFifoEnW::new(self, 0)
            }
            #[doc = "Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear"]
            #[inline(always)]
            pub fn fcr_rx_fifo_clr(&mut self) -> FcrRxFifoClrW<FcrSpec> {
                FcrRxFifoClrW::new(self, 1)
            }
            #[doc = "Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear"]
            #[inline(always)]
            pub fn fcr_tx_fifo_clr(&mut self) -> FcrTxFifoClrW<FcrSpec> {
                FcrTxFifoClrW::new(self, 2)
            }
            #[doc = "Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"]
            #[inline(always)]
            pub fn fcr_fifo_trig(&mut self) -> FcrFifoTrigW<FcrSpec> {
                FcrFifoTrigW::new(self, 6)
            }
        }
        #[doc = "RW, UART1 FIFO control\n\nYou can [`read`](crate::Reg::read) this register and get [`fcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FcrSpec;
        impl crate::RegisterSpec for FcrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`fcr::R`](R) reader structure"]
        impl crate::Readable for FcrSpec {}
        #[doc = "`write(|w| ..)` method takes [`fcr::W`](W) writer structure"]
        impl crate::Writable for FcrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FCR to value 0"]
        impl crate::Resettable for FcrSpec {}
    }
    #[doc = "LCR (rw) register accessor: RW, UART1 line control\n\nYou can [`read`](crate::Reg::read) this register and get [`lcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lcr`] module"]
    #[doc(alias = "LCR")]
    pub type Lcr = crate::Reg<lcr::LcrSpec>;
    #[doc = "RW, UART1 line control"]
    pub mod lcr {
        #[doc = "Register `LCR` reader"]
        pub type R = crate::R<LcrSpec>;
        #[doc = "Register `LCR` writer"]
        pub type W = crate::W<LcrSpec>;
        #[doc = "Field `LCR_WORD_SZ` reader - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"]
        pub type LcrWordSzR = crate::FieldReader;
        #[doc = "Field `LCR_WORD_SZ` writer - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"]
        pub type LcrWordSzW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `LCR_STOP_BIT` reader - RW, UART stop bit length: 0-1bit, 1-2bit"]
        pub type LcrStopBitR = crate::BitReader;
        #[doc = "Field `LCR_STOP_BIT` writer - RW, UART stop bit length: 0-1bit, 1-2bit"]
        pub type LcrStopBitW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LCR_PAR_EN` reader - RW, UART parity enable"]
        pub type LcrParEnR = crate::BitReader;
        #[doc = "Field `LCR_PAR_EN` writer - RW, UART parity enable"]
        pub type LcrParEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LCR_PAR_MOD` reader - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"]
        pub type LcrParModR = crate::FieldReader;
        #[doc = "Field `LCR_PAR_MOD` writer - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"]
        pub type LcrParModW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `LCR_BREAK_EN` reader - RW, UART break control enable"]
        pub type LcrBreakEnR = crate::BitReader;
        #[doc = "Field `LCR_BREAK_EN` writer - RW, UART break control enable"]
        pub type LcrBreakEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LCR_GP_BIT` reader - RW, UART general purpose bit"]
        pub type LcrGpBitR = crate::BitReader;
        #[doc = "Field `LCR_GP_BIT` writer - RW, UART general purpose bit"]
        pub type LcrGpBitW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LCR_DLAB` reader - RW, UART reserved bit"]
        pub type LcrDlabR = crate::BitReader;
        #[doc = "Field `LCR_DLAB` writer - RW, UART reserved bit"]
        pub type LcrDlabW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"]
            #[inline(always)]
            pub fn lcr_word_sz(&self) -> LcrWordSzR {
                LcrWordSzR::new(self.bits & 3)
            }
            #[doc = "Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit"]
            #[inline(always)]
            pub fn lcr_stop_bit(&self) -> LcrStopBitR {
                LcrStopBitR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, UART parity enable"]
            #[inline(always)]
            pub fn lcr_par_en(&self) -> LcrParEnR {
                LcrParEnR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"]
            #[inline(always)]
            pub fn lcr_par_mod(&self) -> LcrParModR {
                LcrParModR::new((self.bits >> 4) & 3)
            }
            #[doc = "Bit 6 - RW, UART break control enable"]
            #[inline(always)]
            pub fn lcr_break_en(&self) -> LcrBreakEnR {
                LcrBreakEnR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RW, UART general purpose bit"]
            #[inline(always)]
            pub fn lcr_gp_bit(&self) -> LcrGpBitR {
                LcrGpBitR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 7 - RW, UART reserved bit"]
            #[inline(always)]
            pub fn lcr_dlab(&self) -> LcrDlabR {
                LcrDlabR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"]
            #[inline(always)]
            pub fn lcr_word_sz(&mut self) -> LcrWordSzW<LcrSpec> {
                LcrWordSzW::new(self, 0)
            }
            #[doc = "Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit"]
            #[inline(always)]
            pub fn lcr_stop_bit(&mut self) -> LcrStopBitW<LcrSpec> {
                LcrStopBitW::new(self, 2)
            }
            #[doc = "Bit 3 - RW, UART parity enable"]
            #[inline(always)]
            pub fn lcr_par_en(&mut self) -> LcrParEnW<LcrSpec> {
                LcrParEnW::new(self, 3)
            }
            #[doc = "Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"]
            #[inline(always)]
            pub fn lcr_par_mod(&mut self) -> LcrParModW<LcrSpec> {
                LcrParModW::new(self, 4)
            }
            #[doc = "Bit 6 - RW, UART break control enable"]
            #[inline(always)]
            pub fn lcr_break_en(&mut self) -> LcrBreakEnW<LcrSpec> {
                LcrBreakEnW::new(self, 6)
            }
            #[doc = "Bit 7 - RW, UART general purpose bit"]
            #[inline(always)]
            pub fn lcr_gp_bit(&mut self) -> LcrGpBitW<LcrSpec> {
                LcrGpBitW::new(self, 7)
            }
            #[doc = "Bit 7 - RW, UART reserved bit"]
            #[inline(always)]
            pub fn lcr_dlab(&mut self) -> LcrDlabW<LcrSpec> {
                LcrDlabW::new(self, 7)
            }
        }
        #[doc = "RW, UART1 line control\n\nYou can [`read`](crate::Reg::read) this register and get [`lcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct LcrSpec;
        impl crate::RegisterSpec for LcrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`lcr::R`](R) reader structure"]
        impl crate::Readable for LcrSpec {}
        #[doc = "`write(|w| ..)` method takes [`lcr::W`](W) writer structure"]
        impl crate::Writable for LcrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets LCR to value 0"]
        impl crate::Resettable for LcrSpec {}
    }
    #[doc = "IIR (r) register accessor: RO, UART1 interrupt identification\n\nYou can [`read`](crate::Reg::read) this register and get [`iir::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iir`] module"]
    #[doc(alias = "IIR")]
    pub type Iir = crate::Reg<iir::IirSpec>;
    #[doc = "RO, UART1 interrupt identification"]
    pub mod iir {
        #[doc = "Register `IIR` reader"]
        pub type R = crate::R<IirSpec>;
        #[doc = "Field `IIR_NO_INT` reader - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt"]
        pub type IirNoIntR = crate::BitReader;
        #[doc = "Field `IIR_INT_MASK` reader - RO, UART interrupt flag bit mask"]
        pub type IirIntMaskR = crate::FieldReader;
        #[doc = "Field `IIR_FIFO_ID` reader - RO, UART FIFO enabled flag"]
        pub type IirFifoIdR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt"]
            #[inline(always)]
            pub fn iir_no_int(&self) -> IirNoIntR {
                IirNoIntR::new((self.bits & 1) != 0)
            }
            #[doc = "Bits 0:3 - RO, UART interrupt flag bit mask"]
            #[inline(always)]
            pub fn iir_int_mask(&self) -> IirIntMaskR {
                IirIntMaskR::new(self.bits & 0x0f)
            }
            #[doc = "Bit 7 - RO, UART FIFO enabled flag"]
            #[inline(always)]
            pub fn iir_fifo_id(&self) -> IirFifoIdR {
                IirFifoIdR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        #[doc = "RO, UART1 interrupt identification\n\nYou can [`read`](crate::Reg::read) this register and get [`iir::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IirSpec;
        impl crate::RegisterSpec for IirSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`iir::R`](R) reader structure"]
        impl crate::Readable for IirSpec {}
        #[doc = "`reset()` method sets IIR to value 0x01"]
        impl crate::Resettable for IirSpec {
            const RESET_VALUE: u8 = 0x01;
        }
    }
    #[doc = "LSR (r) register accessor: RO, UART1 line status\n\nYou can [`read`](crate::Reg::read) this register and get [`lsr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lsr`] module"]
    #[doc(alias = "LSR")]
    pub type Lsr = crate::Reg<lsr::LsrSpec>;
    #[doc = "RO, UART1 line status"]
    pub mod lsr {
        #[doc = "Register `LSR` reader"]
        pub type R = crate::R<LsrSpec>;
        #[doc = "Field `LSR_DATA_RDY` reader - RO, UART receiver fifo data ready status"]
        pub type LsrDataRdyR = crate::BitReader;
        #[doc = "Field `LSR_OVER_ERR` reader - RZ, UART receiver overrun error"]
        pub type LsrOverErrR = crate::BitReader;
        #[doc = "Field `LSR_PAR_ERR` reader - RZ, UART receiver parity error"]
        pub type LsrParErrR = crate::BitReader;
        #[doc = "Field `LSR_FRAME_ERR` reader - RZ, UART receiver frame error"]
        pub type LsrFrameErrR = crate::BitReader;
        #[doc = "Field `LSR_BREAK_ERR` reader - RZ, UART receiver break error"]
        pub type LsrBreakErrR = crate::BitReader;
        #[doc = "Field `LSR_TX_FIFO_EMP` reader - RO, UART transmitter fifo empty status"]
        pub type LsrTxFifoEmpR = crate::BitReader;
        #[doc = "Field `LSR_TX_ALL_EMP` reader - RO, UART transmitter all empty status"]
        pub type LsrTxAllEmpR = crate::BitReader;
        #[doc = "Field `LSR_ERR_RX_FIFO` reader - RO, indicate error in UART receiver fifo"]
        pub type LsrErrRxFifoR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - RO, UART receiver fifo data ready status"]
            #[inline(always)]
            pub fn lsr_data_rdy(&self) -> LsrDataRdyR {
                LsrDataRdyR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RZ, UART receiver overrun error"]
            #[inline(always)]
            pub fn lsr_over_err(&self) -> LsrOverErrR {
                LsrOverErrR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RZ, UART receiver parity error"]
            #[inline(always)]
            pub fn lsr_par_err(&self) -> LsrParErrR {
                LsrParErrR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RZ, UART receiver frame error"]
            #[inline(always)]
            pub fn lsr_frame_err(&self) -> LsrFrameErrR {
                LsrFrameErrR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RZ, UART receiver break error"]
            #[inline(always)]
            pub fn lsr_break_err(&self) -> LsrBreakErrR {
                LsrBreakErrR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RO, UART transmitter fifo empty status"]
            #[inline(always)]
            pub fn lsr_tx_fifo_emp(&self) -> LsrTxFifoEmpR {
                LsrTxFifoEmpR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RO, UART transmitter all empty status"]
            #[inline(always)]
            pub fn lsr_tx_all_emp(&self) -> LsrTxAllEmpR {
                LsrTxAllEmpR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RO, indicate error in UART receiver fifo"]
            #[inline(always)]
            pub fn lsr_err_rx_fifo(&self) -> LsrErrRxFifoR {
                LsrErrRxFifoR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        #[doc = "RO, UART1 line status\n\nYou can [`read`](crate::Reg::read) this register and get [`lsr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct LsrSpec;
        impl crate::RegisterSpec for LsrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`lsr::R`](R) reader structure"]
        impl crate::Readable for LsrSpec {}
        #[doc = "`reset()` method sets LSR to value 0x60"]
        impl crate::Resettable for LsrSpec {
            const RESET_VALUE: u8 = 0x60;
        }
    }
    #[doc = "RBR (r) register accessor: RO, UART1 receiver buffer, receiving byte\n\nYou can [`read`](crate::Reg::read) this register and get [`rbr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rbr`] module"]
    #[doc(alias = "RBR")]
    pub type Rbr = crate::Reg<rbr::RbrSpec>;
    #[doc = "RO, UART1 receiver buffer, receiving byte"]
    pub mod rbr {
        #[doc = "Register `RBR` reader"]
        pub type R = crate::R<RbrSpec>;
        #[doc = "Field `RBR` reader - RO, UART1 receiver buffer, receiving byte"]
        pub type RbrR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RO, UART1 receiver buffer, receiving byte"]
            #[inline(always)]
            pub fn rbr(&self) -> RbrR {
                RbrR::new(self.bits)
            }
        }
        #[doc = "RO, UART1 receiver buffer, receiving byte\n\nYou can [`read`](crate::Reg::read) this register and get [`rbr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RbrSpec;
        impl crate::RegisterSpec for RbrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`rbr::R`](R) reader structure"]
        impl crate::Readable for RbrSpec {}
        #[doc = "`reset()` method sets RBR to value 0"]
        impl crate::Resettable for RbrSpec {}
    }
    #[doc = "THR (w) register accessor: WO, UART1 transmitter holding, transmittal byte\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`thr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@thr`] module"]
    #[doc(alias = "THR")]
    pub type Thr = crate::Reg<thr::ThrSpec>;
    #[doc = "WO, UART1 transmitter holding, transmittal byte"]
    pub mod thr {
        #[doc = "Register `THR` writer"]
        pub type W = crate::W<ThrSpec>;
        #[doc = "Field `RBR` writer - WO, UART1 transmitter holding, transmittal byte"]
        pub type RbrW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl W {
            #[doc = "Bits 0:7 - WO, UART1 transmitter holding, transmittal byte"]
            #[inline(always)]
            pub fn rbr(&mut self) -> RbrW<ThrSpec> {
                RbrW::new(self, 0)
            }
        }
        #[doc = "WO, UART1 transmitter holding, transmittal byte\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`thr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ThrSpec;
        impl crate::RegisterSpec for ThrSpec {
            type Ux = u8;
        }
        #[doc = "`write(|w| ..)` method takes [`thr::W`](W) writer structure"]
        impl crate::Writable for ThrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets THR to value 0"]
        impl crate::Resettable for ThrSpec {}
    }
    #[doc = "RFC (r) register accessor: RO, UART1 receiver FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`rfc::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rfc`] module"]
    #[doc(alias = "RFC")]
    pub type Rfc = crate::Reg<rfc::RfcSpec>;
    #[doc = "RO, UART1 receiver FIFO count"]
    pub mod rfc {
        #[doc = "Register `RFC` reader"]
        pub type R = crate::R<RfcSpec>;
        #[doc = "Field `RFC` reader - RO, UART1 receiver FIFO count"]
        pub type RfcR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RO, UART1 receiver FIFO count"]
            #[inline(always)]
            pub fn rfc(&self) -> RfcR {
                RfcR::new(self.bits)
            }
        }
        #[doc = "RO, UART1 receiver FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`rfc::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RfcSpec;
        impl crate::RegisterSpec for RfcSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`rfc::R`](R) reader structure"]
        impl crate::Readable for RfcSpec {}
        #[doc = "`reset()` method sets RFC to value 0"]
        impl crate::Resettable for RfcSpec {}
    }
    #[doc = "TFC (r) register accessor: RO, UART1 transmitter FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`tfc::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tfc`] module"]
    #[doc(alias = "TFC")]
    pub type Tfc = crate::Reg<tfc::TfcSpec>;
    #[doc = "RO, UART1 transmitter FIFO count"]
    pub mod tfc {
        #[doc = "Register `TFC` reader"]
        pub type R = crate::R<TfcSpec>;
        #[doc = "Field `TFC` reader - RO, UART1 receiver FIFO count"]
        pub type TfcR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RO, UART1 receiver FIFO count"]
            #[inline(always)]
            pub fn tfc(&self) -> TfcR {
                TfcR::new(self.bits)
            }
        }
        #[doc = "RO, UART1 transmitter FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`tfc::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TfcSpec;
        impl crate::RegisterSpec for TfcSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`tfc::R`](R) reader structure"]
        impl crate::Readable for TfcSpec {}
        #[doc = "`reset()` method sets TFC to value 0"]
        impl crate::Resettable for TfcSpec {}
    }
    #[doc = "DL (rw) register accessor: RW, UART1 divisor latch\n\nYou can [`read`](crate::Reg::read) this register and get [`dl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dl`] module"]
    #[doc(alias = "DL")]
    pub type Dl = crate::Reg<dl::DlSpec>;
    #[doc = "RW, UART1 divisor latch"]
    pub mod dl {
        #[doc = "Register `DL` reader"]
        pub type R = crate::R<DlSpec>;
        #[doc = "Register `DL` writer"]
        pub type W = crate::W<DlSpec>;
        #[doc = "Field `DL` reader - RW, UART1 divisor latch"]
        pub type DlR = crate::FieldReader<u16>;
        #[doc = "Field `DL` writer - RW, UART1 divisor latch"]
        pub type DlW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW, UART1 divisor latch"]
            #[inline(always)]
            pub fn dl(&self) -> DlR {
                DlR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW, UART1 divisor latch"]
            #[inline(always)]
            pub fn dl(&mut self) -> DlW<DlSpec> {
                DlW::new(self, 0)
            }
        }
        #[doc = "RW, UART1 divisor latch\n\nYou can [`read`](crate::Reg::read) this register and get [`dl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DlSpec;
        impl crate::RegisterSpec for DlSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`dl::R`](R) reader structure"]
        impl crate::Readable for DlSpec {}
        #[doc = "`write(|w| ..)` method takes [`dl::W`](W) writer structure"]
        impl crate::Writable for DlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DL to value 0"]
        impl crate::Resettable for DlSpec {}
    }
    #[doc = "DIV (rw) register accessor: RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128\n\nYou can [`read`](crate::Reg::read) this register and get [`div::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@div`] module"]
    #[doc(alias = "DIV")]
    pub type Div = crate::Reg<div::DivSpec>;
    #[doc = "RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
    pub mod div {
        #[doc = "Register `DIV` reader"]
        pub type R = crate::R<DivSpec>;
        #[doc = "Register `DIV` writer"]
        pub type W = crate::W<DivSpec>;
        #[doc = "Field `DIV` reader - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
        pub type DivR = crate::FieldReader;
        #[doc = "Field `DIV` writer - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
        pub type DivW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
            #[inline(always)]
            pub fn div(&self) -> DivR {
                DivR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
            #[inline(always)]
            pub fn div(&mut self) -> DivW<DivSpec> {
                DivW::new(self, 0)
            }
        }
        #[doc = "RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128\n\nYou can [`read`](crate::Reg::read) this register and get [`div::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DivSpec;
        impl crate::RegisterSpec for DivSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`div::R`](R) reader structure"]
        impl crate::Readable for DivSpec {}
        #[doc = "`write(|w| ..)` method takes [`div::W`](W) writer structure"]
        impl crate::Writable for DivSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DIV to value 0"]
        impl crate::Resettable for DivSpec {}
    }
}
#[doc = "UART2 register"]
pub type Uart2 = crate::Periph<uart2::RegisterBlock, 0x4000_3800>;
impl core::fmt::Debug for Uart2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart2").finish()
    }
}
#[doc = "UART2 register"]
pub mod uart2 {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        mcr: Mcr,
        ier: Ier,
        fcr: Fcr,
        lcr: Lcr,
        iir: Iir,
        lsr: Lsr,
        _reserved6: [u8; 0x02],
        _reserved_6_rbr: [u8; 0x01],
        _reserved7: [u8; 0x01],
        rfc: Rfc,
        tfc: Tfc,
        dl: Dl,
        div: Div,
    }
    impl RegisterBlock {
        #[doc = "0x00 - RW, UART2 modem control"]
        #[inline(always)]
        pub const fn mcr(&self) -> &Mcr {
            &self.mcr
        }
        #[doc = "0x01 - RW, UART2 interrupt enable"]
        #[inline(always)]
        pub const fn ier(&self) -> &Ier {
            &self.ier
        }
        #[doc = "0x02 - RW, UART2 FIFO control"]
        #[inline(always)]
        pub const fn fcr(&self) -> &Fcr {
            &self.fcr
        }
        #[doc = "0x03 - RW, UART2 line control"]
        #[inline(always)]
        pub const fn lcr(&self) -> &Lcr {
            &self.lcr
        }
        #[doc = "0x04 - RO, UART2 interrupt identification"]
        #[inline(always)]
        pub const fn iir(&self) -> &Iir {
            &self.iir
        }
        #[doc = "0x05 - RO, UART2 line status"]
        #[inline(always)]
        pub const fn lsr(&self) -> &Lsr {
            &self.lsr
        }
        #[doc = "0x08 - WO, UART2 transmitter holding, transmittal byte"]
        #[inline(always)]
        pub const fn thr(&self) -> &Thr {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(8).cast() }
        }
        #[doc = "0x08 - RO, UART2 receiver buffer, receiving byte"]
        #[inline(always)]
        pub const fn rbr(&self) -> &Rbr {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(8).cast() }
        }
        #[doc = "0x0a - RO, UART2 receiver FIFO count"]
        #[inline(always)]
        pub const fn rfc(&self) -> &Rfc {
            &self.rfc
        }
        #[doc = "0x0b - RO, UART2 transmitter FIFO count"]
        #[inline(always)]
        pub const fn tfc(&self) -> &Tfc {
            &self.tfc
        }
        #[doc = "0x0c - RW, UART2 divisor latch"]
        #[inline(always)]
        pub const fn dl(&self) -> &Dl {
            &self.dl
        }
        #[doc = "0x0e - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
        #[inline(always)]
        pub const fn div(&self) -> &Div {
            &self.div
        }
    }
    #[doc = "MCR (rw) register accessor: RW, UART2 modem control\n\nYou can [`read`](crate::Reg::read) this register and get [`mcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mcr`] module"]
    #[doc(alias = "MCR")]
    pub type Mcr = crate::Reg<mcr::McrSpec>;
    #[doc = "RW, UART2 modem control"]
    pub mod mcr {
        #[doc = "Register `MCR` reader"]
        pub type R = crate::R<McrSpec>;
        #[doc = "Register `MCR` writer"]
        pub type W = crate::W<McrSpec>;
        #[doc = "Field `MCR_OUT2` reader - RW, UART control OUT2"]
        pub type McrOut2R = crate::BitReader;
        #[doc = "Field `MCR_OUT2` writer - RW, UART control OUT2"]
        pub type McrOut2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MCR_INT_OE` reader - RW, UART interrupt output enable"]
        pub type McrIntOeR = crate::BitReader;
        #[doc = "Field `MCR_INT_OE` writer - RW, UART interrupt output enable"]
        pub type McrIntOeW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 3 - RW, UART control OUT2"]
            #[inline(always)]
            pub fn mcr_out2(&self) -> McrOut2R {
                McrOut2R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, UART interrupt output enable"]
            #[inline(always)]
            pub fn mcr_int_oe(&self) -> McrIntOeR {
                McrIntOeR::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 3 - RW, UART control OUT2"]
            #[inline(always)]
            pub fn mcr_out2(&mut self) -> McrOut2W<McrSpec> {
                McrOut2W::new(self, 3)
            }
            #[doc = "Bit 3 - RW, UART interrupt output enable"]
            #[inline(always)]
            pub fn mcr_int_oe(&mut self) -> McrIntOeW<McrSpec> {
                McrIntOeW::new(self, 3)
            }
        }
        #[doc = "RW, UART2 modem control\n\nYou can [`read`](crate::Reg::read) this register and get [`mcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct McrSpec;
        impl crate::RegisterSpec for McrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`mcr::R`](R) reader structure"]
        impl crate::Readable for McrSpec {}
        #[doc = "`write(|w| ..)` method takes [`mcr::W`](W) writer structure"]
        impl crate::Writable for McrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets MCR to value 0"]
        impl crate::Resettable for McrSpec {}
    }
    #[doc = "IER (rw) register accessor: RW, UART2 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ier`] module"]
    #[doc(alias = "IER")]
    pub type Ier = crate::Reg<ier::IerSpec>;
    #[doc = "RW, UART2 interrupt enable"]
    pub mod ier {
        #[doc = "Register `IER` reader"]
        pub type R = crate::R<IerSpec>;
        #[doc = "Register `IER` writer"]
        pub type W = crate::W<IerSpec>;
        #[doc = "Field `IER_RECV_RDY` reader - RW, UART interrupt enable for receiver data ready"]
        pub type IerRecvRdyR = crate::BitReader;
        #[doc = "Field `IER_RECV_RDY` writer - RW, UART interrupt enable for receiver data ready"]
        pub type IerRecvRdyW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IER_THR_EMPTY` reader - RW, UART interrupt enable for THR empty"]
        pub type IerThrEmptyR = crate::BitReader;
        #[doc = "Field `IER_THR_EMPTY` writer - RW, UART interrupt enable for THR empty"]
        pub type IerThrEmptyW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IER_LINE_STAT` reader - RW, UART interrupt enable for receiver line status"]
        pub type IerLineStatR = crate::BitReader;
        #[doc = "Field `IER_LINE_STAT` writer - RW, UART interrupt enable for receiver line status"]
        pub type IerLineStatW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IER_TXD_EN` reader - RW, UART TXD pin enable"]
        pub type IerTxdEnR = crate::BitReader;
        #[doc = "Field `IER_TXD_EN` writer - RW, UART TXD pin enable"]
        pub type IerTxdEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IER_RESET` reader - WZ, UART software reset control, high action, auto clear"]
        pub type IerResetR = crate::BitReader;
        #[doc = "Field `IER_RESET` writer - WZ, UART software reset control, high action, auto clear"]
        pub type IerResetW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, UART interrupt enable for receiver data ready"]
            #[inline(always)]
            pub fn ier_recv_rdy(&self) -> IerRecvRdyR {
                IerRecvRdyR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, UART interrupt enable for THR empty"]
            #[inline(always)]
            pub fn ier_thr_empty(&self) -> IerThrEmptyR {
                IerThrEmptyR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW, UART interrupt enable for receiver line status"]
            #[inline(always)]
            pub fn ier_line_stat(&self) -> IerLineStatR {
                IerLineStatR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 6 - RW, UART TXD pin enable"]
            #[inline(always)]
            pub fn ier_txd_en(&self) -> IerTxdEnR {
                IerTxdEnR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - WZ, UART software reset control, high action, auto clear"]
            #[inline(always)]
            pub fn ier_reset(&self) -> IerResetR {
                IerResetR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, UART interrupt enable for receiver data ready"]
            #[inline(always)]
            pub fn ier_recv_rdy(&mut self) -> IerRecvRdyW<IerSpec> {
                IerRecvRdyW::new(self, 0)
            }
            #[doc = "Bit 1 - RW, UART interrupt enable for THR empty"]
            #[inline(always)]
            pub fn ier_thr_empty(&mut self) -> IerThrEmptyW<IerSpec> {
                IerThrEmptyW::new(self, 1)
            }
            #[doc = "Bit 2 - RW, UART interrupt enable for receiver line status"]
            #[inline(always)]
            pub fn ier_line_stat(&mut self) -> IerLineStatW<IerSpec> {
                IerLineStatW::new(self, 2)
            }
            #[doc = "Bit 6 - RW, UART TXD pin enable"]
            #[inline(always)]
            pub fn ier_txd_en(&mut self) -> IerTxdEnW<IerSpec> {
                IerTxdEnW::new(self, 6)
            }
            #[doc = "Bit 7 - WZ, UART software reset control, high action, auto clear"]
            #[inline(always)]
            pub fn ier_reset(&mut self) -> IerResetW<IerSpec> {
                IerResetW::new(self, 7)
            }
        }
        #[doc = "RW, UART2 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IerSpec;
        impl crate::RegisterSpec for IerSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`ier::R`](R) reader structure"]
        impl crate::Readable for IerSpec {}
        #[doc = "`write(|w| ..)` method takes [`ier::W`](W) writer structure"]
        impl crate::Writable for IerSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IER to value 0"]
        impl crate::Resettable for IerSpec {}
    }
    #[doc = "FCR (rw) register accessor: RW, UART2 FIFO control\n\nYou can [`read`](crate::Reg::read) this register and get [`fcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fcr`] module"]
    #[doc(alias = "FCR")]
    pub type Fcr = crate::Reg<fcr::FcrSpec>;
    #[doc = "RW, UART2 FIFO control"]
    pub mod fcr {
        #[doc = "Register `FCR` reader"]
        pub type R = crate::R<FcrSpec>;
        #[doc = "Register `FCR` writer"]
        pub type W = crate::W<FcrSpec>;
        #[doc = "Field `FCR_FIFO_EN` reader - RW, UART FIFO enable"]
        pub type FcrFifoEnR = crate::BitReader;
        #[doc = "Field `FCR_FIFO_EN` writer - RW, UART FIFO enable"]
        pub type FcrFifoEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FCR_RX_FIFO_CLR` reader - WZ, clear UART receiver FIFO, high action, auto clear"]
        pub type FcrRxFifoClrR = crate::BitReader;
        #[doc = "Field `FCR_RX_FIFO_CLR` writer - WZ, clear UART receiver FIFO, high action, auto clear"]
        pub type FcrRxFifoClrW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FCR_TX_FIFO_CLR` reader - WZ, clear UART transmitter FIFO, high action, auto clear"]
        pub type FcrTxFifoClrR = crate::BitReader;
        #[doc = "Field `FCR_TX_FIFO_CLR` writer - WZ, clear UART transmitter FIFO, high action, auto clear"]
        pub type FcrTxFifoClrW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FCR_FIFO_TRIG` reader - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"]
        pub type FcrFifoTrigR = crate::FieldReader;
        #[doc = "Field `FCR_FIFO_TRIG` writer - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"]
        pub type FcrFifoTrigW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            #[doc = "Bit 0 - RW, UART FIFO enable"]
            #[inline(always)]
            pub fn fcr_fifo_en(&self) -> FcrFifoEnR {
                FcrFifoEnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear"]
            #[inline(always)]
            pub fn fcr_rx_fifo_clr(&self) -> FcrRxFifoClrR {
                FcrRxFifoClrR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear"]
            #[inline(always)]
            pub fn fcr_tx_fifo_clr(&self) -> FcrTxFifoClrR {
                FcrTxFifoClrR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"]
            #[inline(always)]
            pub fn fcr_fifo_trig(&self) -> FcrFifoTrigR {
                FcrFifoTrigR::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, UART FIFO enable"]
            #[inline(always)]
            pub fn fcr_fifo_en(&mut self) -> FcrFifoEnW<FcrSpec> {
                FcrFifoEnW::new(self, 0)
            }
            #[doc = "Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear"]
            #[inline(always)]
            pub fn fcr_rx_fifo_clr(&mut self) -> FcrRxFifoClrW<FcrSpec> {
                FcrRxFifoClrW::new(self, 1)
            }
            #[doc = "Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear"]
            #[inline(always)]
            pub fn fcr_tx_fifo_clr(&mut self) -> FcrTxFifoClrW<FcrSpec> {
                FcrTxFifoClrW::new(self, 2)
            }
            #[doc = "Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"]
            #[inline(always)]
            pub fn fcr_fifo_trig(&mut self) -> FcrFifoTrigW<FcrSpec> {
                FcrFifoTrigW::new(self, 6)
            }
        }
        #[doc = "RW, UART2 FIFO control\n\nYou can [`read`](crate::Reg::read) this register and get [`fcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FcrSpec;
        impl crate::RegisterSpec for FcrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`fcr::R`](R) reader structure"]
        impl crate::Readable for FcrSpec {}
        #[doc = "`write(|w| ..)` method takes [`fcr::W`](W) writer structure"]
        impl crate::Writable for FcrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FCR to value 0"]
        impl crate::Resettable for FcrSpec {}
    }
    #[doc = "LCR (rw) register accessor: RW, UART2 line control\n\nYou can [`read`](crate::Reg::read) this register and get [`lcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lcr`] module"]
    #[doc(alias = "LCR")]
    pub type Lcr = crate::Reg<lcr::LcrSpec>;
    #[doc = "RW, UART2 line control"]
    pub mod lcr {
        #[doc = "Register `LCR` reader"]
        pub type R = crate::R<LcrSpec>;
        #[doc = "Register `LCR` writer"]
        pub type W = crate::W<LcrSpec>;
        #[doc = "Field `LCR_WORD_SZ` reader - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"]
        pub type LcrWordSzR = crate::FieldReader;
        #[doc = "Field `LCR_WORD_SZ` writer - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"]
        pub type LcrWordSzW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `LCR_STOP_BIT` reader - RW, UART stop bit length: 0-1bit, 1-2bit"]
        pub type LcrStopBitR = crate::BitReader;
        #[doc = "Field `LCR_STOP_BIT` writer - RW, UART stop bit length: 0-1bit, 1-2bit"]
        pub type LcrStopBitW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LCR_PAR_EN` reader - RW, UART parity enable"]
        pub type LcrParEnR = crate::BitReader;
        #[doc = "Field `LCR_PAR_EN` writer - RW, UART parity enable"]
        pub type LcrParEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LCR_PAR_MOD` reader - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"]
        pub type LcrParModR = crate::FieldReader;
        #[doc = "Field `LCR_PAR_MOD` writer - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"]
        pub type LcrParModW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `LCR_BREAK_EN` reader - RW, UART break control enable"]
        pub type LcrBreakEnR = crate::BitReader;
        #[doc = "Field `LCR_BREAK_EN` writer - RW, UART break control enable"]
        pub type LcrBreakEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LCR_GP_BIT` reader - RW, UART general purpose bit"]
        pub type LcrGpBitR = crate::BitReader;
        #[doc = "Field `LCR_GP_BIT` writer - RW, UART general purpose bit"]
        pub type LcrGpBitW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LCR_DLAB` reader - RW, UART reserved bit"]
        pub type LcrDlabR = crate::BitReader;
        #[doc = "Field `LCR_DLAB` writer - RW, UART reserved bit"]
        pub type LcrDlabW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"]
            #[inline(always)]
            pub fn lcr_word_sz(&self) -> LcrWordSzR {
                LcrWordSzR::new(self.bits & 3)
            }
            #[doc = "Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit"]
            #[inline(always)]
            pub fn lcr_stop_bit(&self) -> LcrStopBitR {
                LcrStopBitR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, UART parity enable"]
            #[inline(always)]
            pub fn lcr_par_en(&self) -> LcrParEnR {
                LcrParEnR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"]
            #[inline(always)]
            pub fn lcr_par_mod(&self) -> LcrParModR {
                LcrParModR::new((self.bits >> 4) & 3)
            }
            #[doc = "Bit 6 - RW, UART break control enable"]
            #[inline(always)]
            pub fn lcr_break_en(&self) -> LcrBreakEnR {
                LcrBreakEnR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RW, UART general purpose bit"]
            #[inline(always)]
            pub fn lcr_gp_bit(&self) -> LcrGpBitR {
                LcrGpBitR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 7 - RW, UART reserved bit"]
            #[inline(always)]
            pub fn lcr_dlab(&self) -> LcrDlabR {
                LcrDlabR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"]
            #[inline(always)]
            pub fn lcr_word_sz(&mut self) -> LcrWordSzW<LcrSpec> {
                LcrWordSzW::new(self, 0)
            }
            #[doc = "Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit"]
            #[inline(always)]
            pub fn lcr_stop_bit(&mut self) -> LcrStopBitW<LcrSpec> {
                LcrStopBitW::new(self, 2)
            }
            #[doc = "Bit 3 - RW, UART parity enable"]
            #[inline(always)]
            pub fn lcr_par_en(&mut self) -> LcrParEnW<LcrSpec> {
                LcrParEnW::new(self, 3)
            }
            #[doc = "Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"]
            #[inline(always)]
            pub fn lcr_par_mod(&mut self) -> LcrParModW<LcrSpec> {
                LcrParModW::new(self, 4)
            }
            #[doc = "Bit 6 - RW, UART break control enable"]
            #[inline(always)]
            pub fn lcr_break_en(&mut self) -> LcrBreakEnW<LcrSpec> {
                LcrBreakEnW::new(self, 6)
            }
            #[doc = "Bit 7 - RW, UART general purpose bit"]
            #[inline(always)]
            pub fn lcr_gp_bit(&mut self) -> LcrGpBitW<LcrSpec> {
                LcrGpBitW::new(self, 7)
            }
            #[doc = "Bit 7 - RW, UART reserved bit"]
            #[inline(always)]
            pub fn lcr_dlab(&mut self) -> LcrDlabW<LcrSpec> {
                LcrDlabW::new(self, 7)
            }
        }
        #[doc = "RW, UART2 line control\n\nYou can [`read`](crate::Reg::read) this register and get [`lcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct LcrSpec;
        impl crate::RegisterSpec for LcrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`lcr::R`](R) reader structure"]
        impl crate::Readable for LcrSpec {}
        #[doc = "`write(|w| ..)` method takes [`lcr::W`](W) writer structure"]
        impl crate::Writable for LcrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets LCR to value 0"]
        impl crate::Resettable for LcrSpec {}
    }
    #[doc = "IIR (r) register accessor: RO, UART2 interrupt identification\n\nYou can [`read`](crate::Reg::read) this register and get [`iir::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iir`] module"]
    #[doc(alias = "IIR")]
    pub type Iir = crate::Reg<iir::IirSpec>;
    #[doc = "RO, UART2 interrupt identification"]
    pub mod iir {
        #[doc = "Register `IIR` reader"]
        pub type R = crate::R<IirSpec>;
        #[doc = "Field `IIR_NO_INT` reader - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt"]
        pub type IirNoIntR = crate::BitReader;
        #[doc = "Field `IIR_INT_MASK` reader - RO, UART interrupt flag bit mask"]
        pub type IirIntMaskR = crate::FieldReader;
        #[doc = "Field `IIR_FIFO_ID` reader - RO, UART FIFO enabled flag"]
        pub type IirFifoIdR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt"]
            #[inline(always)]
            pub fn iir_no_int(&self) -> IirNoIntR {
                IirNoIntR::new((self.bits & 1) != 0)
            }
            #[doc = "Bits 0:3 - RO, UART interrupt flag bit mask"]
            #[inline(always)]
            pub fn iir_int_mask(&self) -> IirIntMaskR {
                IirIntMaskR::new(self.bits & 0x0f)
            }
            #[doc = "Bit 7 - RO, UART FIFO enabled flag"]
            #[inline(always)]
            pub fn iir_fifo_id(&self) -> IirFifoIdR {
                IirFifoIdR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        #[doc = "RO, UART2 interrupt identification\n\nYou can [`read`](crate::Reg::read) this register and get [`iir::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IirSpec;
        impl crate::RegisterSpec for IirSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`iir::R`](R) reader structure"]
        impl crate::Readable for IirSpec {}
        #[doc = "`reset()` method sets IIR to value 0x01"]
        impl crate::Resettable for IirSpec {
            const RESET_VALUE: u8 = 0x01;
        }
    }
    #[doc = "LSR (r) register accessor: RO, UART2 line status\n\nYou can [`read`](crate::Reg::read) this register and get [`lsr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lsr`] module"]
    #[doc(alias = "LSR")]
    pub type Lsr = crate::Reg<lsr::LsrSpec>;
    #[doc = "RO, UART2 line status"]
    pub mod lsr {
        #[doc = "Register `LSR` reader"]
        pub type R = crate::R<LsrSpec>;
        #[doc = "Field `LSR_DATA_RDY` reader - RO, UART receiver fifo data ready status"]
        pub type LsrDataRdyR = crate::BitReader;
        #[doc = "Field `LSR_OVER_ERR` reader - RZ, UART receiver overrun error"]
        pub type LsrOverErrR = crate::BitReader;
        #[doc = "Field `LSR_PAR_ERR` reader - RZ, UART receiver parity error"]
        pub type LsrParErrR = crate::BitReader;
        #[doc = "Field `LSR_FRAME_ERR` reader - RZ, UART receiver frame error"]
        pub type LsrFrameErrR = crate::BitReader;
        #[doc = "Field `LSR_BREAK_ERR` reader - RZ, UART receiver break error"]
        pub type LsrBreakErrR = crate::BitReader;
        #[doc = "Field `LSR_TX_FIFO_EMP` reader - RO, UART transmitter fifo empty status"]
        pub type LsrTxFifoEmpR = crate::BitReader;
        #[doc = "Field `LSR_TX_ALL_EMP` reader - RO, UART transmitter all empty status"]
        pub type LsrTxAllEmpR = crate::BitReader;
        #[doc = "Field `LSR_ERR_RX_FIFO` reader - RO, indicate error in UART receiver fifo"]
        pub type LsrErrRxFifoR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - RO, UART receiver fifo data ready status"]
            #[inline(always)]
            pub fn lsr_data_rdy(&self) -> LsrDataRdyR {
                LsrDataRdyR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RZ, UART receiver overrun error"]
            #[inline(always)]
            pub fn lsr_over_err(&self) -> LsrOverErrR {
                LsrOverErrR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RZ, UART receiver parity error"]
            #[inline(always)]
            pub fn lsr_par_err(&self) -> LsrParErrR {
                LsrParErrR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RZ, UART receiver frame error"]
            #[inline(always)]
            pub fn lsr_frame_err(&self) -> LsrFrameErrR {
                LsrFrameErrR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RZ, UART receiver break error"]
            #[inline(always)]
            pub fn lsr_break_err(&self) -> LsrBreakErrR {
                LsrBreakErrR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RO, UART transmitter fifo empty status"]
            #[inline(always)]
            pub fn lsr_tx_fifo_emp(&self) -> LsrTxFifoEmpR {
                LsrTxFifoEmpR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RO, UART transmitter all empty status"]
            #[inline(always)]
            pub fn lsr_tx_all_emp(&self) -> LsrTxAllEmpR {
                LsrTxAllEmpR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RO, indicate error in UART receiver fifo"]
            #[inline(always)]
            pub fn lsr_err_rx_fifo(&self) -> LsrErrRxFifoR {
                LsrErrRxFifoR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        #[doc = "RO, UART2 line status\n\nYou can [`read`](crate::Reg::read) this register and get [`lsr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct LsrSpec;
        impl crate::RegisterSpec for LsrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`lsr::R`](R) reader structure"]
        impl crate::Readable for LsrSpec {}
        #[doc = "`reset()` method sets LSR to value 0x60"]
        impl crate::Resettable for LsrSpec {
            const RESET_VALUE: u8 = 0x60;
        }
    }
    #[doc = "RBR (r) register accessor: RO, UART2 receiver buffer, receiving byte\n\nYou can [`read`](crate::Reg::read) this register and get [`rbr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rbr`] module"]
    #[doc(alias = "RBR")]
    pub type Rbr = crate::Reg<rbr::RbrSpec>;
    #[doc = "RO, UART2 receiver buffer, receiving byte"]
    pub mod rbr {
        #[doc = "Register `RBR` reader"]
        pub type R = crate::R<RbrSpec>;
        #[doc = "Field `RBR` reader - RO, UART2 receiver buffer, receiving byte"]
        pub type RbrR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RO, UART2 receiver buffer, receiving byte"]
            #[inline(always)]
            pub fn rbr(&self) -> RbrR {
                RbrR::new(self.bits)
            }
        }
        #[doc = "RO, UART2 receiver buffer, receiving byte\n\nYou can [`read`](crate::Reg::read) this register and get [`rbr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RbrSpec;
        impl crate::RegisterSpec for RbrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`rbr::R`](R) reader structure"]
        impl crate::Readable for RbrSpec {}
        #[doc = "`reset()` method sets RBR to value 0"]
        impl crate::Resettable for RbrSpec {}
    }
    #[doc = "THR (w) register accessor: WO, UART2 transmitter holding, transmittal byte\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`thr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@thr`] module"]
    #[doc(alias = "THR")]
    pub type Thr = crate::Reg<thr::ThrSpec>;
    #[doc = "WO, UART2 transmitter holding, transmittal byte"]
    pub mod thr {
        #[doc = "Register `THR` writer"]
        pub type W = crate::W<ThrSpec>;
        #[doc = "Field `THR` writer - WO, UART2 transmitter holding, transmittal byte"]
        pub type ThrW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl W {
            #[doc = "Bits 0:7 - WO, UART2 transmitter holding, transmittal byte"]
            #[inline(always)]
            pub fn thr(&mut self) -> ThrW<ThrSpec> {
                ThrW::new(self, 0)
            }
        }
        #[doc = "WO, UART2 transmitter holding, transmittal byte\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`thr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ThrSpec;
        impl crate::RegisterSpec for ThrSpec {
            type Ux = u8;
        }
        #[doc = "`write(|w| ..)` method takes [`thr::W`](W) writer structure"]
        impl crate::Writable for ThrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets THR to value 0"]
        impl crate::Resettable for ThrSpec {}
    }
    #[doc = "RFC (r) register accessor: RO, UART2 receiver FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`rfc::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rfc`] module"]
    #[doc(alias = "RFC")]
    pub type Rfc = crate::Reg<rfc::RfcSpec>;
    #[doc = "RO, UART2 receiver FIFO count"]
    pub mod rfc {
        #[doc = "Register `RFC` reader"]
        pub type R = crate::R<RfcSpec>;
        #[doc = "Field `RFC` reader - RO, UART2 receiver FIFO count"]
        pub type RfcR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RO, UART2 receiver FIFO count"]
            #[inline(always)]
            pub fn rfc(&self) -> RfcR {
                RfcR::new(self.bits)
            }
        }
        #[doc = "RO, UART2 receiver FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`rfc::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RfcSpec;
        impl crate::RegisterSpec for RfcSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`rfc::R`](R) reader structure"]
        impl crate::Readable for RfcSpec {}
        #[doc = "`reset()` method sets RFC to value 0"]
        impl crate::Resettable for RfcSpec {}
    }
    #[doc = "TFC (r) register accessor: RO, UART2 transmitter FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`tfc::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tfc`] module"]
    #[doc(alias = "TFC")]
    pub type Tfc = crate::Reg<tfc::TfcSpec>;
    #[doc = "RO, UART2 transmitter FIFO count"]
    pub mod tfc {
        #[doc = "Register `TFC` reader"]
        pub type R = crate::R<TfcSpec>;
        #[doc = "Field `TFC` reader - RO, UART2 transmitter FIFO count"]
        pub type TfcR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RO, UART2 transmitter FIFO count"]
            #[inline(always)]
            pub fn tfc(&self) -> TfcR {
                TfcR::new(self.bits)
            }
        }
        #[doc = "RO, UART2 transmitter FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`tfc::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TfcSpec;
        impl crate::RegisterSpec for TfcSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`tfc::R`](R) reader structure"]
        impl crate::Readable for TfcSpec {}
        #[doc = "`reset()` method sets TFC to value 0"]
        impl crate::Resettable for TfcSpec {}
    }
    #[doc = "DL (rw) register accessor: RW, UART2 divisor latch\n\nYou can [`read`](crate::Reg::read) this register and get [`dl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dl`] module"]
    #[doc(alias = "DL")]
    pub type Dl = crate::Reg<dl::DlSpec>;
    #[doc = "RW, UART2 divisor latch"]
    pub mod dl {
        #[doc = "Register `DL` reader"]
        pub type R = crate::R<DlSpec>;
        #[doc = "Register `DL` writer"]
        pub type W = crate::W<DlSpec>;
        #[doc = "Field `DL` reader - RW, UART2 divisor latch"]
        pub type DlR = crate::FieldReader<u16>;
        #[doc = "Field `DL` writer - RW, UART2 divisor latch"]
        pub type DlW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW, UART2 divisor latch"]
            #[inline(always)]
            pub fn dl(&self) -> DlR {
                DlR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW, UART2 divisor latch"]
            #[inline(always)]
            pub fn dl(&mut self) -> DlW<DlSpec> {
                DlW::new(self, 0)
            }
        }
        #[doc = "RW, UART2 divisor latch\n\nYou can [`read`](crate::Reg::read) this register and get [`dl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DlSpec;
        impl crate::RegisterSpec for DlSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`dl::R`](R) reader structure"]
        impl crate::Readable for DlSpec {}
        #[doc = "`write(|w| ..)` method takes [`dl::W`](W) writer structure"]
        impl crate::Writable for DlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DL to value 0"]
        impl crate::Resettable for DlSpec {}
    }
    #[doc = "DIV (rw) register accessor: RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128\n\nYou can [`read`](crate::Reg::read) this register and get [`div::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@div`] module"]
    #[doc(alias = "DIV")]
    pub type Div = crate::Reg<div::DivSpec>;
    #[doc = "RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
    pub mod div {
        #[doc = "Register `DIV` reader"]
        pub type R = crate::R<DivSpec>;
        #[doc = "Register `DIV` writer"]
        pub type W = crate::W<DivSpec>;
        #[doc = "Field `DIV` reader - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
        pub type DivR = crate::FieldReader;
        #[doc = "Field `DIV` writer - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
        pub type DivW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
            #[inline(always)]
            pub fn div(&self) -> DivR {
                DivR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
            #[inline(always)]
            pub fn div(&mut self) -> DivW<DivSpec> {
                DivW::new(self, 0)
            }
        }
        #[doc = "RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128\n\nYou can [`read`](crate::Reg::read) this register and get [`div::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DivSpec;
        impl crate::RegisterSpec for DivSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`div::R`](R) reader structure"]
        impl crate::Readable for DivSpec {}
        #[doc = "`write(|w| ..)` method takes [`div::W`](W) writer structure"]
        impl crate::Writable for DivSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DIV to value 0"]
        impl crate::Resettable for DivSpec {}
    }
}
#[doc = "UART3 register"]
pub type Uart3 = crate::Periph<uart3::RegisterBlock, 0x4000_3c00>;
impl core::fmt::Debug for Uart3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Uart3").finish()
    }
}
#[doc = "UART3 register"]
pub mod uart3 {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        mcr: Mcr,
        ier: Ier,
        fcr: Fcr,
        lcr: Lcr,
        iir: Iir,
        lsr: Lsr,
        _reserved6: [u8; 0x02],
        _reserved_6_rbr: [u8; 0x01],
        _reserved7: [u8; 0x01],
        rfc: Rfc,
        tfc: Tfc,
        dl: Dl,
        div: Div,
    }
    impl RegisterBlock {
        #[doc = "0x00 - RW, UART3 modem control"]
        #[inline(always)]
        pub const fn mcr(&self) -> &Mcr {
            &self.mcr
        }
        #[doc = "0x01 - RW, UART3 interrupt enable"]
        #[inline(always)]
        pub const fn ier(&self) -> &Ier {
            &self.ier
        }
        #[doc = "0x02 - RW, UART3 FIFO control"]
        #[inline(always)]
        pub const fn fcr(&self) -> &Fcr {
            &self.fcr
        }
        #[doc = "0x03 - RW, UART3 line control"]
        #[inline(always)]
        pub const fn lcr(&self) -> &Lcr {
            &self.lcr
        }
        #[doc = "0x04 - RO, UART3 interrupt identification"]
        #[inline(always)]
        pub const fn iir(&self) -> &Iir {
            &self.iir
        }
        #[doc = "0x05 - RO, UART3 line status"]
        #[inline(always)]
        pub const fn lsr(&self) -> &Lsr {
            &self.lsr
        }
        #[doc = "0x08 - WO, UART3 transmitter holding, transmittal byte"]
        #[inline(always)]
        pub const fn thr(&self) -> &Thr {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(8).cast() }
        }
        #[doc = "0x08 - RO, UART3 receiver buffer, receiving byte"]
        #[inline(always)]
        pub const fn rbr(&self) -> &Rbr {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(8).cast() }
        }
        #[doc = "0x0a - RO, UART3 receiver FIFO count"]
        #[inline(always)]
        pub const fn rfc(&self) -> &Rfc {
            &self.rfc
        }
        #[doc = "0x0b - RO, UART3 transmitter FIFO count"]
        #[inline(always)]
        pub const fn tfc(&self) -> &Tfc {
            &self.tfc
        }
        #[doc = "0x0c - RW, UART3 divisor latch"]
        #[inline(always)]
        pub const fn dl(&self) -> &Dl {
            &self.dl
        }
        #[doc = "0x0e - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
        #[inline(always)]
        pub const fn div(&self) -> &Div {
            &self.div
        }
    }
    #[doc = "MCR (rw) register accessor: RW, UART3 modem control\n\nYou can [`read`](crate::Reg::read) this register and get [`mcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mcr`] module"]
    #[doc(alias = "MCR")]
    pub type Mcr = crate::Reg<mcr::McrSpec>;
    #[doc = "RW, UART3 modem control"]
    pub mod mcr {
        #[doc = "Register `MCR` reader"]
        pub type R = crate::R<McrSpec>;
        #[doc = "Register `MCR` writer"]
        pub type W = crate::W<McrSpec>;
        #[doc = "Field `MCR_OUT2` reader - RW, UART control OUT2"]
        pub type McrOut2R = crate::BitReader;
        #[doc = "Field `MCR_OUT2` writer - RW, UART control OUT2"]
        pub type McrOut2W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MCR_INT_OE` reader - RW, UART interrupt output enable"]
        pub type McrIntOeR = crate::BitReader;
        #[doc = "Field `MCR_INT_OE` writer - RW, UART interrupt output enable"]
        pub type McrIntOeW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 3 - RW, UART control OUT2"]
            #[inline(always)]
            pub fn mcr_out2(&self) -> McrOut2R {
                McrOut2R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, UART interrupt output enable"]
            #[inline(always)]
            pub fn mcr_int_oe(&self) -> McrIntOeR {
                McrIntOeR::new(((self.bits >> 3) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 3 - RW, UART control OUT2"]
            #[inline(always)]
            pub fn mcr_out2(&mut self) -> McrOut2W<McrSpec> {
                McrOut2W::new(self, 3)
            }
            #[doc = "Bit 3 - RW, UART interrupt output enable"]
            #[inline(always)]
            pub fn mcr_int_oe(&mut self) -> McrIntOeW<McrSpec> {
                McrIntOeW::new(self, 3)
            }
        }
        #[doc = "RW, UART3 modem control\n\nYou can [`read`](crate::Reg::read) this register and get [`mcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct McrSpec;
        impl crate::RegisterSpec for McrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`mcr::R`](R) reader structure"]
        impl crate::Readable for McrSpec {}
        #[doc = "`write(|w| ..)` method takes [`mcr::W`](W) writer structure"]
        impl crate::Writable for McrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets MCR to value 0"]
        impl crate::Resettable for McrSpec {}
    }
    #[doc = "IER (rw) register accessor: RW, UART3 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ier`] module"]
    #[doc(alias = "IER")]
    pub type Ier = crate::Reg<ier::IerSpec>;
    #[doc = "RW, UART3 interrupt enable"]
    pub mod ier {
        #[doc = "Register `IER` reader"]
        pub type R = crate::R<IerSpec>;
        #[doc = "Register `IER` writer"]
        pub type W = crate::W<IerSpec>;
        #[doc = "Field `IER_RECV_RDY` reader - RW, UART interrupt enable for receiver data ready"]
        pub type IerRecvRdyR = crate::BitReader;
        #[doc = "Field `IER_RECV_RDY` writer - RW, UART interrupt enable for receiver data ready"]
        pub type IerRecvRdyW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IER_THR_EMPTY` reader - RW, UART interrupt enable for THR empty"]
        pub type IerThrEmptyR = crate::BitReader;
        #[doc = "Field `IER_THR_EMPTY` writer - RW, UART interrupt enable for THR empty"]
        pub type IerThrEmptyW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IER_LINE_STAT` reader - RW, UART interrupt enable for receiver line status"]
        pub type IerLineStatR = crate::BitReader;
        #[doc = "Field `IER_LINE_STAT` writer - RW, UART interrupt enable for receiver line status"]
        pub type IerLineStatW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IER_TXD_EN` reader - RW, UART TXD pin enable"]
        pub type IerTxdEnR = crate::BitReader;
        #[doc = "Field `IER_TXD_EN` writer - RW, UART TXD pin enable"]
        pub type IerTxdEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IER_RESET` reader - WZ, UART software reset control, high action, auto clear"]
        pub type IerResetR = crate::BitReader;
        #[doc = "Field `IER_RESET` writer - WZ, UART software reset control, high action, auto clear"]
        pub type IerResetW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, UART interrupt enable for receiver data ready"]
            #[inline(always)]
            pub fn ier_recv_rdy(&self) -> IerRecvRdyR {
                IerRecvRdyR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, UART interrupt enable for THR empty"]
            #[inline(always)]
            pub fn ier_thr_empty(&self) -> IerThrEmptyR {
                IerThrEmptyR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW, UART interrupt enable for receiver line status"]
            #[inline(always)]
            pub fn ier_line_stat(&self) -> IerLineStatR {
                IerLineStatR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 6 - RW, UART TXD pin enable"]
            #[inline(always)]
            pub fn ier_txd_en(&self) -> IerTxdEnR {
                IerTxdEnR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - WZ, UART software reset control, high action, auto clear"]
            #[inline(always)]
            pub fn ier_reset(&self) -> IerResetR {
                IerResetR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, UART interrupt enable for receiver data ready"]
            #[inline(always)]
            pub fn ier_recv_rdy(&mut self) -> IerRecvRdyW<IerSpec> {
                IerRecvRdyW::new(self, 0)
            }
            #[doc = "Bit 1 - RW, UART interrupt enable for THR empty"]
            #[inline(always)]
            pub fn ier_thr_empty(&mut self) -> IerThrEmptyW<IerSpec> {
                IerThrEmptyW::new(self, 1)
            }
            #[doc = "Bit 2 - RW, UART interrupt enable for receiver line status"]
            #[inline(always)]
            pub fn ier_line_stat(&mut self) -> IerLineStatW<IerSpec> {
                IerLineStatW::new(self, 2)
            }
            #[doc = "Bit 6 - RW, UART TXD pin enable"]
            #[inline(always)]
            pub fn ier_txd_en(&mut self) -> IerTxdEnW<IerSpec> {
                IerTxdEnW::new(self, 6)
            }
            #[doc = "Bit 7 - WZ, UART software reset control, high action, auto clear"]
            #[inline(always)]
            pub fn ier_reset(&mut self) -> IerResetW<IerSpec> {
                IerResetW::new(self, 7)
            }
        }
        #[doc = "RW, UART3 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IerSpec;
        impl crate::RegisterSpec for IerSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`ier::R`](R) reader structure"]
        impl crate::Readable for IerSpec {}
        #[doc = "`write(|w| ..)` method takes [`ier::W`](W) writer structure"]
        impl crate::Writable for IerSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IER to value 0"]
        impl crate::Resettable for IerSpec {}
    }
    #[doc = "FCR (rw) register accessor: RW, UART3 FIFO control\n\nYou can [`read`](crate::Reg::read) this register and get [`fcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fcr`] module"]
    #[doc(alias = "FCR")]
    pub type Fcr = crate::Reg<fcr::FcrSpec>;
    #[doc = "RW, UART3 FIFO control"]
    pub mod fcr {
        #[doc = "Register `FCR` reader"]
        pub type R = crate::R<FcrSpec>;
        #[doc = "Register `FCR` writer"]
        pub type W = crate::W<FcrSpec>;
        #[doc = "Field `FCR_FIFO_EN` reader - RW, UART FIFO enable"]
        pub type FcrFifoEnR = crate::BitReader;
        #[doc = "Field `FCR_FIFO_EN` writer - RW, UART FIFO enable"]
        pub type FcrFifoEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FCR_RX_FIFO_CLR` reader - WZ, clear UART receiver FIFO, high action, auto clear"]
        pub type FcrRxFifoClrR = crate::BitReader;
        #[doc = "Field `FCR_RX_FIFO_CLR` writer - WZ, clear UART receiver FIFO, high action, auto clear"]
        pub type FcrRxFifoClrW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FCR_TX_FIFO_CLR` reader - WZ, clear UART transmitter FIFO, high action, auto clear"]
        pub type FcrTxFifoClrR = crate::BitReader;
        #[doc = "Field `FCR_TX_FIFO_CLR` writer - WZ, clear UART transmitter FIFO, high action, auto clear"]
        pub type FcrTxFifoClrW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `FCR_FIFO_TRIG` reader - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"]
        pub type FcrFifoTrigR = crate::FieldReader;
        #[doc = "Field `FCR_FIFO_TRIG` writer - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"]
        pub type FcrFifoTrigW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        impl R {
            #[doc = "Bit 0 - RW, UART FIFO enable"]
            #[inline(always)]
            pub fn fcr_fifo_en(&self) -> FcrFifoEnR {
                FcrFifoEnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear"]
            #[inline(always)]
            pub fn fcr_rx_fifo_clr(&self) -> FcrRxFifoClrR {
                FcrRxFifoClrR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear"]
            #[inline(always)]
            pub fn fcr_tx_fifo_clr(&self) -> FcrTxFifoClrR {
                FcrTxFifoClrR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"]
            #[inline(always)]
            pub fn fcr_fifo_trig(&self) -> FcrFifoTrigR {
                FcrFifoTrigR::new((self.bits >> 6) & 3)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, UART FIFO enable"]
            #[inline(always)]
            pub fn fcr_fifo_en(&mut self) -> FcrFifoEnW<FcrSpec> {
                FcrFifoEnW::new(self, 0)
            }
            #[doc = "Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear"]
            #[inline(always)]
            pub fn fcr_rx_fifo_clr(&mut self) -> FcrRxFifoClrW<FcrSpec> {
                FcrRxFifoClrW::new(self, 1)
            }
            #[doc = "Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear"]
            #[inline(always)]
            pub fn fcr_tx_fifo_clr(&mut self) -> FcrTxFifoClrW<FcrSpec> {
                FcrTxFifoClrW::new(self, 2)
            }
            #[doc = "Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"]
            #[inline(always)]
            pub fn fcr_fifo_trig(&mut self) -> FcrFifoTrigW<FcrSpec> {
                FcrFifoTrigW::new(self, 6)
            }
        }
        #[doc = "RW, UART3 FIFO control\n\nYou can [`read`](crate::Reg::read) this register and get [`fcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FcrSpec;
        impl crate::RegisterSpec for FcrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`fcr::R`](R) reader structure"]
        impl crate::Readable for FcrSpec {}
        #[doc = "`write(|w| ..)` method takes [`fcr::W`](W) writer structure"]
        impl crate::Writable for FcrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FCR to value 0"]
        impl crate::Resettable for FcrSpec {}
    }
    #[doc = "LCR (rw) register accessor: RW, UART3 line control\n\nYou can [`read`](crate::Reg::read) this register and get [`lcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lcr`] module"]
    #[doc(alias = "LCR")]
    pub type Lcr = crate::Reg<lcr::LcrSpec>;
    #[doc = "RW, UART3 line control"]
    pub mod lcr {
        #[doc = "Register `LCR` reader"]
        pub type R = crate::R<LcrSpec>;
        #[doc = "Register `LCR` writer"]
        pub type W = crate::W<LcrSpec>;
        #[doc = "Field `LCR_WORD_SZ` reader - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"]
        pub type LcrWordSzR = crate::FieldReader;
        #[doc = "Field `LCR_WORD_SZ` writer - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"]
        pub type LcrWordSzW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `LCR_STOP_BIT` reader - RW, UART stop bit length: 0-1bit, 1-2bit"]
        pub type LcrStopBitR = crate::BitReader;
        #[doc = "Field `LCR_STOP_BIT` writer - RW, UART stop bit length: 0-1bit, 1-2bit"]
        pub type LcrStopBitW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LCR_PAR_EN` reader - RW, UART parity enable"]
        pub type LcrParEnR = crate::BitReader;
        #[doc = "Field `LCR_PAR_EN` writer - RW, UART parity enable"]
        pub type LcrParEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LCR_PAR_MOD` reader - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"]
        pub type LcrParModR = crate::FieldReader;
        #[doc = "Field `LCR_PAR_MOD` writer - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"]
        pub type LcrParModW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `LCR_BREAK_EN` reader - RW, UART break control enable"]
        pub type LcrBreakEnR = crate::BitReader;
        #[doc = "Field `LCR_BREAK_EN` writer - RW, UART break control enable"]
        pub type LcrBreakEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LCR_GP_BIT` reader - RW, UART general purpose bit"]
        pub type LcrGpBitR = crate::BitReader;
        #[doc = "Field `LCR_GP_BIT` writer - RW, UART general purpose bit"]
        pub type LcrGpBitW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LCR_DLAB` reader - RW, UART reserved bit"]
        pub type LcrDlabR = crate::BitReader;
        #[doc = "Field `LCR_DLAB` writer - RW, UART reserved bit"]
        pub type LcrDlabW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"]
            #[inline(always)]
            pub fn lcr_word_sz(&self) -> LcrWordSzR {
                LcrWordSzR::new(self.bits & 3)
            }
            #[doc = "Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit"]
            #[inline(always)]
            pub fn lcr_stop_bit(&self) -> LcrStopBitR {
                LcrStopBitR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, UART parity enable"]
            #[inline(always)]
            pub fn lcr_par_en(&self) -> LcrParEnR {
                LcrParEnR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"]
            #[inline(always)]
            pub fn lcr_par_mod(&self) -> LcrParModR {
                LcrParModR::new((self.bits >> 4) & 3)
            }
            #[doc = "Bit 6 - RW, UART break control enable"]
            #[inline(always)]
            pub fn lcr_break_en(&self) -> LcrBreakEnR {
                LcrBreakEnR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RW, UART general purpose bit"]
            #[inline(always)]
            pub fn lcr_gp_bit(&self) -> LcrGpBitR {
                LcrGpBitR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 7 - RW, UART reserved bit"]
            #[inline(always)]
            pub fn lcr_dlab(&self) -> LcrDlabR {
                LcrDlabR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"]
            #[inline(always)]
            pub fn lcr_word_sz(&mut self) -> LcrWordSzW<LcrSpec> {
                LcrWordSzW::new(self, 0)
            }
            #[doc = "Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit"]
            #[inline(always)]
            pub fn lcr_stop_bit(&mut self) -> LcrStopBitW<LcrSpec> {
                LcrStopBitW::new(self, 2)
            }
            #[doc = "Bit 3 - RW, UART parity enable"]
            #[inline(always)]
            pub fn lcr_par_en(&mut self) -> LcrParEnW<LcrSpec> {
                LcrParEnW::new(self, 3)
            }
            #[doc = "Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"]
            #[inline(always)]
            pub fn lcr_par_mod(&mut self) -> LcrParModW<LcrSpec> {
                LcrParModW::new(self, 4)
            }
            #[doc = "Bit 6 - RW, UART break control enable"]
            #[inline(always)]
            pub fn lcr_break_en(&mut self) -> LcrBreakEnW<LcrSpec> {
                LcrBreakEnW::new(self, 6)
            }
            #[doc = "Bit 7 - RW, UART general purpose bit"]
            #[inline(always)]
            pub fn lcr_gp_bit(&mut self) -> LcrGpBitW<LcrSpec> {
                LcrGpBitW::new(self, 7)
            }
            #[doc = "Bit 7 - RW, UART reserved bit"]
            #[inline(always)]
            pub fn lcr_dlab(&mut self) -> LcrDlabW<LcrSpec> {
                LcrDlabW::new(self, 7)
            }
        }
        #[doc = "RW, UART3 line control\n\nYou can [`read`](crate::Reg::read) this register and get [`lcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct LcrSpec;
        impl crate::RegisterSpec for LcrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`lcr::R`](R) reader structure"]
        impl crate::Readable for LcrSpec {}
        #[doc = "`write(|w| ..)` method takes [`lcr::W`](W) writer structure"]
        impl crate::Writable for LcrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets LCR to value 0"]
        impl crate::Resettable for LcrSpec {}
    }
    #[doc = "IIR (r) register accessor: RO, UART3 interrupt identification\n\nYou can [`read`](crate::Reg::read) this register and get [`iir::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iir`] module"]
    #[doc(alias = "IIR")]
    pub type Iir = crate::Reg<iir::IirSpec>;
    #[doc = "RO, UART3 interrupt identification"]
    pub mod iir {
        #[doc = "Register `IIR` reader"]
        pub type R = crate::R<IirSpec>;
        #[doc = "Field `IIR_NO_INT` reader - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt"]
        pub type IirNoIntR = crate::BitReader;
        #[doc = "Field `IIR_INT_MASK` reader - RO, UART interrupt flag bit mask"]
        pub type IirIntMaskR = crate::FieldReader;
        #[doc = "Field `IIR_FIFO_ID` reader - RO, UART FIFO enabled flag"]
        pub type IirFifoIdR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt"]
            #[inline(always)]
            pub fn iir_no_int(&self) -> IirNoIntR {
                IirNoIntR::new((self.bits & 1) != 0)
            }
            #[doc = "Bits 1:3 - RO, UART interrupt flag bit mask"]
            #[inline(always)]
            pub fn iir_int_mask(&self) -> IirIntMaskR {
                IirIntMaskR::new((self.bits >> 1) & 7)
            }
            #[doc = "Bit 7 - RO, UART FIFO enabled flag"]
            #[inline(always)]
            pub fn iir_fifo_id(&self) -> IirFifoIdR {
                IirFifoIdR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        #[doc = "RO, UART3 interrupt identification\n\nYou can [`read`](crate::Reg::read) this register and get [`iir::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IirSpec;
        impl crate::RegisterSpec for IirSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`iir::R`](R) reader structure"]
        impl crate::Readable for IirSpec {}
        #[doc = "`reset()` method sets IIR to value 0x01"]
        impl crate::Resettable for IirSpec {
            const RESET_VALUE: u8 = 0x01;
        }
    }
    #[doc = "LSR (r) register accessor: RO, UART3 line status\n\nYou can [`read`](crate::Reg::read) this register and get [`lsr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lsr`] module"]
    #[doc(alias = "LSR")]
    pub type Lsr = crate::Reg<lsr::LsrSpec>;
    #[doc = "RO, UART3 line status"]
    pub mod lsr {
        #[doc = "Register `LSR` reader"]
        pub type R = crate::R<LsrSpec>;
        #[doc = "Field `LSR_DATA_RDY` reader - RO, UART receiver fifo data ready status"]
        pub type LsrDataRdyR = crate::BitReader;
        #[doc = "Field `LSR_OVER_ERR` reader - RZ, UART receiver overrun error"]
        pub type LsrOverErrR = crate::BitReader;
        #[doc = "Field `LSR_PAR_ERR` reader - RZ, UART receiver parity error"]
        pub type LsrParErrR = crate::BitReader;
        #[doc = "Field `LSR_FRAME_ERR` reader - RZ, UART receiver frame error"]
        pub type LsrFrameErrR = crate::BitReader;
        #[doc = "Field `LSR_BREAK_ERR` reader - RZ, UART receiver break error"]
        pub type LsrBreakErrR = crate::BitReader;
        #[doc = "Field `LSR_TX_FIFO_EMP` reader - RO, UART transmitter fifo empty status"]
        pub type LsrTxFifoEmpR = crate::BitReader;
        #[doc = "Field `LSR_TX_ALL_EMP` reader - RO, UART transmitter all empty status"]
        pub type LsrTxAllEmpR = crate::BitReader;
        #[doc = "Field `LSR_ERR_RX_FIFO` reader - RO, indicate error in UART receiver fifo"]
        pub type LsrErrRxFifoR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - RO, UART receiver fifo data ready status"]
            #[inline(always)]
            pub fn lsr_data_rdy(&self) -> LsrDataRdyR {
                LsrDataRdyR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RZ, UART receiver overrun error"]
            #[inline(always)]
            pub fn lsr_over_err(&self) -> LsrOverErrR {
                LsrOverErrR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RZ, UART receiver parity error"]
            #[inline(always)]
            pub fn lsr_par_err(&self) -> LsrParErrR {
                LsrParErrR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RZ, UART receiver frame error"]
            #[inline(always)]
            pub fn lsr_frame_err(&self) -> LsrFrameErrR {
                LsrFrameErrR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RZ, UART receiver break error"]
            #[inline(always)]
            pub fn lsr_break_err(&self) -> LsrBreakErrR {
                LsrBreakErrR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RO, UART transmitter fifo empty status"]
            #[inline(always)]
            pub fn lsr_tx_fifo_emp(&self) -> LsrTxFifoEmpR {
                LsrTxFifoEmpR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RO, UART transmitter all empty status"]
            #[inline(always)]
            pub fn lsr_tx_all_emp(&self) -> LsrTxAllEmpR {
                LsrTxAllEmpR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RO, indicate error in UART receiver fifo"]
            #[inline(always)]
            pub fn lsr_err_rx_fifo(&self) -> LsrErrRxFifoR {
                LsrErrRxFifoR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        #[doc = "RO, UART3 line status\n\nYou can [`read`](crate::Reg::read) this register and get [`lsr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct LsrSpec;
        impl crate::RegisterSpec for LsrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`lsr::R`](R) reader structure"]
        impl crate::Readable for LsrSpec {}
        #[doc = "`reset()` method sets LSR to value 0x60"]
        impl crate::Resettable for LsrSpec {
            const RESET_VALUE: u8 = 0x60;
        }
    }
    #[doc = "RBR (r) register accessor: RO, UART3 receiver buffer, receiving byte\n\nYou can [`read`](crate::Reg::read) this register and get [`rbr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rbr`] module"]
    #[doc(alias = "RBR")]
    pub type Rbr = crate::Reg<rbr::RbrSpec>;
    #[doc = "RO, UART3 receiver buffer, receiving byte"]
    pub mod rbr {
        #[doc = "Register `RBR` reader"]
        pub type R = crate::R<RbrSpec>;
        #[doc = "Field `RBR` reader - RO, UART3 receiver buffer, receiving byte"]
        pub type RbrR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RO, UART3 receiver buffer, receiving byte"]
            #[inline(always)]
            pub fn rbr(&self) -> RbrR {
                RbrR::new(self.bits)
            }
        }
        #[doc = "RO, UART3 receiver buffer, receiving byte\n\nYou can [`read`](crate::Reg::read) this register and get [`rbr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RbrSpec;
        impl crate::RegisterSpec for RbrSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`rbr::R`](R) reader structure"]
        impl crate::Readable for RbrSpec {}
        #[doc = "`reset()` method sets RBR to value 0"]
        impl crate::Resettable for RbrSpec {}
    }
    #[doc = "THR (w) register accessor: WO, UART3 transmitter holding, transmittal byte\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`thr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@thr`] module"]
    #[doc(alias = "THR")]
    pub type Thr = crate::Reg<thr::ThrSpec>;
    #[doc = "WO, UART3 transmitter holding, transmittal byte"]
    pub mod thr {
        #[doc = "Register `THR` writer"]
        pub type W = crate::W<ThrSpec>;
        #[doc = "Field `THR` writer - WO, UART3 transmitter holding, transmittal byte"]
        pub type ThrW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl W {
            #[doc = "Bits 0:7 - WO, UART3 transmitter holding, transmittal byte"]
            #[inline(always)]
            pub fn thr(&mut self) -> ThrW<ThrSpec> {
                ThrW::new(self, 0)
            }
        }
        #[doc = "WO, UART3 transmitter holding, transmittal byte\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`thr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ThrSpec;
        impl crate::RegisterSpec for ThrSpec {
            type Ux = u8;
        }
        #[doc = "`write(|w| ..)` method takes [`thr::W`](W) writer structure"]
        impl crate::Writable for ThrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets THR to value 0"]
        impl crate::Resettable for ThrSpec {}
    }
    #[doc = "RFC (r) register accessor: RO, UART3 receiver FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`rfc::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rfc`] module"]
    #[doc(alias = "RFC")]
    pub type Rfc = crate::Reg<rfc::RfcSpec>;
    #[doc = "RO, UART3 receiver FIFO count"]
    pub mod rfc {
        #[doc = "Register `RFC` reader"]
        pub type R = crate::R<RfcSpec>;
        #[doc = "Field `RFC` reader - RO, UART3 receiver FIFO count"]
        pub type RfcR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RO, UART3 receiver FIFO count"]
            #[inline(always)]
            pub fn rfc(&self) -> RfcR {
                RfcR::new(self.bits)
            }
        }
        #[doc = "RO, UART3 receiver FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`rfc::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RfcSpec;
        impl crate::RegisterSpec for RfcSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`rfc::R`](R) reader structure"]
        impl crate::Readable for RfcSpec {}
        #[doc = "`reset()` method sets RFC to value 0"]
        impl crate::Resettable for RfcSpec {}
    }
    #[doc = "TFC (r) register accessor: RO, UART3 transmitter FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`tfc::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tfc`] module"]
    #[doc(alias = "TFC")]
    pub type Tfc = crate::Reg<tfc::TfcSpec>;
    #[doc = "RO, UART3 transmitter FIFO count"]
    pub mod tfc {
        #[doc = "Register `TFC` reader"]
        pub type R = crate::R<TfcSpec>;
        #[doc = "Field `TFC` reader - RO, UART3 transmitter FIFO count"]
        pub type TfcR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RO, UART3 transmitter FIFO count"]
            #[inline(always)]
            pub fn tfc(&self) -> TfcR {
                TfcR::new(self.bits)
            }
        }
        #[doc = "RO, UART3 transmitter FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`tfc::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TfcSpec;
        impl crate::RegisterSpec for TfcSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`tfc::R`](R) reader structure"]
        impl crate::Readable for TfcSpec {}
        #[doc = "`reset()` method sets TFC to value 0"]
        impl crate::Resettable for TfcSpec {}
    }
    #[doc = "DL (rw) register accessor: RW, UART3 divisor latch\n\nYou can [`read`](crate::Reg::read) this register and get [`dl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dl`] module"]
    #[doc(alias = "DL")]
    pub type Dl = crate::Reg<dl::DlSpec>;
    #[doc = "RW, UART3 divisor latch"]
    pub mod dl {
        #[doc = "Register `DL` reader"]
        pub type R = crate::R<DlSpec>;
        #[doc = "Register `DL` writer"]
        pub type W = crate::W<DlSpec>;
        #[doc = "Field `DL` reader - RW, UART3 divisor latch"]
        pub type DlR = crate::FieldReader<u16>;
        #[doc = "Field `DL` writer - RW, UART3 divisor latch"]
        pub type DlW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW, UART3 divisor latch"]
            #[inline(always)]
            pub fn dl(&self) -> DlR {
                DlR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW, UART3 divisor latch"]
            #[inline(always)]
            pub fn dl(&mut self) -> DlW<DlSpec> {
                DlW::new(self, 0)
            }
        }
        #[doc = "RW, UART3 divisor latch\n\nYou can [`read`](crate::Reg::read) this register and get [`dl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DlSpec;
        impl crate::RegisterSpec for DlSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`dl::R`](R) reader structure"]
        impl crate::Readable for DlSpec {}
        #[doc = "`write(|w| ..)` method takes [`dl::W`](W) writer structure"]
        impl crate::Writable for DlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DL to value 0"]
        impl crate::Resettable for DlSpec {}
    }
    #[doc = "DIV (rw) register accessor: RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128\n\nYou can [`read`](crate::Reg::read) this register and get [`div::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@div`] module"]
    #[doc(alias = "DIV")]
    pub type Div = crate::Reg<div::DivSpec>;
    #[doc = "RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
    pub mod div {
        #[doc = "Register `DIV` reader"]
        pub type R = crate::R<DivSpec>;
        #[doc = "Register `DIV` writer"]
        pub type W = crate::W<DivSpec>;
        #[doc = "Field `DIV` reader - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
        pub type DivR = crate::FieldReader;
        #[doc = "Field `DIV` writer - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
        pub type DivW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
            #[inline(always)]
            pub fn div(&self) -> DivR {
                DivR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
            #[inline(always)]
            pub fn div(&mut self) -> DivW<DivSpec> {
                DivW::new(self, 0)
            }
        }
        #[doc = "RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128\n\nYou can [`read`](crate::Reg::read) this register and get [`div::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DivSpec;
        impl crate::RegisterSpec for DivSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`div::R`](R) reader structure"]
        impl crate::Readable for DivSpec {}
        #[doc = "`write(|w| ..)` method takes [`div::W`](W) writer structure"]
        impl crate::Writable for DivSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DIV to value 0"]
        impl crate::Resettable for DivSpec {}
    }
}
#[doc = "SPI0 register"]
pub type Spi0 = crate::Periph<spi0::RegisterBlock, 0x4000_4000>;
impl core::fmt::Debug for Spi0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spi0").finish()
    }
}
#[doc = "SPI0 register"]
pub mod spi0 {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        ctrl_mod: CtrlMod,
        ctrl_cfg: CtrlCfg,
        inter_en: InterEn,
        _reserved_3_clock_div: [u8; 0x01],
        buffer: Buffer,
        run_flag: RunFlag,
        int_flag: IntFlag,
        fifo_count: FifoCount,
        _reserved8: [u8; 0x04],
        total_cnt: TotalCnt,
        _reserved9: [u8; 0x02],
        fifo: Fifo,
        _reserved10: [u8; 0x02],
        fifo_count1: FifoCount1,
        dma_now: DmaNow,
        _reserved12: [u8; 0x02],
        dma_beg: DmaBeg,
        _reserved13: [u8; 0x02],
        dma_end: DmaEnd,
    }
    impl RegisterBlock {
        #[doc = "0x00 - RW, SPI0 mode control"]
        #[inline(always)]
        pub const fn ctrl_mod(&self) -> &CtrlMod {
            &self.ctrl_mod
        }
        #[doc = "0x01 - RW, SPI0 configuration control"]
        #[inline(always)]
        pub const fn ctrl_cfg(&self) -> &CtrlCfg {
            &self.ctrl_cfg
        }
        #[doc = "0x02 - RW, SPI0 interrupt enable"]
        #[inline(always)]
        pub const fn inter_en(&self) -> &InterEn {
            &self.inter_en
        }
        #[doc = "0x03 - RW, SPI0 slave preset value"]
        #[inline(always)]
        pub const fn slave_pre(&self) -> &SlavePre {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(3).cast() }
        }
        #[doc = "0x03 - RW, SPI0 master clock divisor"]
        #[inline(always)]
        pub const fn clock_div(&self) -> &ClockDiv {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(3).cast() }
        }
        #[doc = "0x04 - RW, SPI0 data buffer"]
        #[inline(always)]
        pub const fn buffer(&self) -> &Buffer {
            &self.buffer
        }
        #[doc = "0x05 - RO, SPI0 work flag"]
        #[inline(always)]
        pub const fn run_flag(&self) -> &RunFlag {
            &self.run_flag
        }
        #[doc = "0x06 - RW1, SPI0 interrupt flag"]
        #[inline(always)]
        pub const fn int_flag(&self) -> &IntFlag {
            &self.int_flag
        }
        #[doc = "0x07 - RO, SPI0 FIFO count status"]
        #[inline(always)]
        pub const fn fifo_count(&self) -> &FifoCount {
            &self.fifo_count
        }
        #[doc = "0x0c - RW, SPI0 total byte count, only low 12 bit"]
        #[inline(always)]
        pub const fn total_cnt(&self) -> &TotalCnt {
            &self.total_cnt
        }
        #[doc = "0x10 - RO/WO, SPI0 FIFO register"]
        #[inline(always)]
        pub const fn fifo(&self) -> &Fifo {
            &self.fifo
        }
        #[doc = "0x13 - RO, SPI0 FIFO count status"]
        #[inline(always)]
        pub const fn fifo_count1(&self) -> &FifoCount1 {
            &self.fifo_count1
        }
        #[doc = "0x14 - RW, SPI0 DMA current address"]
        #[inline(always)]
        pub const fn dma_now(&self) -> &DmaNow {
            &self.dma_now
        }
        #[doc = "0x18 - RW, SPI0 DMA begin address"]
        #[inline(always)]
        pub const fn dma_beg(&self) -> &DmaBeg {
            &self.dma_beg
        }
        #[doc = "0x1c - RW, SPI0 DMA end address"]
        #[inline(always)]
        pub const fn dma_end(&self) -> &DmaEnd {
            &self.dma_end
        }
    }
    #[doc = "CTRL_MOD (rw) register accessor: RW, SPI0 mode control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl_mod`] module"]
    #[doc(alias = "CTRL_MOD")]
    pub type CtrlMod = crate::Reg<ctrl_mod::CtrlModSpec>;
    #[doc = "RW, SPI0 mode control"]
    pub mod ctrl_mod {
        #[doc = "Register `CTRL_MOD` reader"]
        pub type R = crate::R<CtrlModSpec>;
        #[doc = "Register `CTRL_MOD` writer"]
        pub type W = crate::W<CtrlModSpec>;
        #[doc = "Field `ODE_SLAVE` reader - RW, SPI0 slave mode: 0=master or host, 1=slave or device"]
        pub type OdeSlaveR = crate::BitReader;
        #[doc = "Field `ODE_SLAVE` writer - RW, SPI0 slave mode: 0=master or host, 1=slave or device"]
        pub type OdeSlaveW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LL_CLEAR` reader - RW, force clear SPI FIFO and count"]
        pub type LlClearR = crate::BitReader;
        #[doc = "Field `LL_CLEAR` writer - RW, force clear SPI FIFO and count"]
        pub type LlClearW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WIRE_MOD` reader - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)"]
        pub type WireModR = crate::BitReader;
        #[doc = "Field `WIRE_MOD` writer - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)"]
        pub type WireModW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ST_SCK_MOD` reader - RW, SPI master clock mode: 0=mode 0, 1=mode 3"]
        pub type StSckModR = crate::BitReader;
        #[doc = "Field `ST_SCK_MOD` writer - RW, SPI master clock mode: 0=mode 0, 1=mode 3"]
        pub type StSckModW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LV_CMD_MOD` reader - RW, SPI0 slave command mode: 0=byte stream, 1=first byte command"]
        pub type LvCmdModR = crate::BitReader;
        #[doc = "Field `LV_CMD_MOD` writer - RW, SPI0 slave command mode: 0=byte stream, 1=first byte command"]
        pub type LvCmdModW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IFO_DIR` reader - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)"]
        pub type IfoDirR = crate::BitReader;
        #[doc = "Field `IFO_DIR` writer - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)"]
        pub type IfoDirW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CK_OE` reader - RW, SPI SCK output enable"]
        pub type CkOeR = crate::BitReader;
        #[doc = "Field `CK_OE` writer - RW, SPI SCK output enable"]
        pub type CkOeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `OSI_OE` reader - RW, SPI MOSI output enable"]
        pub type OsiOeR = crate::BitReader;
        #[doc = "Field `OSI_OE` writer - RW, SPI MOSI output enable"]
        pub type OsiOeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ISO_OE` reader - RW, SPI MISO output enable"]
        pub type IsoOeR = crate::BitReader;
        #[doc = "Field `ISO_OE` writer - RW, SPI MISO output enable"]
        pub type IsoOeW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, SPI0 slave mode: 0=master or host, 1=slave or device"]
            #[inline(always)]
            pub fn ode_slave(&self) -> OdeSlaveR {
                OdeSlaveR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, force clear SPI FIFO and count"]
            #[inline(always)]
            pub fn ll_clear(&self) -> LlClearR {
                LlClearR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)"]
            #[inline(always)]
            pub fn wire_mod(&self) -> WireModR {
                WireModR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, SPI master clock mode: 0=mode 0, 1=mode 3"]
            #[inline(always)]
            pub fn st_sck_mod(&self) -> StSckModR {
                StSckModR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, SPI0 slave command mode: 0=byte stream, 1=first byte command"]
            #[inline(always)]
            pub fn lv_cmd_mod(&self) -> LvCmdModR {
                LvCmdModR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)"]
            #[inline(always)]
            pub fn ifo_dir(&self) -> IfoDirR {
                IfoDirR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RW, SPI SCK output enable"]
            #[inline(always)]
            pub fn ck_oe(&self) -> CkOeR {
                CkOeR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RW, SPI MOSI output enable"]
            #[inline(always)]
            pub fn osi_oe(&self) -> OsiOeR {
                OsiOeR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RW, SPI MISO output enable"]
            #[inline(always)]
            pub fn iso_oe(&self) -> IsoOeR {
                IsoOeR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, SPI0 slave mode: 0=master or host, 1=slave or device"]
            #[inline(always)]
            pub fn ode_slave(&mut self) -> OdeSlaveW<CtrlModSpec> {
                OdeSlaveW::new(self, 0)
            }
            #[doc = "Bit 1 - RW, force clear SPI FIFO and count"]
            #[inline(always)]
            pub fn ll_clear(&mut self) -> LlClearW<CtrlModSpec> {
                LlClearW::new(self, 1)
            }
            #[doc = "Bit 2 - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)"]
            #[inline(always)]
            pub fn wire_mod(&mut self) -> WireModW<CtrlModSpec> {
                WireModW::new(self, 2)
            }
            #[doc = "Bit 3 - RW, SPI master clock mode: 0=mode 0, 1=mode 3"]
            #[inline(always)]
            pub fn st_sck_mod(&mut self) -> StSckModW<CtrlModSpec> {
                StSckModW::new(self, 3)
            }
            #[doc = "Bit 3 - RW, SPI0 slave command mode: 0=byte stream, 1=first byte command"]
            #[inline(always)]
            pub fn lv_cmd_mod(&mut self) -> LvCmdModW<CtrlModSpec> {
                LvCmdModW::new(self, 3)
            }
            #[doc = "Bit 4 - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)"]
            #[inline(always)]
            pub fn ifo_dir(&mut self) -> IfoDirW<CtrlModSpec> {
                IfoDirW::new(self, 4)
            }
            #[doc = "Bit 5 - RW, SPI SCK output enable"]
            #[inline(always)]
            pub fn ck_oe(&mut self) -> CkOeW<CtrlModSpec> {
                CkOeW::new(self, 5)
            }
            #[doc = "Bit 6 - RW, SPI MOSI output enable"]
            #[inline(always)]
            pub fn osi_oe(&mut self) -> OsiOeW<CtrlModSpec> {
                OsiOeW::new(self, 6)
            }
            #[doc = "Bit 7 - RW, SPI MISO output enable"]
            #[inline(always)]
            pub fn iso_oe(&mut self) -> IsoOeW<CtrlModSpec> {
                IsoOeW::new(self, 7)
            }
        }
        #[doc = "RW, SPI0 mode control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CtrlModSpec;
        impl crate::RegisterSpec for CtrlModSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`ctrl_mod::R`](R) reader structure"]
        impl crate::Readable for CtrlModSpec {}
        #[doc = "`write(|w| ..)` method takes [`ctrl_mod::W`](W) writer structure"]
        impl crate::Writable for CtrlModSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CTRL_MOD to value 0x02"]
        impl crate::Resettable for CtrlModSpec {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    #[doc = "CTRL_CFG (rw) register accessor: RW, SPI0 configuration control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl_cfg`] module"]
    #[doc(alias = "CTRL_CFG")]
    pub type CtrlCfg = crate::Reg<ctrl_cfg::CtrlCfgSpec>;
    #[doc = "RW, SPI0 configuration control"]
    pub mod ctrl_cfg {
        #[doc = "Register `CTRL_CFG` reader"]
        pub type R = crate::R<CtrlCfgSpec>;
        #[doc = "Register `CTRL_CFG` writer"]
        pub type W = crate::W<CtrlCfgSpec>;
        #[doc = "Field `MA_ENABLE` reader - RW, SPI0 DMA enable"]
        pub type MaEnableR = crate::BitReader;
        #[doc = "Field `MA_ENABLE` writer - RW, SPI0 DMA enable"]
        pub type MaEnableW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MA_LOOP` reader - RW, SPI0 DMA address loop enable"]
        pub type MaLoopR = crate::BitReader;
        #[doc = "Field `MA_LOOP` writer - RW, SPI0 DMA address loop enable"]
        pub type MaLoopW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UTO_IF` reader - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag"]
        pub type UtoIfR = crate::BitReader;
        #[doc = "Field `UTO_IF` writer - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag"]
        pub type UtoIfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IT_ORDER` reader - RW, SPI bit data order: 0=MSB first, 1=LSB first"]
        pub type ItOrderR = crate::BitReader;
        #[doc = "Field `IT_ORDER` writer - RW, SPI bit data order: 0=MSB first, 1=LSB first"]
        pub type ItOrderW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ST_DLY_EN` reader - RW, SPI master input delay enable"]
        pub type StDlyEnR = crate::BitReader;
        #[doc = "Field `ST_DLY_EN` writer - RW, SPI master input delay enable"]
        pub type StDlyEnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, SPI0 DMA enable"]
            #[inline(always)]
            pub fn ma_enable(&self) -> MaEnableR {
                MaEnableR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 2 - RW, SPI0 DMA address loop enable"]
            #[inline(always)]
            pub fn ma_loop(&self) -> MaLoopR {
                MaLoopR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag"]
            #[inline(always)]
            pub fn uto_if(&self) -> UtoIfR {
                UtoIfR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RW, SPI bit data order: 0=MSB first, 1=LSB first"]
            #[inline(always)]
            pub fn it_order(&self) -> ItOrderR {
                ItOrderR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RW, SPI master input delay enable"]
            #[inline(always)]
            pub fn st_dly_en(&self) -> StDlyEnR {
                StDlyEnR::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, SPI0 DMA enable"]
            #[inline(always)]
            pub fn ma_enable(&mut self) -> MaEnableW<CtrlCfgSpec> {
                MaEnableW::new(self, 0)
            }
            #[doc = "Bit 2 - RW, SPI0 DMA address loop enable"]
            #[inline(always)]
            pub fn ma_loop(&mut self) -> MaLoopW<CtrlCfgSpec> {
                MaLoopW::new(self, 2)
            }
            #[doc = "Bit 4 - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag"]
            #[inline(always)]
            pub fn uto_if(&mut self) -> UtoIfW<CtrlCfgSpec> {
                UtoIfW::new(self, 4)
            }
            #[doc = "Bit 5 - RW, SPI bit data order: 0=MSB first, 1=LSB first"]
            #[inline(always)]
            pub fn it_order(&mut self) -> ItOrderW<CtrlCfgSpec> {
                ItOrderW::new(self, 5)
            }
            #[doc = "Bit 6 - RW, SPI master input delay enable"]
            #[inline(always)]
            pub fn st_dly_en(&mut self) -> StDlyEnW<CtrlCfgSpec> {
                StDlyEnW::new(self, 6)
            }
        }
        #[doc = "RW, SPI0 configuration control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CtrlCfgSpec;
        impl crate::RegisterSpec for CtrlCfgSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`ctrl_cfg::R`](R) reader structure"]
        impl crate::Readable for CtrlCfgSpec {}
        #[doc = "`write(|w| ..)` method takes [`ctrl_cfg::W`](W) writer structure"]
        impl crate::Writable for CtrlCfgSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CTRL_CFG to value 0"]
        impl crate::Resettable for CtrlCfgSpec {}
    }
    #[doc = "INTER_EN (rw) register accessor: RW, SPI0 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`inter_en::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inter_en::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@inter_en`] module"]
    #[doc(alias = "INTER_EN")]
    pub type InterEn = crate::Reg<inter_en::InterEnSpec>;
    #[doc = "RW, SPI0 interrupt enable"]
    pub mod inter_en {
        #[doc = "Register `INTER_EN` reader"]
        pub type R = crate::R<InterEnSpec>;
        #[doc = "Register `INTER_EN` writer"]
        pub type W = crate::W<InterEnSpec>;
        #[doc = "Field `E_CNT_END` reader - RW, enable interrupt for SPI total byte count end"]
        pub type ECntEndR = crate::BitReader;
        #[doc = "Field `E_CNT_END` writer - RW, enable interrupt for SPI total byte count end"]
        pub type ECntEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_BYTE_END` reader - RW, enable interrupt for SPI byte exchanged"]
        pub type EByteEndR = crate::BitReader;
        #[doc = "Field `E_BYTE_END` writer - RW, enable interrupt for SPI byte exchanged"]
        pub type EByteEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_FIFO_HF` reader - RW, enable interrupt for SPI FIFO half"]
        pub type EFifoHfR = crate::BitReader;
        #[doc = "Field `E_FIFO_HF` writer - RW, enable interrupt for SPI FIFO half"]
        pub type EFifoHfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_DMA_END` reader - RW, enable interrupt for SPI0 DMA completion"]
        pub type EDmaEndR = crate::BitReader;
        #[doc = "Field `E_DMA_END` writer - RW, enable interrupt for SPI0 DMA completion"]
        pub type EDmaEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_FIFO_OV` reader - RW, enable interrupt for SPI0 FIFO overflow"]
        pub type EFifoOvR = crate::BitReader;
        #[doc = "Field `E_FIFO_OV` writer - RW, enable interrupt for SPI0 FIFO overflow"]
        pub type EFifoOvW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_FST_BYTE` reader - RW, enable interrupt for SPI0 slave mode first byte received"]
        pub type EFstByteR = crate::BitReader;
        #[doc = "Field `E_FST_BYTE` writer - RW, enable interrupt for SPI0 slave mode first byte received"]
        pub type EFstByteW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, enable interrupt for SPI total byte count end"]
            #[inline(always)]
            pub fn e_cnt_end(&self) -> ECntEndR {
                ECntEndR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, enable interrupt for SPI byte exchanged"]
            #[inline(always)]
            pub fn e_byte_end(&self) -> EByteEndR {
                EByteEndR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW, enable interrupt for SPI FIFO half"]
            #[inline(always)]
            pub fn e_fifo_hf(&self) -> EFifoHfR {
                EFifoHfR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, enable interrupt for SPI0 DMA completion"]
            #[inline(always)]
            pub fn e_dma_end(&self) -> EDmaEndR {
                EDmaEndR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, enable interrupt for SPI0 FIFO overflow"]
            #[inline(always)]
            pub fn e_fifo_ov(&self) -> EFifoOvR {
                EFifoOvR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 7 - RW, enable interrupt for SPI0 slave mode first byte received"]
            #[inline(always)]
            pub fn e_fst_byte(&self) -> EFstByteR {
                EFstByteR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, enable interrupt for SPI total byte count end"]
            #[inline(always)]
            pub fn e_cnt_end(&mut self) -> ECntEndW<InterEnSpec> {
                ECntEndW::new(self, 0)
            }
            #[doc = "Bit 1 - RW, enable interrupt for SPI byte exchanged"]
            #[inline(always)]
            pub fn e_byte_end(&mut self) -> EByteEndW<InterEnSpec> {
                EByteEndW::new(self, 1)
            }
            #[doc = "Bit 2 - RW, enable interrupt for SPI FIFO half"]
            #[inline(always)]
            pub fn e_fifo_hf(&mut self) -> EFifoHfW<InterEnSpec> {
                EFifoHfW::new(self, 2)
            }
            #[doc = "Bit 3 - RW, enable interrupt for SPI0 DMA completion"]
            #[inline(always)]
            pub fn e_dma_end(&mut self) -> EDmaEndW<InterEnSpec> {
                EDmaEndW::new(self, 3)
            }
            #[doc = "Bit 4 - RW, enable interrupt for SPI0 FIFO overflow"]
            #[inline(always)]
            pub fn e_fifo_ov(&mut self) -> EFifoOvW<InterEnSpec> {
                EFifoOvW::new(self, 4)
            }
            #[doc = "Bit 7 - RW, enable interrupt for SPI0 slave mode first byte received"]
            #[inline(always)]
            pub fn e_fst_byte(&mut self) -> EFstByteW<InterEnSpec> {
                EFstByteW::new(self, 7)
            }
        }
        #[doc = "RW, SPI0 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`inter_en::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inter_en::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct InterEnSpec;
        impl crate::RegisterSpec for InterEnSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`inter_en::R`](R) reader structure"]
        impl crate::Readable for InterEnSpec {}
        #[doc = "`write(|w| ..)` method takes [`inter_en::W`](W) writer structure"]
        impl crate::Writable for InterEnSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets INTER_EN to value 0"]
        impl crate::Resettable for InterEnSpec {}
    }
    #[doc = "CLOCK_DIV (rw) register accessor: RW, SPI0 master clock divisor\n\nYou can [`read`](crate::Reg::read) this register and get [`clock_div::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clock_div::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clock_div`] module"]
    #[doc(alias = "CLOCK_DIV")]
    pub type ClockDiv = crate::Reg<clock_div::ClockDivSpec>;
    #[doc = "RW, SPI0 master clock divisor"]
    pub mod clock_div {
        #[doc = "Register `CLOCK_DIV` reader"]
        pub type R = crate::R<ClockDivSpec>;
        #[doc = "Register `CLOCK_DIV` writer"]
        pub type W = crate::W<ClockDivSpec>;
        #[doc = "Field `CLOCK_DIV` reader - RW, SPI0 master clock divisor"]
        pub type ClockDivR = crate::FieldReader;
        #[doc = "Field `CLOCK_DIV` writer - RW, SPI0 master clock divisor"]
        pub type ClockDivW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW, SPI0 master clock divisor"]
            #[inline(always)]
            pub fn clock_div(&self) -> ClockDivR {
                ClockDivR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW, SPI0 master clock divisor"]
            #[inline(always)]
            pub fn clock_div(&mut self) -> ClockDivW<ClockDivSpec> {
                ClockDivW::new(self, 0)
            }
        }
        #[doc = "RW, SPI0 master clock divisor\n\nYou can [`read`](crate::Reg::read) this register and get [`clock_div::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clock_div::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ClockDivSpec;
        impl crate::RegisterSpec for ClockDivSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`clock_div::R`](R) reader structure"]
        impl crate::Readable for ClockDivSpec {}
        #[doc = "`write(|w| ..)` method takes [`clock_div::W`](W) writer structure"]
        impl crate::Writable for ClockDivSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CLOCK_DIV to value 0x10"]
        impl crate::Resettable for ClockDivSpec {
            const RESET_VALUE: u8 = 0x10;
        }
    }
    #[doc = "SLAVE_PRE (rw) register accessor: RW, SPI0 slave preset value\n\nYou can [`read`](crate::Reg::read) this register and get [`slave_pre::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slave_pre::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@slave_pre`] module"]
    #[doc(alias = "SLAVE_PRE")]
    pub type SlavePre = crate::Reg<slave_pre::SlavePreSpec>;
    #[doc = "RW, SPI0 slave preset value"]
    pub mod slave_pre {
        #[doc = "Register `SLAVE_PRE` reader"]
        pub type R = crate::R<SlavePreSpec>;
        #[doc = "Register `SLAVE_PRE` writer"]
        pub type W = crate::W<SlavePreSpec>;
        #[doc = "Field `SLAVE_PRE` reader - RW, SPI0 slave preset value"]
        pub type SlavePreR = crate::FieldReader;
        #[doc = "Field `SLAVE_PRE` writer - RW, SPI0 slave preset value"]
        pub type SlavePreW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW, SPI0 slave preset value"]
            #[inline(always)]
            pub fn slave_pre(&self) -> SlavePreR {
                SlavePreR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW, SPI0 slave preset value"]
            #[inline(always)]
            pub fn slave_pre(&mut self) -> SlavePreW<SlavePreSpec> {
                SlavePreW::new(self, 0)
            }
        }
        #[doc = "RW, SPI0 slave preset value\n\nYou can [`read`](crate::Reg::read) this register and get [`slave_pre::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slave_pre::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SlavePreSpec;
        impl crate::RegisterSpec for SlavePreSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`slave_pre::R`](R) reader structure"]
        impl crate::Readable for SlavePreSpec {}
        #[doc = "`write(|w| ..)` method takes [`slave_pre::W`](W) writer structure"]
        impl crate::Writable for SlavePreSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SLAVE_PRE to value 0x10"]
        impl crate::Resettable for SlavePreSpec {
            const RESET_VALUE: u8 = 0x10;
        }
    }
    #[doc = "BUFFER (rw) register accessor: RW, SPI0 data buffer\n\nYou can [`read`](crate::Reg::read) this register and get [`buffer::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`buffer::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@buffer`] module"]
    #[doc(alias = "BUFFER")]
    pub type Buffer = crate::Reg<buffer::BufferSpec>;
    #[doc = "RW, SPI0 data buffer"]
    pub mod buffer {
        #[doc = "Register `BUFFER` reader"]
        pub type R = crate::R<BufferSpec>;
        #[doc = "Register `BUFFER` writer"]
        pub type W = crate::W<BufferSpec>;
        #[doc = "Field `BUFFER` reader - RW, SPI0 data buffer"]
        pub type BufferR = crate::FieldReader;
        #[doc = "Field `BUFFER` writer - RW, SPI0 data buffer"]
        pub type BufferW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW, SPI0 data buffer"]
            #[inline(always)]
            pub fn buffer(&self) -> BufferR {
                BufferR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW, SPI0 data buffer"]
            #[inline(always)]
            pub fn buffer(&mut self) -> BufferW<BufferSpec> {
                BufferW::new(self, 0)
            }
        }
        #[doc = "RW, SPI0 data buffer\n\nYou can [`read`](crate::Reg::read) this register and get [`buffer::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`buffer::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct BufferSpec;
        impl crate::RegisterSpec for BufferSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`buffer::R`](R) reader structure"]
        impl crate::Readable for BufferSpec {}
        #[doc = "`write(|w| ..)` method takes [`buffer::W`](W) writer structure"]
        impl crate::Writable for BufferSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets BUFFER to value 0"]
        impl crate::Resettable for BufferSpec {}
    }
    #[doc = "RUN_FLAG (r) register accessor: RO, SPI0 work flag\n\nYou can [`read`](crate::Reg::read) this register and get [`run_flag::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@run_flag`] module"]
    #[doc(alias = "RUN_FLAG")]
    pub type RunFlag = crate::Reg<run_flag::RunFlagSpec>;
    #[doc = "RO, SPI0 work flag"]
    pub mod run_flag {
        #[doc = "Register `RUN_FLAG` reader"]
        pub type R = crate::R<RunFlagSpec>;
        #[doc = "Field `LV_CMD_ACT` reader - RO, SPI0 slave first byte or command flag"]
        pub type LvCmdActR = crate::BitReader;
        #[doc = "Field `IFO_READY` reader - RO, SPI FIFO ready status"]
        pub type IfoReadyR = crate::BitReader;
        #[doc = "Field `LV_CS_LOAD` reader - RO, SPI0 slave chip-select loading status"]
        pub type LvCsLoadR = crate::BitReader;
        #[doc = "Field `LV_SELECT` reader - RO, SPI0 slave selection status"]
        pub type LvSelectR = crate::BitReader;
        impl R {
            #[doc = "Bit 4 - RO, SPI0 slave first byte or command flag"]
            #[inline(always)]
            pub fn lv_cmd_act(&self) -> LvCmdActR {
                LvCmdActR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RO, SPI FIFO ready status"]
            #[inline(always)]
            pub fn ifo_ready(&self) -> IfoReadyR {
                IfoReadyR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RO, SPI0 slave chip-select loading status"]
            #[inline(always)]
            pub fn lv_cs_load(&self) -> LvCsLoadR {
                LvCsLoadR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RO, SPI0 slave selection status"]
            #[inline(always)]
            pub fn lv_select(&self) -> LvSelectR {
                LvSelectR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        #[doc = "RO, SPI0 work flag\n\nYou can [`read`](crate::Reg::read) this register and get [`run_flag::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RunFlagSpec;
        impl crate::RegisterSpec for RunFlagSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`run_flag::R`](R) reader structure"]
        impl crate::Readable for RunFlagSpec {}
        #[doc = "`reset()` method sets RUN_FLAG to value 0"]
        impl crate::Resettable for RunFlagSpec {}
    }
    #[doc = "INT_FLAG (rw) register accessor: RW1, SPI0 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_flag`] module"]
    #[doc(alias = "INT_FLAG")]
    pub type IntFlag = crate::Reg<int_flag::IntFlagSpec>;
    #[doc = "RW1, SPI0 interrupt flag"]
    pub mod int_flag {
        #[doc = "Register `INT_FLAG` reader"]
        pub type R = crate::R<IntFlagSpec>;
        #[doc = "Register `INT_FLAG` writer"]
        pub type W = crate::W<IntFlagSpec>;
        #[doc = "Field `F_CNT_END` reader - RW1, interrupt flag for SPI total byte count end"]
        pub type FCntEndR = crate::BitReader;
        #[doc = "Field `F_CNT_END` writer - RW1, interrupt flag for SPI total byte count end"]
        pub type FCntEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_BYTE_END` reader - RW1, interrupt flag for SPI byte exchanged"]
        pub type FByteEndR = crate::BitReader;
        #[doc = "Field `F_BYTE_END` writer - RW1, interrupt flag for SPI byte exchanged"]
        pub type FByteEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_FIFO_HF` reader - RW1, interrupt flag for SPI FIFO half"]
        pub type FFifoHfR = crate::BitReader;
        #[doc = "Field `F_FIFO_HF` writer - RW1, interrupt flag for SPI FIFO half"]
        pub type FFifoHfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_DMA_END` reader - RW1, interrupt flag for SPI0 DMA completion"]
        pub type FDmaEndR = crate::BitReader;
        #[doc = "Field `F_DMA_END` writer - RW1, interrupt flag for SPI0 DMA completion"]
        pub type FDmaEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_FIFO_OV` reader - RW1, interrupt flag for SPI0 FIFO overflow"]
        pub type FFifoOvR = crate::BitReader;
        #[doc = "Field `F_FIFO_OV` writer - RW1, interrupt flag for SPI0 FIFO overflow"]
        pub type FFifoOvW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `REE` reader - RO, current SPI free status"]
        pub type ReeR = crate::BitReader;
        #[doc = "Field `REE` writer - RO, current SPI free status"]
        pub type ReeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_FST_BYTE` reader - RW1, interrupt flag for SPI0 slave mode first byte received"]
        pub type FFstByteR = crate::BitReader;
        #[doc = "Field `F_FST_BYTE` writer - RW1, interrupt flag for SPI0 slave mode first byte received"]
        pub type FFstByteW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW1, interrupt flag for SPI total byte count end"]
            #[inline(always)]
            pub fn f_cnt_end(&self) -> FCntEndR {
                FCntEndR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW1, interrupt flag for SPI byte exchanged"]
            #[inline(always)]
            pub fn f_byte_end(&self) -> FByteEndR {
                FByteEndR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW1, interrupt flag for SPI FIFO half"]
            #[inline(always)]
            pub fn f_fifo_hf(&self) -> FFifoHfR {
                FFifoHfR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW1, interrupt flag for SPI0 DMA completion"]
            #[inline(always)]
            pub fn f_dma_end(&self) -> FDmaEndR {
                FDmaEndR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW1, interrupt flag for SPI0 FIFO overflow"]
            #[inline(always)]
            pub fn f_fifo_ov(&self) -> FFifoOvR {
                FFifoOvR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - RO, current SPI free status"]
            #[inline(always)]
            pub fn ree(&self) -> ReeR {
                ReeR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RW1, interrupt flag for SPI0 slave mode first byte received"]
            #[inline(always)]
            pub fn f_fst_byte(&self) -> FFstByteR {
                FFstByteR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW1, interrupt flag for SPI total byte count end"]
            #[inline(always)]
            pub fn f_cnt_end(&mut self) -> FCntEndW<IntFlagSpec> {
                FCntEndW::new(self, 0)
            }
            #[doc = "Bit 1 - RW1, interrupt flag for SPI byte exchanged"]
            #[inline(always)]
            pub fn f_byte_end(&mut self) -> FByteEndW<IntFlagSpec> {
                FByteEndW::new(self, 1)
            }
            #[doc = "Bit 2 - RW1, interrupt flag for SPI FIFO half"]
            #[inline(always)]
            pub fn f_fifo_hf(&mut self) -> FFifoHfW<IntFlagSpec> {
                FFifoHfW::new(self, 2)
            }
            #[doc = "Bit 3 - RW1, interrupt flag for SPI0 DMA completion"]
            #[inline(always)]
            pub fn f_dma_end(&mut self) -> FDmaEndW<IntFlagSpec> {
                FDmaEndW::new(self, 3)
            }
            #[doc = "Bit 4 - RW1, interrupt flag for SPI0 FIFO overflow"]
            #[inline(always)]
            pub fn f_fifo_ov(&mut self) -> FFifoOvW<IntFlagSpec> {
                FFifoOvW::new(self, 4)
            }
            #[doc = "Bit 6 - RO, current SPI free status"]
            #[inline(always)]
            pub fn ree(&mut self) -> ReeW<IntFlagSpec> {
                ReeW::new(self, 6)
            }
            #[doc = "Bit 7 - RW1, interrupt flag for SPI0 slave mode first byte received"]
            #[inline(always)]
            pub fn f_fst_byte(&mut self) -> FFstByteW<IntFlagSpec> {
                FFstByteW::new(self, 7)
            }
        }
        #[doc = "RW1, SPI0 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IntFlagSpec;
        impl crate::RegisterSpec for IntFlagSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`int_flag::R`](R) reader structure"]
        impl crate::Readable for IntFlagSpec {}
        #[doc = "`write(|w| ..)` method takes [`int_flag::W`](W) writer structure"]
        impl crate::Writable for IntFlagSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets INT_FLAG to value 0x40"]
        impl crate::Resettable for IntFlagSpec {
            const RESET_VALUE: u8 = 0x40;
        }
    }
    #[doc = "FIFO_COUNT (r) register accessor: RO, SPI0 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo_count`] module"]
    #[doc(alias = "FIFO_COUNT")]
    pub type FifoCount = crate::Reg<fifo_count::FifoCountSpec>;
    #[doc = "RO, SPI0 FIFO count status"]
    pub mod fifo_count {
        #[doc = "Register `FIFO_COUNT` reader"]
        pub type R = crate::R<FifoCountSpec>;
        #[doc = "Field `FIFO_COUNT` reader - RO, SPI0 FIFO count status"]
        pub type FifoCountR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RO, SPI0 FIFO count status"]
            #[inline(always)]
            pub fn fifo_count(&self) -> FifoCountR {
                FifoCountR::new(self.bits)
            }
        }
        #[doc = "RO, SPI0 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FifoCountSpec;
        impl crate::RegisterSpec for FifoCountSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`fifo_count::R`](R) reader structure"]
        impl crate::Readable for FifoCountSpec {}
        #[doc = "`reset()` method sets FIFO_COUNT to value 0"]
        impl crate::Resettable for FifoCountSpec {}
    }
    #[doc = "TOTAL_CNT (rw) register accessor: RW, SPI0 total byte count, only low 12 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`total_cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`total_cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@total_cnt`] module"]
    #[doc(alias = "TOTAL_CNT")]
    pub type TotalCnt = crate::Reg<total_cnt::TotalCntSpec>;
    #[doc = "RW, SPI0 total byte count, only low 12 bit"]
    pub mod total_cnt {
        #[doc = "Register `TOTAL_CNT` reader"]
        pub type R = crate::R<TotalCntSpec>;
        #[doc = "Register `TOTAL_CNT` writer"]
        pub type W = crate::W<TotalCntSpec>;
        #[doc = "Field `TOTAL_CNT` reader - RW, SPI0 total byte count, only low 12 bit"]
        pub type TotalCntR = crate::FieldReader<u16>;
        #[doc = "Field `TOTAL_CNT` writer - RW, SPI0 total byte count, only low 12 bit"]
        pub type TotalCntW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW, SPI0 total byte count, only low 12 bit"]
            #[inline(always)]
            pub fn total_cnt(&self) -> TotalCntR {
                TotalCntR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW, SPI0 total byte count, only low 12 bit"]
            #[inline(always)]
            pub fn total_cnt(&mut self) -> TotalCntW<TotalCntSpec> {
                TotalCntW::new(self, 0)
            }
        }
        #[doc = "RW, SPI0 total byte count, only low 12 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`total_cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`total_cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TotalCntSpec;
        impl crate::RegisterSpec for TotalCntSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`total_cnt::R`](R) reader structure"]
        impl crate::Readable for TotalCntSpec {}
        #[doc = "`write(|w| ..)` method takes [`total_cnt::W`](W) writer structure"]
        impl crate::Writable for TotalCntSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TOTAL_CNT to value 0"]
        impl crate::Resettable for TotalCntSpec {}
    }
    #[doc = "FIFO (rw) register accessor: RO/WO, SPI0 FIFO register\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fifo::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo`] module"]
    #[doc(alias = "FIFO")]
    pub type Fifo = crate::Reg<fifo::FifoSpec>;
    #[doc = "RO/WO, SPI0 FIFO register"]
    pub mod fifo {
        #[doc = "Register `FIFO` reader"]
        pub type R = crate::R<FifoSpec>;
        #[doc = "Register `FIFO` writer"]
        pub type W = crate::W<FifoSpec>;
        #[doc = "Field `FIFO` reader - RO/WO, SPI0 FIFO register"]
        pub type FifoR = crate::FieldReader;
        #[doc = "Field `FIFO` writer - RO/WO, SPI0 FIFO register"]
        pub type FifoW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RO/WO, SPI0 FIFO register"]
            #[inline(always)]
            pub fn fifo(&self) -> FifoR {
                FifoR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RO/WO, SPI0 FIFO register"]
            #[inline(always)]
            pub fn fifo(&mut self) -> FifoW<FifoSpec> {
                FifoW::new(self, 0)
            }
        }
        #[doc = "RO/WO, SPI0 FIFO register\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fifo::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FifoSpec;
        impl crate::RegisterSpec for FifoSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`fifo::R`](R) reader structure"]
        impl crate::Readable for FifoSpec {}
        #[doc = "`write(|w| ..)` method takes [`fifo::W`](W) writer structure"]
        impl crate::Writable for FifoSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FIFO to value 0"]
        impl crate::Resettable for FifoSpec {}
    }
    #[doc = "FIFO_COUNT1 (r) register accessor: RO, SPI0 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count1::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo_count1`] module"]
    #[doc(alias = "FIFO_COUNT1")]
    pub type FifoCount1 = crate::Reg<fifo_count1::FifoCount1Spec>;
    #[doc = "RO, SPI0 FIFO count status"]
    pub mod fifo_count1 {
        #[doc = "Register `FIFO_COUNT1` reader"]
        pub type R = crate::R<FifoCount1Spec>;
        #[doc = "Field `FIFO_COUNT1` reader - RO, SPI0 FIFO count status"]
        pub type FifoCount1R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RO, SPI0 FIFO count status"]
            #[inline(always)]
            pub fn fifo_count1(&self) -> FifoCount1R {
                FifoCount1R::new(self.bits)
            }
        }
        #[doc = "RO, SPI0 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count1::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FifoCount1Spec;
        impl crate::RegisterSpec for FifoCount1Spec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`fifo_count1::R`](R) reader structure"]
        impl crate::Readable for FifoCount1Spec {}
        #[doc = "`reset()` method sets FIFO_COUNT1 to value 0"]
        impl crate::Resettable for FifoCount1Spec {}
    }
    #[doc = "DMA_NOW (rw) register accessor: RW, SPI0 DMA current address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_now::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_now::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_now`] module"]
    #[doc(alias = "DMA_NOW")]
    pub type DmaNow = crate::Reg<dma_now::DmaNowSpec>;
    #[doc = "RW, SPI0 DMA current address"]
    pub mod dma_now {
        #[doc = "Register `DMA_NOW` reader"]
        pub type R = crate::R<DmaNowSpec>;
        #[doc = "Register `DMA_NOW` writer"]
        pub type W = crate::W<DmaNowSpec>;
        #[doc = "Field `DMA_NOW` reader - RW, SPI0 DMA current address"]
        pub type DmaNowR = crate::FieldReader<u16>;
        #[doc = "Field `DMA_NOW` writer - RW, SPI0 DMA current address"]
        pub type DmaNowW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW, SPI0 DMA current address"]
            #[inline(always)]
            pub fn dma_now(&self) -> DmaNowR {
                DmaNowR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW, SPI0 DMA current address"]
            #[inline(always)]
            pub fn dma_now(&mut self) -> DmaNowW<DmaNowSpec> {
                DmaNowW::new(self, 0)
            }
        }
        #[doc = "RW, SPI0 DMA current address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_now::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_now::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DmaNowSpec;
        impl crate::RegisterSpec for DmaNowSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`dma_now::R`](R) reader structure"]
        impl crate::Readable for DmaNowSpec {}
        #[doc = "`write(|w| ..)` method takes [`dma_now::W`](W) writer structure"]
        impl crate::Writable for DmaNowSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DMA_NOW to value 0"]
        impl crate::Resettable for DmaNowSpec {}
    }
    #[doc = "DMA_BEG (rw) register accessor: RW, SPI0 DMA begin address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_beg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_beg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_beg`] module"]
    #[doc(alias = "DMA_BEG")]
    pub type DmaBeg = crate::Reg<dma_beg::DmaBegSpec>;
    #[doc = "RW, SPI0 DMA begin address"]
    pub mod dma_beg {
        #[doc = "Register `DMA_BEG` reader"]
        pub type R = crate::R<DmaBegSpec>;
        #[doc = "Register `DMA_BEG` writer"]
        pub type W = crate::W<DmaBegSpec>;
        #[doc = "Field `DMA_BEG` reader - RW, SPI0 DMA begin address"]
        pub type DmaBegR = crate::FieldReader<u16>;
        #[doc = "Field `DMA_BEG` writer - RW, SPI0 DMA begin address"]
        pub type DmaBegW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW, SPI0 DMA begin address"]
            #[inline(always)]
            pub fn dma_beg(&self) -> DmaBegR {
                DmaBegR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW, SPI0 DMA begin address"]
            #[inline(always)]
            pub fn dma_beg(&mut self) -> DmaBegW<DmaBegSpec> {
                DmaBegW::new(self, 0)
            }
        }
        #[doc = "RW, SPI0 DMA begin address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_beg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_beg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DmaBegSpec;
        impl crate::RegisterSpec for DmaBegSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`dma_beg::R`](R) reader structure"]
        impl crate::Readable for DmaBegSpec {}
        #[doc = "`write(|w| ..)` method takes [`dma_beg::W`](W) writer structure"]
        impl crate::Writable for DmaBegSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DMA_BEG to value 0"]
        impl crate::Resettable for DmaBegSpec {}
    }
    #[doc = "DMA_END (rw) register accessor: RW, SPI0 DMA end address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_end::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_end::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_end`] module"]
    #[doc(alias = "DMA_END")]
    pub type DmaEnd = crate::Reg<dma_end::DmaEndSpec>;
    #[doc = "RW, SPI0 DMA end address"]
    pub mod dma_end {
        #[doc = "Register `DMA_END` reader"]
        pub type R = crate::R<DmaEndSpec>;
        #[doc = "Register `DMA_END` writer"]
        pub type W = crate::W<DmaEndSpec>;
        #[doc = "Field `DMA_END` reader - RW, SPI0 DMA end address"]
        pub type DmaEndR = crate::FieldReader<u16>;
        #[doc = "Field `DMA_END` writer - RW, SPI0 DMA end address"]
        pub type DmaEndW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW, SPI0 DMA end address"]
            #[inline(always)]
            pub fn dma_end(&self) -> DmaEndR {
                DmaEndR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW, SPI0 DMA end address"]
            #[inline(always)]
            pub fn dma_end(&mut self) -> DmaEndW<DmaEndSpec> {
                DmaEndW::new(self, 0)
            }
        }
        #[doc = "RW, SPI0 DMA end address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_end::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_end::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DmaEndSpec;
        impl crate::RegisterSpec for DmaEndSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`dma_end::R`](R) reader structure"]
        impl crate::Readable for DmaEndSpec {}
        #[doc = "`write(|w| ..)` method takes [`dma_end::W`](W) writer structure"]
        impl crate::Writable for DmaEndSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DMA_END to value 0"]
        impl crate::Resettable for DmaEndSpec {}
    }
}
#[doc = "SPI1 register"]
pub type Spi1 = crate::Periph<spi1::RegisterBlock, 0x4000_4400>;
impl core::fmt::Debug for Spi1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spi1").finish()
    }
}
#[doc = "SPI1 register"]
pub mod spi1 {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        ctrl_mod: CtrlMod,
        ctrl_cfg: CtrlCfg,
        inter_en: InterEn,
        _reserved_3_clock_div: [u8; 0x01],
        buffer: Buffer,
        run_flag: RunFlag,
        int_flag: IntFlag,
        fifo_count: FifoCount,
        _reserved8: [u8; 0x04],
        total_cnt: TotalCnt,
        _reserved9: [u8; 0x02],
        fifo: Fifo,
        _reserved10: [u8; 0x02],
        fifo_count1: FifoCount1,
    }
    impl RegisterBlock {
        #[doc = "0x00 - RW, SPI1 mode control"]
        #[inline(always)]
        pub const fn ctrl_mod(&self) -> &CtrlMod {
            &self.ctrl_mod
        }
        #[doc = "0x01 - RW, SPI1 configuration control"]
        #[inline(always)]
        pub const fn ctrl_cfg(&self) -> &CtrlCfg {
            &self.ctrl_cfg
        }
        #[doc = "0x02 - RW, SPI1 interrupt enable"]
        #[inline(always)]
        pub const fn inter_en(&self) -> &InterEn {
            &self.inter_en
        }
        #[doc = "0x03 - RW, SPI1 slave preset value"]
        #[inline(always)]
        pub const fn slave_pre(&self) -> &SlavePre {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(3).cast() }
        }
        #[doc = "0x03 - RW, SPI1 master clock divisor"]
        #[inline(always)]
        pub const fn clock_div(&self) -> &ClockDiv {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(3).cast() }
        }
        #[doc = "0x04 - RW, SPI1 data buffer"]
        #[inline(always)]
        pub const fn buffer(&self) -> &Buffer {
            &self.buffer
        }
        #[doc = "0x05 - RO, SPI1 work flag"]
        #[inline(always)]
        pub const fn run_flag(&self) -> &RunFlag {
            &self.run_flag
        }
        #[doc = "0x06 - RW1, SPI1 interrupt flag"]
        #[inline(always)]
        pub const fn int_flag(&self) -> &IntFlag {
            &self.int_flag
        }
        #[doc = "0x07 - RO, SPI1 FIFO count status"]
        #[inline(always)]
        pub const fn fifo_count(&self) -> &FifoCount {
            &self.fifo_count
        }
        #[doc = "0x0c - RW, SPI1 total byte count, only low 12 bit"]
        #[inline(always)]
        pub const fn total_cnt(&self) -> &TotalCnt {
            &self.total_cnt
        }
        #[doc = "0x10 - RO/WO, SPI1 FIFO register"]
        #[inline(always)]
        pub const fn fifo(&self) -> &Fifo {
            &self.fifo
        }
        #[doc = "0x13 - RO, SPI1 FIFO count status"]
        #[inline(always)]
        pub const fn fifo_count1(&self) -> &FifoCount1 {
            &self.fifo_count1
        }
    }
    #[doc = "CTRL_MOD (rw) register accessor: RW, SPI1 mode control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl_mod`] module"]
    #[doc(alias = "CTRL_MOD")]
    pub type CtrlMod = crate::Reg<ctrl_mod::CtrlModSpec>;
    #[doc = "RW, SPI1 mode control"]
    pub mod ctrl_mod {
        #[doc = "Register `CTRL_MOD` reader"]
        pub type R = crate::R<CtrlModSpec>;
        #[doc = "Register `CTRL_MOD` writer"]
        pub type W = crate::W<CtrlModSpec>;
        #[doc = "Field `ODE_SLAVE` reader - RW, SPI0 slave mode: 0=master or host, 1=slave or device"]
        pub type OdeSlaveR = crate::BitReader;
        #[doc = "Field `ODE_SLAVE` writer - RW, SPI0 slave mode: 0=master or host, 1=slave or device"]
        pub type OdeSlaveW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LL_CLEAR` reader - RW, force clear SPI FIFO and count"]
        pub type LlClearR = crate::BitReader;
        #[doc = "Field `LL_CLEAR` writer - RW, force clear SPI FIFO and count"]
        pub type LlClearW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WIRE_MOD` reader - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)"]
        pub type WireModR = crate::BitReader;
        #[doc = "Field `WIRE_MOD` writer - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)"]
        pub type WireModW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ST_SCK_MOD` reader - RW, SPI master clock mode: 0=mode 0, 1=mode 3"]
        pub type StSckModR = crate::BitReader;
        #[doc = "Field `ST_SCK_MOD` writer - RW, SPI master clock mode: 0=mode 0, 1=mode 3"]
        pub type StSckModW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `LV_CMD_MOD` reader - RW, SPI0 slave command mode: 0=byte stream, 1=first byte command"]
        pub type LvCmdModR = crate::BitReader;
        #[doc = "Field `LV_CMD_MOD` writer - RW, SPI0 slave command mode: 0=byte stream, 1=first byte command"]
        pub type LvCmdModW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IFO_DIR` reader - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)"]
        pub type IfoDirR = crate::BitReader;
        #[doc = "Field `IFO_DIR` writer - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)"]
        pub type IfoDirW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `CK_OE` reader - RW, SPI SCK output enable"]
        pub type CkOeR = crate::BitReader;
        #[doc = "Field `CK_OE` writer - RW, SPI SCK output enable"]
        pub type CkOeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `OSI_OE` reader - RW, SPI MOSI output enable"]
        pub type OsiOeR = crate::BitReader;
        #[doc = "Field `OSI_OE` writer - RW, SPI MOSI output enable"]
        pub type OsiOeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ISO_OE` reader - RW, SPI MISO output enable"]
        pub type IsoOeR = crate::BitReader;
        #[doc = "Field `ISO_OE` writer - RW, SPI MISO output enable"]
        pub type IsoOeW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, SPI0 slave mode: 0=master or host, 1=slave or device"]
            #[inline(always)]
            pub fn ode_slave(&self) -> OdeSlaveR {
                OdeSlaveR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, force clear SPI FIFO and count"]
            #[inline(always)]
            pub fn ll_clear(&self) -> LlClearR {
                LlClearR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)"]
            #[inline(always)]
            pub fn wire_mod(&self) -> WireModR {
                WireModR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, SPI master clock mode: 0=mode 0, 1=mode 3"]
            #[inline(always)]
            pub fn st_sck_mod(&self) -> StSckModR {
                StSckModR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, SPI0 slave command mode: 0=byte stream, 1=first byte command"]
            #[inline(always)]
            pub fn lv_cmd_mod(&self) -> LvCmdModR {
                LvCmdModR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)"]
            #[inline(always)]
            pub fn ifo_dir(&self) -> IfoDirR {
                IfoDirR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RW, SPI SCK output enable"]
            #[inline(always)]
            pub fn ck_oe(&self) -> CkOeR {
                CkOeR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RW, SPI MOSI output enable"]
            #[inline(always)]
            pub fn osi_oe(&self) -> OsiOeR {
                OsiOeR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RW, SPI MISO output enable"]
            #[inline(always)]
            pub fn iso_oe(&self) -> IsoOeR {
                IsoOeR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, SPI0 slave mode: 0=master or host, 1=slave or device"]
            #[inline(always)]
            pub fn ode_slave(&mut self) -> OdeSlaveW<CtrlModSpec> {
                OdeSlaveW::new(self, 0)
            }
            #[doc = "Bit 1 - RW, force clear SPI FIFO and count"]
            #[inline(always)]
            pub fn ll_clear(&mut self) -> LlClearW<CtrlModSpec> {
                LlClearW::new(self, 1)
            }
            #[doc = "Bit 2 - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)"]
            #[inline(always)]
            pub fn wire_mod(&mut self) -> WireModW<CtrlModSpec> {
                WireModW::new(self, 2)
            }
            #[doc = "Bit 3 - RW, SPI master clock mode: 0=mode 0, 1=mode 3"]
            #[inline(always)]
            pub fn st_sck_mod(&mut self) -> StSckModW<CtrlModSpec> {
                StSckModW::new(self, 3)
            }
            #[doc = "Bit 3 - RW, SPI0 slave command mode: 0=byte stream, 1=first byte command"]
            #[inline(always)]
            pub fn lv_cmd_mod(&mut self) -> LvCmdModW<CtrlModSpec> {
                LvCmdModW::new(self, 3)
            }
            #[doc = "Bit 4 - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)"]
            #[inline(always)]
            pub fn ifo_dir(&mut self) -> IfoDirW<CtrlModSpec> {
                IfoDirW::new(self, 4)
            }
            #[doc = "Bit 5 - RW, SPI SCK output enable"]
            #[inline(always)]
            pub fn ck_oe(&mut self) -> CkOeW<CtrlModSpec> {
                CkOeW::new(self, 5)
            }
            #[doc = "Bit 6 - RW, SPI MOSI output enable"]
            #[inline(always)]
            pub fn osi_oe(&mut self) -> OsiOeW<CtrlModSpec> {
                OsiOeW::new(self, 6)
            }
            #[doc = "Bit 7 - RW, SPI MISO output enable"]
            #[inline(always)]
            pub fn iso_oe(&mut self) -> IsoOeW<CtrlModSpec> {
                IsoOeW::new(self, 7)
            }
        }
        #[doc = "RW, SPI1 mode control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CtrlModSpec;
        impl crate::RegisterSpec for CtrlModSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`ctrl_mod::R`](R) reader structure"]
        impl crate::Readable for CtrlModSpec {}
        #[doc = "`write(|w| ..)` method takes [`ctrl_mod::W`](W) writer structure"]
        impl crate::Writable for CtrlModSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CTRL_MOD to value 0x02"]
        impl crate::Resettable for CtrlModSpec {
            const RESET_VALUE: u8 = 0x02;
        }
    }
    #[doc = "CTRL_CFG (rw) register accessor: RW, SPI1 configuration control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl_cfg`] module"]
    #[doc(alias = "CTRL_CFG")]
    pub type CtrlCfg = crate::Reg<ctrl_cfg::CtrlCfgSpec>;
    #[doc = "RW, SPI1 configuration control"]
    pub mod ctrl_cfg {
        #[doc = "Register `CTRL_CFG` reader"]
        pub type R = crate::R<CtrlCfgSpec>;
        #[doc = "Register `CTRL_CFG` writer"]
        pub type W = crate::W<CtrlCfgSpec>;
        #[doc = "Field `MA_ENABLE` reader - RW, SPI0 DMA enable"]
        pub type MaEnableR = crate::BitReader;
        #[doc = "Field `MA_ENABLE` writer - RW, SPI0 DMA enable"]
        pub type MaEnableW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MA_LOOP` reader - RW, SPI0 DMA address loop enable"]
        pub type MaLoopR = crate::BitReader;
        #[doc = "Field `MA_LOOP` writer - RW, SPI0 DMA address loop enable"]
        pub type MaLoopW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UTO_IF` reader - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag"]
        pub type UtoIfR = crate::BitReader;
        #[doc = "Field `UTO_IF` writer - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag"]
        pub type UtoIfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `IT_ORDER` reader - RW, SPI bit data order: 0=MSB first, 1=LSB first"]
        pub type ItOrderR = crate::BitReader;
        #[doc = "Field `IT_ORDER` writer - RW, SPI bit data order: 0=MSB first, 1=LSB first"]
        pub type ItOrderW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ST_DLY_EN` reader - RW, SPI master input delay enable"]
        pub type StDlyEnR = crate::BitReader;
        #[doc = "Field `ST_DLY_EN` writer - RW, SPI master input delay enable"]
        pub type StDlyEnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, SPI0 DMA enable"]
            #[inline(always)]
            pub fn ma_enable(&self) -> MaEnableR {
                MaEnableR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 2 - RW, SPI0 DMA address loop enable"]
            #[inline(always)]
            pub fn ma_loop(&self) -> MaLoopR {
                MaLoopR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag"]
            #[inline(always)]
            pub fn uto_if(&self) -> UtoIfR {
                UtoIfR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RW, SPI bit data order: 0=MSB first, 1=LSB first"]
            #[inline(always)]
            pub fn it_order(&self) -> ItOrderR {
                ItOrderR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RW, SPI master input delay enable"]
            #[inline(always)]
            pub fn st_dly_en(&self) -> StDlyEnR {
                StDlyEnR::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, SPI0 DMA enable"]
            #[inline(always)]
            pub fn ma_enable(&mut self) -> MaEnableW<CtrlCfgSpec> {
                MaEnableW::new(self, 0)
            }
            #[doc = "Bit 2 - RW, SPI0 DMA address loop enable"]
            #[inline(always)]
            pub fn ma_loop(&mut self) -> MaLoopW<CtrlCfgSpec> {
                MaLoopW::new(self, 2)
            }
            #[doc = "Bit 4 - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag"]
            #[inline(always)]
            pub fn uto_if(&mut self) -> UtoIfW<CtrlCfgSpec> {
                UtoIfW::new(self, 4)
            }
            #[doc = "Bit 5 - RW, SPI bit data order: 0=MSB first, 1=LSB first"]
            #[inline(always)]
            pub fn it_order(&mut self) -> ItOrderW<CtrlCfgSpec> {
                ItOrderW::new(self, 5)
            }
            #[doc = "Bit 6 - RW, SPI master input delay enable"]
            #[inline(always)]
            pub fn st_dly_en(&mut self) -> StDlyEnW<CtrlCfgSpec> {
                StDlyEnW::new(self, 6)
            }
        }
        #[doc = "RW, SPI1 configuration control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CtrlCfgSpec;
        impl crate::RegisterSpec for CtrlCfgSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`ctrl_cfg::R`](R) reader structure"]
        impl crate::Readable for CtrlCfgSpec {}
        #[doc = "`write(|w| ..)` method takes [`ctrl_cfg::W`](W) writer structure"]
        impl crate::Writable for CtrlCfgSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CTRL_CFG to value 0"]
        impl crate::Resettable for CtrlCfgSpec {}
    }
    #[doc = "INTER_EN (rw) register accessor: RW, SPI1 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`inter_en::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inter_en::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@inter_en`] module"]
    #[doc(alias = "INTER_EN")]
    pub type InterEn = crate::Reg<inter_en::InterEnSpec>;
    #[doc = "RW, SPI1 interrupt enable"]
    pub mod inter_en {
        #[doc = "Register `INTER_EN` reader"]
        pub type R = crate::R<InterEnSpec>;
        #[doc = "Register `INTER_EN` writer"]
        pub type W = crate::W<InterEnSpec>;
        #[doc = "Field `E_CNT_END` reader - RW, enable interrupt for SPI total byte count end"]
        pub type ECntEndR = crate::BitReader;
        #[doc = "Field `E_CNT_END` writer - RW, enable interrupt for SPI total byte count end"]
        pub type ECntEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_BYTE_END` reader - RW, enable interrupt for SPI byte exchanged"]
        pub type EByteEndR = crate::BitReader;
        #[doc = "Field `E_BYTE_END` writer - RW, enable interrupt for SPI byte exchanged"]
        pub type EByteEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_FIFO_HF` reader - RW, enable interrupt for SPI FIFO half"]
        pub type EFifoHfR = crate::BitReader;
        #[doc = "Field `E_FIFO_HF` writer - RW, enable interrupt for SPI FIFO half"]
        pub type EFifoHfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_DMA_END` reader - RW, enable interrupt for SPI0 DMA completion"]
        pub type EDmaEndR = crate::BitReader;
        #[doc = "Field `E_DMA_END` writer - RW, enable interrupt for SPI0 DMA completion"]
        pub type EDmaEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_FIFO_OV` reader - RW, enable interrupt for SPI0 FIFO overflow"]
        pub type EFifoOvR = crate::BitReader;
        #[doc = "Field `E_FIFO_OV` writer - RW, enable interrupt for SPI0 FIFO overflow"]
        pub type EFifoOvW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `E_FST_BYTE` reader - RW, enable interrupt for SPI0 slave mode first byte received"]
        pub type EFstByteR = crate::BitReader;
        #[doc = "Field `E_FST_BYTE` writer - RW, enable interrupt for SPI0 slave mode first byte received"]
        pub type EFstByteW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, enable interrupt for SPI total byte count end"]
            #[inline(always)]
            pub fn e_cnt_end(&self) -> ECntEndR {
                ECntEndR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, enable interrupt for SPI byte exchanged"]
            #[inline(always)]
            pub fn e_byte_end(&self) -> EByteEndR {
                EByteEndR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW, enable interrupt for SPI FIFO half"]
            #[inline(always)]
            pub fn e_fifo_hf(&self) -> EFifoHfR {
                EFifoHfR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, enable interrupt for SPI0 DMA completion"]
            #[inline(always)]
            pub fn e_dma_end(&self) -> EDmaEndR {
                EDmaEndR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, enable interrupt for SPI0 FIFO overflow"]
            #[inline(always)]
            pub fn e_fifo_ov(&self) -> EFifoOvR {
                EFifoOvR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 7 - RW, enable interrupt for SPI0 slave mode first byte received"]
            #[inline(always)]
            pub fn e_fst_byte(&self) -> EFstByteR {
                EFstByteR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, enable interrupt for SPI total byte count end"]
            #[inline(always)]
            pub fn e_cnt_end(&mut self) -> ECntEndW<InterEnSpec> {
                ECntEndW::new(self, 0)
            }
            #[doc = "Bit 1 - RW, enable interrupt for SPI byte exchanged"]
            #[inline(always)]
            pub fn e_byte_end(&mut self) -> EByteEndW<InterEnSpec> {
                EByteEndW::new(self, 1)
            }
            #[doc = "Bit 2 - RW, enable interrupt for SPI FIFO half"]
            #[inline(always)]
            pub fn e_fifo_hf(&mut self) -> EFifoHfW<InterEnSpec> {
                EFifoHfW::new(self, 2)
            }
            #[doc = "Bit 3 - RW, enable interrupt for SPI0 DMA completion"]
            #[inline(always)]
            pub fn e_dma_end(&mut self) -> EDmaEndW<InterEnSpec> {
                EDmaEndW::new(self, 3)
            }
            #[doc = "Bit 4 - RW, enable interrupt for SPI0 FIFO overflow"]
            #[inline(always)]
            pub fn e_fifo_ov(&mut self) -> EFifoOvW<InterEnSpec> {
                EFifoOvW::new(self, 4)
            }
            #[doc = "Bit 7 - RW, enable interrupt for SPI0 slave mode first byte received"]
            #[inline(always)]
            pub fn e_fst_byte(&mut self) -> EFstByteW<InterEnSpec> {
                EFstByteW::new(self, 7)
            }
        }
        #[doc = "RW, SPI1 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`inter_en::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inter_en::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct InterEnSpec;
        impl crate::RegisterSpec for InterEnSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`inter_en::R`](R) reader structure"]
        impl crate::Readable for InterEnSpec {}
        #[doc = "`write(|w| ..)` method takes [`inter_en::W`](W) writer structure"]
        impl crate::Writable for InterEnSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets INTER_EN to value 0"]
        impl crate::Resettable for InterEnSpec {}
    }
    #[doc = "CLOCK_DIV (rw) register accessor: RW, SPI1 master clock divisor\n\nYou can [`read`](crate::Reg::read) this register and get [`clock_div::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clock_div::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clock_div`] module"]
    #[doc(alias = "CLOCK_DIV")]
    pub type ClockDiv = crate::Reg<clock_div::ClockDivSpec>;
    #[doc = "RW, SPI1 master clock divisor"]
    pub mod clock_div {
        #[doc = "Register `CLOCK_DIV` reader"]
        pub type R = crate::R<ClockDivSpec>;
        #[doc = "Register `CLOCK_DIV` writer"]
        pub type W = crate::W<ClockDivSpec>;
        #[doc = "Field `CLOCK_DIV` reader - RW, SPI1 master clock divisor"]
        pub type ClockDivR = crate::FieldReader;
        #[doc = "Field `CLOCK_DIV` writer - RW, SPI1 master clock divisor"]
        pub type ClockDivW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW, SPI1 master clock divisor"]
            #[inline(always)]
            pub fn clock_div(&self) -> ClockDivR {
                ClockDivR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW, SPI1 master clock divisor"]
            #[inline(always)]
            pub fn clock_div(&mut self) -> ClockDivW<ClockDivSpec> {
                ClockDivW::new(self, 0)
            }
        }
        #[doc = "RW, SPI1 master clock divisor\n\nYou can [`read`](crate::Reg::read) this register and get [`clock_div::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clock_div::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct ClockDivSpec;
        impl crate::RegisterSpec for ClockDivSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`clock_div::R`](R) reader structure"]
        impl crate::Readable for ClockDivSpec {}
        #[doc = "`write(|w| ..)` method takes [`clock_div::W`](W) writer structure"]
        impl crate::Writable for ClockDivSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CLOCK_DIV to value 0x10"]
        impl crate::Resettable for ClockDivSpec {
            const RESET_VALUE: u8 = 0x10;
        }
    }
    #[doc = "SLAVE_PRE (rw) register accessor: RW, SPI1 slave preset value\n\nYou can [`read`](crate::Reg::read) this register and get [`slave_pre::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slave_pre::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@slave_pre`] module"]
    #[doc(alias = "SLAVE_PRE")]
    pub type SlavePre = crate::Reg<slave_pre::SlavePreSpec>;
    #[doc = "RW, SPI1 slave preset value"]
    pub mod slave_pre {
        #[doc = "Register `SLAVE_PRE` reader"]
        pub type R = crate::R<SlavePreSpec>;
        #[doc = "Register `SLAVE_PRE` writer"]
        pub type W = crate::W<SlavePreSpec>;
        #[doc = "Field `SLAVE_PRE` reader - RW, SPI1 slave preset value"]
        pub type SlavePreR = crate::FieldReader;
        #[doc = "Field `SLAVE_PRE` writer - RW, SPI1 slave preset value"]
        pub type SlavePreW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW, SPI1 slave preset value"]
            #[inline(always)]
            pub fn slave_pre(&self) -> SlavePreR {
                SlavePreR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW, SPI1 slave preset value"]
            #[inline(always)]
            pub fn slave_pre(&mut self) -> SlavePreW<SlavePreSpec> {
                SlavePreW::new(self, 0)
            }
        }
        #[doc = "RW, SPI1 slave preset value\n\nYou can [`read`](crate::Reg::read) this register and get [`slave_pre::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slave_pre::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SlavePreSpec;
        impl crate::RegisterSpec for SlavePreSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`slave_pre::R`](R) reader structure"]
        impl crate::Readable for SlavePreSpec {}
        #[doc = "`write(|w| ..)` method takes [`slave_pre::W`](W) writer structure"]
        impl crate::Writable for SlavePreSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SLAVE_PRE to value 0x10"]
        impl crate::Resettable for SlavePreSpec {
            const RESET_VALUE: u8 = 0x10;
        }
    }
    #[doc = "BUFFER (rw) register accessor: RW, SPI1 data buffer\n\nYou can [`read`](crate::Reg::read) this register and get [`buffer::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`buffer::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@buffer`] module"]
    #[doc(alias = "BUFFER")]
    pub type Buffer = crate::Reg<buffer::BufferSpec>;
    #[doc = "RW, SPI1 data buffer"]
    pub mod buffer {
        #[doc = "Register `BUFFER` reader"]
        pub type R = crate::R<BufferSpec>;
        #[doc = "Register `BUFFER` writer"]
        pub type W = crate::W<BufferSpec>;
        #[doc = "Field `BUFFER` reader - RW, SPI1 data buffer"]
        pub type BufferR = crate::FieldReader;
        #[doc = "Field `BUFFER` writer - RW, SPI1 data buffer"]
        pub type BufferW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW, SPI1 data buffer"]
            #[inline(always)]
            pub fn buffer(&self) -> BufferR {
                BufferR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW, SPI1 data buffer"]
            #[inline(always)]
            pub fn buffer(&mut self) -> BufferW<BufferSpec> {
                BufferW::new(self, 0)
            }
        }
        #[doc = "RW, SPI1 data buffer\n\nYou can [`read`](crate::Reg::read) this register and get [`buffer::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`buffer::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct BufferSpec;
        impl crate::RegisterSpec for BufferSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`buffer::R`](R) reader structure"]
        impl crate::Readable for BufferSpec {}
        #[doc = "`write(|w| ..)` method takes [`buffer::W`](W) writer structure"]
        impl crate::Writable for BufferSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets BUFFER to value 0"]
        impl crate::Resettable for BufferSpec {}
    }
    #[doc = "RUN_FLAG (r) register accessor: RO, SPI1 work flag\n\nYou can [`read`](crate::Reg::read) this register and get [`run_flag::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@run_flag`] module"]
    #[doc(alias = "RUN_FLAG")]
    pub type RunFlag = crate::Reg<run_flag::RunFlagSpec>;
    #[doc = "RO, SPI1 work flag"]
    pub mod run_flag {
        #[doc = "Register `RUN_FLAG` reader"]
        pub type R = crate::R<RunFlagSpec>;
        #[doc = "Field `LV_CMD_ACT` reader - RO, SPI0 slave first byte or command flag"]
        pub type LvCmdActR = crate::BitReader;
        #[doc = "Field `IFO_READY` reader - RO, SPI FIFO ready status"]
        pub type IfoReadyR = crate::BitReader;
        #[doc = "Field `LV_CS_LOAD` reader - RO, SPI0 slave chip-select loading status"]
        pub type LvCsLoadR = crate::BitReader;
        #[doc = "Field `LV_SELECT` reader - RO, SPI0 slave selection status"]
        pub type LvSelectR = crate::BitReader;
        impl R {
            #[doc = "Bit 4 - RO, SPI0 slave first byte or command flag"]
            #[inline(always)]
            pub fn lv_cmd_act(&self) -> LvCmdActR {
                LvCmdActR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RO, SPI FIFO ready status"]
            #[inline(always)]
            pub fn ifo_ready(&self) -> IfoReadyR {
                IfoReadyR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RO, SPI0 slave chip-select loading status"]
            #[inline(always)]
            pub fn lv_cs_load(&self) -> LvCsLoadR {
                LvCsLoadR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RO, SPI0 slave selection status"]
            #[inline(always)]
            pub fn lv_select(&self) -> LvSelectR {
                LvSelectR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        #[doc = "RO, SPI1 work flag\n\nYou can [`read`](crate::Reg::read) this register and get [`run_flag::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RunFlagSpec;
        impl crate::RegisterSpec for RunFlagSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`run_flag::R`](R) reader structure"]
        impl crate::Readable for RunFlagSpec {}
        #[doc = "`reset()` method sets RUN_FLAG to value 0"]
        impl crate::Resettable for RunFlagSpec {}
    }
    #[doc = "INT_FLAG (rw) register accessor: RW1, SPI1 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_flag`] module"]
    #[doc(alias = "INT_FLAG")]
    pub type IntFlag = crate::Reg<int_flag::IntFlagSpec>;
    #[doc = "RW1, SPI1 interrupt flag"]
    pub mod int_flag {
        #[doc = "Register `INT_FLAG` reader"]
        pub type R = crate::R<IntFlagSpec>;
        #[doc = "Register `INT_FLAG` writer"]
        pub type W = crate::W<IntFlagSpec>;
        #[doc = "Field `F_CNT_END` reader - RW1, interrupt flag for SPI total byte count end"]
        pub type FCntEndR = crate::BitReader;
        #[doc = "Field `F_CNT_END` writer - RW1, interrupt flag for SPI total byte count end"]
        pub type FCntEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_BYTE_END` reader - RW1, interrupt flag for SPI byte exchanged"]
        pub type FByteEndR = crate::BitReader;
        #[doc = "Field `F_BYTE_END` writer - RW1, interrupt flag for SPI byte exchanged"]
        pub type FByteEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_FIFO_HF` reader - RW1, interrupt flag for SPI FIFO half"]
        pub type FFifoHfR = crate::BitReader;
        #[doc = "Field `F_FIFO_HF` writer - RW1, interrupt flag for SPI FIFO half"]
        pub type FFifoHfW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_DMA_END` reader - RW1, interrupt flag for SPI0 DMA completion"]
        pub type FDmaEndR = crate::BitReader;
        #[doc = "Field `F_DMA_END` writer - RW1, interrupt flag for SPI0 DMA completion"]
        pub type FDmaEndW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_FIFO_OV` reader - RW1, interrupt flag for SPI0 FIFO overflow"]
        pub type FFifoOvR = crate::BitReader;
        #[doc = "Field `F_FIFO_OV` writer - RW1, interrupt flag for SPI0 FIFO overflow"]
        pub type FFifoOvW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `REE` reader - RO, current SPI free status"]
        pub type ReeR = crate::BitReader;
        #[doc = "Field `REE` writer - RO, current SPI free status"]
        pub type ReeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_FST_BYTE` reader - RW1, interrupt flag for SPI0 slave mode first byte received"]
        pub type FFstByteR = crate::BitReader;
        #[doc = "Field `F_FST_BYTE` writer - RW1, interrupt flag for SPI0 slave mode first byte received"]
        pub type FFstByteW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW1, interrupt flag for SPI total byte count end"]
            #[inline(always)]
            pub fn f_cnt_end(&self) -> FCntEndR {
                FCntEndR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW1, interrupt flag for SPI byte exchanged"]
            #[inline(always)]
            pub fn f_byte_end(&self) -> FByteEndR {
                FByteEndR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW1, interrupt flag for SPI FIFO half"]
            #[inline(always)]
            pub fn f_fifo_hf(&self) -> FFifoHfR {
                FFifoHfR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW1, interrupt flag for SPI0 DMA completion"]
            #[inline(always)]
            pub fn f_dma_end(&self) -> FDmaEndR {
                FDmaEndR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW1, interrupt flag for SPI0 FIFO overflow"]
            #[inline(always)]
            pub fn f_fifo_ov(&self) -> FFifoOvR {
                FFifoOvR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - RO, current SPI free status"]
            #[inline(always)]
            pub fn ree(&self) -> ReeR {
                ReeR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RW1, interrupt flag for SPI0 slave mode first byte received"]
            #[inline(always)]
            pub fn f_fst_byte(&self) -> FFstByteR {
                FFstByteR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW1, interrupt flag for SPI total byte count end"]
            #[inline(always)]
            pub fn f_cnt_end(&mut self) -> FCntEndW<IntFlagSpec> {
                FCntEndW::new(self, 0)
            }
            #[doc = "Bit 1 - RW1, interrupt flag for SPI byte exchanged"]
            #[inline(always)]
            pub fn f_byte_end(&mut self) -> FByteEndW<IntFlagSpec> {
                FByteEndW::new(self, 1)
            }
            #[doc = "Bit 2 - RW1, interrupt flag for SPI FIFO half"]
            #[inline(always)]
            pub fn f_fifo_hf(&mut self) -> FFifoHfW<IntFlagSpec> {
                FFifoHfW::new(self, 2)
            }
            #[doc = "Bit 3 - RW1, interrupt flag for SPI0 DMA completion"]
            #[inline(always)]
            pub fn f_dma_end(&mut self) -> FDmaEndW<IntFlagSpec> {
                FDmaEndW::new(self, 3)
            }
            #[doc = "Bit 4 - RW1, interrupt flag for SPI0 FIFO overflow"]
            #[inline(always)]
            pub fn f_fifo_ov(&mut self) -> FFifoOvW<IntFlagSpec> {
                FFifoOvW::new(self, 4)
            }
            #[doc = "Bit 6 - RO, current SPI free status"]
            #[inline(always)]
            pub fn ree(&mut self) -> ReeW<IntFlagSpec> {
                ReeW::new(self, 6)
            }
            #[doc = "Bit 7 - RW1, interrupt flag for SPI0 slave mode first byte received"]
            #[inline(always)]
            pub fn f_fst_byte(&mut self) -> FFstByteW<IntFlagSpec> {
                FFstByteW::new(self, 7)
            }
        }
        #[doc = "RW1, SPI1 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IntFlagSpec;
        impl crate::RegisterSpec for IntFlagSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`int_flag::R`](R) reader structure"]
        impl crate::Readable for IntFlagSpec {}
        #[doc = "`write(|w| ..)` method takes [`int_flag::W`](W) writer structure"]
        impl crate::Writable for IntFlagSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets INT_FLAG to value 0x40"]
        impl crate::Resettable for IntFlagSpec {
            const RESET_VALUE: u8 = 0x40;
        }
    }
    #[doc = "FIFO_COUNT (r) register accessor: RO, SPI1 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo_count`] module"]
    #[doc(alias = "FIFO_COUNT")]
    pub type FifoCount = crate::Reg<fifo_count::FifoCountSpec>;
    #[doc = "RO, SPI1 FIFO count status"]
    pub mod fifo_count {
        #[doc = "Register `FIFO_COUNT` reader"]
        pub type R = crate::R<FifoCountSpec>;
        #[doc = "Field `FIFO_COUNT` reader - RO, SPI0 FIFO count status"]
        pub type FifoCountR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RO, SPI0 FIFO count status"]
            #[inline(always)]
            pub fn fifo_count(&self) -> FifoCountR {
                FifoCountR::new(self.bits)
            }
        }
        #[doc = "RO, SPI1 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FifoCountSpec;
        impl crate::RegisterSpec for FifoCountSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`fifo_count::R`](R) reader structure"]
        impl crate::Readable for FifoCountSpec {}
        #[doc = "`reset()` method sets FIFO_COUNT to value 0"]
        impl crate::Resettable for FifoCountSpec {}
    }
    #[doc = "TOTAL_CNT (rw) register accessor: RW, SPI1 total byte count, only low 12 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`total_cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`total_cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@total_cnt`] module"]
    #[doc(alias = "TOTAL_CNT")]
    pub type TotalCnt = crate::Reg<total_cnt::TotalCntSpec>;
    #[doc = "RW, SPI1 total byte count, only low 12 bit"]
    pub mod total_cnt {
        #[doc = "Register `TOTAL_CNT` reader"]
        pub type R = crate::R<TotalCntSpec>;
        #[doc = "Register `TOTAL_CNT` writer"]
        pub type W = crate::W<TotalCntSpec>;
        #[doc = "Field `TOTAL_CNT` reader - RW, SPI1 total byte count, only low 12 bit"]
        pub type TotalCntR = crate::FieldReader<u16>;
        #[doc = "Field `TOTAL_CNT` writer - RW, SPI1 total byte count, only low 12 bit"]
        pub type TotalCntW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW, SPI1 total byte count, only low 12 bit"]
            #[inline(always)]
            pub fn total_cnt(&self) -> TotalCntR {
                TotalCntR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW, SPI1 total byte count, only low 12 bit"]
            #[inline(always)]
            pub fn total_cnt(&mut self) -> TotalCntW<TotalCntSpec> {
                TotalCntW::new(self, 0)
            }
        }
        #[doc = "RW, SPI1 total byte count, only low 12 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`total_cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`total_cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct TotalCntSpec;
        impl crate::RegisterSpec for TotalCntSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`total_cnt::R`](R) reader structure"]
        impl crate::Readable for TotalCntSpec {}
        #[doc = "`write(|w| ..)` method takes [`total_cnt::W`](W) writer structure"]
        impl crate::Writable for TotalCntSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets TOTAL_CNT to value 0"]
        impl crate::Resettable for TotalCntSpec {}
    }
    #[doc = "FIFO (rw) register accessor: RO/WO, SPI1 FIFO register\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fifo::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo`] module"]
    #[doc(alias = "FIFO")]
    pub type Fifo = crate::Reg<fifo::FifoSpec>;
    #[doc = "RO/WO, SPI1 FIFO register"]
    pub mod fifo {
        #[doc = "Register `FIFO` reader"]
        pub type R = crate::R<FifoSpec>;
        #[doc = "Register `FIFO` writer"]
        pub type W = crate::W<FifoSpec>;
        #[doc = "Field `FIFO` reader - RO/WO, SPI1 FIFO register"]
        pub type FifoR = crate::FieldReader;
        #[doc = "Field `FIFO` writer - RO/WO, SPI1 FIFO register"]
        pub type FifoW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RO/WO, SPI1 FIFO register"]
            #[inline(always)]
            pub fn fifo(&self) -> FifoR {
                FifoR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RO/WO, SPI1 FIFO register"]
            #[inline(always)]
            pub fn fifo(&mut self) -> FifoW<FifoSpec> {
                FifoW::new(self, 0)
            }
        }
        #[doc = "RO/WO, SPI1 FIFO register\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fifo::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FifoSpec;
        impl crate::RegisterSpec for FifoSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`fifo::R`](R) reader structure"]
        impl crate::Readable for FifoSpec {}
        #[doc = "`write(|w| ..)` method takes [`fifo::W`](W) writer structure"]
        impl crate::Writable for FifoSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FIFO to value 0"]
        impl crate::Resettable for FifoSpec {}
    }
    #[doc = "FIFO_COUNT1 (r) register accessor: RO, SPI1 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count1::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo_count1`] module"]
    #[doc(alias = "FIFO_COUNT1")]
    pub type FifoCount1 = crate::Reg<fifo_count1::FifoCount1Spec>;
    #[doc = "RO, SPI1 FIFO count status"]
    pub mod fifo_count1 {
        #[doc = "Register `FIFO_COUNT1` reader"]
        pub type R = crate::R<FifoCount1Spec>;
        #[doc = "Field `FIFO_COUNT1` reader - RO, SPI1 FIFO count status"]
        pub type FifoCount1R = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RO, SPI1 FIFO count status"]
            #[inline(always)]
            pub fn fifo_count1(&self) -> FifoCount1R {
                FifoCount1R::new(self.bits)
            }
        }
        #[doc = "RO, SPI1 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count1::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct FifoCount1Spec;
        impl crate::RegisterSpec for FifoCount1Spec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`fifo_count1::R`](R) reader structure"]
        impl crate::Readable for FifoCount1Spec {}
        #[doc = "`reset()` method sets FIFO_COUNT1 to value 0"]
        impl crate::Resettable for FifoCount1Spec {}
    }
}
#[doc = "I2C register"]
pub type I2c = crate::Periph<i2c::RegisterBlock, 0x4000_4800>;
impl core::fmt::Debug for I2c {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2c").finish()
    }
}
#[doc = "I2C register"]
pub mod i2c {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        ctrl1: Ctrl1,
        _reserved1: [u8; 0x02],
        ctrl2: Ctrl2,
        _reserved2: [u8; 0x02],
        oaddr1: Oaddr1,
        _reserved3: [u8; 0x02],
        oaddr2: Oaddr2,
        _reserved4: [u8; 0x02],
        datar: Datar,
        _reserved5: [u8; 0x02],
        star1: Star1,
        _reserved6: [u8; 0x02],
        _reserved_6_pec: [u8; 0x02],
        _reserved7: [u8; 0x02],
        ckcfgr: Ckcfgr,
        _reserved8: [u8; 0x02],
        rtr: Rtr,
    }
    impl RegisterBlock {
        #[doc = "0x00 - RW, I2C control 1"]
        #[inline(always)]
        pub const fn ctrl1(&self) -> &Ctrl1 {
            &self.ctrl1
        }
        #[doc = "0x04 - RW, I2C control 2"]
        #[inline(always)]
        pub const fn ctrl2(&self) -> &Ctrl2 {
            &self.ctrl2
        }
        #[doc = "0x08 - RW, I2C own address register 1"]
        #[inline(always)]
        pub const fn oaddr1(&self) -> &Oaddr1 {
            &self.oaddr1
        }
        #[doc = "0x0c - RW, I2C own address register 2"]
        #[inline(always)]
        pub const fn oaddr2(&self) -> &Oaddr2 {
            &self.oaddr2
        }
        #[doc = "0x10 - RW, I2C data register"]
        #[inline(always)]
        pub const fn datar(&self) -> &Datar {
            &self.datar
        }
        #[doc = "0x14 - R0, I2C stauts register 1"]
        #[inline(always)]
        pub const fn star1(&self) -> &Star1 {
            &self.star1
        }
        #[doc = "0x18 - R0, I2C status register 2"]
        #[inline(always)]
        pub const fn star2(&self) -> &Star2 {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(24).cast() }
        }
        #[doc = "0x19 - R0, I2C Packet error checking register"]
        #[inline(always)]
        pub const fn pec(&self) -> &Pec {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(25).cast() }
        }
        #[doc = "0x1c - RW, I2C clock control register"]
        #[inline(always)]
        pub const fn ckcfgr(&self) -> &Ckcfgr {
            &self.ckcfgr
        }
        #[doc = "0x20 - RW, I2C trise register"]
        #[inline(always)]
        pub const fn rtr(&self) -> &Rtr {
            &self.rtr
        }
    }
    #[doc = "CTRL1 (rw) register accessor: RW, I2C control 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl1`] module"]
    #[doc(alias = "CTRL1")]
    pub type Ctrl1 = crate::Reg<ctrl1::Ctrl1Spec>;
    #[doc = "RW, I2C control 1"]
    pub mod ctrl1 {
        #[doc = "Register `CTRL1` reader"]
        pub type R = crate::R<Ctrl1Spec>;
        #[doc = "Register `CTRL1` writer"]
        pub type W = crate::W<Ctrl1Spec>;
        #[doc = "Field `PE` reader - RW, Peripheral enable"]
        pub type PeR = crate::BitReader;
        #[doc = "Field `PE` writer - RW, Peripheral enable"]
        pub type PeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SMBUS` reader - RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode"]
        pub type SmbusR = crate::BitReader;
        #[doc = "Field `SMBUS` writer - RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode"]
        pub type SmbusW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SMBTYPE` reader - RW, SMBus type: 0=Device, 1=Host"]
        pub type SmbtypeR = crate::BitReader;
        #[doc = "Field `SMBTYPE` writer - RW, SMBus type: 0=Device, 1=Host"]
        pub type SmbtypeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `EBARP` reader - RW, ARP enable"]
        pub type EbarpR = crate::BitReader;
        #[doc = "Field `EBARP` writer - RW, ARP enable"]
        pub type EbarpW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ENPEC` reader - RW, PEC ebable"]
        pub type EnpecR = crate::BitReader;
        #[doc = "Field `ENPEC` writer - RW, PEC ebable"]
        pub type EnpecW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ENGC` reader - RW, General call enable"]
        pub type EngcR = crate::BitReader;
        #[doc = "Field `ENGC` writer - RW, General call enable"]
        pub type EngcW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `NOSTRETCH` reader - RW, Clock stretching disable (Slave mode)"]
        pub type NostretchR = crate::BitReader;
        #[doc = "Field `NOSTRETCH` writer - RW, Clock stretching disable (Slave mode)"]
        pub type NostretchW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `START` reader - RW, Start generation: master mode: 0=no start, 1=repeated start; slave mode: 0=no start, 1=start at bus free"]
        pub type StartR = crate::BitReader;
        #[doc = "Field `START` writer - RW, Start generation: master mode: 0=no start, 1=repeated start; slave mode: 0=no start, 1=start at bus free"]
        pub type StartW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `STOP` reader - RW, Stop generation: master mode: 0=no stop, 1=stop after the current byte transfer or after the current Start condition is sent; slave mode: 0=no stop, 1=Release the SCL and SDA lines after the current byte transfer"]
        pub type StopR = crate::BitReader;
        #[doc = "Field `STOP` writer - RW, Stop generation: master mode: 0=no stop, 1=stop after the current byte transfer or after the current Start condition is sent; slave mode: 0=no stop, 1=Release the SCL and SDA lines after the current byte transfer"]
        pub type StopW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ACK` reader - RW, Acknowledge enable"]
        pub type AckR = crate::BitReader;
        #[doc = "Field `ACK` writer - RW, Acknowledge enable"]
        pub type AckW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `POS` reader - RW, Acknowledge/PEC Position (for data reception)"]
        pub type PosR = crate::BitReader;
        #[doc = "Field `POS` writer - RW, Acknowledge/PEC Position (for data reception)"]
        pub type PosW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PEC` reader - RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer (in Tx or Rx mode)"]
        pub type PecR = crate::BitReader;
        #[doc = "Field `PEC` writer - RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer (in Tx or Rx mode)"]
        pub type PecW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ALERT` reader - RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin low."]
        pub type AlertR = crate::BitReader;
        #[doc = "Field `ALERT` writer - RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin low."]
        pub type AlertW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SWRST` reader - RW, Software reset"]
        pub type SwrstR = crate::BitReader;
        #[doc = "Field `SWRST` writer - RW, Software reset"]
        pub type SwrstW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, Peripheral enable"]
            #[inline(always)]
            pub fn pe(&self) -> PeR {
                PeR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode"]
            #[inline(always)]
            pub fn smbus(&self) -> SmbusR {
                SmbusR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, SMBus type: 0=Device, 1=Host"]
            #[inline(always)]
            pub fn smbtype(&self) -> SmbtypeR {
                SmbtypeR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, ARP enable"]
            #[inline(always)]
            pub fn ebarp(&self) -> EbarpR {
                EbarpR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RW, PEC ebable"]
            #[inline(always)]
            pub fn enpec(&self) -> EnpecR {
                EnpecR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RW, General call enable"]
            #[inline(always)]
            pub fn engc(&self) -> EngcR {
                EngcR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RW, Clock stretching disable (Slave mode)"]
            #[inline(always)]
            pub fn nostretch(&self) -> NostretchR {
                NostretchR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - RW, Start generation: master mode: 0=no start, 1=repeated start; slave mode: 0=no start, 1=start at bus free"]
            #[inline(always)]
            pub fn start(&self) -> StartR {
                StartR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - RW, Stop generation: master mode: 0=no stop, 1=stop after the current byte transfer or after the current Start condition is sent; slave mode: 0=no stop, 1=Release the SCL and SDA lines after the current byte transfer"]
            #[inline(always)]
            pub fn stop(&self) -> StopR {
                StopR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - RW, Acknowledge enable"]
            #[inline(always)]
            pub fn ack(&self) -> AckR {
                AckR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - RW, Acknowledge/PEC Position (for data reception)"]
            #[inline(always)]
            pub fn pos(&self) -> PosR {
                PosR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer (in Tx or Rx mode)"]
            #[inline(always)]
            pub fn pec(&self) -> PecR {
                PecR::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin low."]
            #[inline(always)]
            pub fn alert(&self) -> AlertR {
                AlertR::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 15 - RW, Software reset"]
            #[inline(always)]
            pub fn swrst(&self) -> SwrstR {
                SwrstR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, Peripheral enable"]
            #[inline(always)]
            pub fn pe(&mut self) -> PeW<Ctrl1Spec> {
                PeW::new(self, 0)
            }
            #[doc = "Bit 1 - RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode"]
            #[inline(always)]
            pub fn smbus(&mut self) -> SmbusW<Ctrl1Spec> {
                SmbusW::new(self, 1)
            }
            #[doc = "Bit 3 - RW, SMBus type: 0=Device, 1=Host"]
            #[inline(always)]
            pub fn smbtype(&mut self) -> SmbtypeW<Ctrl1Spec> {
                SmbtypeW::new(self, 3)
            }
            #[doc = "Bit 4 - RW, ARP enable"]
            #[inline(always)]
            pub fn ebarp(&mut self) -> EbarpW<Ctrl1Spec> {
                EbarpW::new(self, 4)
            }
            #[doc = "Bit 5 - RW, PEC ebable"]
            #[inline(always)]
            pub fn enpec(&mut self) -> EnpecW<Ctrl1Spec> {
                EnpecW::new(self, 5)
            }
            #[doc = "Bit 6 - RW, General call enable"]
            #[inline(always)]
            pub fn engc(&mut self) -> EngcW<Ctrl1Spec> {
                EngcW::new(self, 6)
            }
            #[doc = "Bit 7 - RW, Clock stretching disable (Slave mode)"]
            #[inline(always)]
            pub fn nostretch(&mut self) -> NostretchW<Ctrl1Spec> {
                NostretchW::new(self, 7)
            }
            #[doc = "Bit 8 - RW, Start generation: master mode: 0=no start, 1=repeated start; slave mode: 0=no start, 1=start at bus free"]
            #[inline(always)]
            pub fn start(&mut self) -> StartW<Ctrl1Spec> {
                StartW::new(self, 8)
            }
            #[doc = "Bit 9 - RW, Stop generation: master mode: 0=no stop, 1=stop after the current byte transfer or after the current Start condition is sent; slave mode: 0=no stop, 1=Release the SCL and SDA lines after the current byte transfer"]
            #[inline(always)]
            pub fn stop(&mut self) -> StopW<Ctrl1Spec> {
                StopW::new(self, 9)
            }
            #[doc = "Bit 10 - RW, Acknowledge enable"]
            #[inline(always)]
            pub fn ack(&mut self) -> AckW<Ctrl1Spec> {
                AckW::new(self, 10)
            }
            #[doc = "Bit 11 - RW, Acknowledge/PEC Position (for data reception)"]
            #[inline(always)]
            pub fn pos(&mut self) -> PosW<Ctrl1Spec> {
                PosW::new(self, 11)
            }
            #[doc = "Bit 12 - RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer (in Tx or Rx mode)"]
            #[inline(always)]
            pub fn pec(&mut self) -> PecW<Ctrl1Spec> {
                PecW::new(self, 12)
            }
            #[doc = "Bit 13 - RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin low."]
            #[inline(always)]
            pub fn alert(&mut self) -> AlertW<Ctrl1Spec> {
                AlertW::new(self, 13)
            }
            #[doc = "Bit 15 - RW, Software reset"]
            #[inline(always)]
            pub fn swrst(&mut self) -> SwrstW<Ctrl1Spec> {
                SwrstW::new(self, 15)
            }
        }
        #[doc = "RW, I2C control 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ctrl1Spec;
        impl crate::RegisterSpec for Ctrl1Spec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`ctrl1::R`](R) reader structure"]
        impl crate::Readable for Ctrl1Spec {}
        #[doc = "`write(|w| ..)` method takes [`ctrl1::W`](W) writer structure"]
        impl crate::Writable for Ctrl1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CTRL1 to value 0"]
        impl crate::Resettable for Ctrl1Spec {}
    }
    #[doc = "CTRL2 (rw) register accessor: RW, I2C control 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl2`] module"]
    #[doc(alias = "CTRL2")]
    pub type Ctrl2 = crate::Reg<ctrl2::Ctrl2Spec>;
    #[doc = "RW, I2C control 2"]
    pub mod ctrl2 {
        #[doc = "Register `CTRL2` reader"]
        pub type R = crate::R<Ctrl2Spec>;
        #[doc = "Register `CTRL2` writer"]
        pub type W = crate::W<Ctrl2Spec>;
        #[doc = "Field `FREQ` reader - RW, Peripheral clock frequency, The minimum allowed frequency is 2 MHz,the maximum frequency is 36 MHz"]
        pub type FreqR = crate::FieldReader;
        #[doc = "Field `FREQ` writer - RW, Peripheral clock frequency, The minimum allowed frequency is 2 MHz,the maximum frequency is 36 MHz"]
        pub type FreqW<'a, REG> = crate::FieldWriter<'a, REG, 6>;
        #[doc = "Field `ITERREN` reader - RW, Error interrupt enable"]
        pub type IterrenR = crate::BitReader;
        #[doc = "Field `ITERREN` writer - RW, Error interrupt enable"]
        pub type IterrenW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ITEVTEN` reader - RW, Event interrupt enable"]
        pub type ItevtenR = crate::BitReader;
        #[doc = "Field `ITEVTEN` writer - RW, Event interrupt enable"]
        pub type ItevtenW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ITBUFEN` reader - RW, Buffer interrupt enable"]
        pub type ItbufenR = crate::BitReader;
        #[doc = "Field `ITBUFEN` writer - RW, Buffer interrupt enable"]
        pub type ItbufenW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:5 - RW, Peripheral clock frequency, The minimum allowed frequency is 2 MHz,the maximum frequency is 36 MHz"]
            #[inline(always)]
            pub fn freq(&self) -> FreqR {
                FreqR::new((self.bits & 0x3f) as u8)
            }
            #[doc = "Bit 8 - RW, Error interrupt enable"]
            #[inline(always)]
            pub fn iterren(&self) -> IterrenR {
                IterrenR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - RW, Event interrupt enable"]
            #[inline(always)]
            pub fn itevten(&self) -> ItevtenR {
                ItevtenR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - RW, Buffer interrupt enable"]
            #[inline(always)]
            pub fn itbufen(&self) -> ItbufenR {
                ItbufenR::new(((self.bits >> 10) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:5 - RW, Peripheral clock frequency, The minimum allowed frequency is 2 MHz,the maximum frequency is 36 MHz"]
            #[inline(always)]
            pub fn freq(&mut self) -> FreqW<Ctrl2Spec> {
                FreqW::new(self, 0)
            }
            #[doc = "Bit 8 - RW, Error interrupt enable"]
            #[inline(always)]
            pub fn iterren(&mut self) -> IterrenW<Ctrl2Spec> {
                IterrenW::new(self, 8)
            }
            #[doc = "Bit 9 - RW, Event interrupt enable"]
            #[inline(always)]
            pub fn itevten(&mut self) -> ItevtenW<Ctrl2Spec> {
                ItevtenW::new(self, 9)
            }
            #[doc = "Bit 10 - RW, Buffer interrupt enable"]
            #[inline(always)]
            pub fn itbufen(&mut self) -> ItbufenW<Ctrl2Spec> {
                ItbufenW::new(self, 10)
            }
        }
        #[doc = "RW, I2C control 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ctrl2Spec;
        impl crate::RegisterSpec for Ctrl2Spec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`ctrl2::R`](R) reader structure"]
        impl crate::Readable for Ctrl2Spec {}
        #[doc = "`write(|w| ..)` method takes [`ctrl2::W`](W) writer structure"]
        impl crate::Writable for Ctrl2Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CTRL2 to value 0"]
        impl crate::Resettable for Ctrl2Spec {}
    }
    #[doc = "OADDR1 (rw) register accessor: RW, I2C own address register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`oaddr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`oaddr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@oaddr1`] module"]
    #[doc(alias = "OADDR1")]
    pub type Oaddr1 = crate::Reg<oaddr1::Oaddr1Spec>;
    #[doc = "RW, I2C own address register 1"]
    pub mod oaddr1 {
        #[doc = "Register `OADDR1` reader"]
        pub type R = crate::R<Oaddr1Spec>;
        #[doc = "Register `OADDR1` writer"]
        pub type W = crate::W<Oaddr1Spec>;
        #[doc = "Field `ADD0` reader - RW, bit0 of address in 10-bit addressing mode"]
        pub type Add0R = crate::BitReader;
        #[doc = "Field `ADD0` writer - RW, bit0 of address in 10-bit addressing mode"]
        pub type Add0W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ADD7_1` reader - RW, bit\\[7:1\\] of address"]
        pub type Add7_1R = crate::FieldReader;
        #[doc = "Field `ADD7_1` writer - RW, bit\\[7:1\\] of address"]
        pub type Add7_1W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        #[doc = "Field `ADD9_8` reader - RW, bit\\[9:8\\] of address in 10-bit addressing mode"]
        pub type Add9_8R = crate::FieldReader;
        #[doc = "Field `ADD9_8` writer - RW, bit\\[9:8\\] of address in 10-bit addressing mode"]
        pub type Add9_8W<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `MUST1` reader - RW, Should always be kept at 1"]
        pub type Must1R = crate::BitReader;
        #[doc = "Field `MUST1` writer - RW, Should always be kept at 1"]
        pub type Must1W<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ADDMODE` reader - RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit slave address"]
        pub type AddmodeR = crate::BitReader;
        #[doc = "Field `ADDMODE` writer - RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit slave address"]
        pub type AddmodeW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, bit0 of address in 10-bit addressing mode"]
            #[inline(always)]
            pub fn add0(&self) -> Add0R {
                Add0R::new((self.bits & 1) != 0)
            }
            #[doc = "Bits 1:7 - RW, bit\\[7:1\\] of address"]
            #[inline(always)]
            pub fn add7_1(&self) -> Add7_1R {
                Add7_1R::new(((self.bits >> 1) & 0x7f) as u8)
            }
            #[doc = "Bits 8:9 - RW, bit\\[9:8\\] of address in 10-bit addressing mode"]
            #[inline(always)]
            pub fn add9_8(&self) -> Add9_8R {
                Add9_8R::new(((self.bits >> 8) & 3) as u8)
            }
            #[doc = "Bit 14 - RW, Should always be kept at 1"]
            #[inline(always)]
            pub fn must1(&self) -> Must1R {
                Must1R::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit slave address"]
            #[inline(always)]
            pub fn addmode(&self) -> AddmodeR {
                AddmodeR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, bit0 of address in 10-bit addressing mode"]
            #[inline(always)]
            pub fn add0(&mut self) -> Add0W<Oaddr1Spec> {
                Add0W::new(self, 0)
            }
            #[doc = "Bits 1:7 - RW, bit\\[7:1\\] of address"]
            #[inline(always)]
            pub fn add7_1(&mut self) -> Add7_1W<Oaddr1Spec> {
                Add7_1W::new(self, 1)
            }
            #[doc = "Bits 8:9 - RW, bit\\[9:8\\] of address in 10-bit addressing mode"]
            #[inline(always)]
            pub fn add9_8(&mut self) -> Add9_8W<Oaddr1Spec> {
                Add9_8W::new(self, 8)
            }
            #[doc = "Bit 14 - RW, Should always be kept at 1"]
            #[inline(always)]
            pub fn must1(&mut self) -> Must1W<Oaddr1Spec> {
                Must1W::new(self, 14)
            }
            #[doc = "Bit 15 - RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit slave address"]
            #[inline(always)]
            pub fn addmode(&mut self) -> AddmodeW<Oaddr1Spec> {
                AddmodeW::new(self, 15)
            }
        }
        #[doc = "RW, I2C own address register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`oaddr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`oaddr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Oaddr1Spec;
        impl crate::RegisterSpec for Oaddr1Spec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`oaddr1::R`](R) reader structure"]
        impl crate::Readable for Oaddr1Spec {}
        #[doc = "`write(|w| ..)` method takes [`oaddr1::W`](W) writer structure"]
        impl crate::Writable for Oaddr1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets OADDR1 to value 0"]
        impl crate::Resettable for Oaddr1Spec {}
    }
    #[doc = "OADDR2 (rw) register accessor: RW, I2C own address register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`oaddr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`oaddr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@oaddr2`] module"]
    #[doc(alias = "OADDR2")]
    pub type Oaddr2 = crate::Reg<oaddr2::Oaddr2Spec>;
    #[doc = "RW, I2C own address register 2"]
    pub mod oaddr2 {
        #[doc = "Register `OADDR2` reader"]
        pub type R = crate::R<Oaddr2Spec>;
        #[doc = "Register `OADDR2` writer"]
        pub type W = crate::W<Oaddr2Spec>;
        #[doc = "Field `ENDUAL` reader - RW, Dual addressing mode enable"]
        pub type EndualR = crate::BitReader;
        #[doc = "Field `ENDUAL` writer - RW, Dual addressing mode enable"]
        pub type EndualW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ADD2` reader - RW, bit\\[7:1\\] of address2"]
        pub type Add2R = crate::FieldReader;
        #[doc = "Field `ADD2` writer - RW, bit\\[7:1\\] of address2"]
        pub type Add2W<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        impl R {
            #[doc = "Bit 0 - RW, Dual addressing mode enable"]
            #[inline(always)]
            pub fn endual(&self) -> EndualR {
                EndualR::new((self.bits & 1) != 0)
            }
            #[doc = "Bits 1:7 - RW, bit\\[7:1\\] of address2"]
            #[inline(always)]
            pub fn add2(&self) -> Add2R {
                Add2R::new(((self.bits >> 1) & 0x7f) as u8)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, Dual addressing mode enable"]
            #[inline(always)]
            pub fn endual(&mut self) -> EndualW<Oaddr2Spec> {
                EndualW::new(self, 0)
            }
            #[doc = "Bits 1:7 - RW, bit\\[7:1\\] of address2"]
            #[inline(always)]
            pub fn add2(&mut self) -> Add2W<Oaddr2Spec> {
                Add2W::new(self, 1)
            }
        }
        #[doc = "RW, I2C own address register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`oaddr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`oaddr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Oaddr2Spec;
        impl crate::RegisterSpec for Oaddr2Spec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`oaddr2::R`](R) reader structure"]
        impl crate::Readable for Oaddr2Spec {}
        #[doc = "`write(|w| ..)` method takes [`oaddr2::W`](W) writer structure"]
        impl crate::Writable for Oaddr2Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets OADDR2 to value 0"]
        impl crate::Resettable for Oaddr2Spec {}
    }
    #[doc = "DATAR (rw) register accessor: RW, I2C data register\n\nYou can [`read`](crate::Reg::read) this register and get [`datar::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`datar::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@datar`] module"]
    #[doc(alias = "DATAR")]
    pub type Datar = crate::Reg<datar::DatarSpec>;
    #[doc = "RW, I2C data register"]
    pub mod datar {
        #[doc = "Register `DATAR` reader"]
        pub type R = crate::R<DatarSpec>;
        #[doc = "Register `DATAR` writer"]
        pub type W = crate::W<DatarSpec>;
        #[doc = "Field `DATAR` reader - RW, I2C data register"]
        pub type DatarR = crate::FieldReader;
        #[doc = "Field `DATAR` writer - RW, I2C data register"]
        pub type DatarW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW, I2C data register"]
            #[inline(always)]
            pub fn datar(&self) -> DatarR {
                DatarR::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW, I2C data register"]
            #[inline(always)]
            pub fn datar(&mut self) -> DatarW<DatarSpec> {
                DatarW::new(self, 0)
            }
        }
        #[doc = "RW, I2C data register\n\nYou can [`read`](crate::Reg::read) this register and get [`datar::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`datar::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DatarSpec;
        impl crate::RegisterSpec for DatarSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`datar::R`](R) reader structure"]
        impl crate::Readable for DatarSpec {}
        #[doc = "`write(|w| ..)` method takes [`datar::W`](W) writer structure"]
        impl crate::Writable for DatarSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DATAR to value 0"]
        impl crate::Resettable for DatarSpec {}
    }
    #[doc = "STAR1 (r) register accessor: R0, I2C stauts register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`star1::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@star1`] module"]
    #[doc(alias = "STAR1")]
    pub type Star1 = crate::Reg<star1::Star1Spec>;
    #[doc = "R0, I2C stauts register 1"]
    pub mod star1 {
        #[doc = "Register `STAR1` reader"]
        pub type R = crate::R<Star1Spec>;
        #[doc = "Field `SB` reader - RW0, Start bit flag (Master mode)"]
        pub type SbR = crate::BitReader;
        #[doc = "Field `ADDR` reader - RW0, Address sent (master mode)/matched (slave mode) flag"]
        pub type AddrR = crate::BitReader;
        #[doc = "Field `BTF` reader - RO, Byte transfer finished flag"]
        pub type BtfR = crate::BitReader;
        #[doc = "Field `ADD10` reader - RO, 10-bit header sent flag (Master mode)"]
        pub type Add10R = crate::BitReader;
        #[doc = "Field `STOPF` reader - RO, Stop detection flag (slave mode)"]
        pub type StopfR = crate::BitReader;
        #[doc = "Field `RxNE` reader - RO, Data register not empty flag (receivers)"]
        pub type RxNeR = crate::BitReader;
        #[doc = "Field `TxE` reader - RO, Data register empty flag (transmitters)"]
        pub type TxER = crate::BitReader;
        #[doc = "Field `BERR` reader - RW0, Bus error flag"]
        pub type BerrR = crate::BitReader;
        #[doc = "Field `ARLO` reader - RW0, Arbitration lost flag (master mode)"]
        pub type ArloR = crate::BitReader;
        #[doc = "Field `AF` reader - RW0, Acknowledge failure flag"]
        pub type AfR = crate::BitReader;
        #[doc = "Field `OVR` reader - RW0, Overrun/Underrun flag"]
        pub type OvrR = crate::BitReader;
        #[doc = "Field `PECERR` reader - RW0, PEC Error flag in reception"]
        pub type PecerrR = crate::BitReader;
        #[doc = "Field `TIMEOUT` reader - RW0, Timeout or Tlow error flag"]
        pub type TimeoutR = crate::BitReader;
        #[doc = "Field `SMBALERT` reader - RW0, SMBus alert flag"]
        pub type SmbalertR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - RW0, Start bit flag (Master mode)"]
            #[inline(always)]
            pub fn sb(&self) -> SbR {
                SbR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW0, Address sent (master mode)/matched (slave mode) flag"]
            #[inline(always)]
            pub fn addr(&self) -> AddrR {
                AddrR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RO, Byte transfer finished flag"]
            #[inline(always)]
            pub fn btf(&self) -> BtfR {
                BtfR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RO, 10-bit header sent flag (Master mode)"]
            #[inline(always)]
            pub fn add10(&self) -> Add10R {
                Add10R::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RO, Stop detection flag (slave mode)"]
            #[inline(always)]
            pub fn stopf(&self) -> StopfR {
                StopfR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - RO, Data register not empty flag (receivers)"]
            #[inline(always)]
            pub fn rx_ne(&self) -> RxNeR {
                RxNeR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RO, Data register empty flag (transmitters)"]
            #[inline(always)]
            pub fn tx_e(&self) -> TxER {
                TxER::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bit 8 - RW0, Bus error flag"]
            #[inline(always)]
            pub fn berr(&self) -> BerrR {
                BerrR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - RW0, Arbitration lost flag (master mode)"]
            #[inline(always)]
            pub fn arlo(&self) -> ArloR {
                ArloR::new(((self.bits >> 9) & 1) != 0)
            }
            #[doc = "Bit 10 - RW0, Acknowledge failure flag"]
            #[inline(always)]
            pub fn af(&self) -> AfR {
                AfR::new(((self.bits >> 10) & 1) != 0)
            }
            #[doc = "Bit 11 - RW0, Overrun/Underrun flag"]
            #[inline(always)]
            pub fn ovr(&self) -> OvrR {
                OvrR::new(((self.bits >> 11) & 1) != 0)
            }
            #[doc = "Bit 12 - RW0, PEC Error flag in reception"]
            #[inline(always)]
            pub fn pecerr(&self) -> PecerrR {
                PecerrR::new(((self.bits >> 12) & 1) != 0)
            }
            #[doc = "Bit 13 - RW0, Timeout or Tlow error flag"]
            #[inline(always)]
            pub fn timeout(&self) -> TimeoutR {
                TimeoutR::new(((self.bits >> 13) & 1) != 0)
            }
            #[doc = "Bit 15 - RW0, SMBus alert flag"]
            #[inline(always)]
            pub fn smbalert(&self) -> SmbalertR {
                SmbalertR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        #[doc = "R0, I2C stauts register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`star1::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Star1Spec;
        impl crate::RegisterSpec for Star1Spec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`star1::R`](R) reader structure"]
        impl crate::Readable for Star1Spec {}
        #[doc = "`reset()` method sets STAR1 to value 0"]
        impl crate::Resettable for Star1Spec {}
    }
    #[doc = "STAR2 (r) register accessor: R0, I2C status register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`star2::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@star2`] module"]
    #[doc(alias = "STAR2")]
    pub type Star2 = crate::Reg<star2::Star2Spec>;
    #[doc = "R0, I2C status register 2"]
    pub mod star2 {
        #[doc = "Register `STAR2` reader"]
        pub type R = crate::R<Star2Spec>;
        #[doc = "Field `MSL` reader - RO, Mode statu: 0=Slave mode, 1=Master mode"]
        pub type MslR = crate::BitReader;
        #[doc = "Field `BUSY` reader - RO, Bus busy flag"]
        pub type BusyR = crate::BitReader;
        #[doc = "Field `TRA` reader - RO, Trans flag: 0=data bytes received, 1=data bytes transmitted"]
        pub type TraR = crate::BitReader;
        #[doc = "Field `GENCALL` reader - RO, General call address (Slave mode) received flag"]
        pub type GencallR = crate::BitReader;
        #[doc = "Field `SMBDEFAULT` reader - RO, SMBus device default address (Slave mode) received flag"]
        pub type SmbdefaultR = crate::BitReader;
        #[doc = "Field `SMBHOST` reader - RO, SMBus host header (Slave mode) received flag"]
        pub type SmbhostR = crate::BitReader;
        #[doc = "Field `DUALF` reader - RO, Dual flag (Slave mode): 0=Received address matched with OAR1, 1=Received address matched with OAR2"]
        pub type DualfR = crate::BitReader;
        #[doc = "Field `PECX` reader - RO, Packet error checking register"]
        pub type PecxR = crate::FieldReader;
        impl R {
            #[doc = "Bit 0 - RO, Mode statu: 0=Slave mode, 1=Master mode"]
            #[inline(always)]
            pub fn msl(&self) -> MslR {
                MslR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RO, Bus busy flag"]
            #[inline(always)]
            pub fn busy(&self) -> BusyR {
                BusyR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RO, Trans flag: 0=data bytes received, 1=data bytes transmitted"]
            #[inline(always)]
            pub fn tra(&self) -> TraR {
                TraR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 4 - RO, General call address (Slave mode) received flag"]
            #[inline(always)]
            pub fn gencall(&self) -> GencallR {
                GencallR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RO, SMBus device default address (Slave mode) received flag"]
            #[inline(always)]
            pub fn smbdefault(&self) -> SmbdefaultR {
                SmbdefaultR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RO, SMBus host header (Slave mode) received flag"]
            #[inline(always)]
            pub fn smbhost(&self) -> SmbhostR {
                SmbhostR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RO, Dual flag (Slave mode): 0=Received address matched with OAR1, 1=Received address matched with OAR2"]
            #[inline(always)]
            pub fn dualf(&self) -> DualfR {
                DualfR::new(((self.bits >> 7) & 1) != 0)
            }
            #[doc = "Bits 8:15 - RO, Packet error checking register"]
            #[inline(always)]
            pub fn pecx(&self) -> PecxR {
                PecxR::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        #[doc = "R0, I2C status register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`star2::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Star2Spec;
        impl crate::RegisterSpec for Star2Spec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`star2::R`](R) reader structure"]
        impl crate::Readable for Star2Spec {}
        #[doc = "`reset()` method sets STAR2 to value 0"]
        impl crate::Resettable for Star2Spec {}
    }
    #[doc = "PEC (r) register accessor: R0, I2C Packet error checking register\n\nYou can [`read`](crate::Reg::read) this register and get [`pec::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pec`] module"]
    #[doc(alias = "PEC")]
    pub type Pec = crate::Reg<pec::PecSpec>;
    #[doc = "R0, I2C Packet error checking register"]
    pub mod pec {
        #[doc = "Register `PEC` reader"]
        pub type R = crate::R<PecSpec>;
        #[doc = "Field `SPI0_FIFO_COUNT` reader - RO, SPI0 FIFO count status"]
        pub type Spi0FifoCountR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RO, SPI0 FIFO count status"]
            #[inline(always)]
            pub fn spi0_fifo_count(&self) -> Spi0FifoCountR {
                Spi0FifoCountR::new(self.bits)
            }
        }
        #[doc = "R0, I2C Packet error checking register\n\nYou can [`read`](crate::Reg::read) this register and get [`pec::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PecSpec;
        impl crate::RegisterSpec for PecSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`pec::R`](R) reader structure"]
        impl crate::Readable for PecSpec {}
        #[doc = "`reset()` method sets PEC to value 0"]
        impl crate::Resettable for PecSpec {}
    }
    #[doc = "CKCFGR (rw) register accessor: RW, I2C clock control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ckcfgr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ckcfgr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ckcfgr`] module"]
    #[doc(alias = "CKCFGR")]
    pub type Ckcfgr = crate::Reg<ckcfgr::CkcfgrSpec>;
    #[doc = "RW, I2C clock control register"]
    pub mod ckcfgr {
        #[doc = "Register `CKCFGR` reader"]
        pub type R = crate::R<CkcfgrSpec>;
        #[doc = "Register `CKCFGR` writer"]
        pub type W = crate::W<CkcfgrSpec>;
        #[doc = "Field `CCR` reader - RW, Controls the SCL clock in Fm/Sm mode (Master mode)"]
        pub type CcrR = crate::FieldReader<u16>;
        #[doc = "Field `CCR` writer - RW, Controls the SCL clock in Fm/Sm mode (Master mode)"]
        pub type CcrW<'a, REG> = crate::FieldWriter<'a, REG, 12, u16>;
        #[doc = "Field `DUTY` reader - RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9"]
        pub type DutyR = crate::BitReader;
        #[doc = "Field `DUTY` writer - RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9"]
        pub type DutyW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `F_S` reader - RW, I2C master mode selection: 0=standard mode, 1=fast mode"]
        pub type FSR = crate::BitReader;
        #[doc = "Field `F_S` writer - RW, I2C master mode selection: 0=standard mode, 1=fast mode"]
        pub type FSW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:11 - RW, Controls the SCL clock in Fm/Sm mode (Master mode)"]
            #[inline(always)]
            pub fn ccr(&self) -> CcrR {
                CcrR::new(self.bits & 0x0fff)
            }
            #[doc = "Bit 14 - RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9"]
            #[inline(always)]
            pub fn duty(&self) -> DutyR {
                DutyR::new(((self.bits >> 14) & 1) != 0)
            }
            #[doc = "Bit 15 - RW, I2C master mode selection: 0=standard mode, 1=fast mode"]
            #[inline(always)]
            pub fn f_s(&self) -> FSR {
                FSR::new(((self.bits >> 15) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:11 - RW, Controls the SCL clock in Fm/Sm mode (Master mode)"]
            #[inline(always)]
            pub fn ccr(&mut self) -> CcrW<CkcfgrSpec> {
                CcrW::new(self, 0)
            }
            #[doc = "Bit 14 - RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9"]
            #[inline(always)]
            pub fn duty(&mut self) -> DutyW<CkcfgrSpec> {
                DutyW::new(self, 14)
            }
            #[doc = "Bit 15 - RW, I2C master mode selection: 0=standard mode, 1=fast mode"]
            #[inline(always)]
            pub fn f_s(&mut self) -> FSW<CkcfgrSpec> {
                FSW::new(self, 15)
            }
        }
        #[doc = "RW, I2C clock control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ckcfgr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ckcfgr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CkcfgrSpec;
        impl crate::RegisterSpec for CkcfgrSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`ckcfgr::R`](R) reader structure"]
        impl crate::Readable for CkcfgrSpec {}
        #[doc = "`write(|w| ..)` method takes [`ckcfgr::W`](W) writer structure"]
        impl crate::Writable for CkcfgrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CKCFGR to value 0"]
        impl crate::Resettable for CkcfgrSpec {}
    }
    #[doc = "RTR (rw) register accessor: RW, I2C trise register\n\nYou can [`read`](crate::Reg::read) this register and get [`rtr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rtr`] module"]
    #[doc(alias = "RTR")]
    pub type Rtr = crate::Reg<rtr::RtrSpec>;
    #[doc = "RW, I2C trise register"]
    pub mod rtr {
        #[doc = "Register `RTR` reader"]
        pub type R = crate::R<RtrSpec>;
        #[doc = "Register `RTR` writer"]
        pub type W = crate::W<RtrSpec>;
        #[doc = "Field `TRISE` reader - RW, Maximum rise time in Fm/Sm mode (Master mode)"]
        pub type TriseR = crate::FieldReader;
        #[doc = "Field `TRISE` writer - RW, Maximum rise time in Fm/Sm mode (Master mode)"]
        pub type TriseW<'a, REG> = crate::FieldWriter<'a, REG, 6>;
        impl R {
            #[doc = "Bits 0:5 - RW, Maximum rise time in Fm/Sm mode (Master mode)"]
            #[inline(always)]
            pub fn trise(&self) -> TriseR {
                TriseR::new((self.bits & 0x3f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:5 - RW, Maximum rise time in Fm/Sm mode (Master mode)"]
            #[inline(always)]
            pub fn trise(&mut self) -> TriseW<RtrSpec> {
                TriseW::new(self, 0)
            }
        }
        #[doc = "RW, I2C trise register\n\nYou can [`read`](crate::Reg::read) this register and get [`rtr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RtrSpec;
        impl crate::RegisterSpec for RtrSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`rtr::R`](R) reader structure"]
        impl crate::Readable for RtrSpec {}
        #[doc = "`write(|w| ..)` method takes [`rtr::W`](W) writer structure"]
        impl crate::Writable for RtrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets RTR to value 0x02"]
        impl crate::Resettable for RtrSpec {
            const RESET_VALUE: u16 = 0x02;
        }
    }
}
#[doc = "PWMx register"]
pub type Pwmx = crate::Periph<pwmx::RegisterBlock, 0x4000_5000>;
impl core::fmt::Debug for Pwmx {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwmx").finish()
    }
}
#[doc = "PWMx register"]
pub mod pwmx {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        pwm_out_en: PwmOutEn,
        pwm_polar: PwmPolar,
        pwm_config: PwmConfig,
        pwm_clock_div: PwmClockDiv,
        pwm4_data: Pwm4Data,
        pwm5_data: Pwm5Data,
        pwm6_data: Pwm6Data,
        pwm7_data: Pwm7Data,
        pwm8_data: Pwm8Data,
        pwm9_data: Pwm9Data,
        pwm10_data: Pwm10Data,
        pwm11_data: Pwm11Data,
        pwm_int_ctrl: PwmIntCtrl,
    }
    impl RegisterBlock {
        #[doc = "0x00 - RW, PWM output enable control"]
        #[inline(always)]
        pub const fn pwm_out_en(&self) -> &PwmOutEn {
            &self.pwm_out_en
        }
        #[doc = "0x01 - RW, PWM output polarity control"]
        #[inline(always)]
        pub const fn pwm_polar(&self) -> &PwmPolar {
            &self.pwm_polar
        }
        #[doc = "0x02 - RW, PWM configuration"]
        #[inline(always)]
        pub const fn pwm_config(&self) -> &PwmConfig {
            &self.pwm_config
        }
        #[doc = "0x03 - RW, PWM clock divisor"]
        #[inline(always)]
        pub const fn pwm_clock_div(&self) -> &PwmClockDiv {
            &self.pwm_clock_div
        }
        #[doc = "0x04 - RW, PWM4 data holding"]
        #[inline(always)]
        pub const fn pwm4_data(&self) -> &Pwm4Data {
            &self.pwm4_data
        }
        #[doc = "0x05 - RW, PWM5 data holding"]
        #[inline(always)]
        pub const fn pwm5_data(&self) -> &Pwm5Data {
            &self.pwm5_data
        }
        #[doc = "0x06 - RW, PWM6 data holding"]
        #[inline(always)]
        pub const fn pwm6_data(&self) -> &Pwm6Data {
            &self.pwm6_data
        }
        #[doc = "0x07 - RW, PWM7 data holding"]
        #[inline(always)]
        pub const fn pwm7_data(&self) -> &Pwm7Data {
            &self.pwm7_data
        }
        #[doc = "0x08 - RW, PWM8 data holding"]
        #[inline(always)]
        pub const fn pwm8_data(&self) -> &Pwm8Data {
            &self.pwm8_data
        }
        #[doc = "0x09 - RW, PWM9 data holding"]
        #[inline(always)]
        pub const fn pwm9_data(&self) -> &Pwm9Data {
            &self.pwm9_data
        }
        #[doc = "0x0a - RW, PWM10 data holding"]
        #[inline(always)]
        pub const fn pwm10_data(&self) -> &Pwm10Data {
            &self.pwm10_data
        }
        #[doc = "0x0b - RW, PWM11 data holding"]
        #[inline(always)]
        pub const fn pwm11_data(&self) -> &Pwm11Data {
            &self.pwm11_data
        }
        #[doc = "0x0c - RW, PWM interrupt control"]
        #[inline(always)]
        pub const fn pwm_int_ctrl(&self) -> &PwmIntCtrl {
            &self.pwm_int_ctrl
        }
    }
    #[doc = "PWM_OUT_EN (rw) register accessor: RW, PWM output enable control\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm_out_en::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm_out_en::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm_out_en`] module"]
    #[doc(alias = "PWM_OUT_EN")]
    pub type PwmOutEn = crate::Reg<pwm_out_en::PwmOutEnSpec>;
    #[doc = "RW, PWM output enable control"]
    pub mod pwm_out_en {
        #[doc = "Register `PWM_OUT_EN` reader"]
        pub type R = crate::R<PwmOutEnSpec>;
        #[doc = "Register `PWM_OUT_EN` writer"]
        pub type W = crate::W<PwmOutEnSpec>;
        #[doc = "Field `PWM4_OUT_EN` reader - RW, PWM4 output enable"]
        pub type Pwm4OutEnR = crate::BitReader;
        #[doc = "Field `PWM4_OUT_EN` writer - RW, PWM4 output enable"]
        pub type Pwm4OutEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM5_OUT_EN` reader - RW, PWM5 output enable"]
        pub type Pwm5OutEnR = crate::BitReader;
        #[doc = "Field `PWM5_OUT_EN` writer - RW, PWM5 output enable"]
        pub type Pwm5OutEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM6_OUT_EN` reader - RW, PWM6 output enable"]
        pub type Pwm6OutEnR = crate::BitReader;
        #[doc = "Field `PWM6_OUT_EN` writer - RW, PWM6 output enable"]
        pub type Pwm6OutEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM7_OUT_EN` reader - RW, PWM7 output enable"]
        pub type Pwm7OutEnR = crate::BitReader;
        #[doc = "Field `PWM7_OUT_EN` writer - RW, PWM7 output enable"]
        pub type Pwm7OutEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM8_OUT_EN` reader - RW, PWM8 output enable"]
        pub type Pwm8OutEnR = crate::BitReader;
        #[doc = "Field `PWM8_OUT_EN` writer - RW, PWM8 output enable"]
        pub type Pwm8OutEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM9_OUT_EN` reader - RW, PWM9 output enable"]
        pub type Pwm9OutEnR = crate::BitReader;
        #[doc = "Field `PWM9_OUT_EN` writer - RW, PWM9 output enable"]
        pub type Pwm9OutEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM10_OUT_EN` reader - RW, PWM10 output enable"]
        pub type Pwm10OutEnR = crate::BitReader;
        #[doc = "Field `PWM10_OUT_EN` writer - RW, PWM10 output enable"]
        pub type Pwm10OutEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM11_OUT_EN` reader - RW, PWM11 output enable"]
        pub type Pwm11OutEnR = crate::BitReader;
        #[doc = "Field `PWM11_OUT_EN` writer - RW, PWM11 output enable"]
        pub type Pwm11OutEnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, PWM4 output enable"]
            #[inline(always)]
            pub fn pwm4_out_en(&self) -> Pwm4OutEnR {
                Pwm4OutEnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, PWM5 output enable"]
            #[inline(always)]
            pub fn pwm5_out_en(&self) -> Pwm5OutEnR {
                Pwm5OutEnR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW, PWM6 output enable"]
            #[inline(always)]
            pub fn pwm6_out_en(&self) -> Pwm6OutEnR {
                Pwm6OutEnR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, PWM7 output enable"]
            #[inline(always)]
            pub fn pwm7_out_en(&self) -> Pwm7OutEnR {
                Pwm7OutEnR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, PWM8 output enable"]
            #[inline(always)]
            pub fn pwm8_out_en(&self) -> Pwm8OutEnR {
                Pwm8OutEnR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RW, PWM9 output enable"]
            #[inline(always)]
            pub fn pwm9_out_en(&self) -> Pwm9OutEnR {
                Pwm9OutEnR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RW, PWM10 output enable"]
            #[inline(always)]
            pub fn pwm10_out_en(&self) -> Pwm10OutEnR {
                Pwm10OutEnR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RW, PWM11 output enable"]
            #[inline(always)]
            pub fn pwm11_out_en(&self) -> Pwm11OutEnR {
                Pwm11OutEnR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, PWM4 output enable"]
            #[inline(always)]
            pub fn pwm4_out_en(&mut self) -> Pwm4OutEnW<PwmOutEnSpec> {
                Pwm4OutEnW::new(self, 0)
            }
            #[doc = "Bit 1 - RW, PWM5 output enable"]
            #[inline(always)]
            pub fn pwm5_out_en(&mut self) -> Pwm5OutEnW<PwmOutEnSpec> {
                Pwm5OutEnW::new(self, 1)
            }
            #[doc = "Bit 2 - RW, PWM6 output enable"]
            #[inline(always)]
            pub fn pwm6_out_en(&mut self) -> Pwm6OutEnW<PwmOutEnSpec> {
                Pwm6OutEnW::new(self, 2)
            }
            #[doc = "Bit 3 - RW, PWM7 output enable"]
            #[inline(always)]
            pub fn pwm7_out_en(&mut self) -> Pwm7OutEnW<PwmOutEnSpec> {
                Pwm7OutEnW::new(self, 3)
            }
            #[doc = "Bit 4 - RW, PWM8 output enable"]
            #[inline(always)]
            pub fn pwm8_out_en(&mut self) -> Pwm8OutEnW<PwmOutEnSpec> {
                Pwm8OutEnW::new(self, 4)
            }
            #[doc = "Bit 5 - RW, PWM9 output enable"]
            #[inline(always)]
            pub fn pwm9_out_en(&mut self) -> Pwm9OutEnW<PwmOutEnSpec> {
                Pwm9OutEnW::new(self, 5)
            }
            #[doc = "Bit 6 - RW, PWM10 output enable"]
            #[inline(always)]
            pub fn pwm10_out_en(&mut self) -> Pwm10OutEnW<PwmOutEnSpec> {
                Pwm10OutEnW::new(self, 6)
            }
            #[doc = "Bit 7 - RW, PWM11 output enable"]
            #[inline(always)]
            pub fn pwm11_out_en(&mut self) -> Pwm11OutEnW<PwmOutEnSpec> {
                Pwm11OutEnW::new(self, 7)
            }
        }
        #[doc = "RW, PWM output enable control\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm_out_en::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm_out_en::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PwmOutEnSpec;
        impl crate::RegisterSpec for PwmOutEnSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`pwm_out_en::R`](R) reader structure"]
        impl crate::Readable for PwmOutEnSpec {}
        #[doc = "`write(|w| ..)` method takes [`pwm_out_en::W`](W) writer structure"]
        impl crate::Writable for PwmOutEnSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PWM_OUT_EN to value 0"]
        impl crate::Resettable for PwmOutEnSpec {}
    }
    #[doc = "PWM_POLAR (rw) register accessor: RW, PWM output polarity control\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm_polar::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm_polar::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm_polar`] module"]
    #[doc(alias = "PWM_POLAR")]
    pub type PwmPolar = crate::Reg<pwm_polar::PwmPolarSpec>;
    #[doc = "RW, PWM output polarity control"]
    pub mod pwm_polar {
        #[doc = "Register `PWM_POLAR` reader"]
        pub type R = crate::R<PwmPolarSpec>;
        #[doc = "Register `PWM_POLAR` writer"]
        pub type W = crate::W<PwmPolarSpec>;
        #[doc = "Field `PWM4_POLAR` reader - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action"]
        pub type Pwm4PolarR = crate::BitReader;
        #[doc = "Field `PWM4_POLAR` writer - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action"]
        pub type Pwm4PolarW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM5_POLAR` reader - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action"]
        pub type Pwm5PolarR = crate::BitReader;
        #[doc = "Field `PWM5_POLAR` writer - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action"]
        pub type Pwm5PolarW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM6_POLAR` reader - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action"]
        pub type Pwm6PolarR = crate::BitReader;
        #[doc = "Field `PWM6_POLAR` writer - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action"]
        pub type Pwm6PolarW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM7_POLAR` reader - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action"]
        pub type Pwm7PolarR = crate::BitReader;
        #[doc = "Field `PWM7_POLAR` writer - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action"]
        pub type Pwm7PolarW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM8_POLAR` reader - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action"]
        pub type Pwm8PolarR = crate::BitReader;
        #[doc = "Field `PWM8_POLAR` writer - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action"]
        pub type Pwm8PolarW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM9_POLAR` reader - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action"]
        pub type Pwm9PolarR = crate::BitReader;
        #[doc = "Field `PWM9_POLAR` writer - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action"]
        pub type Pwm9PolarW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM10_POLAR` reader - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action"]
        pub type Pwm10PolarR = crate::BitReader;
        #[doc = "Field `PWM10_POLAR` writer - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action"]
        pub type Pwm10PolarW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM11_POLAR` reader - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action"]
        pub type Pwm11PolarR = crate::BitReader;
        #[doc = "Field `PWM11_POLAR` writer - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action"]
        pub type Pwm11PolarW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action"]
            #[inline(always)]
            pub fn pwm4_polar(&self) -> Pwm4PolarR {
                Pwm4PolarR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action"]
            #[inline(always)]
            pub fn pwm5_polar(&self) -> Pwm5PolarR {
                Pwm5PolarR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action"]
            #[inline(always)]
            pub fn pwm6_polar(&self) -> Pwm6PolarR {
                Pwm6PolarR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action"]
            #[inline(always)]
            pub fn pwm7_polar(&self) -> Pwm7PolarR {
                Pwm7PolarR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action"]
            #[inline(always)]
            pub fn pwm8_polar(&self) -> Pwm8PolarR {
                Pwm8PolarR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action"]
            #[inline(always)]
            pub fn pwm9_polar(&self) -> Pwm9PolarR {
                Pwm9PolarR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action"]
            #[inline(always)]
            pub fn pwm10_polar(&self) -> Pwm10PolarR {
                Pwm10PolarR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action"]
            #[inline(always)]
            pub fn pwm11_polar(&self) -> Pwm11PolarR {
                Pwm11PolarR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action"]
            #[inline(always)]
            pub fn pwm4_polar(&mut self) -> Pwm4PolarW<PwmPolarSpec> {
                Pwm4PolarW::new(self, 0)
            }
            #[doc = "Bit 1 - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action"]
            #[inline(always)]
            pub fn pwm5_polar(&mut self) -> Pwm5PolarW<PwmPolarSpec> {
                Pwm5PolarW::new(self, 1)
            }
            #[doc = "Bit 2 - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action"]
            #[inline(always)]
            pub fn pwm6_polar(&mut self) -> Pwm6PolarW<PwmPolarSpec> {
                Pwm6PolarW::new(self, 2)
            }
            #[doc = "Bit 3 - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action"]
            #[inline(always)]
            pub fn pwm7_polar(&mut self) -> Pwm7PolarW<PwmPolarSpec> {
                Pwm7PolarW::new(self, 3)
            }
            #[doc = "Bit 4 - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action"]
            #[inline(always)]
            pub fn pwm8_polar(&mut self) -> Pwm8PolarW<PwmPolarSpec> {
                Pwm8PolarW::new(self, 4)
            }
            #[doc = "Bit 5 - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action"]
            #[inline(always)]
            pub fn pwm9_polar(&mut self) -> Pwm9PolarW<PwmPolarSpec> {
                Pwm9PolarW::new(self, 5)
            }
            #[doc = "Bit 6 - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action"]
            #[inline(always)]
            pub fn pwm10_polar(&mut self) -> Pwm10PolarW<PwmPolarSpec> {
                Pwm10PolarW::new(self, 6)
            }
            #[doc = "Bit 7 - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action"]
            #[inline(always)]
            pub fn pwm11_polar(&mut self) -> Pwm11PolarW<PwmPolarSpec> {
                Pwm11PolarW::new(self, 7)
            }
        }
        #[doc = "RW, PWM output polarity control\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm_polar::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm_polar::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PwmPolarSpec;
        impl crate::RegisterSpec for PwmPolarSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`pwm_polar::R`](R) reader structure"]
        impl crate::Readable for PwmPolarSpec {}
        #[doc = "`write(|w| ..)` method takes [`pwm_polar::W`](W) writer structure"]
        impl crate::Writable for PwmPolarSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PWM_POLAR to value 0"]
        impl crate::Resettable for PwmPolarSpec {}
    }
    #[doc = "PWM_CONFIG (rw) register accessor: RW, PWM configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm_config::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm_config::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm_config`] module"]
    #[doc(alias = "PWM_CONFIG")]
    pub type PwmConfig = crate::Reg<pwm_config::PwmConfigSpec>;
    #[doc = "RW, PWM configuration"]
    pub mod pwm_config {
        #[doc = "Register `PWM_CONFIG` reader"]
        pub type R = crate::R<PwmConfigSpec>;
        #[doc = "Register `PWM_CONFIG` writer"]
        pub type W = crate::W<PwmConfigSpec>;
        #[doc = "Field `PWM_CYCLE_SEL` reader - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks"]
        pub type PwmCycleSelR = crate::BitReader;
        #[doc = "Field `PWM_CYCLE_SEL` writer - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks"]
        pub type PwmCycleSelW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM_STAG_ST` reader - RO, PWM stagger cycle status"]
        pub type PwmStagStR = crate::BitReader;
        #[doc = "Field `PWM_CYC_MOD` reader - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data"]
        pub type PwmCycModR = crate::FieldReader;
        #[doc = "Field `PWM_CYC_MOD` writer - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data"]
        pub type PwmCycModW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `PWM4_5_STAG_EN` reader - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output"]
        pub type Pwm4_5StagEnR = crate::BitReader;
        #[doc = "Field `PWM4_5_STAG_EN` writer - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output"]
        pub type Pwm4_5StagEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM6_7_STAG_EN` reader - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output"]
        pub type Pwm6_7StagEnR = crate::BitReader;
        #[doc = "Field `PWM6_7_STAG_EN` writer - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output"]
        pub type Pwm6_7StagEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM8_9_STAG_EN` reader - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output"]
        pub type Pwm8_9StagEnR = crate::BitReader;
        #[doc = "Field `PWM8_9_STAG_EN` writer - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output"]
        pub type Pwm8_9StagEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM10_11_STAG_EN` reader - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output"]
        pub type Pwm10_11StagEnR = crate::BitReader;
        #[doc = "Field `PWM10_11_STAG_EN` writer - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output"]
        pub type Pwm10_11StagEnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks"]
            #[inline(always)]
            pub fn pwm_cycle_sel(&self) -> PwmCycleSelR {
                PwmCycleSelR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RO, PWM stagger cycle status"]
            #[inline(always)]
            pub fn pwm_stag_st(&self) -> PwmStagStR {
                PwmStagStR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bits 2:3 - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data"]
            #[inline(always)]
            pub fn pwm_cyc_mod(&self) -> PwmCycModR {
                PwmCycModR::new((self.bits >> 2) & 3)
            }
            #[doc = "Bit 4 - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output"]
            #[inline(always)]
            pub fn pwm4_5_stag_en(&self) -> Pwm4_5StagEnR {
                Pwm4_5StagEnR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output"]
            #[inline(always)]
            pub fn pwm6_7_stag_en(&self) -> Pwm6_7StagEnR {
                Pwm6_7StagEnR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output"]
            #[inline(always)]
            pub fn pwm8_9_stag_en(&self) -> Pwm8_9StagEnR {
                Pwm8_9StagEnR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output"]
            #[inline(always)]
            pub fn pwm10_11_stag_en(&self) -> Pwm10_11StagEnR {
                Pwm10_11StagEnR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks"]
            #[inline(always)]
            pub fn pwm_cycle_sel(&mut self) -> PwmCycleSelW<PwmConfigSpec> {
                PwmCycleSelW::new(self, 0)
            }
            #[doc = "Bits 2:3 - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data"]
            #[inline(always)]
            pub fn pwm_cyc_mod(&mut self) -> PwmCycModW<PwmConfigSpec> {
                PwmCycModW::new(self, 2)
            }
            #[doc = "Bit 4 - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output"]
            #[inline(always)]
            pub fn pwm4_5_stag_en(&mut self) -> Pwm4_5StagEnW<PwmConfigSpec> {
                Pwm4_5StagEnW::new(self, 4)
            }
            #[doc = "Bit 5 - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output"]
            #[inline(always)]
            pub fn pwm6_7_stag_en(&mut self) -> Pwm6_7StagEnW<PwmConfigSpec> {
                Pwm6_7StagEnW::new(self, 5)
            }
            #[doc = "Bit 6 - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output"]
            #[inline(always)]
            pub fn pwm8_9_stag_en(&mut self) -> Pwm8_9StagEnW<PwmConfigSpec> {
                Pwm8_9StagEnW::new(self, 6)
            }
            #[doc = "Bit 7 - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output"]
            #[inline(always)]
            pub fn pwm10_11_stag_en(&mut self) -> Pwm10_11StagEnW<PwmConfigSpec> {
                Pwm10_11StagEnW::new(self, 7)
            }
        }
        #[doc = "RW, PWM configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm_config::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm_config::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PwmConfigSpec;
        impl crate::RegisterSpec for PwmConfigSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`pwm_config::R`](R) reader structure"]
        impl crate::Readable for PwmConfigSpec {}
        #[doc = "`write(|w| ..)` method takes [`pwm_config::W`](W) writer structure"]
        impl crate::Writable for PwmConfigSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PWM_CONFIG to value 0"]
        impl crate::Resettable for PwmConfigSpec {}
    }
    #[doc = "PWM_CLOCK_DIV (rw) register accessor: RW, PWM clock divisor\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm_clock_div::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm_clock_div::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm_clock_div`] module"]
    #[doc(alias = "PWM_CLOCK_DIV")]
    pub type PwmClockDiv = crate::Reg<pwm_clock_div::PwmClockDivSpec>;
    #[doc = "RW, PWM clock divisor"]
    pub mod pwm_clock_div {
        #[doc = "Register `PWM_CLOCK_DIV` reader"]
        pub type R = crate::R<PwmClockDivSpec>;
        #[doc = "Register `PWM_CLOCK_DIV` writer"]
        pub type W = crate::W<PwmClockDivSpec>;
        #[doc = "Field `PWM_CLOCK_DIV` reader - RW, PWM clock divisor"]
        pub type PwmClockDivR = crate::FieldReader;
        #[doc = "Field `PWM_CLOCK_DIV` writer - RW, PWM clock divisor"]
        pub type PwmClockDivW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW, PWM clock divisor"]
            #[inline(always)]
            pub fn pwm_clock_div(&self) -> PwmClockDivR {
                PwmClockDivR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW, PWM clock divisor"]
            #[inline(always)]
            pub fn pwm_clock_div(&mut self) -> PwmClockDivW<PwmClockDivSpec> {
                PwmClockDivW::new(self, 0)
            }
        }
        #[doc = "RW, PWM clock divisor\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm_clock_div::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm_clock_div::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PwmClockDivSpec;
        impl crate::RegisterSpec for PwmClockDivSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`pwm_clock_div::R`](R) reader structure"]
        impl crate::Readable for PwmClockDivSpec {}
        #[doc = "`write(|w| ..)` method takes [`pwm_clock_div::W`](W) writer structure"]
        impl crate::Writable for PwmClockDivSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PWM_CLOCK_DIV to value 0"]
        impl crate::Resettable for PwmClockDivSpec {}
    }
    #[doc = "PWM4_DATA (rw) register accessor: RW, PWM4 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm4_data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm4_data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm4_data`] module"]
    #[doc(alias = "PWM4_DATA")]
    pub type Pwm4Data = crate::Reg<pwm4_data::Pwm4DataSpec>;
    #[doc = "RW, PWM4 data holding"]
    pub mod pwm4_data {
        #[doc = "Register `PWM4_DATA` reader"]
        pub type R = crate::R<Pwm4DataSpec>;
        #[doc = "Register `PWM4_DATA` writer"]
        pub type W = crate::W<Pwm4DataSpec>;
        #[doc = "Field `PWM4_DATA` reader - RW, PWM4 data holding"]
        pub type Pwm4DataR = crate::FieldReader;
        #[doc = "Field `PWM4_DATA` writer - RW, PWM4 data holding"]
        pub type Pwm4DataW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW, PWM4 data holding"]
            #[inline(always)]
            pub fn pwm4_data(&self) -> Pwm4DataR {
                Pwm4DataR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW, PWM4 data holding"]
            #[inline(always)]
            pub fn pwm4_data(&mut self) -> Pwm4DataW<Pwm4DataSpec> {
                Pwm4DataW::new(self, 0)
            }
        }
        #[doc = "RW, PWM4 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm4_data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm4_data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Pwm4DataSpec;
        impl crate::RegisterSpec for Pwm4DataSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`pwm4_data::R`](R) reader structure"]
        impl crate::Readable for Pwm4DataSpec {}
        #[doc = "`write(|w| ..)` method takes [`pwm4_data::W`](W) writer structure"]
        impl crate::Writable for Pwm4DataSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PWM4_DATA to value 0"]
        impl crate::Resettable for Pwm4DataSpec {}
    }
    #[doc = "PWM5_DATA (rw) register accessor: RW, PWM5 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm5_data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm5_data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm5_data`] module"]
    #[doc(alias = "PWM5_DATA")]
    pub type Pwm5Data = crate::Reg<pwm5_data::Pwm5DataSpec>;
    #[doc = "RW, PWM5 data holding"]
    pub mod pwm5_data {
        #[doc = "Register `PWM5_DATA` reader"]
        pub type R = crate::R<Pwm5DataSpec>;
        #[doc = "Register `PWM5_DATA` writer"]
        pub type W = crate::W<Pwm5DataSpec>;
        #[doc = "Field `PWM5_DATA` reader - RW, PWM5 data holding"]
        pub type Pwm5DataR = crate::FieldReader;
        #[doc = "Field `PWM5_DATA` writer - RW, PWM5 data holding"]
        pub type Pwm5DataW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW, PWM5 data holding"]
            #[inline(always)]
            pub fn pwm5_data(&self) -> Pwm5DataR {
                Pwm5DataR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW, PWM5 data holding"]
            #[inline(always)]
            pub fn pwm5_data(&mut self) -> Pwm5DataW<Pwm5DataSpec> {
                Pwm5DataW::new(self, 0)
            }
        }
        #[doc = "RW, PWM5 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm5_data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm5_data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Pwm5DataSpec;
        impl crate::RegisterSpec for Pwm5DataSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`pwm5_data::R`](R) reader structure"]
        impl crate::Readable for Pwm5DataSpec {}
        #[doc = "`write(|w| ..)` method takes [`pwm5_data::W`](W) writer structure"]
        impl crate::Writable for Pwm5DataSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PWM5_DATA to value 0"]
        impl crate::Resettable for Pwm5DataSpec {}
    }
    #[doc = "PWM6_DATA (rw) register accessor: RW, PWM6 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm6_data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm6_data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm6_data`] module"]
    #[doc(alias = "PWM6_DATA")]
    pub type Pwm6Data = crate::Reg<pwm6_data::Pwm6DataSpec>;
    #[doc = "RW, PWM6 data holding"]
    pub mod pwm6_data {
        #[doc = "Register `PWM6_DATA` reader"]
        pub type R = crate::R<Pwm6DataSpec>;
        #[doc = "Register `PWM6_DATA` writer"]
        pub type W = crate::W<Pwm6DataSpec>;
        #[doc = "Field `PWM6_DATA` reader - RW, PWM6 data holding"]
        pub type Pwm6DataR = crate::FieldReader;
        #[doc = "Field `PWM6_DATA` writer - RW, PWM6 data holding"]
        pub type Pwm6DataW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW, PWM6 data holding"]
            #[inline(always)]
            pub fn pwm6_data(&self) -> Pwm6DataR {
                Pwm6DataR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW, PWM6 data holding"]
            #[inline(always)]
            pub fn pwm6_data(&mut self) -> Pwm6DataW<Pwm6DataSpec> {
                Pwm6DataW::new(self, 0)
            }
        }
        #[doc = "RW, PWM6 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm6_data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm6_data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Pwm6DataSpec;
        impl crate::RegisterSpec for Pwm6DataSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`pwm6_data::R`](R) reader structure"]
        impl crate::Readable for Pwm6DataSpec {}
        #[doc = "`write(|w| ..)` method takes [`pwm6_data::W`](W) writer structure"]
        impl crate::Writable for Pwm6DataSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PWM6_DATA to value 0"]
        impl crate::Resettable for Pwm6DataSpec {}
    }
    #[doc = "PWM7_DATA (rw) register accessor: RW, PWM7 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm7_data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm7_data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm7_data`] module"]
    #[doc(alias = "PWM7_DATA")]
    pub type Pwm7Data = crate::Reg<pwm7_data::Pwm7DataSpec>;
    #[doc = "RW, PWM7 data holding"]
    pub mod pwm7_data {
        #[doc = "Register `PWM7_DATA` reader"]
        pub type R = crate::R<Pwm7DataSpec>;
        #[doc = "Register `PWM7_DATA` writer"]
        pub type W = crate::W<Pwm7DataSpec>;
        #[doc = "Field `PWM7_DATA` reader - RW, PWM7 data holding"]
        pub type Pwm7DataR = crate::FieldReader;
        #[doc = "Field `PWM7_DATA` writer - RW, PWM7 data holding"]
        pub type Pwm7DataW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW, PWM7 data holding"]
            #[inline(always)]
            pub fn pwm7_data(&self) -> Pwm7DataR {
                Pwm7DataR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW, PWM7 data holding"]
            #[inline(always)]
            pub fn pwm7_data(&mut self) -> Pwm7DataW<Pwm7DataSpec> {
                Pwm7DataW::new(self, 0)
            }
        }
        #[doc = "RW, PWM7 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm7_data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm7_data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Pwm7DataSpec;
        impl crate::RegisterSpec for Pwm7DataSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`pwm7_data::R`](R) reader structure"]
        impl crate::Readable for Pwm7DataSpec {}
        #[doc = "`write(|w| ..)` method takes [`pwm7_data::W`](W) writer structure"]
        impl crate::Writable for Pwm7DataSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PWM7_DATA to value 0"]
        impl crate::Resettable for Pwm7DataSpec {}
    }
    #[doc = "PWM8_DATA (rw) register accessor: RW, PWM8 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm8_data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm8_data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm8_data`] module"]
    #[doc(alias = "PWM8_DATA")]
    pub type Pwm8Data = crate::Reg<pwm8_data::Pwm8DataSpec>;
    #[doc = "RW, PWM8 data holding"]
    pub mod pwm8_data {
        #[doc = "Register `PWM8_DATA` reader"]
        pub type R = crate::R<Pwm8DataSpec>;
        #[doc = "Register `PWM8_DATA` writer"]
        pub type W = crate::W<Pwm8DataSpec>;
        #[doc = "Field `PWM8_DATA` reader - RW, PWM8 data holding"]
        pub type Pwm8DataR = crate::FieldReader;
        #[doc = "Field `PWM8_DATA` writer - RW, PWM8 data holding"]
        pub type Pwm8DataW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW, PWM8 data holding"]
            #[inline(always)]
            pub fn pwm8_data(&self) -> Pwm8DataR {
                Pwm8DataR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW, PWM8 data holding"]
            #[inline(always)]
            pub fn pwm8_data(&mut self) -> Pwm8DataW<Pwm8DataSpec> {
                Pwm8DataW::new(self, 0)
            }
        }
        #[doc = "RW, PWM8 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm8_data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm8_data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Pwm8DataSpec;
        impl crate::RegisterSpec for Pwm8DataSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`pwm8_data::R`](R) reader structure"]
        impl crate::Readable for Pwm8DataSpec {}
        #[doc = "`write(|w| ..)` method takes [`pwm8_data::W`](W) writer structure"]
        impl crate::Writable for Pwm8DataSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PWM8_DATA to value 0"]
        impl crate::Resettable for Pwm8DataSpec {}
    }
    #[doc = "PWM9_DATA (rw) register accessor: RW, PWM9 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm9_data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm9_data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm9_data`] module"]
    #[doc(alias = "PWM9_DATA")]
    pub type Pwm9Data = crate::Reg<pwm9_data::Pwm9DataSpec>;
    #[doc = "RW, PWM9 data holding"]
    pub mod pwm9_data {
        #[doc = "Register `PWM9_DATA` reader"]
        pub type R = crate::R<Pwm9DataSpec>;
        #[doc = "Register `PWM9_DATA` writer"]
        pub type W = crate::W<Pwm9DataSpec>;
        #[doc = "Field `PWM9_DATA` reader - RW, PWM9 data holding"]
        pub type Pwm9DataR = crate::FieldReader;
        #[doc = "Field `PWM9_DATA` writer - RW, PWM9 data holding"]
        pub type Pwm9DataW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW, PWM9 data holding"]
            #[inline(always)]
            pub fn pwm9_data(&self) -> Pwm9DataR {
                Pwm9DataR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW, PWM9 data holding"]
            #[inline(always)]
            pub fn pwm9_data(&mut self) -> Pwm9DataW<Pwm9DataSpec> {
                Pwm9DataW::new(self, 0)
            }
        }
        #[doc = "RW, PWM9 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm9_data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm9_data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Pwm9DataSpec;
        impl crate::RegisterSpec for Pwm9DataSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`pwm9_data::R`](R) reader structure"]
        impl crate::Readable for Pwm9DataSpec {}
        #[doc = "`write(|w| ..)` method takes [`pwm9_data::W`](W) writer structure"]
        impl crate::Writable for Pwm9DataSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PWM9_DATA to value 0"]
        impl crate::Resettable for Pwm9DataSpec {}
    }
    #[doc = "PWM10_DATA (rw) register accessor: RW, PWM10 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm10_data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm10_data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm10_data`] module"]
    #[doc(alias = "PWM10_DATA")]
    pub type Pwm10Data = crate::Reg<pwm10_data::Pwm10DataSpec>;
    #[doc = "RW, PWM10 data holding"]
    pub mod pwm10_data {
        #[doc = "Register `PWM10_DATA` reader"]
        pub type R = crate::R<Pwm10DataSpec>;
        #[doc = "Register `PWM10_DATA` writer"]
        pub type W = crate::W<Pwm10DataSpec>;
        #[doc = "Field `PWM10_DATA` reader - RW, PWM10 data holding"]
        pub type Pwm10DataR = crate::FieldReader;
        #[doc = "Field `PWM10_DATA` writer - RW, PWM10 data holding"]
        pub type Pwm10DataW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW, PWM10 data holding"]
            #[inline(always)]
            pub fn pwm10_data(&self) -> Pwm10DataR {
                Pwm10DataR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW, PWM10 data holding"]
            #[inline(always)]
            pub fn pwm10_data(&mut self) -> Pwm10DataW<Pwm10DataSpec> {
                Pwm10DataW::new(self, 0)
            }
        }
        #[doc = "RW, PWM10 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm10_data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm10_data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Pwm10DataSpec;
        impl crate::RegisterSpec for Pwm10DataSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`pwm10_data::R`](R) reader structure"]
        impl crate::Readable for Pwm10DataSpec {}
        #[doc = "`write(|w| ..)` method takes [`pwm10_data::W`](W) writer structure"]
        impl crate::Writable for Pwm10DataSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PWM10_DATA to value 0"]
        impl crate::Resettable for Pwm10DataSpec {}
    }
    #[doc = "PWM11_DATA (rw) register accessor: RW, PWM11 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm11_data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm11_data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm11_data`] module"]
    #[doc(alias = "PWM11_DATA")]
    pub type Pwm11Data = crate::Reg<pwm11_data::Pwm11DataSpec>;
    #[doc = "RW, PWM11 data holding"]
    pub mod pwm11_data {
        #[doc = "Register `PWM11_DATA` reader"]
        pub type R = crate::R<Pwm11DataSpec>;
        #[doc = "Register `PWM11_DATA` writer"]
        pub type W = crate::W<Pwm11DataSpec>;
        #[doc = "Field `PWM11_DATA` reader - RW, PWM11 data holding"]
        pub type Pwm11DataR = crate::FieldReader;
        #[doc = "Field `PWM11_DATA` writer - RW, PWM11 data holding"]
        pub type Pwm11DataW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW, PWM11 data holding"]
            #[inline(always)]
            pub fn pwm11_data(&self) -> Pwm11DataR {
                Pwm11DataR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW, PWM11 data holding"]
            #[inline(always)]
            pub fn pwm11_data(&mut self) -> Pwm11DataW<Pwm11DataSpec> {
                Pwm11DataW::new(self, 0)
            }
        }
        #[doc = "RW, PWM11 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm11_data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm11_data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Pwm11DataSpec;
        impl crate::RegisterSpec for Pwm11DataSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`pwm11_data::R`](R) reader structure"]
        impl crate::Readable for Pwm11DataSpec {}
        #[doc = "`write(|w| ..)` method takes [`pwm11_data::W`](W) writer structure"]
        impl crate::Writable for Pwm11DataSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PWM11_DATA to value 0"]
        impl crate::Resettable for Pwm11DataSpec {}
    }
    #[doc = "PWM_INT_CTRL (rw) register accessor: RW, PWM interrupt control\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm_int_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm_int_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm_int_ctrl`] module"]
    #[doc(alias = "PWM_INT_CTRL")]
    pub type PwmIntCtrl = crate::Reg<pwm_int_ctrl::PwmIntCtrlSpec>;
    #[doc = "RW, PWM interrupt control"]
    pub mod pwm_int_ctrl {
        #[doc = "Register `PWM_INT_CTRL` reader"]
        pub type R = crate::R<PwmIntCtrlSpec>;
        #[doc = "Register `PWM_INT_CTRL` writer"]
        pub type W = crate::W<PwmIntCtrlSpec>;
        #[doc = "Field `PWM_IE_CYC` reader - RW, enable interrupt for PWM cycle end"]
        pub type PwmIeCycR = crate::BitReader;
        #[doc = "Field `PWM_IE_CYC` writer - RW, enable interrupt for PWM cycle end"]
        pub type PwmIeCycW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM_CYC_PRE` reader - RW, select PWM cycle interrupt point"]
        pub type PwmCycPreR = crate::BitReader;
        #[doc = "Field `PWM_CYC_PRE` writer - RW, select PWM cycle interrupt point"]
        pub type PwmCycPreW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `PWM_IF_CYC` reader - RW1, interrupt flag for PWM cycle end"]
        pub type PwmIfCycR = crate::BitReader;
        #[doc = "Field `PWM_IF_CYC` writer - RW1, interrupt flag for PWM cycle end"]
        pub type PwmIfCycW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW, enable interrupt for PWM cycle end"]
            #[inline(always)]
            pub fn pwm_ie_cyc(&self) -> PwmIeCycR {
                PwmIeCycR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW, select PWM cycle interrupt point"]
            #[inline(always)]
            pub fn pwm_cyc_pre(&self) -> PwmCycPreR {
                PwmCycPreR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 7 - RW1, interrupt flag for PWM cycle end"]
            #[inline(always)]
            pub fn pwm_if_cyc(&self) -> PwmIfCycR {
                PwmIfCycR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW, enable interrupt for PWM cycle end"]
            #[inline(always)]
            pub fn pwm_ie_cyc(&mut self) -> PwmIeCycW<PwmIntCtrlSpec> {
                PwmIeCycW::new(self, 0)
            }
            #[doc = "Bit 1 - RW, select PWM cycle interrupt point"]
            #[inline(always)]
            pub fn pwm_cyc_pre(&mut self) -> PwmCycPreW<PwmIntCtrlSpec> {
                PwmCycPreW::new(self, 1)
            }
            #[doc = "Bit 7 - RW1, interrupt flag for PWM cycle end"]
            #[inline(always)]
            pub fn pwm_if_cyc(&mut self) -> PwmIfCycW<PwmIntCtrlSpec> {
                PwmIfCycW::new(self, 7)
            }
        }
        #[doc = "RW, PWM interrupt control\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm_int_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm_int_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct PwmIntCtrlSpec;
        impl crate::RegisterSpec for PwmIntCtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`pwm_int_ctrl::R`](R) reader structure"]
        impl crate::Readable for PwmIntCtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`pwm_int_ctrl::W`](W) writer structure"]
        impl crate::Writable for PwmIntCtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets PWM_INT_CTRL to value 0"]
        impl crate::Resettable for PwmIntCtrlSpec {}
    }
}
#[doc = "USB register"]
pub type Usb = crate::Periph<usb::RegisterBlock, 0x4000_8000>;
impl core::fmt::Debug for Usb {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb").finish()
    }
}
#[doc = "USB register"]
pub mod usb {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        ctrl: Ctrl,
        _reserved_1_udev_ctrl: [u8; 0x01],
        int_en: IntEn,
        dev_ad: DevAd,
        _reserved4: [u8; 0x01],
        mis_st: MisSt,
        int_fg: IntFg,
        int_st: IntSt,
        rx_len: RxLen,
        _reserved8: [u8; 0x03],
        uep4_1_mod: Uep4_1Mod,
        _reserved_9_uh_ep_mod: [u8; 0x01],
        uep567_mod: Uep567Mod,
        _reserved11: [u8; 0x01],
        uep0_dma: Uep0Dma,
        _reserved12: [u8; 0x02],
        uep1_dma: Uep1Dma,
        _reserved13: [u8; 0x02],
        _reserved_13_uep2_dma: [u8; 0x02],
        _reserved14: [u8; 0x02],
        _reserved_14_uep3_dma: [u8; 0x02],
        _reserved15: [u8; 0x02],
        uep0_t_len: Uep0TLen,
        _reserved16: [u8; 0x01],
        uep0_ctrl: Uep0Ctrl,
        _reserved17: [u8; 0x01],
        uep1_t_len: Uep1TLen,
        _reserved18: [u8; 0x01],
        _reserved_18_uh_setup: [u8; 0x01],
        _reserved19: [u8; 0x01],
        _reserved_19_uh_ep_pid: [u8; 0x01],
        _reserved20: [u8; 0x01],
        _reserved_20_uep2_ctrl: [u8; 0x01],
        _reserved21: [u8; 0x01],
        _reserved_21_uh_tx_len: [u8; 0x01],
        _reserved22: [u8; 0x01],
        _reserved_22_uep3_ctrl: [u8; 0x01],
        _reserved23: [u8; 0x01],
        uep4_t_len: Uep4TLen,
        _reserved24: [u8; 0x01],
        uep4_ctrl: Uep4Ctrl,
        _reserved25: [u8; 0x21],
        uep5_dma: Uep5Dma,
        _reserved26: [u8; 0x02],
        uep6_dma: Uep6Dma,
        _reserved27: [u8; 0x02],
        uep7_dma: Uep7Dma,
        _reserved28: [u8; 0x06],
        uep5_t_len: Uep5TLen,
        _reserved29: [u8; 0x01],
        uep5_ctrl: Uep5Ctrl,
        _reserved30: [u8; 0x01],
        uep6_t_len: Uep6TLen,
        _reserved31: [u8; 0x01],
        uep6_ctrl: Uep6Ctrl,
        _reserved32: [u8; 0x01],
        uep7_t_len: Uep7TLen,
        _reserved33: [u8; 0x01],
        uep7_ctrl: Uep7Ctrl,
    }
    impl RegisterBlock {
        #[doc = "0x00 - USB base control"]
        #[inline(always)]
        pub const fn ctrl(&self) -> &Ctrl {
            &self.ctrl
        }
        #[doc = "0x01 - USB device physical prot control"]
        #[inline(always)]
        pub const fn uhost_ctrl(&self) -> &UhostCtrl {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(1).cast() }
        }
        #[doc = "0x01 - USB device physical prot control"]
        #[inline(always)]
        pub const fn udev_ctrl(&self) -> &UdevCtrl {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(1).cast() }
        }
        #[doc = "0x02 - USB interrupt enable"]
        #[inline(always)]
        pub const fn int_en(&self) -> &IntEn {
            &self.int_en
        }
        #[doc = "0x03 - USB device address"]
        #[inline(always)]
        pub const fn dev_ad(&self) -> &DevAd {
            &self.dev_ad
        }
        #[doc = "0x05 - USB miscellaneous status"]
        #[inline(always)]
        pub const fn mis_st(&self) -> &MisSt {
            &self.mis_st
        }
        #[doc = "0x06 - USB interrupt flag"]
        #[inline(always)]
        pub const fn int_fg(&self) -> &IntFg {
            &self.int_fg
        }
        #[doc = "0x07 - USB interrupt status"]
        #[inline(always)]
        pub const fn int_st(&self) -> &IntSt {
            &self.int_st
        }
        #[doc = "0x08 - USB receiving length"]
        #[inline(always)]
        pub const fn rx_len(&self) -> &RxLen {
            &self.rx_len
        }
        #[doc = "0x0c - endpoint 4/1 mode"]
        #[inline(always)]
        pub const fn uep4_1_mod(&self) -> &Uep4_1Mod {
            &self.uep4_1_mod
        }
        #[doc = "0x0d - host endpoint mode"]
        #[inline(always)]
        pub const fn uh_ep_mod(&self) -> &UhEpMod {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(13).cast() }
        }
        #[doc = "0x0d - endpoint 2_3 mode"]
        #[inline(always)]
        pub const fn uep2_3_mod(&self) -> &Uep2_3Mod {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(13).cast() }
        }
        #[doc = "0x0e - endpoint 5/6/7 mode"]
        #[inline(always)]
        pub const fn uep567_mod(&self) -> &Uep567Mod {
            &self.uep567_mod
        }
        #[doc = "0x10 - endpoint 0 DMA buffer address"]
        #[inline(always)]
        pub const fn uep0_dma(&self) -> &Uep0Dma {
            &self.uep0_dma
        }
        #[doc = "0x14 - endpoint 1 DMA buffer address"]
        #[inline(always)]
        pub const fn uep1_dma(&self) -> &Uep1Dma {
            &self.uep1_dma
        }
        #[doc = "0x18 - host rx endpoint buffer high address"]
        #[inline(always)]
        pub const fn uh_rx_dma(&self) -> &UhRxDma {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(24).cast() }
        }
        #[doc = "0x18 - endpoint 2 DMA buffer address"]
        #[inline(always)]
        pub const fn uep2_dma(&self) -> &Uep2Dma {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(24).cast() }
        }
        #[doc = "0x1c - host tx endpoint buffer high address"]
        #[inline(always)]
        pub const fn uh_tx_dma(&self) -> &UhTxDma {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(28).cast() }
        }
        #[doc = "0x1c - endpoint 3 DMA buffer address"]
        #[inline(always)]
        pub const fn uep3_dma(&self) -> &Uep3Dma {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(28).cast() }
        }
        #[doc = "0x20 - endpoint 0 transmittal length"]
        #[inline(always)]
        pub const fn uep0_t_len(&self) -> &Uep0TLen {
            &self.uep0_t_len
        }
        #[doc = "0x22 - endpoint 0 control"]
        #[inline(always)]
        pub const fn uep0_ctrl(&self) -> &Uep0Ctrl {
            &self.uep0_ctrl
        }
        #[doc = "0x24 - endpoint 1 transmittal length"]
        #[inline(always)]
        pub const fn uep1_t_len(&self) -> &Uep1TLen {
            &self.uep1_t_len
        }
        #[doc = "0x26 - host aux setup"]
        #[inline(always)]
        pub const fn uh_setup(&self) -> &UhSetup {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(38).cast() }
        }
        #[doc = "0x26 - endpoint 1 control"]
        #[inline(always)]
        pub const fn uep1_ctrl(&self) -> &Uep1Ctrl {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(38).cast() }
        }
        #[doc = "0x28 - host endpoint and PID"]
        #[inline(always)]
        pub const fn uh_ep_pid(&self) -> &UhEpPid {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(40).cast() }
        }
        #[doc = "0x28 - endpoint 2 transmittal length"]
        #[inline(always)]
        pub const fn uep2_t_len(&self) -> &Uep2TLen {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(40).cast() }
        }
        #[doc = "0x2a - host receiver endpoint control"]
        #[inline(always)]
        pub const fn uh_rx_ctrl(&self) -> &UhRxCtrl {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(42).cast() }
        }
        #[doc = "0x2a - endpoint 2 control"]
        #[inline(always)]
        pub const fn uep2_ctrl(&self) -> &Uep2Ctrl {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(42).cast() }
        }
        #[doc = "0x2c - host transmittal endpoint transmittal length"]
        #[inline(always)]
        pub const fn uh_tx_len(&self) -> &UhTxLen {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(44).cast() }
        }
        #[doc = "0x2c - endpoint 3 transmittal length"]
        #[inline(always)]
        pub const fn uep3_t_len(&self) -> &Uep3TLen {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(44).cast() }
        }
        #[doc = "0x2e - host transmittal endpoint control"]
        #[inline(always)]
        pub const fn uh_tx_ctrl(&self) -> &UhTxCtrl {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(46).cast() }
        }
        #[doc = "0x2e - endpoint 3 control"]
        #[inline(always)]
        pub const fn uep3_ctrl(&self) -> &Uep3Ctrl {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(46).cast() }
        }
        #[doc = "0x30 - endpoint 4 transmittal length"]
        #[inline(always)]
        pub const fn uep4_t_len(&self) -> &Uep4TLen {
            &self.uep4_t_len
        }
        #[doc = "0x32 - endpoint 4 control"]
        #[inline(always)]
        pub const fn uep4_ctrl(&self) -> &Uep4Ctrl {
            &self.uep4_ctrl
        }
        #[doc = "0x54 - endpoint 5 DMA buffer address"]
        #[inline(always)]
        pub const fn uep5_dma(&self) -> &Uep5Dma {
            &self.uep5_dma
        }
        #[doc = "0x58 - endpoint 6 DMA buffer address"]
        #[inline(always)]
        pub const fn uep6_dma(&self) -> &Uep6Dma {
            &self.uep6_dma
        }
        #[doc = "0x5c - endpoint 7 DMA buffer address"]
        #[inline(always)]
        pub const fn uep7_dma(&self) -> &Uep7Dma {
            &self.uep7_dma
        }
        #[doc = "0x64 - endpoint 5 transmittal length"]
        #[inline(always)]
        pub const fn uep5_t_len(&self) -> &Uep5TLen {
            &self.uep5_t_len
        }
        #[doc = "0x66 - endpoint 5 control"]
        #[inline(always)]
        pub const fn uep5_ctrl(&self) -> &Uep5Ctrl {
            &self.uep5_ctrl
        }
        #[doc = "0x68 - endpoint 6 transmittal length"]
        #[inline(always)]
        pub const fn uep6_t_len(&self) -> &Uep6TLen {
            &self.uep6_t_len
        }
        #[doc = "0x6a - endpoint 6 control"]
        #[inline(always)]
        pub const fn uep6_ctrl(&self) -> &Uep6Ctrl {
            &self.uep6_ctrl
        }
        #[doc = "0x6c - endpoint 7 transmittal length"]
        #[inline(always)]
        pub const fn uep7_t_len(&self) -> &Uep7TLen {
            &self.uep7_t_len
        }
        #[doc = "0x6e - endpoint 7 control"]
        #[inline(always)]
        pub const fn uep7_ctrl(&self) -> &Uep7Ctrl {
            &self.uep7_ctrl
        }
    }
    #[doc = "CTRL (rw) register accessor: USB base control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`] module"]
    #[doc(alias = "CTRL")]
    pub type Ctrl = crate::Reg<ctrl::CtrlSpec>;
    #[doc = "USB base control"]
    pub mod ctrl {
        #[doc = "Register `CTRL` reader"]
        pub type R = crate::R<CtrlSpec>;
        #[doc = "Register `CTRL` writer"]
        pub type W = crate::W<CtrlSpec>;
        #[doc = "Field `UC_DMA_EN` reader - DMA enable and DMA interrupt enable for USB"]
        pub type UcDmaEnR = crate::BitReader;
        #[doc = "Field `UC_DMA_EN` writer - DMA enable and DMA interrupt enable for USB"]
        pub type UcDmaEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UC_CLR_ALL` reader - force clear FIFO and count of USB"]
        pub type UcClrAllR = crate::BitReader;
        #[doc = "Field `UC_CLR_ALL` writer - force clear FIFO and count of USB"]
        pub type UcClrAllW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UC_RESET_SIE` reader - force reset USB SIE, need software clear"]
        pub type UcResetSieR = crate::BitReader;
        #[doc = "Field `UC_RESET_SIE` writer - force reset USB SIE, need software clear"]
        pub type UcResetSieW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UC_INT_BUSY` reader - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid"]
        pub type UcIntBusyR = crate::BitReader;
        #[doc = "Field `UC_INT_BUSY` writer - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid"]
        pub type UcIntBusyW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UC_SYS_CTRL` reader - bit mask of USB system control"]
        pub type UcSysCtrlR = crate::FieldReader;
        #[doc = "Field `UC_SYS_CTRL` writer - bit mask of USB system control"]
        pub type UcSysCtrlW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UC_DEV_PU_EN` reader - USB device enable and internal pullup resistance enable"]
        pub type UcDevPuEnR = crate::BitReader;
        #[doc = "Field `UC_DEV_PU_EN` writer - USB device enable and internal pullup resistance enable"]
        pub type UcDevPuEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UC_LOW_SPEED` reader - enable USB low speed: 0=12Mbps, 1=1.5Mbps"]
        pub type UcLowSpeedR = crate::BitReader;
        #[doc = "Field `UC_LOW_SPEED` writer - enable USB low speed: 0=12Mbps, 1=1.5Mbps"]
        pub type UcLowSpeedW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UC_HOST_MODE` reader - enable USB host mode: 0=device mode, 1=host mode"]
        pub type UcHostModeR = crate::BitReader;
        #[doc = "Field `UC_HOST_MODE` writer - enable USB host mode: 0=device mode, 1=host mode"]
        pub type UcHostModeW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - DMA enable and DMA interrupt enable for USB"]
            #[inline(always)]
            pub fn uc_dma_en(&self) -> UcDmaEnR {
                UcDmaEnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - force clear FIFO and count of USB"]
            #[inline(always)]
            pub fn uc_clr_all(&self) -> UcClrAllR {
                UcClrAllR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - force reset USB SIE, need software clear"]
            #[inline(always)]
            pub fn uc_reset_sie(&self) -> UcResetSieR {
                UcResetSieR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid"]
            #[inline(always)]
            pub fn uc_int_busy(&self) -> UcIntBusyR {
                UcIntBusyR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:5 - bit mask of USB system control"]
            #[inline(always)]
            pub fn uc_sys_ctrl(&self) -> UcSysCtrlR {
                UcSysCtrlR::new((self.bits >> 4) & 3)
            }
            #[doc = "Bit 5 - USB device enable and internal pullup resistance enable"]
            #[inline(always)]
            pub fn uc_dev_pu_en(&self) -> UcDevPuEnR {
                UcDevPuEnR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps"]
            #[inline(always)]
            pub fn uc_low_speed(&self) -> UcLowSpeedR {
                UcLowSpeedR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - enable USB host mode: 0=device mode, 1=host mode"]
            #[inline(always)]
            pub fn uc_host_mode(&self) -> UcHostModeR {
                UcHostModeR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - DMA enable and DMA interrupt enable for USB"]
            #[inline(always)]
            pub fn uc_dma_en(&mut self) -> UcDmaEnW<CtrlSpec> {
                UcDmaEnW::new(self, 0)
            }
            #[doc = "Bit 1 - force clear FIFO and count of USB"]
            #[inline(always)]
            pub fn uc_clr_all(&mut self) -> UcClrAllW<CtrlSpec> {
                UcClrAllW::new(self, 1)
            }
            #[doc = "Bit 2 - force reset USB SIE, need software clear"]
            #[inline(always)]
            pub fn uc_reset_sie(&mut self) -> UcResetSieW<CtrlSpec> {
                UcResetSieW::new(self, 2)
            }
            #[doc = "Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid"]
            #[inline(always)]
            pub fn uc_int_busy(&mut self) -> UcIntBusyW<CtrlSpec> {
                UcIntBusyW::new(self, 3)
            }
            #[doc = "Bits 4:5 - bit mask of USB system control"]
            #[inline(always)]
            pub fn uc_sys_ctrl(&mut self) -> UcSysCtrlW<CtrlSpec> {
                UcSysCtrlW::new(self, 4)
            }
            #[doc = "Bit 5 - USB device enable and internal pullup resistance enable"]
            #[inline(always)]
            pub fn uc_dev_pu_en(&mut self) -> UcDevPuEnW<CtrlSpec> {
                UcDevPuEnW::new(self, 5)
            }
            #[doc = "Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps"]
            #[inline(always)]
            pub fn uc_low_speed(&mut self) -> UcLowSpeedW<CtrlSpec> {
                UcLowSpeedW::new(self, 6)
            }
            #[doc = "Bit 7 - enable USB host mode: 0=device mode, 1=host mode"]
            #[inline(always)]
            pub fn uc_host_mode(&mut self) -> UcHostModeW<CtrlSpec> {
                UcHostModeW::new(self, 7)
            }
        }
        #[doc = "USB base control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CtrlSpec;
        impl crate::RegisterSpec for CtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`ctrl::R`](R) reader structure"]
        impl crate::Readable for CtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"]
        impl crate::Writable for CtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CTRL to value 0x06"]
        impl crate::Resettable for CtrlSpec {
            const RESET_VALUE: u8 = 0x06;
        }
    }
    #[doc = "UDEV_CTRL (rw) register accessor: USB device physical prot control\n\nYou can [`read`](crate::Reg::read) this register and get [`udev_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`udev_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@udev_ctrl`] module"]
    #[doc(alias = "UDEV_CTRL")]
    pub type UdevCtrl = crate::Reg<udev_ctrl::UdevCtrlSpec>;
    #[doc = "USB device physical prot control"]
    pub mod udev_ctrl {
        #[doc = "Register `UDEV_CTRL` reader"]
        pub type R = crate::R<UdevCtrlSpec>;
        #[doc = "Register `UDEV_CTRL` writer"]
        pub type W = crate::W<UdevCtrlSpec>;
        #[doc = "Field `UD_PORT_EN` reader - enable USB physical port I-O: 0=disable, 1=enable"]
        pub type UdPortEnR = crate::BitReader;
        #[doc = "Field `UD_PORT_EN` writer - enable USB physical port I-O: 0=disable, 1=enable"]
        pub type UdPortEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UD_GP_BIT` reader - general purpose bit"]
        pub type UdGpBitR = crate::BitReader;
        #[doc = "Field `UD_GP_BIT` writer - general purpose bit"]
        pub type UdGpBitW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UD_LOW_SPEED` reader - enable USB physical port low speed: 0=full speed, 1=low speed"]
        pub type UdLowSpeedR = crate::BitReader;
        #[doc = "Field `UD_LOW_SPEED` writer - enable USB physical port low speed: 0=full speed, 1=low speed"]
        pub type UdLowSpeedW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UD_DM_PIN` reader - ReadOnly: indicate current UDM pin level"]
        pub type UdDmPinR = crate::BitReader;
        #[doc = "Field `UD_DP_PIN` reader - ReadOnly: indicate current UDP pin level"]
        pub type UdDpPinR = crate::BitReader;
        #[doc = "Field `UD_PD_DIS` reader - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable"]
        pub type UdPdDisR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - enable USB physical port I-O: 0=disable, 1=enable"]
            #[inline(always)]
            pub fn ud_port_en(&self) -> UdPortEnR {
                UdPortEnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - general purpose bit"]
            #[inline(always)]
            pub fn ud_gp_bit(&self) -> UdGpBitR {
                UdGpBitR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed"]
            #[inline(always)]
            pub fn ud_low_speed(&self) -> UdLowSpeedR {
                UdLowSpeedR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 4 - ReadOnly: indicate current UDM pin level"]
            #[inline(always)]
            pub fn ud_dm_pin(&self) -> UdDmPinR {
                UdDmPinR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - ReadOnly: indicate current UDP pin level"]
            #[inline(always)]
            pub fn ud_dp_pin(&self) -> UdDpPinR {
                UdDpPinR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 7 - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable"]
            #[inline(always)]
            pub fn ud_pd_dis(&self) -> UdPdDisR {
                UdPdDisR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - enable USB physical port I-O: 0=disable, 1=enable"]
            #[inline(always)]
            pub fn ud_port_en(&mut self) -> UdPortEnW<UdevCtrlSpec> {
                UdPortEnW::new(self, 0)
            }
            #[doc = "Bit 1 - general purpose bit"]
            #[inline(always)]
            pub fn ud_gp_bit(&mut self) -> UdGpBitW<UdevCtrlSpec> {
                UdGpBitW::new(self, 1)
            }
            #[doc = "Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed"]
            #[inline(always)]
            pub fn ud_low_speed(&mut self) -> UdLowSpeedW<UdevCtrlSpec> {
                UdLowSpeedW::new(self, 2)
            }
        }
        #[doc = "USB device physical prot control\n\nYou can [`read`](crate::Reg::read) this register and get [`udev_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`udev_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct UdevCtrlSpec;
        impl crate::RegisterSpec for UdevCtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`udev_ctrl::R`](R) reader structure"]
        impl crate::Readable for UdevCtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`udev_ctrl::W`](W) writer structure"]
        impl crate::Writable for UdevCtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UDEV_CTRL to value 0"]
        impl crate::Resettable for UdevCtrlSpec {}
    }
    #[doc = "UHOST_CTRL (rw) register accessor: USB device physical prot control\n\nYou can [`read`](crate::Reg::read) this register and get [`uhost_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uhost_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uhost_ctrl`] module"]
    #[doc(alias = "UHOST_CTRL")]
    pub type UhostCtrl = crate::Reg<uhost_ctrl::UhostCtrlSpec>;
    #[doc = "USB device physical prot control"]
    pub mod uhost_ctrl {
        #[doc = "Register `UHOST_CTRL` reader"]
        pub type R = crate::R<UhostCtrlSpec>;
        #[doc = "Register `UHOST_CTRL` writer"]
        pub type W = crate::W<UhostCtrlSpec>;
        #[doc = "Field `UH_PORT_EN` reader - enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached"]
        pub type UhPortEnR = crate::BitReader;
        #[doc = "Field `UH_PORT_EN` writer - enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached"]
        pub type UhPortEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UH_BUS_RESET` reader - control USB bus reset: 0=normal, 1=force bus reset"]
        pub type UhBusResetR = crate::BitReader;
        #[doc = "Field `UH_BUS_RESET` writer - control USB bus reset: 0=normal, 1=force bus reset"]
        pub type UhBusResetW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UH_LOW_SPEED` reader - enable USB port low speed: 0=full speed, 1=low speed"]
        pub type UhLowSpeedR = crate::BitReader;
        #[doc = "Field `UH_LOW_SPEED` writer - enable USB port low speed: 0=full speed, 1=low speed"]
        pub type UhLowSpeedW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UH_DM_PIN` reader - ReadOnly: indicate current UDM pin level"]
        pub type UhDmPinR = crate::BitReader;
        #[doc = "Field `UH_DP_PIN` reader - ReadOnly: indicate current UDP pin level"]
        pub type UhDpPinR = crate::BitReader;
        #[doc = "Field `UH_PD_DIS` reader - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable"]
        pub type UhPdDisR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached"]
            #[inline(always)]
            pub fn uh_port_en(&self) -> UhPortEnR {
                UhPortEnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - control USB bus reset: 0=normal, 1=force bus reset"]
            #[inline(always)]
            pub fn uh_bus_reset(&self) -> UhBusResetR {
                UhBusResetR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - enable USB port low speed: 0=full speed, 1=low speed"]
            #[inline(always)]
            pub fn uh_low_speed(&self) -> UhLowSpeedR {
                UhLowSpeedR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 4 - ReadOnly: indicate current UDM pin level"]
            #[inline(always)]
            pub fn uh_dm_pin(&self) -> UhDmPinR {
                UhDmPinR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - ReadOnly: indicate current UDP pin level"]
            #[inline(always)]
            pub fn uh_dp_pin(&self) -> UhDpPinR {
                UhDpPinR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 7 - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable"]
            #[inline(always)]
            pub fn uh_pd_dis(&self) -> UhPdDisR {
                UhPdDisR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached"]
            #[inline(always)]
            pub fn uh_port_en(&mut self) -> UhPortEnW<UhostCtrlSpec> {
                UhPortEnW::new(self, 0)
            }
            #[doc = "Bit 1 - control USB bus reset: 0=normal, 1=force bus reset"]
            #[inline(always)]
            pub fn uh_bus_reset(&mut self) -> UhBusResetW<UhostCtrlSpec> {
                UhBusResetW::new(self, 1)
            }
            #[doc = "Bit 2 - enable USB port low speed: 0=full speed, 1=low speed"]
            #[inline(always)]
            pub fn uh_low_speed(&mut self) -> UhLowSpeedW<UhostCtrlSpec> {
                UhLowSpeedW::new(self, 2)
            }
        }
        #[doc = "USB device physical prot control\n\nYou can [`read`](crate::Reg::read) this register and get [`uhost_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uhost_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct UhostCtrlSpec;
        impl crate::RegisterSpec for UhostCtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uhost_ctrl::R`](R) reader structure"]
        impl crate::Readable for UhostCtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`uhost_ctrl::W`](W) writer structure"]
        impl crate::Writable for UhostCtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UHOST_CTRL to value 0"]
        impl crate::Resettable for UhostCtrlSpec {}
    }
    #[doc = "INT_EN (rw) register accessor: USB interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`int_en::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_en::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_en`] module"]
    #[doc(alias = "INT_EN")]
    pub type IntEn = crate::Reg<int_en::IntEnSpec>;
    #[doc = "USB interrupt enable"]
    pub mod int_en {
        #[doc = "Register `INT_EN` reader"]
        pub type R = crate::R<IntEnSpec>;
        #[doc = "Register `INT_EN` writer"]
        pub type W = crate::W<IntEnSpec>;
        #[doc = "Field `UIE_BUS_RST` reader - enable interrupt for USB bus reset event for USB device mode"]
        pub type UieBusRstR = crate::BitReader;
        #[doc = "Field `UIE_BUS_RST` writer - enable interrupt for USB bus reset event for USB device mode"]
        pub type UieBusRstW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UIE_DETECT` reader - enable interrupt for USB device detected event for USB host mode"]
        pub type UieDetectR = crate::BitReader;
        #[doc = "Field `UIE_DETECT` writer - enable interrupt for USB device detected event for USB host mode"]
        pub type UieDetectW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UIE_TRANSFER` reader - enable interrupt for USB transfer completion"]
        pub type UieTransferR = crate::BitReader;
        #[doc = "Field `UIE_TRANSFER` writer - enable interrupt for USB transfer completion"]
        pub type UieTransferW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UIE_SUSPEND` reader - enable interrupt for USB suspend or resume event"]
        pub type UieSuspendR = crate::BitReader;
        #[doc = "Field `UIE_SUSPEND` writer - enable interrupt for USB suspend or resume event"]
        pub type UieSuspendW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UIE_HST_SOF` reader - enable interrupt for host SOF timer action for USB host mode"]
        pub type UieHstSofR = crate::BitReader;
        #[doc = "Field `UIE_HST_SOF` writer - enable interrupt for host SOF timer action for USB host mode"]
        pub type UieHstSofW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UIE_FIFO_OV` reader - enable interrupt for FIFO overflow"]
        pub type UieFifoOvR = crate::BitReader;
        #[doc = "Field `UIE_FIFO_OV` writer - enable interrupt for FIFO overflow"]
        pub type UieFifoOvW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UIE_DEV_NAK` reader - enable interrupt for NAK responded for USB device mode"]
        pub type UieDevNakR = crate::BitReader;
        #[doc = "Field `UIE_DEV_NAK` writer - enable interrupt for NAK responded for USB device mode"]
        pub type UieDevNakW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UIE_DEV_SOF` reader - enable interrupt for SOF received for USB device mode"]
        pub type UieDevSofR = crate::BitReader;
        #[doc = "Field `UIE_DEV_SOF` writer - enable interrupt for SOF received for USB device mode"]
        pub type UieDevSofW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - enable interrupt for USB bus reset event for USB device mode"]
            #[inline(always)]
            pub fn uie_bus_rst(&self) -> UieBusRstR {
                UieBusRstR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 0 - enable interrupt for USB device detected event for USB host mode"]
            #[inline(always)]
            pub fn uie_detect(&self) -> UieDetectR {
                UieDetectR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - enable interrupt for USB transfer completion"]
            #[inline(always)]
            pub fn uie_transfer(&self) -> UieTransferR {
                UieTransferR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - enable interrupt for USB suspend or resume event"]
            #[inline(always)]
            pub fn uie_suspend(&self) -> UieSuspendR {
                UieSuspendR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - enable interrupt for host SOF timer action for USB host mode"]
            #[inline(always)]
            pub fn uie_hst_sof(&self) -> UieHstSofR {
                UieHstSofR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - enable interrupt for FIFO overflow"]
            #[inline(always)]
            pub fn uie_fifo_ov(&self) -> UieFifoOvR {
                UieFifoOvR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - enable interrupt for NAK responded for USB device mode"]
            #[inline(always)]
            pub fn uie_dev_nak(&self) -> UieDevNakR {
                UieDevNakR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - enable interrupt for SOF received for USB device mode"]
            #[inline(always)]
            pub fn uie_dev_sof(&self) -> UieDevSofR {
                UieDevSofR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - enable interrupt for USB bus reset event for USB device mode"]
            #[inline(always)]
            pub fn uie_bus_rst(&mut self) -> UieBusRstW<IntEnSpec> {
                UieBusRstW::new(self, 0)
            }
            #[doc = "Bit 0 - enable interrupt for USB device detected event for USB host mode"]
            #[inline(always)]
            pub fn uie_detect(&mut self) -> UieDetectW<IntEnSpec> {
                UieDetectW::new(self, 0)
            }
            #[doc = "Bit 1 - enable interrupt for USB transfer completion"]
            #[inline(always)]
            pub fn uie_transfer(&mut self) -> UieTransferW<IntEnSpec> {
                UieTransferW::new(self, 1)
            }
            #[doc = "Bit 2 - enable interrupt for USB suspend or resume event"]
            #[inline(always)]
            pub fn uie_suspend(&mut self) -> UieSuspendW<IntEnSpec> {
                UieSuspendW::new(self, 2)
            }
            #[doc = "Bit 3 - enable interrupt for host SOF timer action for USB host mode"]
            #[inline(always)]
            pub fn uie_hst_sof(&mut self) -> UieHstSofW<IntEnSpec> {
                UieHstSofW::new(self, 3)
            }
            #[doc = "Bit 4 - enable interrupt for FIFO overflow"]
            #[inline(always)]
            pub fn uie_fifo_ov(&mut self) -> UieFifoOvW<IntEnSpec> {
                UieFifoOvW::new(self, 4)
            }
            #[doc = "Bit 6 - enable interrupt for NAK responded for USB device mode"]
            #[inline(always)]
            pub fn uie_dev_nak(&mut self) -> UieDevNakW<IntEnSpec> {
                UieDevNakW::new(self, 6)
            }
            #[doc = "Bit 7 - enable interrupt for SOF received for USB device mode"]
            #[inline(always)]
            pub fn uie_dev_sof(&mut self) -> UieDevSofW<IntEnSpec> {
                UieDevSofW::new(self, 7)
            }
        }
        #[doc = "USB interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`int_en::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_en::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IntEnSpec;
        impl crate::RegisterSpec for IntEnSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`int_en::R`](R) reader structure"]
        impl crate::Readable for IntEnSpec {}
        #[doc = "`write(|w| ..)` method takes [`int_en::W`](W) writer structure"]
        impl crate::Writable for IntEnSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets INT_EN to value 0"]
        impl crate::Resettable for IntEnSpec {}
    }
    #[doc = "DEV_AD (rw) register accessor: USB device address\n\nYou can [`read`](crate::Reg::read) this register and get [`dev_ad::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dev_ad::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dev_ad`] module"]
    #[doc(alias = "DEV_AD")]
    pub type DevAd = crate::Reg<dev_ad::DevAdSpec>;
    #[doc = "USB device address"]
    pub mod dev_ad {
        #[doc = "Register `DEV_AD` reader"]
        pub type R = crate::R<DevAdSpec>;
        #[doc = "Register `DEV_AD` writer"]
        pub type W = crate::W<DevAdSpec>;
        #[doc = "Field `ADDR` reader - bit mask for USB device address"]
        pub type AddrR = crate::FieldReader;
        #[doc = "Field `ADDR` writer - bit mask for USB device address"]
        pub type AddrW<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        #[doc = "Field `UDA_GP_BIT` reader - general purpose bit"]
        pub type UdaGpBitR = crate::BitReader;
        #[doc = "Field `UDA_GP_BIT` writer - general purpose bit"]
        pub type UdaGpBitW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:6 - bit mask for USB device address"]
            #[inline(always)]
            pub fn addr(&self) -> AddrR {
                AddrR::new(self.bits & 0x7f)
            }
            #[doc = "Bit 7 - general purpose bit"]
            #[inline(always)]
            pub fn uda_gp_bit(&self) -> UdaGpBitR {
                UdaGpBitR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:6 - bit mask for USB device address"]
            #[inline(always)]
            pub fn addr(&mut self) -> AddrW<DevAdSpec> {
                AddrW::new(self, 0)
            }
            #[doc = "Bit 7 - general purpose bit"]
            #[inline(always)]
            pub fn uda_gp_bit(&mut self) -> UdaGpBitW<DevAdSpec> {
                UdaGpBitW::new(self, 7)
            }
        }
        #[doc = "USB device address\n\nYou can [`read`](crate::Reg::read) this register and get [`dev_ad::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dev_ad::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DevAdSpec;
        impl crate::RegisterSpec for DevAdSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`dev_ad::R`](R) reader structure"]
        impl crate::Readable for DevAdSpec {}
        #[doc = "`write(|w| ..)` method takes [`dev_ad::W`](W) writer structure"]
        impl crate::Writable for DevAdSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DEV_AD to value 0"]
        impl crate::Resettable for DevAdSpec {}
    }
    #[doc = "MIS_ST (r) register accessor: USB miscellaneous status\n\nYou can [`read`](crate::Reg::read) this register and get [`mis_st::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mis_st`] module"]
    #[doc(alias = "MIS_ST")]
    pub type MisSt = crate::Reg<mis_st::MisStSpec>;
    #[doc = "USB miscellaneous status"]
    pub mod mis_st {
        #[doc = "Register `MIS_ST` reader"]
        pub type R = crate::R<MisStSpec>;
        #[doc = "Field `UMS_DEV_ATTACH` reader - RO, indicate device attached status on USB host"]
        pub type UmsDevAttachR = crate::BitReader;
        #[doc = "Field `UMS_DM_LEVEL` reader - RO, indicate UDM level saved at device attached to USB host"]
        pub type UmsDmLevelR = crate::BitReader;
        #[doc = "Field `UMS_SUSPEND` reader - RO, indicate USB suspend status"]
        pub type UmsSuspendR = crate::BitReader;
        #[doc = "Field `UMS_BUS_RESET` reader - RO, indicate USB bus reset status"]
        pub type UmsBusResetR = crate::BitReader;
        #[doc = "Field `UMS_R_FIFO_RDY` reader - RO, indicate USB receiving FIFO ready status (not empty)"]
        pub type UmsRFifoRdyR = crate::BitReader;
        #[doc = "Field `UMS_SIE_FREE` reader - RO, indicate USB SIE free status"]
        pub type UmsSieFreeR = crate::BitReader;
        #[doc = "Field `UMS_SOF_ACT` reader - RO, indicate host SOF timer action status for USB host"]
        pub type UmsSofActR = crate::BitReader;
        #[doc = "Field `UMS_SOF_PRES` reader - RO, indicate host SOF timer presage status"]
        pub type UmsSofPresR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - RO, indicate device attached status on USB host"]
            #[inline(always)]
            pub fn ums_dev_attach(&self) -> UmsDevAttachR {
                UmsDevAttachR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RO, indicate UDM level saved at device attached to USB host"]
            #[inline(always)]
            pub fn ums_dm_level(&self) -> UmsDmLevelR {
                UmsDmLevelR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RO, indicate USB suspend status"]
            #[inline(always)]
            pub fn ums_suspend(&self) -> UmsSuspendR {
                UmsSuspendR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RO, indicate USB bus reset status"]
            #[inline(always)]
            pub fn ums_bus_reset(&self) -> UmsBusResetR {
                UmsBusResetR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RO, indicate USB receiving FIFO ready status (not empty)"]
            #[inline(always)]
            pub fn ums_r_fifo_rdy(&self) -> UmsRFifoRdyR {
                UmsRFifoRdyR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RO, indicate USB SIE free status"]
            #[inline(always)]
            pub fn ums_sie_free(&self) -> UmsSieFreeR {
                UmsSieFreeR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RO, indicate host SOF timer action status for USB host"]
            #[inline(always)]
            pub fn ums_sof_act(&self) -> UmsSofActR {
                UmsSofActR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RO, indicate host SOF timer presage status"]
            #[inline(always)]
            pub fn ums_sof_pres(&self) -> UmsSofPresR {
                UmsSofPresR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        #[doc = "USB miscellaneous status\n\nYou can [`read`](crate::Reg::read) this register and get [`mis_st::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct MisStSpec;
        impl crate::RegisterSpec for MisStSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`mis_st::R`](R) reader structure"]
        impl crate::Readable for MisStSpec {}
        #[doc = "`reset()` method sets MIS_ST to value 0"]
        impl crate::Resettable for MisStSpec {}
    }
    #[doc = "INT_FG (rw) register accessor: USB interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_fg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_fg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_fg`] module"]
    #[doc(alias = "INT_FG")]
    pub type IntFg = crate::Reg<int_fg::IntFgSpec>;
    #[doc = "USB interrupt flag"]
    pub mod int_fg {
        #[doc = "Register `INT_FG` reader"]
        pub type R = crate::R<IntFgSpec>;
        #[doc = "Register `INT_FG` writer"]
        pub type W = crate::W<IntFgSpec>;
        #[doc = "Field `UIF_BUS_RST` reader - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear"]
        pub type UifBusRstR = crate::BitReader;
        #[doc = "Field `UIF_BUS_RST` writer - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear"]
        pub type UifBusRstW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UIF_DETECT` reader - RW,device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear"]
        pub type UifDetectR = crate::BitReader;
        #[doc = "Field `UIF_DETECT` writer - RW,device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear"]
        pub type UifDetectW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UIF_TRANSFER` reader - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear"]
        pub type UifTransferR = crate::BitReader;
        #[doc = "Field `UIF_TRANSFER` writer - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear"]
        pub type UifTransferW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UIF_SUSPEND` reader - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear"]
        pub type UifSuspendR = crate::BitReader;
        #[doc = "Field `UIF_SUSPEND` writer - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear"]
        pub type UifSuspendW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UIF_HST_SOF` reader - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear"]
        pub type UifHstSofR = crate::BitReader;
        #[doc = "Field `UIF_HST_SOF` writer - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear"]
        pub type UifHstSofW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UIF_FIFO_OV` reader - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear"]
        pub type UifFifoOvR = crate::BitReader;
        #[doc = "Field `UIF_FIFO_OV` writer - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear"]
        pub type UifFifoOvW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `U_SIE_FREE` reader - RO, indicate USB SIE free status"]
        pub type USieFreeR = crate::BitReader;
        #[doc = "Field `U_TOG_OK` reader - RO, indicate current USB transfer toggle is OK"]
        pub type UTogOkR = crate::BitReader;
        #[doc = "Field `U_IS_NAK` reader - RO, indicate current USB transfer is NAK received"]
        pub type UIsNakR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear"]
            #[inline(always)]
            pub fn uif_bus_rst(&self) -> UifBusRstR {
                UifBusRstR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 0 - RW,device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear"]
            #[inline(always)]
            pub fn uif_detect(&self) -> UifDetectR {
                UifDetectR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear"]
            #[inline(always)]
            pub fn uif_transfer(&self) -> UifTransferR {
                UifTransferR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear"]
            #[inline(always)]
            pub fn uif_suspend(&self) -> UifSuspendR {
                UifSuspendR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear"]
            #[inline(always)]
            pub fn uif_hst_sof(&self) -> UifHstSofR {
                UifHstSofR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear"]
            #[inline(always)]
            pub fn uif_fifo_ov(&self) -> UifFifoOvR {
                UifFifoOvR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RO, indicate USB SIE free status"]
            #[inline(always)]
            pub fn u_sie_free(&self) -> USieFreeR {
                USieFreeR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RO, indicate current USB transfer toggle is OK"]
            #[inline(always)]
            pub fn u_tog_ok(&self) -> UTogOkR {
                UTogOkR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RO, indicate current USB transfer is NAK received"]
            #[inline(always)]
            pub fn u_is_nak(&self) -> UIsNakR {
                UIsNakR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear"]
            #[inline(always)]
            pub fn uif_bus_rst(&mut self) -> UifBusRstW<IntFgSpec> {
                UifBusRstW::new(self, 0)
            }
            #[doc = "Bit 0 - RW,device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear"]
            #[inline(always)]
            pub fn uif_detect(&mut self) -> UifDetectW<IntFgSpec> {
                UifDetectW::new(self, 0)
            }
            #[doc = "Bit 1 - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear"]
            #[inline(always)]
            pub fn uif_transfer(&mut self) -> UifTransferW<IntFgSpec> {
                UifTransferW::new(self, 1)
            }
            #[doc = "Bit 2 - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear"]
            #[inline(always)]
            pub fn uif_suspend(&mut self) -> UifSuspendW<IntFgSpec> {
                UifSuspendW::new(self, 2)
            }
            #[doc = "Bit 3 - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear"]
            #[inline(always)]
            pub fn uif_hst_sof(&mut self) -> UifHstSofW<IntFgSpec> {
                UifHstSofW::new(self, 3)
            }
            #[doc = "Bit 4 - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear"]
            #[inline(always)]
            pub fn uif_fifo_ov(&mut self) -> UifFifoOvW<IntFgSpec> {
                UifFifoOvW::new(self, 4)
            }
        }
        #[doc = "USB interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_fg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_fg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IntFgSpec;
        impl crate::RegisterSpec for IntFgSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`int_fg::R`](R) reader structure"]
        impl crate::Readable for IntFgSpec {}
        #[doc = "`write(|w| ..)` method takes [`int_fg::W`](W) writer structure"]
        impl crate::Writable for IntFgSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets INT_FG to value 0x20"]
        impl crate::Resettable for IntFgSpec {
            const RESET_VALUE: u8 = 0x20;
        }
    }
    #[doc = "INT_ST (r) register accessor: USB interrupt status\n\nYou can [`read`](crate::Reg::read) this register and get [`int_st::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_st`] module"]
    #[doc(alias = "INT_ST")]
    pub type IntSt = crate::Reg<int_st::IntStSpec>;
    #[doc = "USB interrupt status"]
    pub mod int_st {
        #[doc = "Register `INT_ST` reader"]
        pub type R = crate::R<IntStSpec>;
        #[doc = "Field `UIS_H_RES` reader - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received"]
        pub type UisHResR = crate::FieldReader;
        #[doc = "Field `UIS_ENDP` reader - RO, bit mask of current transfer endpoint number for USB device mode"]
        pub type UisEndpR = crate::FieldReader;
        #[doc = "Field `UIS_TOKEN` reader - RO, bit mask of current token PID code received for USB device mode"]
        pub type UisTokenR = crate::FieldReader;
        #[doc = "Field `UIS_TOG_OK` reader - RO, indicate current USB transfer toggle is OK"]
        pub type UisTogOkR = crate::BitReader;
        #[doc = "Field `UIS_SETUP_ACT` reader - RO, indicate current USB transfer is NAK received for USB device mode"]
        pub type UisSetupActR = crate::BitReader;
        impl R {
            #[doc = "Bits 0:3 - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received"]
            #[inline(always)]
            pub fn uis_h_res(&self) -> UisHResR {
                UisHResR::new(self.bits & 0x0f)
            }
            #[doc = "Bits 0:3 - RO, bit mask of current transfer endpoint number for USB device mode"]
            #[inline(always)]
            pub fn uis_endp(&self) -> UisEndpR {
                UisEndpR::new(self.bits & 0x0f)
            }
            #[doc = "Bits 4:5 - RO, bit mask of current token PID code received for USB device mode"]
            #[inline(always)]
            pub fn uis_token(&self) -> UisTokenR {
                UisTokenR::new((self.bits >> 4) & 3)
            }
            #[doc = "Bit 6 - RO, indicate current USB transfer toggle is OK"]
            #[inline(always)]
            pub fn uis_tog_ok(&self) -> UisTogOkR {
                UisTogOkR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RO, indicate current USB transfer is NAK received for USB device mode"]
            #[inline(always)]
            pub fn uis_setup_act(&self) -> UisSetupActR {
                UisSetupActR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        #[doc = "USB interrupt status\n\nYou can [`read`](crate::Reg::read) this register and get [`int_st::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IntStSpec;
        impl crate::RegisterSpec for IntStSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`int_st::R`](R) reader structure"]
        impl crate::Readable for IntStSpec {}
        #[doc = "`reset()` method sets INT_ST to value 0"]
        impl crate::Resettable for IntStSpec {}
    }
    #[doc = "RX_LEN (r) register accessor: USB receiving length\n\nYou can [`read`](crate::Reg::read) this register and get [`rx_len::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rx_len`] module"]
    #[doc(alias = "RX_LEN")]
    pub type RxLen = crate::Reg<rx_len::RxLenSpec>;
    #[doc = "USB receiving length"]
    pub mod rx_len {
        #[doc = "Register `RX_LEN` reader"]
        pub type R = crate::R<RxLenSpec>;
        #[doc = "Field `RX_LEN` reader - RO,USB receiving length"]
        pub type RxLenR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RO,USB receiving length"]
            #[inline(always)]
            pub fn rx_len(&self) -> RxLenR {
                RxLenR::new(self.bits)
            }
        }
        #[doc = "USB receiving length\n\nYou can [`read`](crate::Reg::read) this register and get [`rx_len::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RxLenSpec;
        impl crate::RegisterSpec for RxLenSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`rx_len::R`](R) reader structure"]
        impl crate::Readable for RxLenSpec {}
        #[doc = "`reset()` method sets RX_LEN to value 0"]
        impl crate::Resettable for RxLenSpec {}
    }
    #[doc = "UEP4_1_MOD (rw) register accessor: endpoint 4/1 mode\n\nYou can [`read`](crate::Reg::read) this register and get [`uep4_1_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep4_1_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep4_1_mod`] module"]
    #[doc(alias = "UEP4_1_MOD")]
    pub type Uep4_1Mod = crate::Reg<uep4_1_mod::Uep4_1ModSpec>;
    #[doc = "endpoint 4/1 mode"]
    pub mod uep4_1_mod {
        #[doc = "Register `UEP4_1_MOD` reader"]
        pub type R = crate::R<Uep4_1ModSpec>;
        #[doc = "Register `UEP4_1_MOD` writer"]
        pub type W = crate::W<Uep4_1ModSpec>;
        #[doc = "Field `UEP4_TX_EN` reader - enable USB endpoint 4 transmittal (IN)"]
        pub type Uep4TxEnR = crate::BitReader;
        #[doc = "Field `UEP4_TX_EN` writer - enable USB endpoint 4 transmittal (IN)"]
        pub type Uep4TxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP4_RX_EN` reader - enable USB endpoint 4 receiving (OUT)"]
        pub type Uep4RxEnR = crate::BitReader;
        #[doc = "Field `UEP4_RX_EN` writer - enable USB endpoint 4 receiving (OUT)"]
        pub type Uep4RxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP1_BUF_MOD` reader - buffer mode of USB endpoint 1"]
        pub type Uep1BufModR = crate::BitReader;
        #[doc = "Field `UEP1_BUF_MOD` writer - buffer mode of USB endpoint 1"]
        pub type Uep1BufModW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP1_TX_EN` reader - enable USB endpoint 1 transmittal (IN)"]
        pub type Uep1TxEnR = crate::BitReader;
        #[doc = "Field `UEP1_TX_EN` writer - enable USB endpoint 1 transmittal (IN)"]
        pub type Uep1TxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP1_RX_EN` reader - enable USB endpoint 1 receiving (OUT)"]
        pub type Uep1RxEnR = crate::BitReader;
        #[doc = "Field `UEP1_RX_EN` writer - enable USB endpoint 1 receiving (OUT)"]
        pub type Uep1RxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 2 - enable USB endpoint 4 transmittal (IN)"]
            #[inline(always)]
            pub fn uep4_tx_en(&self) -> Uep4TxEnR {
                Uep4TxEnR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - enable USB endpoint 4 receiving (OUT)"]
            #[inline(always)]
            pub fn uep4_rx_en(&self) -> Uep4RxEnR {
                Uep4RxEnR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - buffer mode of USB endpoint 1"]
            #[inline(always)]
            pub fn uep1_buf_mod(&self) -> Uep1BufModR {
                Uep1BufModR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - enable USB endpoint 1 transmittal (IN)"]
            #[inline(always)]
            pub fn uep1_tx_en(&self) -> Uep1TxEnR {
                Uep1TxEnR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - enable USB endpoint 1 receiving (OUT)"]
            #[inline(always)]
            pub fn uep1_rx_en(&self) -> Uep1RxEnR {
                Uep1RxEnR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 2 - enable USB endpoint 4 transmittal (IN)"]
            #[inline(always)]
            pub fn uep4_tx_en(&mut self) -> Uep4TxEnW<Uep4_1ModSpec> {
                Uep4TxEnW::new(self, 2)
            }
            #[doc = "Bit 3 - enable USB endpoint 4 receiving (OUT)"]
            #[inline(always)]
            pub fn uep4_rx_en(&mut self) -> Uep4RxEnW<Uep4_1ModSpec> {
                Uep4RxEnW::new(self, 3)
            }
            #[doc = "Bit 4 - buffer mode of USB endpoint 1"]
            #[inline(always)]
            pub fn uep1_buf_mod(&mut self) -> Uep1BufModW<Uep4_1ModSpec> {
                Uep1BufModW::new(self, 4)
            }
            #[doc = "Bit 6 - enable USB endpoint 1 transmittal (IN)"]
            #[inline(always)]
            pub fn uep1_tx_en(&mut self) -> Uep1TxEnW<Uep4_1ModSpec> {
                Uep1TxEnW::new(self, 6)
            }
            #[doc = "Bit 7 - enable USB endpoint 1 receiving (OUT)"]
            #[inline(always)]
            pub fn uep1_rx_en(&mut self) -> Uep1RxEnW<Uep4_1ModSpec> {
                Uep1RxEnW::new(self, 7)
            }
        }
        #[doc = "endpoint 4/1 mode\n\nYou can [`read`](crate::Reg::read) this register and get [`uep4_1_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep4_1_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep4_1ModSpec;
        impl crate::RegisterSpec for Uep4_1ModSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uep4_1_mod::R`](R) reader structure"]
        impl crate::Readable for Uep4_1ModSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep4_1_mod::W`](W) writer structure"]
        impl crate::Writable for Uep4_1ModSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP4_1_MOD to value 0"]
        impl crate::Resettable for Uep4_1ModSpec {}
    }
    #[doc = "UEP2_3_MOD (rw) register accessor: endpoint 2_3 mode\n\nYou can [`read`](crate::Reg::read) this register and get [`uep2_3_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep2_3_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep2_3_mod`] module"]
    #[doc(alias = "UEP2_3_MOD")]
    pub type Uep2_3Mod = crate::Reg<uep2_3_mod::Uep2_3ModSpec>;
    #[doc = "endpoint 2_3 mode"]
    pub mod uep2_3_mod {
        #[doc = "Register `UEP2_3_MOD` reader"]
        pub type R = crate::R<Uep2_3ModSpec>;
        #[doc = "Register `UEP2_3_MOD` writer"]
        pub type W = crate::W<Uep2_3ModSpec>;
        #[doc = "Field `UEP2_BUF_MOD` reader - buffer mode of USB endpoint 2"]
        pub type Uep2BufModR = crate::BitReader;
        #[doc = "Field `UEP2_BUF_MOD` writer - buffer mode of USB endpoint 2"]
        pub type Uep2BufModW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP2_TX_EN` reader - enable USB endpoint 2 transmittal (IN)"]
        pub type Uep2TxEnR = crate::BitReader;
        #[doc = "Field `UEP2_TX_EN` writer - enable USB endpoint 2 transmittal (IN)"]
        pub type Uep2TxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP2_RX_EN` reader - enable USB endpoint 2 receiving (OUT)"]
        pub type Uep2RxEnR = crate::BitReader;
        #[doc = "Field `UEP2_RX_EN` writer - enable USB endpoint 2 receiving (OUT)"]
        pub type Uep2RxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP3_BUF_MOD` reader - buffer mode of USB endpoint 3"]
        pub type Uep3BufModR = crate::BitReader;
        #[doc = "Field `UEP3_BUF_MOD` writer - buffer mode of USB endpoint 3"]
        pub type Uep3BufModW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP3_TX_EN` reader - enable USB endpoint 3 transmittal (IN)"]
        pub type Uep3TxEnR = crate::BitReader;
        #[doc = "Field `UEP3_TX_EN` writer - enable USB endpoint 3 transmittal (IN)"]
        pub type Uep3TxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP3_RX_EN` reader - enable USB endpoint 3 receiving (OUT)"]
        pub type Uep3RxEnR = crate::BitReader;
        #[doc = "Field `UEP3_RX_EN` writer - enable USB endpoint 3 receiving (OUT)"]
        pub type Uep3RxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - buffer mode of USB endpoint 2"]
            #[inline(always)]
            pub fn uep2_buf_mod(&self) -> Uep2BufModR {
                Uep2BufModR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 2 - enable USB endpoint 2 transmittal (IN)"]
            #[inline(always)]
            pub fn uep2_tx_en(&self) -> Uep2TxEnR {
                Uep2TxEnR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - enable USB endpoint 2 receiving (OUT)"]
            #[inline(always)]
            pub fn uep2_rx_en(&self) -> Uep2RxEnR {
                Uep2RxEnR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - buffer mode of USB endpoint 3"]
            #[inline(always)]
            pub fn uep3_buf_mod(&self) -> Uep3BufModR {
                Uep3BufModR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - enable USB endpoint 3 transmittal (IN)"]
            #[inline(always)]
            pub fn uep3_tx_en(&self) -> Uep3TxEnR {
                Uep3TxEnR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - enable USB endpoint 3 receiving (OUT)"]
            #[inline(always)]
            pub fn uep3_rx_en(&self) -> Uep3RxEnR {
                Uep3RxEnR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - buffer mode of USB endpoint 2"]
            #[inline(always)]
            pub fn uep2_buf_mod(&mut self) -> Uep2BufModW<Uep2_3ModSpec> {
                Uep2BufModW::new(self, 0)
            }
            #[doc = "Bit 2 - enable USB endpoint 2 transmittal (IN)"]
            #[inline(always)]
            pub fn uep2_tx_en(&mut self) -> Uep2TxEnW<Uep2_3ModSpec> {
                Uep2TxEnW::new(self, 2)
            }
            #[doc = "Bit 3 - enable USB endpoint 2 receiving (OUT)"]
            #[inline(always)]
            pub fn uep2_rx_en(&mut self) -> Uep2RxEnW<Uep2_3ModSpec> {
                Uep2RxEnW::new(self, 3)
            }
            #[doc = "Bit 4 - buffer mode of USB endpoint 3"]
            #[inline(always)]
            pub fn uep3_buf_mod(&mut self) -> Uep3BufModW<Uep2_3ModSpec> {
                Uep3BufModW::new(self, 4)
            }
            #[doc = "Bit 6 - enable USB endpoint 3 transmittal (IN)"]
            #[inline(always)]
            pub fn uep3_tx_en(&mut self) -> Uep3TxEnW<Uep2_3ModSpec> {
                Uep3TxEnW::new(self, 6)
            }
            #[doc = "Bit 7 - enable USB endpoint 3 receiving (OUT)"]
            #[inline(always)]
            pub fn uep3_rx_en(&mut self) -> Uep3RxEnW<Uep2_3ModSpec> {
                Uep3RxEnW::new(self, 7)
            }
        }
        #[doc = "endpoint 2_3 mode\n\nYou can [`read`](crate::Reg::read) this register and get [`uep2_3_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep2_3_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep2_3ModSpec;
        impl crate::RegisterSpec for Uep2_3ModSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uep2_3_mod::R`](R) reader structure"]
        impl crate::Readable for Uep2_3ModSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep2_3_mod::W`](W) writer structure"]
        impl crate::Writable for Uep2_3ModSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP2_3_MOD to value 0"]
        impl crate::Resettable for Uep2_3ModSpec {}
    }
    #[doc = "UH_EP_MOD (rw) register accessor: host endpoint mode\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_ep_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_ep_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uh_ep_mod`] module"]
    #[doc(alias = "UH_EP_MOD")]
    pub type UhEpMod = crate::Reg<uh_ep_mod::UhEpModSpec>;
    #[doc = "host endpoint mode"]
    pub mod uh_ep_mod {
        #[doc = "Register `UH_EP_MOD` reader"]
        pub type R = crate::R<UhEpModSpec>;
        #[doc = "Register `UH_EP_MOD` writer"]
        pub type W = crate::W<UhEpModSpec>;
        #[doc = "Field `UH_EP_RBUF_MOD` reader - buffer mode of USB host IN endpoint"]
        pub type UhEpRbufModR = crate::BitReader;
        #[doc = "Field `UH_EP_RBUF_MOD` writer - buffer mode of USB host IN endpoint"]
        pub type UhEpRbufModW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UH_EP_RX_EN` reader - enable USB host IN endpoint receiving"]
        pub type UhEpRxEnR = crate::BitReader;
        #[doc = "Field `UH_EP_RX_EN` writer - enable USB host IN endpoint receiving"]
        pub type UhEpRxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UH_EP_TBUF_MOD` reader - buffer mode of USB host OUT endpoint"]
        pub type UhEpTbufModR = crate::BitReader;
        #[doc = "Field `UH_EP_TBUF_MOD` writer - buffer mode of USB host OUT endpoint"]
        pub type UhEpTbufModW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UH_EP_TX_EN` reader - enable USB host OUT endpoint transmittal"]
        pub type UhEpTxEnR = crate::BitReader;
        #[doc = "Field `UH_EP_TX_EN` writer - enable USB host OUT endpoint transmittal"]
        pub type UhEpTxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - buffer mode of USB host IN endpoint"]
            #[inline(always)]
            pub fn uh_ep_rbuf_mod(&self) -> UhEpRbufModR {
                UhEpRbufModR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 3 - enable USB host IN endpoint receiving"]
            #[inline(always)]
            pub fn uh_ep_rx_en(&self) -> UhEpRxEnR {
                UhEpRxEnR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - buffer mode of USB host OUT endpoint"]
            #[inline(always)]
            pub fn uh_ep_tbuf_mod(&self) -> UhEpTbufModR {
                UhEpTbufModR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - enable USB host OUT endpoint transmittal"]
            #[inline(always)]
            pub fn uh_ep_tx_en(&self) -> UhEpTxEnR {
                UhEpTxEnR::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - buffer mode of USB host IN endpoint"]
            #[inline(always)]
            pub fn uh_ep_rbuf_mod(&mut self) -> UhEpRbufModW<UhEpModSpec> {
                UhEpRbufModW::new(self, 0)
            }
            #[doc = "Bit 3 - enable USB host IN endpoint receiving"]
            #[inline(always)]
            pub fn uh_ep_rx_en(&mut self) -> UhEpRxEnW<UhEpModSpec> {
                UhEpRxEnW::new(self, 3)
            }
            #[doc = "Bit 4 - buffer mode of USB host OUT endpoint"]
            #[inline(always)]
            pub fn uh_ep_tbuf_mod(&mut self) -> UhEpTbufModW<UhEpModSpec> {
                UhEpTbufModW::new(self, 4)
            }
            #[doc = "Bit 6 - enable USB host OUT endpoint transmittal"]
            #[inline(always)]
            pub fn uh_ep_tx_en(&mut self) -> UhEpTxEnW<UhEpModSpec> {
                UhEpTxEnW::new(self, 6)
            }
        }
        #[doc = "host endpoint mode\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_ep_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_ep_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct UhEpModSpec;
        impl crate::RegisterSpec for UhEpModSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uh_ep_mod::R`](R) reader structure"]
        impl crate::Readable for UhEpModSpec {}
        #[doc = "`write(|w| ..)` method takes [`uh_ep_mod::W`](W) writer structure"]
        impl crate::Writable for UhEpModSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UH_EP_MOD to value 0"]
        impl crate::Resettable for UhEpModSpec {}
    }
    #[doc = "UEP567_MOD (rw) register accessor: endpoint 5/6/7 mode\n\nYou can [`read`](crate::Reg::read) this register and get [`uep567_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep567_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep567_mod`] module"]
    #[doc(alias = "UEP567_MOD")]
    pub type Uep567Mod = crate::Reg<uep567_mod::Uep567ModSpec>;
    #[doc = "endpoint 5/6/7 mode"]
    pub mod uep567_mod {
        #[doc = "Register `UEP567_MOD` reader"]
        pub type R = crate::R<Uep567ModSpec>;
        #[doc = "Register `UEP567_MOD` writer"]
        pub type W = crate::W<Uep567ModSpec>;
        #[doc = "Field `UEP5_TX_EN` reader - enable USB endpoint 5 transmittal (IN)"]
        pub type Uep5TxEnR = crate::BitReader;
        #[doc = "Field `UEP5_TX_EN` writer - enable USB endpoint 5 transmittal (IN)"]
        pub type Uep5TxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP5_RX_EN` reader - enable USB endpoint 5 receiving (OUT)"]
        pub type Uep5RxEnR = crate::BitReader;
        #[doc = "Field `UEP5_RX_EN` writer - enable USB endpoint 5 receiving (OUT)"]
        pub type Uep5RxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP6_TX_EN` reader - enable USB endpoint 6 transmittal (IN)"]
        pub type Uep6TxEnR = crate::BitReader;
        #[doc = "Field `UEP6_TX_EN` writer - enable USB endpoint 6 transmittal (IN)"]
        pub type Uep6TxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP6_RX_EN` reader - enable USB endpoint 6 receiving (OUT)"]
        pub type Uep6RxEnR = crate::BitReader;
        #[doc = "Field `UEP6_RX_EN` writer - enable USB endpoint 6 receiving (OUT)"]
        pub type Uep6RxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP7_TX_EN` reader - enable USB endpoint 7 transmittal (IN)"]
        pub type Uep7TxEnR = crate::BitReader;
        #[doc = "Field `UEP7_TX_EN` writer - enable USB endpoint 7 transmittal (IN)"]
        pub type Uep7TxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP7_RX_EN` reader - enable USB endpoint 7 receiving (OUT)"]
        pub type Uep7RxEnR = crate::BitReader;
        #[doc = "Field `UEP7_RX_EN` writer - enable USB endpoint 7 receiving (OUT)"]
        pub type Uep7RxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - enable USB endpoint 5 transmittal (IN)"]
            #[inline(always)]
            pub fn uep5_tx_en(&self) -> Uep5TxEnR {
                Uep5TxEnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - enable USB endpoint 5 receiving (OUT)"]
            #[inline(always)]
            pub fn uep5_rx_en(&self) -> Uep5RxEnR {
                Uep5RxEnR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - enable USB endpoint 6 transmittal (IN)"]
            #[inline(always)]
            pub fn uep6_tx_en(&self) -> Uep6TxEnR {
                Uep6TxEnR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - enable USB endpoint 6 receiving (OUT)"]
            #[inline(always)]
            pub fn uep6_rx_en(&self) -> Uep6RxEnR {
                Uep6RxEnR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - enable USB endpoint 7 transmittal (IN)"]
            #[inline(always)]
            pub fn uep7_tx_en(&self) -> Uep7TxEnR {
                Uep7TxEnR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - enable USB endpoint 7 receiving (OUT)"]
            #[inline(always)]
            pub fn uep7_rx_en(&self) -> Uep7RxEnR {
                Uep7RxEnR::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - enable USB endpoint 5 transmittal (IN)"]
            #[inline(always)]
            pub fn uep5_tx_en(&mut self) -> Uep5TxEnW<Uep567ModSpec> {
                Uep5TxEnW::new(self, 0)
            }
            #[doc = "Bit 1 - enable USB endpoint 5 receiving (OUT)"]
            #[inline(always)]
            pub fn uep5_rx_en(&mut self) -> Uep5RxEnW<Uep567ModSpec> {
                Uep5RxEnW::new(self, 1)
            }
            #[doc = "Bit 2 - enable USB endpoint 6 transmittal (IN)"]
            #[inline(always)]
            pub fn uep6_tx_en(&mut self) -> Uep6TxEnW<Uep567ModSpec> {
                Uep6TxEnW::new(self, 2)
            }
            #[doc = "Bit 3 - enable USB endpoint 6 receiving (OUT)"]
            #[inline(always)]
            pub fn uep6_rx_en(&mut self) -> Uep6RxEnW<Uep567ModSpec> {
                Uep6RxEnW::new(self, 3)
            }
            #[doc = "Bit 4 - enable USB endpoint 7 transmittal (IN)"]
            #[inline(always)]
            pub fn uep7_tx_en(&mut self) -> Uep7TxEnW<Uep567ModSpec> {
                Uep7TxEnW::new(self, 4)
            }
            #[doc = "Bit 5 - enable USB endpoint 7 receiving (OUT)"]
            #[inline(always)]
            pub fn uep7_rx_en(&mut self) -> Uep7RxEnW<Uep567ModSpec> {
                Uep7RxEnW::new(self, 5)
            }
        }
        #[doc = "endpoint 5/6/7 mode\n\nYou can [`read`](crate::Reg::read) this register and get [`uep567_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep567_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep567ModSpec;
        impl crate::RegisterSpec for Uep567ModSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uep567_mod::R`](R) reader structure"]
        impl crate::Readable for Uep567ModSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep567_mod::W`](W) writer structure"]
        impl crate::Writable for Uep567ModSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP567_MOD to value 0"]
        impl crate::Resettable for Uep567ModSpec {}
    }
    #[doc = "UEP0_DMA (rw) register accessor: endpoint 0 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep0_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep0_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep0_dma`] module"]
    #[doc(alias = "UEP0_DMA")]
    pub type Uep0Dma = crate::Reg<uep0_dma::Uep0DmaSpec>;
    #[doc = "endpoint 0 DMA buffer address"]
    pub mod uep0_dma {
        #[doc = "Register `UEP0_DMA` reader"]
        pub type R = crate::R<Uep0DmaSpec>;
        #[doc = "Register `UEP0_DMA` writer"]
        pub type W = crate::W<Uep0DmaSpec>;
        #[doc = "Field `UEP0_DMA` reader - RW,endpoint 0 DMA buffer address"]
        pub type Uep0DmaR = crate::FieldReader<u16>;
        #[doc = "Field `UEP0_DMA` writer - RW,endpoint 0 DMA buffer address"]
        pub type Uep0DmaW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW,endpoint 0 DMA buffer address"]
            #[inline(always)]
            pub fn uep0_dma(&self) -> Uep0DmaR {
                Uep0DmaR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW,endpoint 0 DMA buffer address"]
            #[inline(always)]
            pub fn uep0_dma(&mut self) -> Uep0DmaW<Uep0DmaSpec> {
                Uep0DmaW::new(self, 0)
            }
        }
        #[doc = "endpoint 0 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep0_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep0_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep0DmaSpec;
        impl crate::RegisterSpec for Uep0DmaSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`uep0_dma::R`](R) reader structure"]
        impl crate::Readable for Uep0DmaSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep0_dma::W`](W) writer structure"]
        impl crate::Writable for Uep0DmaSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP0_DMA to value 0"]
        impl crate::Resettable for Uep0DmaSpec {}
    }
    #[doc = "UEP1_DMA (rw) register accessor: endpoint 1 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep1_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep1_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep1_dma`] module"]
    #[doc(alias = "UEP1_DMA")]
    pub type Uep1Dma = crate::Reg<uep1_dma::Uep1DmaSpec>;
    #[doc = "endpoint 1 DMA buffer address"]
    pub mod uep1_dma {
        #[doc = "Register `UEP1_DMA` reader"]
        pub type R = crate::R<Uep1DmaSpec>;
        #[doc = "Register `UEP1_DMA` writer"]
        pub type W = crate::W<Uep1DmaSpec>;
        #[doc = "Field `UEP1_DMA` reader - RW,endpoint 1 DMA buffer address"]
        pub type Uep1DmaR = crate::FieldReader<u16>;
        #[doc = "Field `UEP1_DMA` writer - RW,endpoint 1 DMA buffer address"]
        pub type Uep1DmaW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW,endpoint 1 DMA buffer address"]
            #[inline(always)]
            pub fn uep1_dma(&self) -> Uep1DmaR {
                Uep1DmaR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW,endpoint 1 DMA buffer address"]
            #[inline(always)]
            pub fn uep1_dma(&mut self) -> Uep1DmaW<Uep1DmaSpec> {
                Uep1DmaW::new(self, 0)
            }
        }
        #[doc = "endpoint 1 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep1_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep1_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep1DmaSpec;
        impl crate::RegisterSpec for Uep1DmaSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`uep1_dma::R`](R) reader structure"]
        impl crate::Readable for Uep1DmaSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep1_dma::W`](W) writer structure"]
        impl crate::Writable for Uep1DmaSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP1_DMA to value 0"]
        impl crate::Resettable for Uep1DmaSpec {}
    }
    #[doc = "UEP2_DMA (rw) register accessor: endpoint 2 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep2_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep2_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep2_dma`] module"]
    #[doc(alias = "UEP2_DMA")]
    pub type Uep2Dma = crate::Reg<uep2_dma::Uep2DmaSpec>;
    #[doc = "endpoint 2 DMA buffer address"]
    pub mod uep2_dma {
        #[doc = "Register `UEP2_DMA` reader"]
        pub type R = crate::R<Uep2DmaSpec>;
        #[doc = "Register `UEP2_DMA` writer"]
        pub type W = crate::W<Uep2DmaSpec>;
        #[doc = "Field `UEP2_DMA` reader - RW,endpoint 2 DMA buffer address"]
        pub type Uep2DmaR = crate::FieldReader<u16>;
        #[doc = "Field `UEP2_DMA` writer - RW,endpoint 2 DMA buffer address"]
        pub type Uep2DmaW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW,endpoint 2 DMA buffer address"]
            #[inline(always)]
            pub fn uep2_dma(&self) -> Uep2DmaR {
                Uep2DmaR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW,endpoint 2 DMA buffer address"]
            #[inline(always)]
            pub fn uep2_dma(&mut self) -> Uep2DmaW<Uep2DmaSpec> {
                Uep2DmaW::new(self, 0)
            }
        }
        #[doc = "endpoint 2 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep2_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep2_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep2DmaSpec;
        impl crate::RegisterSpec for Uep2DmaSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`uep2_dma::R`](R) reader structure"]
        impl crate::Readable for Uep2DmaSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep2_dma::W`](W) writer structure"]
        impl crate::Writable for Uep2DmaSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP2_DMA to value 0"]
        impl crate::Resettable for Uep2DmaSpec {}
    }
    #[doc = "UH_RX_DMA (rw) register accessor: host rx endpoint buffer high address\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_rx_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_rx_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uh_rx_dma`] module"]
    #[doc(alias = "UH_RX_DMA")]
    pub type UhRxDma = crate::Reg<uh_rx_dma::UhRxDmaSpec>;
    #[doc = "host rx endpoint buffer high address"]
    pub mod uh_rx_dma {
        #[doc = "Register `UH_RX_DMA` reader"]
        pub type R = crate::R<UhRxDmaSpec>;
        #[doc = "Register `UH_RX_DMA` writer"]
        pub type W = crate::W<UhRxDmaSpec>;
        #[doc = "Field `UEP2_DMA` reader - RW,host rx endpoint buffer high address"]
        pub type Uep2DmaR = crate::FieldReader<u16>;
        #[doc = "Field `UEP2_DMA` writer - RW,host rx endpoint buffer high address"]
        pub type Uep2DmaW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW,host rx endpoint buffer high address"]
            #[inline(always)]
            pub fn uep2_dma(&self) -> Uep2DmaR {
                Uep2DmaR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW,host rx endpoint buffer high address"]
            #[inline(always)]
            pub fn uep2_dma(&mut self) -> Uep2DmaW<UhRxDmaSpec> {
                Uep2DmaW::new(self, 0)
            }
        }
        #[doc = "host rx endpoint buffer high address\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_rx_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_rx_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct UhRxDmaSpec;
        impl crate::RegisterSpec for UhRxDmaSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`uh_rx_dma::R`](R) reader structure"]
        impl crate::Readable for UhRxDmaSpec {}
        #[doc = "`write(|w| ..)` method takes [`uh_rx_dma::W`](W) writer structure"]
        impl crate::Writable for UhRxDmaSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UH_RX_DMA to value 0"]
        impl crate::Resettable for UhRxDmaSpec {}
    }
    #[doc = "UEP3_DMA (rw) register accessor: endpoint 3 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep3_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep3_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep3_dma`] module"]
    #[doc(alias = "UEP3_DMA")]
    pub type Uep3Dma = crate::Reg<uep3_dma::Uep3DmaSpec>;
    #[doc = "endpoint 3 DMA buffer address"]
    pub mod uep3_dma {
        #[doc = "Register `UEP3_DMA` reader"]
        pub type R = crate::R<Uep3DmaSpec>;
        #[doc = "Register `UEP3_DMA` writer"]
        pub type W = crate::W<Uep3DmaSpec>;
        #[doc = "Field `UEP3_DMA` reader - RW,endpoint 3 DMA buffer address"]
        pub type Uep3DmaR = crate::FieldReader<u16>;
        #[doc = "Field `UEP3_DMA` writer - RW,endpoint 3 DMA buffer address"]
        pub type Uep3DmaW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW,endpoint 3 DMA buffer address"]
            #[inline(always)]
            pub fn uep3_dma(&self) -> Uep3DmaR {
                Uep3DmaR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW,endpoint 3 DMA buffer address"]
            #[inline(always)]
            pub fn uep3_dma(&mut self) -> Uep3DmaW<Uep3DmaSpec> {
                Uep3DmaW::new(self, 0)
            }
        }
        #[doc = "endpoint 3 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep3_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep3_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep3DmaSpec;
        impl crate::RegisterSpec for Uep3DmaSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`uep3_dma::R`](R) reader structure"]
        impl crate::Readable for Uep3DmaSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep3_dma::W`](W) writer structure"]
        impl crate::Writable for Uep3DmaSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP3_DMA to value 0"]
        impl crate::Resettable for Uep3DmaSpec {}
    }
    #[doc = "UH_TX_DMA (rw) register accessor: host tx endpoint buffer high address\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_tx_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_tx_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uh_tx_dma`] module"]
    #[doc(alias = "UH_TX_DMA")]
    pub type UhTxDma = crate::Reg<uh_tx_dma::UhTxDmaSpec>;
    #[doc = "host tx endpoint buffer high address"]
    pub mod uh_tx_dma {
        #[doc = "Register `UH_TX_DMA` reader"]
        pub type R = crate::R<UhTxDmaSpec>;
        #[doc = "Register `UH_TX_DMA` writer"]
        pub type W = crate::W<UhTxDmaSpec>;
        #[doc = "Field `UEP3_DMA` reader - RW,host tx endpoint buffer high address"]
        pub type Uep3DmaR = crate::FieldReader<u16>;
        #[doc = "Field `UEP3_DMA` writer - RW,host tx endpoint buffer high address"]
        pub type Uep3DmaW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW,host tx endpoint buffer high address"]
            #[inline(always)]
            pub fn uep3_dma(&self) -> Uep3DmaR {
                Uep3DmaR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW,host tx endpoint buffer high address"]
            #[inline(always)]
            pub fn uep3_dma(&mut self) -> Uep3DmaW<UhTxDmaSpec> {
                Uep3DmaW::new(self, 0)
            }
        }
        #[doc = "host tx endpoint buffer high address\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_tx_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_tx_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct UhTxDmaSpec;
        impl crate::RegisterSpec for UhTxDmaSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`uh_tx_dma::R`](R) reader structure"]
        impl crate::Readable for UhTxDmaSpec {}
        #[doc = "`write(|w| ..)` method takes [`uh_tx_dma::W`](W) writer structure"]
        impl crate::Writable for UhTxDmaSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UH_TX_DMA to value 0"]
        impl crate::Resettable for UhTxDmaSpec {}
    }
    #[doc = "UEP5_DMA (rw) register accessor: endpoint 5 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep5_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep5_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep5_dma`] module"]
    #[doc(alias = "UEP5_DMA")]
    pub type Uep5Dma = crate::Reg<uep5_dma::Uep5DmaSpec>;
    #[doc = "endpoint 5 DMA buffer address"]
    pub mod uep5_dma {
        #[doc = "Register `UEP5_DMA` reader"]
        pub type R = crate::R<Uep5DmaSpec>;
        #[doc = "Register `UEP5_DMA` writer"]
        pub type W = crate::W<Uep5DmaSpec>;
        #[doc = "Field `UEP5_DMA` reader - RW,endpoint 5 DMA buffer address"]
        pub type Uep5DmaR = crate::FieldReader<u16>;
        #[doc = "Field `UEP5_DMA` writer - RW,endpoint 5 DMA buffer address"]
        pub type Uep5DmaW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW,endpoint 5 DMA buffer address"]
            #[inline(always)]
            pub fn uep5_dma(&self) -> Uep5DmaR {
                Uep5DmaR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW,endpoint 5 DMA buffer address"]
            #[inline(always)]
            pub fn uep5_dma(&mut self) -> Uep5DmaW<Uep5DmaSpec> {
                Uep5DmaW::new(self, 0)
            }
        }
        #[doc = "endpoint 5 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep5_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep5_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep5DmaSpec;
        impl crate::RegisterSpec for Uep5DmaSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`uep5_dma::R`](R) reader structure"]
        impl crate::Readable for Uep5DmaSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep5_dma::W`](W) writer structure"]
        impl crate::Writable for Uep5DmaSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP5_DMA to value 0"]
        impl crate::Resettable for Uep5DmaSpec {}
    }
    #[doc = "UEP6_DMA (rw) register accessor: endpoint 6 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep6_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep6_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep6_dma`] module"]
    #[doc(alias = "UEP6_DMA")]
    pub type Uep6Dma = crate::Reg<uep6_dma::Uep6DmaSpec>;
    #[doc = "endpoint 6 DMA buffer address"]
    pub mod uep6_dma {
        #[doc = "Register `UEP6_DMA` reader"]
        pub type R = crate::R<Uep6DmaSpec>;
        #[doc = "Register `UEP6_DMA` writer"]
        pub type W = crate::W<Uep6DmaSpec>;
        #[doc = "Field `UEP6_DMA` reader - RW,endpoint 6 DMA buffer address"]
        pub type Uep6DmaR = crate::FieldReader<u16>;
        #[doc = "Field `UEP6_DMA` writer - RW,endpoint 6 DMA buffer address"]
        pub type Uep6DmaW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW,endpoint 6 DMA buffer address"]
            #[inline(always)]
            pub fn uep6_dma(&self) -> Uep6DmaR {
                Uep6DmaR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW,endpoint 6 DMA buffer address"]
            #[inline(always)]
            pub fn uep6_dma(&mut self) -> Uep6DmaW<Uep6DmaSpec> {
                Uep6DmaW::new(self, 0)
            }
        }
        #[doc = "endpoint 6 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep6_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep6_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep6DmaSpec;
        impl crate::RegisterSpec for Uep6DmaSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`uep6_dma::R`](R) reader structure"]
        impl crate::Readable for Uep6DmaSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep6_dma::W`](W) writer structure"]
        impl crate::Writable for Uep6DmaSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP6_DMA to value 0"]
        impl crate::Resettable for Uep6DmaSpec {}
    }
    #[doc = "UEP7_DMA (rw) register accessor: endpoint 7 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep7_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep7_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep7_dma`] module"]
    #[doc(alias = "UEP7_DMA")]
    pub type Uep7Dma = crate::Reg<uep7_dma::Uep7DmaSpec>;
    #[doc = "endpoint 7 DMA buffer address"]
    pub mod uep7_dma {
        #[doc = "Register `UEP7_DMA` reader"]
        pub type R = crate::R<Uep7DmaSpec>;
        #[doc = "Register `UEP7_DMA` writer"]
        pub type W = crate::W<Uep7DmaSpec>;
        #[doc = "Field `UEP7_DMA` reader - RW,endpoint 7 DMA buffer address"]
        pub type Uep7DmaR = crate::FieldReader<u16>;
        #[doc = "Field `UEP7_DMA` writer - RW,endpoint 7 DMA buffer address"]
        pub type Uep7DmaW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW,endpoint 7 DMA buffer address"]
            #[inline(always)]
            pub fn uep7_dma(&self) -> Uep7DmaR {
                Uep7DmaR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW,endpoint 7 DMA buffer address"]
            #[inline(always)]
            pub fn uep7_dma(&mut self) -> Uep7DmaW<Uep7DmaSpec> {
                Uep7DmaW::new(self, 0)
            }
        }
        #[doc = "endpoint 7 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep7_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep7_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep7DmaSpec;
        impl crate::RegisterSpec for Uep7DmaSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`uep7_dma::R`](R) reader structure"]
        impl crate::Readable for Uep7DmaSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep7_dma::W`](W) writer structure"]
        impl crate::Writable for Uep7DmaSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP7_DMA to value 0"]
        impl crate::Resettable for Uep7DmaSpec {}
    }
    #[doc = "UEP0_T_LEN (rw) register accessor: endpoint 0 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep0_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep0_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep0_t_len`] module"]
    #[doc(alias = "UEP0_T_LEN")]
    pub type Uep0TLen = crate::Reg<uep0_t_len::Uep0TLenSpec>;
    #[doc = "endpoint 0 transmittal length"]
    pub mod uep0_t_len {
        #[doc = "Register `UEP0_T_LEN` reader"]
        pub type R = crate::R<Uep0TLenSpec>;
        #[doc = "Register `UEP0_T_LEN` writer"]
        pub type W = crate::W<Uep0TLenSpec>;
        #[doc = "Field `UEP0_T_LEN` reader - endpoint 0 transmittal length"]
        pub type Uep0TLenR = crate::FieldReader;
        #[doc = "Field `UEP0_T_LEN` writer - endpoint 0 transmittal length"]
        pub type Uep0TLenW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - endpoint 0 transmittal length"]
            #[inline(always)]
            pub fn uep0_t_len(&self) -> Uep0TLenR {
                Uep0TLenR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - endpoint 0 transmittal length"]
            #[inline(always)]
            pub fn uep0_t_len(&mut self) -> Uep0TLenW<Uep0TLenSpec> {
                Uep0TLenW::new(self, 0)
            }
        }
        #[doc = "endpoint 0 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep0_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep0_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep0TLenSpec;
        impl crate::RegisterSpec for Uep0TLenSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uep0_t_len::R`](R) reader structure"]
        impl crate::Readable for Uep0TLenSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep0_t_len::W`](W) writer structure"]
        impl crate::Writable for Uep0TLenSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP0_T_LEN to value 0"]
        impl crate::Resettable for Uep0TLenSpec {}
    }
    #[doc = "UEP0_CTRL (rw) register accessor: endpoint 0 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep0_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep0_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep0_ctrl`] module"]
    #[doc(alias = "UEP0_CTRL")]
    pub type Uep0Ctrl = crate::Reg<uep0_ctrl::Uep0CtrlSpec>;
    #[doc = "endpoint 0 control"]
    pub mod uep0_ctrl {
        #[doc = "Register `UEP0_CTRL` reader"]
        pub type R = crate::R<Uep0CtrlSpec>;
        #[doc = "Register `UEP0_CTRL` writer"]
        pub type W = crate::W<Uep0CtrlSpec>;
        #[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResR = crate::FieldReader;
        #[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResR = crate::FieldReader;
        #[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogR = crate::BitReader;
        #[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogR = crate::BitReader;
        #[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogR = crate::BitReader;
        #[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&self) -> UepTResR {
                UepTResR::new(self.bits & 3)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&self) -> UepRResR {
                UepRResR::new((self.bits >> 2) & 3)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UepAutoTogR {
                UepAutoTogR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UepTTogR {
                UepTTogR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UepRTogR {
                UepRTogR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&mut self) -> UepTResW<Uep0CtrlSpec> {
                UepTResW::new(self, 0)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&mut self) -> UepRResW<Uep0CtrlSpec> {
                UepRResW::new(self, 2)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&mut self) -> UepAutoTogW<Uep0CtrlSpec> {
                UepAutoTogW::new(self, 4)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&mut self) -> UepTTogW<Uep0CtrlSpec> {
                UepTTogW::new(self, 6)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&mut self) -> UepRTogW<Uep0CtrlSpec> {
                UepRTogW::new(self, 7)
            }
        }
        #[doc = "endpoint 0 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep0_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep0_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep0CtrlSpec;
        impl crate::RegisterSpec for Uep0CtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uep0_ctrl::R`](R) reader structure"]
        impl crate::Readable for Uep0CtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep0_ctrl::W`](W) writer structure"]
        impl crate::Writable for Uep0CtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP0_CTRL to value 0"]
        impl crate::Resettable for Uep0CtrlSpec {}
    }
    #[doc = "UEP1_T_LEN (rw) register accessor: endpoint 1 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep1_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep1_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep1_t_len`] module"]
    #[doc(alias = "UEP1_T_LEN")]
    pub type Uep1TLen = crate::Reg<uep1_t_len::Uep1TLenSpec>;
    #[doc = "endpoint 1 transmittal length"]
    pub mod uep1_t_len {
        #[doc = "Register `UEP1_T_LEN` reader"]
        pub type R = crate::R<Uep1TLenSpec>;
        #[doc = "Register `UEP1_T_LEN` writer"]
        pub type W = crate::W<Uep1TLenSpec>;
        #[doc = "Field `UEP1_T_LEN` reader - endpoint 1 transmittal length"]
        pub type Uep1TLenR = crate::FieldReader;
        #[doc = "Field `UEP1_T_LEN` writer - endpoint 1 transmittal length"]
        pub type Uep1TLenW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - endpoint 1 transmittal length"]
            #[inline(always)]
            pub fn uep1_t_len(&self) -> Uep1TLenR {
                Uep1TLenR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - endpoint 1 transmittal length"]
            #[inline(always)]
            pub fn uep1_t_len(&mut self) -> Uep1TLenW<Uep1TLenSpec> {
                Uep1TLenW::new(self, 0)
            }
        }
        #[doc = "endpoint 1 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep1_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep1_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep1TLenSpec;
        impl crate::RegisterSpec for Uep1TLenSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uep1_t_len::R`](R) reader structure"]
        impl crate::Readable for Uep1TLenSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep1_t_len::W`](W) writer structure"]
        impl crate::Writable for Uep1TLenSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP1_T_LEN to value 0"]
        impl crate::Resettable for Uep1TLenSpec {}
    }
    #[doc = "UEP1_CTRL (rw) register accessor: endpoint 1 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep1_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep1_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep1_ctrl`] module"]
    #[doc(alias = "UEP1_CTRL")]
    pub type Uep1Ctrl = crate::Reg<uep1_ctrl::Uep1CtrlSpec>;
    #[doc = "endpoint 1 control"]
    pub mod uep1_ctrl {
        #[doc = "Register `UEP1_CTRL` reader"]
        pub type R = crate::R<Uep1CtrlSpec>;
        #[doc = "Register `UEP1_CTRL` writer"]
        pub type W = crate::W<Uep1CtrlSpec>;
        #[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResR = crate::FieldReader;
        #[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResR = crate::FieldReader;
        #[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogR = crate::BitReader;
        #[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogR = crate::BitReader;
        #[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogR = crate::BitReader;
        #[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&self) -> UepTResR {
                UepTResR::new(self.bits & 3)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&self) -> UepRResR {
                UepRResR::new((self.bits >> 2) & 3)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UepAutoTogR {
                UepAutoTogR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UepTTogR {
                UepTTogR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UepRTogR {
                UepRTogR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&mut self) -> UepTResW<Uep1CtrlSpec> {
                UepTResW::new(self, 0)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&mut self) -> UepRResW<Uep1CtrlSpec> {
                UepRResW::new(self, 2)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&mut self) -> UepAutoTogW<Uep1CtrlSpec> {
                UepAutoTogW::new(self, 4)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&mut self) -> UepTTogW<Uep1CtrlSpec> {
                UepTTogW::new(self, 6)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&mut self) -> UepRTogW<Uep1CtrlSpec> {
                UepRTogW::new(self, 7)
            }
        }
        #[doc = "endpoint 1 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep1_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep1_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep1CtrlSpec;
        impl crate::RegisterSpec for Uep1CtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uep1_ctrl::R`](R) reader structure"]
        impl crate::Readable for Uep1CtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep1_ctrl::W`](W) writer structure"]
        impl crate::Writable for Uep1CtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP1_CTRL to value 0"]
        impl crate::Resettable for Uep1CtrlSpec {}
    }
    #[doc = "UH_SETUP (rw) register accessor: host aux setup\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_setup::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_setup::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uh_setup`] module"]
    #[doc(alias = "UH_SETUP")]
    pub type UhSetup = crate::Reg<uh_setup::UhSetupSpec>;
    #[doc = "host aux setup"]
    pub mod uh_setup {
        #[doc = "Register `UH_SETUP` reader"]
        pub type R = crate::R<UhSetupSpec>;
        #[doc = "Register `UH_SETUP` writer"]
        pub type W = crate::W<UhSetupSpec>;
        #[doc = "Field `UH_SOF_EN` reader - USB host automatic SOF enable"]
        pub type UhSofEnR = crate::BitReader;
        #[doc = "Field `UH_SOF_EN` writer - USB host automatic SOF enable"]
        pub type UhSofEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UH_PRE_PID_EN` reader - USB host PRE PID enable for low speed device via hub"]
        pub type UhPrePidEnR = crate::BitReader;
        #[doc = "Field `UH_PRE_PID_EN` writer - USB host PRE PID enable for low speed device via hub"]
        pub type UhPrePidEnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 6 - USB host automatic SOF enable"]
            #[inline(always)]
            pub fn uh_sof_en(&self) -> UhSofEnR {
                UhSofEnR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - USB host PRE PID enable for low speed device via hub"]
            #[inline(always)]
            pub fn uh_pre_pid_en(&self) -> UhPrePidEnR {
                UhPrePidEnR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 6 - USB host automatic SOF enable"]
            #[inline(always)]
            pub fn uh_sof_en(&mut self) -> UhSofEnW<UhSetupSpec> {
                UhSofEnW::new(self, 6)
            }
            #[doc = "Bit 7 - USB host PRE PID enable for low speed device via hub"]
            #[inline(always)]
            pub fn uh_pre_pid_en(&mut self) -> UhPrePidEnW<UhSetupSpec> {
                UhPrePidEnW::new(self, 7)
            }
        }
        #[doc = "host aux setup\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_setup::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_setup::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct UhSetupSpec;
        impl crate::RegisterSpec for UhSetupSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uh_setup::R`](R) reader structure"]
        impl crate::Readable for UhSetupSpec {}
        #[doc = "`write(|w| ..)` method takes [`uh_setup::W`](W) writer structure"]
        impl crate::Writable for UhSetupSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UH_SETUP to value 0"]
        impl crate::Resettable for UhSetupSpec {}
    }
    #[doc = "UEP2_T_LEN (rw) register accessor: endpoint 2 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep2_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep2_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep2_t_len`] module"]
    #[doc(alias = "UEP2_T_LEN")]
    pub type Uep2TLen = crate::Reg<uep2_t_len::Uep2TLenSpec>;
    #[doc = "endpoint 2 transmittal length"]
    pub mod uep2_t_len {
        #[doc = "Register `UEP2_T_LEN` reader"]
        pub type R = crate::R<Uep2TLenSpec>;
        #[doc = "Register `UEP2_T_LEN` writer"]
        pub type W = crate::W<Uep2TLenSpec>;
        #[doc = "Field `UEP2_T_LEN` reader - endpoint 2 transmittal length"]
        pub type Uep2TLenR = crate::FieldReader;
        #[doc = "Field `UEP2_T_LEN` writer - endpoint 2 transmittal length"]
        pub type Uep2TLenW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - endpoint 2 transmittal length"]
            #[inline(always)]
            pub fn uep2_t_len(&self) -> Uep2TLenR {
                Uep2TLenR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - endpoint 2 transmittal length"]
            #[inline(always)]
            pub fn uep2_t_len(&mut self) -> Uep2TLenW<Uep2TLenSpec> {
                Uep2TLenW::new(self, 0)
            }
        }
        #[doc = "endpoint 2 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep2_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep2_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep2TLenSpec;
        impl crate::RegisterSpec for Uep2TLenSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uep2_t_len::R`](R) reader structure"]
        impl crate::Readable for Uep2TLenSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep2_t_len::W`](W) writer structure"]
        impl crate::Writable for Uep2TLenSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP2_T_LEN to value 0"]
        impl crate::Resettable for Uep2TLenSpec {}
    }
    #[doc = "UH_EP_PID (rw) register accessor: host endpoint and PID\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_ep_pid::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_ep_pid::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uh_ep_pid`] module"]
    #[doc(alias = "UH_EP_PID")]
    pub type UhEpPid = crate::Reg<uh_ep_pid::UhEpPidSpec>;
    #[doc = "host endpoint and PID"]
    pub mod uh_ep_pid {
        #[doc = "Register `UH_EP_PID` reader"]
        pub type R = crate::R<UhEpPidSpec>;
        #[doc = "Register `UH_EP_PID` writer"]
        pub type W = crate::W<UhEpPidSpec>;
        #[doc = "Field `UH_ENDP` reader - bit mask of endpoint number for USB host transfer"]
        pub type UhEndpR = crate::FieldReader;
        #[doc = "Field `UH_ENDP` writer - bit mask of endpoint number for USB host transfer"]
        pub type UhEndpW<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `UH_TOKEN` reader - bit mask of token PID for USB host transfer"]
        pub type UhTokenR = crate::FieldReader;
        #[doc = "Field `UH_TOKEN` writer - bit mask of token PID for USB host transfer"]
        pub type UhTokenW<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            #[doc = "Bits 0:3 - bit mask of endpoint number for USB host transfer"]
            #[inline(always)]
            pub fn uh_endp(&self) -> UhEndpR {
                UhEndpR::new(self.bits & 0x0f)
            }
            #[doc = "Bits 4:7 - bit mask of token PID for USB host transfer"]
            #[inline(always)]
            pub fn uh_token(&self) -> UhTokenR {
                UhTokenR::new((self.bits >> 4) & 0x0f)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - bit mask of endpoint number for USB host transfer"]
            #[inline(always)]
            pub fn uh_endp(&mut self) -> UhEndpW<UhEpPidSpec> {
                UhEndpW::new(self, 0)
            }
            #[doc = "Bits 4:7 - bit mask of token PID for USB host transfer"]
            #[inline(always)]
            pub fn uh_token(&mut self) -> UhTokenW<UhEpPidSpec> {
                UhTokenW::new(self, 4)
            }
        }
        #[doc = "host endpoint and PID\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_ep_pid::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_ep_pid::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct UhEpPidSpec;
        impl crate::RegisterSpec for UhEpPidSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uh_ep_pid::R`](R) reader structure"]
        impl crate::Readable for UhEpPidSpec {}
        #[doc = "`write(|w| ..)` method takes [`uh_ep_pid::W`](W) writer structure"]
        impl crate::Writable for UhEpPidSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UH_EP_PID to value 0"]
        impl crate::Resettable for UhEpPidSpec {}
    }
    #[doc = "UEP2_CTRL (rw) register accessor: endpoint 2 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep2_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep2_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep2_ctrl`] module"]
    #[doc(alias = "UEP2_CTRL")]
    pub type Uep2Ctrl = crate::Reg<uep2_ctrl::Uep2CtrlSpec>;
    #[doc = "endpoint 2 control"]
    pub mod uep2_ctrl {
        #[doc = "Register `UEP2_CTRL` reader"]
        pub type R = crate::R<Uep2CtrlSpec>;
        #[doc = "Register `UEP2_CTRL` writer"]
        pub type W = crate::W<Uep2CtrlSpec>;
        #[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResR = crate::FieldReader;
        #[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResR = crate::FieldReader;
        #[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogR = crate::BitReader;
        #[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogR = crate::BitReader;
        #[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogR = crate::BitReader;
        #[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&self) -> UepTResR {
                UepTResR::new(self.bits & 3)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&self) -> UepRResR {
                UepRResR::new((self.bits >> 2) & 3)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UepAutoTogR {
                UepAutoTogR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UepTTogR {
                UepTTogR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UepRTogR {
                UepRTogR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&mut self) -> UepTResW<Uep2CtrlSpec> {
                UepTResW::new(self, 0)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&mut self) -> UepRResW<Uep2CtrlSpec> {
                UepRResW::new(self, 2)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&mut self) -> UepAutoTogW<Uep2CtrlSpec> {
                UepAutoTogW::new(self, 4)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&mut self) -> UepTTogW<Uep2CtrlSpec> {
                UepTTogW::new(self, 6)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&mut self) -> UepRTogW<Uep2CtrlSpec> {
                UepRTogW::new(self, 7)
            }
        }
        #[doc = "endpoint 2 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep2_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep2_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep2CtrlSpec;
        impl crate::RegisterSpec for Uep2CtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uep2_ctrl::R`](R) reader structure"]
        impl crate::Readable for Uep2CtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep2_ctrl::W`](W) writer structure"]
        impl crate::Writable for Uep2CtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP2_CTRL to value 0"]
        impl crate::Resettable for Uep2CtrlSpec {}
    }
    #[doc = "UH_RX_CTRL (rw) register accessor: host receiver endpoint control\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_rx_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_rx_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uh_rx_ctrl`] module"]
    #[doc(alias = "UH_RX_CTRL")]
    pub type UhRxCtrl = crate::Reg<uh_rx_ctrl::UhRxCtrlSpec>;
    #[doc = "host receiver endpoint control"]
    pub mod uh_rx_ctrl {
        #[doc = "Register `UH_RX_CTRL` reader"]
        pub type R = crate::R<UhRxCtrlSpec>;
        #[doc = "Register `UH_RX_CTRL` writer"]
        pub type W = crate::W<UhRxCtrlSpec>;
        #[doc = "Field `UH_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UhRResR = crate::BitReader;
        #[doc = "Field `UH_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UhRResW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResR = crate::FieldReader;
        #[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UH_R_AUTO_TOG` reader - enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle"]
        pub type UhRAutoTogR = crate::BitReader;
        #[doc = "Field `UH_R_AUTO_TOG` writer - enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle"]
        pub type UhRAutoTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UH_R_TOG` reader - expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1"]
        pub type UhRTogR = crate::BitReader;
        #[doc = "Field `UH_R_TOG` writer - expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1"]
        pub type UhRTogW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 2 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uh_r_res(&self) -> UhRResR {
                UhRResR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&self) -> UepRResR {
                UepRResR::new((self.bits >> 2) & 3)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uh_r_auto_tog(&self) -> UhRAutoTogR {
                UhRAutoTogR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 7 - expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uh_r_tog(&self) -> UhRTogR {
                UhRTogR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 2 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uh_r_res(&mut self) -> UhRResW<UhRxCtrlSpec> {
                UhRResW::new(self, 2)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&mut self) -> UepRResW<UhRxCtrlSpec> {
                UepRResW::new(self, 2)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uh_r_auto_tog(&mut self) -> UhRAutoTogW<UhRxCtrlSpec> {
                UhRAutoTogW::new(self, 4)
            }
            #[doc = "Bit 7 - expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uh_r_tog(&mut self) -> UhRTogW<UhRxCtrlSpec> {
                UhRTogW::new(self, 7)
            }
        }
        #[doc = "host receiver endpoint control\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_rx_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_rx_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct UhRxCtrlSpec;
        impl crate::RegisterSpec for UhRxCtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uh_rx_ctrl::R`](R) reader structure"]
        impl crate::Readable for UhRxCtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`uh_rx_ctrl::W`](W) writer structure"]
        impl crate::Writable for UhRxCtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UH_RX_CTRL to value 0"]
        impl crate::Resettable for UhRxCtrlSpec {}
    }
    #[doc = "UEP3_T_LEN (rw) register accessor: endpoint 3 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep3_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep3_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep3_t_len`] module"]
    #[doc(alias = "UEP3_T_LEN")]
    pub type Uep3TLen = crate::Reg<uep3_t_len::Uep3TLenSpec>;
    #[doc = "endpoint 3 transmittal length"]
    pub mod uep3_t_len {
        #[doc = "Register `UEP3_T_LEN` reader"]
        pub type R = crate::R<Uep3TLenSpec>;
        #[doc = "Register `UEP3_T_LEN` writer"]
        pub type W = crate::W<Uep3TLenSpec>;
        #[doc = "Field `UEP3_T_LEN` reader - endpoint 1 transmittal length"]
        pub type Uep3TLenR = crate::FieldReader;
        #[doc = "Field `UEP3_T_LEN` writer - endpoint 1 transmittal length"]
        pub type Uep3TLenW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - endpoint 1 transmittal length"]
            #[inline(always)]
            pub fn uep3_t_len(&self) -> Uep3TLenR {
                Uep3TLenR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - endpoint 1 transmittal length"]
            #[inline(always)]
            pub fn uep3_t_len(&mut self) -> Uep3TLenW<Uep3TLenSpec> {
                Uep3TLenW::new(self, 0)
            }
        }
        #[doc = "endpoint 3 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep3_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep3_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep3TLenSpec;
        impl crate::RegisterSpec for Uep3TLenSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uep3_t_len::R`](R) reader structure"]
        impl crate::Readable for Uep3TLenSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep3_t_len::W`](W) writer structure"]
        impl crate::Writable for Uep3TLenSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP3_T_LEN to value 0"]
        impl crate::Resettable for Uep3TLenSpec {}
    }
    #[doc = "UH_TX_LEN (rw) register accessor: host transmittal endpoint transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_tx_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_tx_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uh_tx_len`] module"]
    #[doc(alias = "UH_TX_LEN")]
    pub type UhTxLen = crate::Reg<uh_tx_len::UhTxLenSpec>;
    #[doc = "host transmittal endpoint transmittal length"]
    pub mod uh_tx_len {
        #[doc = "Register `UH_TX_LEN` reader"]
        pub type R = crate::R<UhTxLenSpec>;
        #[doc = "Register `UH_TX_LEN` writer"]
        pub type W = crate::W<UhTxLenSpec>;
        #[doc = "Field `UH_TX_LEN` reader - endpoint 1 transmittal length"]
        pub type UhTxLenR = crate::FieldReader;
        #[doc = "Field `UH_TX_LEN` writer - endpoint 1 transmittal length"]
        pub type UhTxLenW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - endpoint 1 transmittal length"]
            #[inline(always)]
            pub fn uh_tx_len(&self) -> UhTxLenR {
                UhTxLenR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - endpoint 1 transmittal length"]
            #[inline(always)]
            pub fn uh_tx_len(&mut self) -> UhTxLenW<UhTxLenSpec> {
                UhTxLenW::new(self, 0)
            }
        }
        #[doc = "host transmittal endpoint transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_tx_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_tx_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct UhTxLenSpec;
        impl crate::RegisterSpec for UhTxLenSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uh_tx_len::R`](R) reader structure"]
        impl crate::Readable for UhTxLenSpec {}
        #[doc = "`write(|w| ..)` method takes [`uh_tx_len::W`](W) writer structure"]
        impl crate::Writable for UhTxLenSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UH_TX_LEN to value 0"]
        impl crate::Resettable for UhTxLenSpec {}
    }
    #[doc = "UEP3_CTRL (rw) register accessor: endpoint 3 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep3_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep3_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep3_ctrl`] module"]
    #[doc(alias = "UEP3_CTRL")]
    pub type Uep3Ctrl = crate::Reg<uep3_ctrl::Uep3CtrlSpec>;
    #[doc = "endpoint 3 control"]
    pub mod uep3_ctrl {
        #[doc = "Register `UEP3_CTRL` reader"]
        pub type R = crate::R<Uep3CtrlSpec>;
        #[doc = "Register `UEP3_CTRL` writer"]
        pub type W = crate::W<Uep3CtrlSpec>;
        #[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResR = crate::FieldReader;
        #[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResR = crate::FieldReader;
        #[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogR = crate::BitReader;
        #[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogR = crate::BitReader;
        #[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogR = crate::BitReader;
        #[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&self) -> UepTResR {
                UepTResR::new(self.bits & 3)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&self) -> UepRResR {
                UepRResR::new((self.bits >> 2) & 3)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UepAutoTogR {
                UepAutoTogR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UepTTogR {
                UepTTogR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UepRTogR {
                UepRTogR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&mut self) -> UepTResW<Uep3CtrlSpec> {
                UepTResW::new(self, 0)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&mut self) -> UepRResW<Uep3CtrlSpec> {
                UepRResW::new(self, 2)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&mut self) -> UepAutoTogW<Uep3CtrlSpec> {
                UepAutoTogW::new(self, 4)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&mut self) -> UepTTogW<Uep3CtrlSpec> {
                UepTTogW::new(self, 6)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&mut self) -> UepRTogW<Uep3CtrlSpec> {
                UepRTogW::new(self, 7)
            }
        }
        #[doc = "endpoint 3 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep3_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep3_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep3CtrlSpec;
        impl crate::RegisterSpec for Uep3CtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uep3_ctrl::R`](R) reader structure"]
        impl crate::Readable for Uep3CtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep3_ctrl::W`](W) writer structure"]
        impl crate::Writable for Uep3CtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP3_CTRL to value 0"]
        impl crate::Resettable for Uep3CtrlSpec {}
    }
    #[doc = "UH_TX_CTRL (rw) register accessor: host transmittal endpoint control\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_tx_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_tx_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uh_tx_ctrl`] module"]
    #[doc(alias = "UH_TX_CTRL")]
    pub type UhTxCtrl = crate::Reg<uh_tx_ctrl::UhTxCtrlSpec>;
    #[doc = "host transmittal endpoint control"]
    pub mod uh_tx_ctrl {
        #[doc = "Register `UH_TX_CTRL` reader"]
        pub type R = crate::R<UhTxCtrlSpec>;
        #[doc = "Register `UH_TX_CTRL` writer"]
        pub type W = crate::W<UhTxCtrlSpec>;
        #[doc = "Field `UH_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UhTResR = crate::FieldReader;
        #[doc = "Field `UH_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UhTResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UH_T_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UhTAutoTogR = crate::BitReader;
        #[doc = "Field `UH_T_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UhTAutoTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UH_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UhTTogR = crate::BitReader;
        #[doc = "Field `UH_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UhTTogW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uh_t_res(&self) -> UhTResR {
                UhTResR::new(self.bits & 3)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uh_t_auto_tog(&self) -> UhTAutoTogR {
                UhTAutoTogR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uh_t_tog(&self) -> UhTTogR {
                UhTTogR::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uh_t_res(&mut self) -> UhTResW<UhTxCtrlSpec> {
                UhTResW::new(self, 0)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uh_t_auto_tog(&mut self) -> UhTAutoTogW<UhTxCtrlSpec> {
                UhTAutoTogW::new(self, 4)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uh_t_tog(&mut self) -> UhTTogW<UhTxCtrlSpec> {
                UhTTogW::new(self, 6)
            }
        }
        #[doc = "host transmittal endpoint control\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_tx_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_tx_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct UhTxCtrlSpec;
        impl crate::RegisterSpec for UhTxCtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uh_tx_ctrl::R`](R) reader structure"]
        impl crate::Readable for UhTxCtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`uh_tx_ctrl::W`](W) writer structure"]
        impl crate::Writable for UhTxCtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UH_TX_CTRL to value 0"]
        impl crate::Resettable for UhTxCtrlSpec {}
    }
    #[doc = "UEP4_T_LEN (rw) register accessor: endpoint 4 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep4_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep4_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep4_t_len`] module"]
    #[doc(alias = "UEP4_T_LEN")]
    pub type Uep4TLen = crate::Reg<uep4_t_len::Uep4TLenSpec>;
    #[doc = "endpoint 4 transmittal length"]
    pub mod uep4_t_len {
        #[doc = "Register `UEP4_T_LEN` reader"]
        pub type R = crate::R<Uep4TLenSpec>;
        #[doc = "Register `UEP4_T_LEN` writer"]
        pub type W = crate::W<Uep4TLenSpec>;
        #[doc = "Field `UEP4_T_LEN` reader - endpoint 4 transmittal length"]
        pub type Uep4TLenR = crate::FieldReader;
        #[doc = "Field `UEP4_T_LEN` writer - endpoint 4 transmittal length"]
        pub type Uep4TLenW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - endpoint 4 transmittal length"]
            #[inline(always)]
            pub fn uep4_t_len(&self) -> Uep4TLenR {
                Uep4TLenR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - endpoint 4 transmittal length"]
            #[inline(always)]
            pub fn uep4_t_len(&mut self) -> Uep4TLenW<Uep4TLenSpec> {
                Uep4TLenW::new(self, 0)
            }
        }
        #[doc = "endpoint 4 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep4_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep4_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep4TLenSpec;
        impl crate::RegisterSpec for Uep4TLenSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uep4_t_len::R`](R) reader structure"]
        impl crate::Readable for Uep4TLenSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep4_t_len::W`](W) writer structure"]
        impl crate::Writable for Uep4TLenSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP4_T_LEN to value 0"]
        impl crate::Resettable for Uep4TLenSpec {}
    }
    #[doc = "UEP4_CTRL (rw) register accessor: endpoint 4 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep4_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep4_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep4_ctrl`] module"]
    #[doc(alias = "UEP4_CTRL")]
    pub type Uep4Ctrl = crate::Reg<uep4_ctrl::Uep4CtrlSpec>;
    #[doc = "endpoint 4 control"]
    pub mod uep4_ctrl {
        #[doc = "Register `UEP4_CTRL` reader"]
        pub type R = crate::R<Uep4CtrlSpec>;
        #[doc = "Register `UEP4_CTRL` writer"]
        pub type W = crate::W<Uep4CtrlSpec>;
        #[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResR = crate::FieldReader;
        #[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResR = crate::FieldReader;
        #[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogR = crate::BitReader;
        #[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogR = crate::BitReader;
        #[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogR = crate::BitReader;
        #[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&self) -> UepTResR {
                UepTResR::new(self.bits & 3)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&self) -> UepRResR {
                UepRResR::new((self.bits >> 2) & 3)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UepAutoTogR {
                UepAutoTogR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UepTTogR {
                UepTTogR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UepRTogR {
                UepRTogR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&mut self) -> UepTResW<Uep4CtrlSpec> {
                UepTResW::new(self, 0)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&mut self) -> UepRResW<Uep4CtrlSpec> {
                UepRResW::new(self, 2)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&mut self) -> UepAutoTogW<Uep4CtrlSpec> {
                UepAutoTogW::new(self, 4)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&mut self) -> UepTTogW<Uep4CtrlSpec> {
                UepTTogW::new(self, 6)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&mut self) -> UepRTogW<Uep4CtrlSpec> {
                UepRTogW::new(self, 7)
            }
        }
        #[doc = "endpoint 4 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep4_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep4_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep4CtrlSpec;
        impl crate::RegisterSpec for Uep4CtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uep4_ctrl::R`](R) reader structure"]
        impl crate::Readable for Uep4CtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep4_ctrl::W`](W) writer structure"]
        impl crate::Writable for Uep4CtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP4_CTRL to value 0"]
        impl crate::Resettable for Uep4CtrlSpec {}
    }
    #[doc = "UEP5_T_LEN (rw) register accessor: endpoint 5 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep5_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep5_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep5_t_len`] module"]
    #[doc(alias = "UEP5_T_LEN")]
    pub type Uep5TLen = crate::Reg<uep5_t_len::Uep5TLenSpec>;
    #[doc = "endpoint 5 transmittal length"]
    pub mod uep5_t_len {
        #[doc = "Register `UEP5_T_LEN` reader"]
        pub type R = crate::R<Uep5TLenSpec>;
        #[doc = "Register `UEP5_T_LEN` writer"]
        pub type W = crate::W<Uep5TLenSpec>;
        #[doc = "Field `UEP5_T_LEN` reader - endpoint 5 transmittal length"]
        pub type Uep5TLenR = crate::FieldReader;
        #[doc = "Field `UEP5_T_LEN` writer - endpoint 5 transmittal length"]
        pub type Uep5TLenW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - endpoint 5 transmittal length"]
            #[inline(always)]
            pub fn uep5_t_len(&self) -> Uep5TLenR {
                Uep5TLenR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - endpoint 5 transmittal length"]
            #[inline(always)]
            pub fn uep5_t_len(&mut self) -> Uep5TLenW<Uep5TLenSpec> {
                Uep5TLenW::new(self, 0)
            }
        }
        #[doc = "endpoint 5 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep5_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep5_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep5TLenSpec;
        impl crate::RegisterSpec for Uep5TLenSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uep5_t_len::R`](R) reader structure"]
        impl crate::Readable for Uep5TLenSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep5_t_len::W`](W) writer structure"]
        impl crate::Writable for Uep5TLenSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP5_T_LEN to value 0"]
        impl crate::Resettable for Uep5TLenSpec {}
    }
    #[doc = "UEP5_CTRL (rw) register accessor: endpoint 5 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep5_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep5_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep5_ctrl`] module"]
    #[doc(alias = "UEP5_CTRL")]
    pub type Uep5Ctrl = crate::Reg<uep5_ctrl::Uep5CtrlSpec>;
    #[doc = "endpoint 5 control"]
    pub mod uep5_ctrl {
        #[doc = "Register `UEP5_CTRL` reader"]
        pub type R = crate::R<Uep5CtrlSpec>;
        #[doc = "Register `UEP5_CTRL` writer"]
        pub type W = crate::W<Uep5CtrlSpec>;
        #[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResR = crate::FieldReader;
        #[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResR = crate::FieldReader;
        #[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogR = crate::BitReader;
        #[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogR = crate::BitReader;
        #[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogR = crate::BitReader;
        #[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&self) -> UepTResR {
                UepTResR::new(self.bits & 3)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&self) -> UepRResR {
                UepRResR::new((self.bits >> 2) & 3)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UepAutoTogR {
                UepAutoTogR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UepTTogR {
                UepTTogR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UepRTogR {
                UepRTogR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&mut self) -> UepTResW<Uep5CtrlSpec> {
                UepTResW::new(self, 0)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&mut self) -> UepRResW<Uep5CtrlSpec> {
                UepRResW::new(self, 2)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&mut self) -> UepAutoTogW<Uep5CtrlSpec> {
                UepAutoTogW::new(self, 4)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&mut self) -> UepTTogW<Uep5CtrlSpec> {
                UepTTogW::new(self, 6)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&mut self) -> UepRTogW<Uep5CtrlSpec> {
                UepRTogW::new(self, 7)
            }
        }
        #[doc = "endpoint 5 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep5_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep5_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep5CtrlSpec;
        impl crate::RegisterSpec for Uep5CtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uep5_ctrl::R`](R) reader structure"]
        impl crate::Readable for Uep5CtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep5_ctrl::W`](W) writer structure"]
        impl crate::Writable for Uep5CtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP5_CTRL to value 0"]
        impl crate::Resettable for Uep5CtrlSpec {}
    }
    #[doc = "UEP6_T_LEN (rw) register accessor: endpoint 6 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep6_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep6_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep6_t_len`] module"]
    #[doc(alias = "UEP6_T_LEN")]
    pub type Uep6TLen = crate::Reg<uep6_t_len::Uep6TLenSpec>;
    #[doc = "endpoint 6 transmittal length"]
    pub mod uep6_t_len {
        #[doc = "Register `UEP6_T_LEN` reader"]
        pub type R = crate::R<Uep6TLenSpec>;
        #[doc = "Register `UEP6_T_LEN` writer"]
        pub type W = crate::W<Uep6TLenSpec>;
        #[doc = "Field `UEP6_T_LEN` reader - endpoint 6 transmittal length"]
        pub type Uep6TLenR = crate::FieldReader;
        #[doc = "Field `UEP6_T_LEN` writer - endpoint 6 transmittal length"]
        pub type Uep6TLenW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - endpoint 6 transmittal length"]
            #[inline(always)]
            pub fn uep6_t_len(&self) -> Uep6TLenR {
                Uep6TLenR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - endpoint 6 transmittal length"]
            #[inline(always)]
            pub fn uep6_t_len(&mut self) -> Uep6TLenW<Uep6TLenSpec> {
                Uep6TLenW::new(self, 0)
            }
        }
        #[doc = "endpoint 6 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep6_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep6_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep6TLenSpec;
        impl crate::RegisterSpec for Uep6TLenSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uep6_t_len::R`](R) reader structure"]
        impl crate::Readable for Uep6TLenSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep6_t_len::W`](W) writer structure"]
        impl crate::Writable for Uep6TLenSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP6_T_LEN to value 0"]
        impl crate::Resettable for Uep6TLenSpec {}
    }
    #[doc = "UEP6_CTRL (rw) register accessor: endpoint 6 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep6_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep6_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep6_ctrl`] module"]
    #[doc(alias = "UEP6_CTRL")]
    pub type Uep6Ctrl = crate::Reg<uep6_ctrl::Uep6CtrlSpec>;
    #[doc = "endpoint 6 control"]
    pub mod uep6_ctrl {
        #[doc = "Register `UEP6_CTRL` reader"]
        pub type R = crate::R<Uep6CtrlSpec>;
        #[doc = "Register `UEP6_CTRL` writer"]
        pub type W = crate::W<Uep6CtrlSpec>;
        #[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResR = crate::FieldReader;
        #[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResR = crate::FieldReader;
        #[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogR = crate::BitReader;
        #[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogR = crate::BitReader;
        #[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogR = crate::BitReader;
        #[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&self) -> UepTResR {
                UepTResR::new(self.bits & 3)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&self) -> UepRResR {
                UepRResR::new((self.bits >> 2) & 3)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UepAutoTogR {
                UepAutoTogR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UepTTogR {
                UepTTogR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UepRTogR {
                UepRTogR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&mut self) -> UepTResW<Uep6CtrlSpec> {
                UepTResW::new(self, 0)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&mut self) -> UepRResW<Uep6CtrlSpec> {
                UepRResW::new(self, 2)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&mut self) -> UepAutoTogW<Uep6CtrlSpec> {
                UepAutoTogW::new(self, 4)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&mut self) -> UepTTogW<Uep6CtrlSpec> {
                UepTTogW::new(self, 6)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&mut self) -> UepRTogW<Uep6CtrlSpec> {
                UepRTogW::new(self, 7)
            }
        }
        #[doc = "endpoint 6 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep6_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep6_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep6CtrlSpec;
        impl crate::RegisterSpec for Uep6CtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uep6_ctrl::R`](R) reader structure"]
        impl crate::Readable for Uep6CtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep6_ctrl::W`](W) writer structure"]
        impl crate::Writable for Uep6CtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP6_CTRL to value 0"]
        impl crate::Resettable for Uep6CtrlSpec {}
    }
    #[doc = "UEP7_T_LEN (rw) register accessor: endpoint 7 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep7_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep7_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep7_t_len`] module"]
    #[doc(alias = "UEP7_T_LEN")]
    pub type Uep7TLen = crate::Reg<uep7_t_len::Uep7TLenSpec>;
    #[doc = "endpoint 7 transmittal length"]
    pub mod uep7_t_len {
        #[doc = "Register `UEP7_T_LEN` reader"]
        pub type R = crate::R<Uep7TLenSpec>;
        #[doc = "Register `UEP7_T_LEN` writer"]
        pub type W = crate::W<Uep7TLenSpec>;
        #[doc = "Field `UEP7_T_LEN` reader - endpoint 7 transmittal length"]
        pub type Uep7TLenR = crate::FieldReader;
        #[doc = "Field `UEP7_T_LEN` writer - endpoint 7 transmittal length"]
        pub type Uep7TLenW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - endpoint 7 transmittal length"]
            #[inline(always)]
            pub fn uep7_t_len(&self) -> Uep7TLenR {
                Uep7TLenR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - endpoint 7 transmittal length"]
            #[inline(always)]
            pub fn uep7_t_len(&mut self) -> Uep7TLenW<Uep7TLenSpec> {
                Uep7TLenW::new(self, 0)
            }
        }
        #[doc = "endpoint 7 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep7_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep7_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep7TLenSpec;
        impl crate::RegisterSpec for Uep7TLenSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uep7_t_len::R`](R) reader structure"]
        impl crate::Readable for Uep7TLenSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep7_t_len::W`](W) writer structure"]
        impl crate::Writable for Uep7TLenSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP7_T_LEN to value 0"]
        impl crate::Resettable for Uep7TLenSpec {}
    }
    #[doc = "UEP7_CTRL (rw) register accessor: endpoint 7 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep7_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep7_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep7_ctrl`] module"]
    #[doc(alias = "UEP7_CTRL")]
    pub type Uep7Ctrl = crate::Reg<uep7_ctrl::Uep7CtrlSpec>;
    #[doc = "endpoint 7 control"]
    pub mod uep7_ctrl {
        #[doc = "Register `UEP7_CTRL` reader"]
        pub type R = crate::R<Uep7CtrlSpec>;
        #[doc = "Register `UEP7_CTRL` writer"]
        pub type W = crate::W<Uep7CtrlSpec>;
        #[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResR = crate::FieldReader;
        #[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResR = crate::FieldReader;
        #[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogR = crate::BitReader;
        #[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogR = crate::BitReader;
        #[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogR = crate::BitReader;
        #[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&self) -> UepTResR {
                UepTResR::new(self.bits & 3)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&self) -> UepRResR {
                UepRResR::new((self.bits >> 2) & 3)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UepAutoTogR {
                UepAutoTogR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UepTTogR {
                UepTTogR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UepRTogR {
                UepRTogR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&mut self) -> UepTResW<Uep7CtrlSpec> {
                UepTResW::new(self, 0)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&mut self) -> UepRResW<Uep7CtrlSpec> {
                UepRResW::new(self, 2)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&mut self) -> UepAutoTogW<Uep7CtrlSpec> {
                UepAutoTogW::new(self, 4)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&mut self) -> UepTTogW<Uep7CtrlSpec> {
                UepTTogW::new(self, 6)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&mut self) -> UepRTogW<Uep7CtrlSpec> {
                UepRTogW::new(self, 7)
            }
        }
        #[doc = "endpoint 7 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep7_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep7_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Uep7CtrlSpec;
        impl crate::RegisterSpec for Uep7CtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`uep7_ctrl::R`](R) reader structure"]
        impl crate::Readable for Uep7CtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`uep7_ctrl::W`](W) writer structure"]
        impl crate::Writable for Uep7CtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets UEP7_CTRL to value 0"]
        impl crate::Resettable for Uep7CtrlSpec {}
    }
}
#[doc = "USB2 register"]
pub type Usb2 = crate::Periph<usb2::RegisterBlock, 0x4000_8400>;
impl core::fmt::Debug for Usb2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usb2").finish()
    }
}
#[doc = "USB2 register"]
pub mod usb2 {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        ctrl: Ctrl,
        _reserved_1_u: [u8; 0x01],
        int_en: IntEn,
        dev_ad: DevAd,
        _reserved4: [u8; 0x01],
        mis_st: MisSt,
        int_fg: IntFg,
        int_st: IntSt,
        rx_len: RxLen,
        _reserved8: [u8; 0x03],
        u2ep4_1_mod: U2ep4_1Mod,
        _reserved_9_u: [u8; 0x01],
        u2ep567_mod: U2ep567Mod,
        _reserved11: [u8; 0x01],
        u2ep0_dma: U2ep0Dma,
        _reserved12: [u8; 0x02],
        u2ep1_dma: U2ep1Dma,
        _reserved13: [u8; 0x02],
        _reserved_13_u: [u8; 0x02],
        _reserved14: [u8; 0x02],
        _reserved_14_u: [u8; 0x02],
        _reserved15: [u8; 0x02],
        u2ep0_t_len: U2ep0TLen,
        _reserved16: [u8; 0x01],
        u2ep0_ctrl: U2ep0Ctrl,
        _reserved17: [u8; 0x01],
        u2ep1_t_len: U2ep1TLen,
        _reserved18: [u8; 0x01],
        _reserved_18_u: [u8; 0x01],
        _reserved19: [u8; 0x01],
        _reserved_19_u: [u8; 0x01],
        _reserved20: [u8; 0x01],
        _reserved_20_u: [u8; 0x01],
        _reserved21: [u8; 0x01],
        _reserved_21_u: [u8; 0x01],
        _reserved22: [u8; 0x01],
        _reserved_22_u: [u8; 0x01],
        _reserved23: [u8; 0x01],
        u2ep4_t_len: U2ep4TLen,
        _reserved24: [u8; 0x01],
        u2ep4_ctrl: U2ep4Ctrl,
        _reserved25: [u8; 0x21],
        u2ep5_dma: U2ep5Dma,
        _reserved26: [u8; 0x02],
        u2ep6_dma: U2ep6Dma,
        _reserved27: [u8; 0x02],
        u2ep7_dma: U2ep7Dma,
        _reserved28: [u8; 0x06],
        u2ep5_t_len: U2ep5TLen,
        _reserved29: [u8; 0x01],
        u2ep5_ctrl: U2ep5Ctrl,
        _reserved30: [u8; 0x01],
        u2ep6_t_len: U2ep6TLen,
        _reserved31: [u8; 0x01],
        u2ep6_ctrl: U2ep6Ctrl,
        _reserved32: [u8; 0x01],
        u2ep7_t_len: U2ep7TLen,
        _reserved33: [u8; 0x01],
        u2ep7_ctrl: U2ep7Ctrl,
    }
    impl RegisterBlock {
        #[doc = "0x00 - USB2 base control"]
        #[inline(always)]
        pub const fn ctrl(&self) -> &Ctrl {
            &self.ctrl
        }
        #[doc = "0x01 - USB2 device physical prot control"]
        #[inline(always)]
        pub const fn u2host_ctrl(&self) -> &U2hostCtrl {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(1).cast() }
        }
        #[doc = "0x01 - USB2 device physical prot control"]
        #[inline(always)]
        pub const fn u2dev_ctrl(&self) -> &U2devCtrl {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(1).cast() }
        }
        #[doc = "0x02 - USB2 interrupt enable"]
        #[inline(always)]
        pub const fn int_en(&self) -> &IntEn {
            &self.int_en
        }
        #[doc = "0x03 - USB2 device address"]
        #[inline(always)]
        pub const fn dev_ad(&self) -> &DevAd {
            &self.dev_ad
        }
        #[doc = "0x05 - USB2 miscellaneous status"]
        #[inline(always)]
        pub const fn mis_st(&self) -> &MisSt {
            &self.mis_st
        }
        #[doc = "0x06 - USB2 interrupt flag"]
        #[inline(always)]
        pub const fn int_fg(&self) -> &IntFg {
            &self.int_fg
        }
        #[doc = "0x07 - USB2 interrupt status"]
        #[inline(always)]
        pub const fn int_st(&self) -> &IntSt {
            &self.int_st
        }
        #[doc = "0x08 - USB2 receiving length"]
        #[inline(always)]
        pub const fn rx_len(&self) -> &RxLen {
            &self.rx_len
        }
        #[doc = "0x0c - endpoint 4/1 mode"]
        #[inline(always)]
        pub const fn u2ep4_1_mod(&self) -> &U2ep4_1Mod {
            &self.u2ep4_1_mod
        }
        #[doc = "0x0d - host endpoint mode"]
        #[inline(always)]
        pub const fn u2h_ep_mod(&self) -> &U2hEpMod {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(13).cast() }
        }
        #[doc = "0x0d - endpoint 2_3 mode"]
        #[inline(always)]
        pub const fn u2ep2_3_mod(&self) -> &U2ep2_3Mod {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(13).cast() }
        }
        #[doc = "0x0e - USB2 endpoint 5/6/7 mode"]
        #[inline(always)]
        pub const fn u2ep567_mod(&self) -> &U2ep567Mod {
            &self.u2ep567_mod
        }
        #[doc = "0x10 - endpoint 0 DMA buffer address"]
        #[inline(always)]
        pub const fn u2ep0_dma(&self) -> &U2ep0Dma {
            &self.u2ep0_dma
        }
        #[doc = "0x14 - USB2 endpoint 1 DMA buffer address"]
        #[inline(always)]
        pub const fn u2ep1_dma(&self) -> &U2ep1Dma {
            &self.u2ep1_dma
        }
        #[doc = "0x18 - host rx endpoint buffer high address"]
        #[inline(always)]
        pub const fn u2h_rx_dma(&self) -> &U2hRxDma {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(24).cast() }
        }
        #[doc = "0x18 - USB2 endpoint 2 DMA buffer address"]
        #[inline(always)]
        pub const fn u2ep2_dma(&self) -> &U2ep2Dma {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(24).cast() }
        }
        #[doc = "0x1c - host tx endpoint buffer high address"]
        #[inline(always)]
        pub const fn u2h_tx_dma(&self) -> &U2hTxDma {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(28).cast() }
        }
        #[doc = "0x1c - USB2 endpoint 3 DMA buffer address"]
        #[inline(always)]
        pub const fn u2ep3_dma(&self) -> &U2ep3Dma {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(28).cast() }
        }
        #[doc = "0x20 - USB2 endpoint 0 transmittal length"]
        #[inline(always)]
        pub const fn u2ep0_t_len(&self) -> &U2ep0TLen {
            &self.u2ep0_t_len
        }
        #[doc = "0x22 - USB2 endpoint 0 control"]
        #[inline(always)]
        pub const fn u2ep0_ctrl(&self) -> &U2ep0Ctrl {
            &self.u2ep0_ctrl
        }
        #[doc = "0x24 - USB2 endpoint 1 transmittal length"]
        #[inline(always)]
        pub const fn u2ep1_t_len(&self) -> &U2ep1TLen {
            &self.u2ep1_t_len
        }
        #[doc = "0x26 - host aux setup"]
        #[inline(always)]
        pub const fn u2h_setup(&self) -> &U2hSetup {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(38).cast() }
        }
        #[doc = "0x26 - USB2 endpoint 1 control"]
        #[inline(always)]
        pub const fn u2ep1_ctrl(&self) -> &U2ep1Ctrl {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(38).cast() }
        }
        #[doc = "0x28 - host endpoint and PID"]
        #[inline(always)]
        pub const fn u2h_ep_pid(&self) -> &U2hEpPid {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(40).cast() }
        }
        #[doc = "0x28 - USB2 endpoint 2 transmittal length"]
        #[inline(always)]
        pub const fn u2ep2_t_len(&self) -> &U2ep2TLen {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(40).cast() }
        }
        #[doc = "0x2a - host receiver endpoint control"]
        #[inline(always)]
        pub const fn u2h_rx_ctrl(&self) -> &U2hRxCtrl {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(42).cast() }
        }
        #[doc = "0x2a - USB2 endpoint 2 control"]
        #[inline(always)]
        pub const fn u2ep2_ctrl(&self) -> &U2ep2Ctrl {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(42).cast() }
        }
        #[doc = "0x2c - host transmittal endpoint transmittal length"]
        #[inline(always)]
        pub const fn u2h_tx_len(&self) -> &U2hTxLen {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(44).cast() }
        }
        #[doc = "0x2c - USB2 endpoint 3 transmittal length"]
        #[inline(always)]
        pub const fn u2ep3_t_len(&self) -> &U2ep3TLen {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(44).cast() }
        }
        #[doc = "0x2e - host transmittal endpoint control"]
        #[inline(always)]
        pub const fn u2h_tx_ctrl(&self) -> &U2hTxCtrl {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(46).cast() }
        }
        #[doc = "0x2e - USB2 endpoint 3 control"]
        #[inline(always)]
        pub const fn u2ep3_ctrl(&self) -> &U2ep3Ctrl {
            unsafe { &*core::ptr::from_ref(self).cast::<u8>().add(46).cast() }
        }
        #[doc = "0x30 - USB2 endpoint 4 transmittal length"]
        #[inline(always)]
        pub const fn u2ep4_t_len(&self) -> &U2ep4TLen {
            &self.u2ep4_t_len
        }
        #[doc = "0x32 - USB2 endpoint 4 control"]
        #[inline(always)]
        pub const fn u2ep4_ctrl(&self) -> &U2ep4Ctrl {
            &self.u2ep4_ctrl
        }
        #[doc = "0x54 - USB2 endpoint 5 DMA buffer address"]
        #[inline(always)]
        pub const fn u2ep5_dma(&self) -> &U2ep5Dma {
            &self.u2ep5_dma
        }
        #[doc = "0x58 - USB2 endpoint 6 DMA buffer address"]
        #[inline(always)]
        pub const fn u2ep6_dma(&self) -> &U2ep6Dma {
            &self.u2ep6_dma
        }
        #[doc = "0x5c - USB2 endpoint 7 DMA buffer address"]
        #[inline(always)]
        pub const fn u2ep7_dma(&self) -> &U2ep7Dma {
            &self.u2ep7_dma
        }
        #[doc = "0x64 - USB2 endpoint 5 transmittal length"]
        #[inline(always)]
        pub const fn u2ep5_t_len(&self) -> &U2ep5TLen {
            &self.u2ep5_t_len
        }
        #[doc = "0x66 - USB2 endpoint 5 control"]
        #[inline(always)]
        pub const fn u2ep5_ctrl(&self) -> &U2ep5Ctrl {
            &self.u2ep5_ctrl
        }
        #[doc = "0x68 - USB2 endpoint 6 transmittal length"]
        #[inline(always)]
        pub const fn u2ep6_t_len(&self) -> &U2ep6TLen {
            &self.u2ep6_t_len
        }
        #[doc = "0x6a - USB2 endpoint 6 control"]
        #[inline(always)]
        pub const fn u2ep6_ctrl(&self) -> &U2ep6Ctrl {
            &self.u2ep6_ctrl
        }
        #[doc = "0x6c - USB2 endpoint 7 transmittal length"]
        #[inline(always)]
        pub const fn u2ep7_t_len(&self) -> &U2ep7TLen {
            &self.u2ep7_t_len
        }
        #[doc = "0x6e - USB2 endpoint 7 control"]
        #[inline(always)]
        pub const fn u2ep7_ctrl(&self) -> &U2ep7Ctrl {
            &self.u2ep7_ctrl
        }
    }
    #[doc = "CTRL (rw) register accessor: USB2 base control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`] module"]
    #[doc(alias = "CTRL")]
    pub type Ctrl = crate::Reg<ctrl::CtrlSpec>;
    #[doc = "USB2 base control"]
    pub mod ctrl {
        #[doc = "Register `CTRL` reader"]
        pub type R = crate::R<CtrlSpec>;
        #[doc = "Register `CTRL` writer"]
        pub type W = crate::W<CtrlSpec>;
        #[doc = "Field `UC_DMA_EN` reader - DMA enable and DMA interrupt enable for USB"]
        pub type UcDmaEnR = crate::BitReader;
        #[doc = "Field `UC_DMA_EN` writer - DMA enable and DMA interrupt enable for USB"]
        pub type UcDmaEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UC_CLR_ALL` reader - force clear FIFO and count of USB"]
        pub type UcClrAllR = crate::BitReader;
        #[doc = "Field `UC_CLR_ALL` writer - force clear FIFO and count of USB"]
        pub type UcClrAllW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UC_RESET_SIE` reader - force reset USB SIE, need software clear"]
        pub type UcResetSieR = crate::BitReader;
        #[doc = "Field `UC_RESET_SIE` writer - force reset USB SIE, need software clear"]
        pub type UcResetSieW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UC_INT_BUSY` reader - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid"]
        pub type UcIntBusyR = crate::BitReader;
        #[doc = "Field `UC_INT_BUSY` writer - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid"]
        pub type UcIntBusyW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UC_SYS_CTRL` reader - bit mask of USB system control"]
        pub type UcSysCtrlR = crate::FieldReader;
        #[doc = "Field `UC_SYS_CTRL` writer - bit mask of USB system control"]
        pub type UcSysCtrlW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UC_DEV_PU_EN` reader - USB device enable and internal pullup resistance enable"]
        pub type UcDevPuEnR = crate::BitReader;
        #[doc = "Field `UC_DEV_PU_EN` writer - USB device enable and internal pullup resistance enable"]
        pub type UcDevPuEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UC_LOW_SPEED` reader - enable USB low speed: 0=12Mbps, 1=1.5Mbps"]
        pub type UcLowSpeedR = crate::BitReader;
        #[doc = "Field `UC_LOW_SPEED` writer - enable USB low speed: 0=12Mbps, 1=1.5Mbps"]
        pub type UcLowSpeedW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UC_HOST_MODE` reader - enable USB host mode: 0=device mode, 1=host mode"]
        pub type UcHostModeR = crate::BitReader;
        #[doc = "Field `UC_HOST_MODE` writer - enable USB host mode: 0=device mode, 1=host mode"]
        pub type UcHostModeW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - DMA enable and DMA interrupt enable for USB"]
            #[inline(always)]
            pub fn uc_dma_en(&self) -> UcDmaEnR {
                UcDmaEnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - force clear FIFO and count of USB"]
            #[inline(always)]
            pub fn uc_clr_all(&self) -> UcClrAllR {
                UcClrAllR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - force reset USB SIE, need software clear"]
            #[inline(always)]
            pub fn uc_reset_sie(&self) -> UcResetSieR {
                UcResetSieR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid"]
            #[inline(always)]
            pub fn uc_int_busy(&self) -> UcIntBusyR {
                UcIntBusyR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bits 4:5 - bit mask of USB system control"]
            #[inline(always)]
            pub fn uc_sys_ctrl(&self) -> UcSysCtrlR {
                UcSysCtrlR::new((self.bits >> 4) & 3)
            }
            #[doc = "Bit 5 - USB device enable and internal pullup resistance enable"]
            #[inline(always)]
            pub fn uc_dev_pu_en(&self) -> UcDevPuEnR {
                UcDevPuEnR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps"]
            #[inline(always)]
            pub fn uc_low_speed(&self) -> UcLowSpeedR {
                UcLowSpeedR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - enable USB host mode: 0=device mode, 1=host mode"]
            #[inline(always)]
            pub fn uc_host_mode(&self) -> UcHostModeR {
                UcHostModeR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - DMA enable and DMA interrupt enable for USB"]
            #[inline(always)]
            pub fn uc_dma_en(&mut self) -> UcDmaEnW<CtrlSpec> {
                UcDmaEnW::new(self, 0)
            }
            #[doc = "Bit 1 - force clear FIFO and count of USB"]
            #[inline(always)]
            pub fn uc_clr_all(&mut self) -> UcClrAllW<CtrlSpec> {
                UcClrAllW::new(self, 1)
            }
            #[doc = "Bit 2 - force reset USB SIE, need software clear"]
            #[inline(always)]
            pub fn uc_reset_sie(&mut self) -> UcResetSieW<CtrlSpec> {
                UcResetSieW::new(self, 2)
            }
            #[doc = "Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid"]
            #[inline(always)]
            pub fn uc_int_busy(&mut self) -> UcIntBusyW<CtrlSpec> {
                UcIntBusyW::new(self, 3)
            }
            #[doc = "Bits 4:5 - bit mask of USB system control"]
            #[inline(always)]
            pub fn uc_sys_ctrl(&mut self) -> UcSysCtrlW<CtrlSpec> {
                UcSysCtrlW::new(self, 4)
            }
            #[doc = "Bit 5 - USB device enable and internal pullup resistance enable"]
            #[inline(always)]
            pub fn uc_dev_pu_en(&mut self) -> UcDevPuEnW<CtrlSpec> {
                UcDevPuEnW::new(self, 5)
            }
            #[doc = "Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps"]
            #[inline(always)]
            pub fn uc_low_speed(&mut self) -> UcLowSpeedW<CtrlSpec> {
                UcLowSpeedW::new(self, 6)
            }
            #[doc = "Bit 7 - enable USB host mode: 0=device mode, 1=host mode"]
            #[inline(always)]
            pub fn uc_host_mode(&mut self) -> UcHostModeW<CtrlSpec> {
                UcHostModeW::new(self, 7)
            }
        }
        #[doc = "USB2 base control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CtrlSpec;
        impl crate::RegisterSpec for CtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`ctrl::R`](R) reader structure"]
        impl crate::Readable for CtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"]
        impl crate::Writable for CtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CTRL to value 0x06"]
        impl crate::Resettable for CtrlSpec {
            const RESET_VALUE: u8 = 0x06;
        }
    }
    #[doc = "U2DEV_CTRL (rw) register accessor: USB2 device physical prot control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2dev_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2dev_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2dev_ctrl`] module"]
    #[doc(alias = "U2DEV_CTRL")]
    pub type U2devCtrl = crate::Reg<u2dev_ctrl::U2devCtrlSpec>;
    #[doc = "USB2 device physical prot control"]
    pub mod u2dev_ctrl {
        #[doc = "Register `U2DEV_CTRL` reader"]
        pub type R = crate::R<U2devCtrlSpec>;
        #[doc = "Register `U2DEV_CTRL` writer"]
        pub type W = crate::W<U2devCtrlSpec>;
        #[doc = "Field `UD_PORT_EN` reader - enable USB physical port I-O: 0=disable, 1=enable"]
        pub type UdPortEnR = crate::BitReader;
        #[doc = "Field `UD_PORT_EN` writer - enable USB physical port I-O: 0=disable, 1=enable"]
        pub type UdPortEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UD_GP_BIT` reader - general purpose bit"]
        pub type UdGpBitR = crate::BitReader;
        #[doc = "Field `UD_GP_BIT` writer - general purpose bit"]
        pub type UdGpBitW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UD_LOW_SPEED` reader - enable USB physical port low speed: 0=full speed, 1=low speed"]
        pub type UdLowSpeedR = crate::BitReader;
        #[doc = "Field `UD_LOW_SPEED` writer - enable USB physical port low speed: 0=full speed, 1=low speed"]
        pub type UdLowSpeedW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UD_DM_PIN` reader - ReadOnly: indicate current UDM pin level"]
        pub type UdDmPinR = crate::BitReader;
        #[doc = "Field `UD_DP_PIN` reader - ReadOnly: indicate current UDP pin level"]
        pub type UdDpPinR = crate::BitReader;
        #[doc = "Field `UD_PD_DIS` reader - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable"]
        pub type UdPdDisR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - enable USB physical port I-O: 0=disable, 1=enable"]
            #[inline(always)]
            pub fn ud_port_en(&self) -> UdPortEnR {
                UdPortEnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - general purpose bit"]
            #[inline(always)]
            pub fn ud_gp_bit(&self) -> UdGpBitR {
                UdGpBitR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed"]
            #[inline(always)]
            pub fn ud_low_speed(&self) -> UdLowSpeedR {
                UdLowSpeedR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 4 - ReadOnly: indicate current UDM pin level"]
            #[inline(always)]
            pub fn ud_dm_pin(&self) -> UdDmPinR {
                UdDmPinR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - ReadOnly: indicate current UDP pin level"]
            #[inline(always)]
            pub fn ud_dp_pin(&self) -> UdDpPinR {
                UdDpPinR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 7 - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable"]
            #[inline(always)]
            pub fn ud_pd_dis(&self) -> UdPdDisR {
                UdPdDisR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - enable USB physical port I-O: 0=disable, 1=enable"]
            #[inline(always)]
            pub fn ud_port_en(&mut self) -> UdPortEnW<U2devCtrlSpec> {
                UdPortEnW::new(self, 0)
            }
            #[doc = "Bit 1 - general purpose bit"]
            #[inline(always)]
            pub fn ud_gp_bit(&mut self) -> UdGpBitW<U2devCtrlSpec> {
                UdGpBitW::new(self, 1)
            }
            #[doc = "Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed"]
            #[inline(always)]
            pub fn ud_low_speed(&mut self) -> UdLowSpeedW<U2devCtrlSpec> {
                UdLowSpeedW::new(self, 2)
            }
        }
        #[doc = "USB2 device physical prot control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2dev_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2dev_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2devCtrlSpec;
        impl crate::RegisterSpec for U2devCtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2dev_ctrl::R`](R) reader structure"]
        impl crate::Readable for U2devCtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2dev_ctrl::W`](W) writer structure"]
        impl crate::Writable for U2devCtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2DEV_CTRL to value 0"]
        impl crate::Resettable for U2devCtrlSpec {}
    }
    #[doc = "U2HOST_CTRL (rw) register accessor: USB2 device physical prot control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2host_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2host_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2host_ctrl`] module"]
    #[doc(alias = "U2HOST_CTRL")]
    pub type U2hostCtrl = crate::Reg<u2host_ctrl::U2hostCtrlSpec>;
    #[doc = "USB2 device physical prot control"]
    pub mod u2host_ctrl {
        #[doc = "Register `U2HOST_CTRL` reader"]
        pub type R = crate::R<U2hostCtrlSpec>;
        #[doc = "Register `U2HOST_CTRL` writer"]
        pub type W = crate::W<U2hostCtrlSpec>;
        #[doc = "Field `UH_PORT_EN` reader - enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached"]
        pub type UhPortEnR = crate::BitReader;
        #[doc = "Field `UH_PORT_EN` writer - enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached"]
        pub type UhPortEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UH_BUS_RESET` reader - control USB bus reset: 0=normal, 1=force bus reset"]
        pub type UhBusResetR = crate::BitReader;
        #[doc = "Field `UH_BUS_RESET` writer - control USB bus reset: 0=normal, 1=force bus reset"]
        pub type UhBusResetW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UH_LOW_SPEED` reader - enable USB port low speed: 0=full speed, 1=low speed"]
        pub type UhLowSpeedR = crate::BitReader;
        #[doc = "Field `UH_LOW_SPEED` writer - enable USB port low speed: 0=full speed, 1=low speed"]
        pub type UhLowSpeedW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UH_DM_PIN` reader - ReadOnly: indicate current UDM pin level"]
        pub type UhDmPinR = crate::BitReader;
        #[doc = "Field `UH_DP_PIN` reader - ReadOnly: indicate current UDP pin level"]
        pub type UhDpPinR = crate::BitReader;
        #[doc = "Field `UH_PD_DIS` reader - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable"]
        pub type UhPdDisR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached"]
            #[inline(always)]
            pub fn uh_port_en(&self) -> UhPortEnR {
                UhPortEnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - control USB bus reset: 0=normal, 1=force bus reset"]
            #[inline(always)]
            pub fn uh_bus_reset(&self) -> UhBusResetR {
                UhBusResetR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - enable USB port low speed: 0=full speed, 1=low speed"]
            #[inline(always)]
            pub fn uh_low_speed(&self) -> UhLowSpeedR {
                UhLowSpeedR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 4 - ReadOnly: indicate current UDM pin level"]
            #[inline(always)]
            pub fn uh_dm_pin(&self) -> UhDmPinR {
                UhDmPinR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - ReadOnly: indicate current UDP pin level"]
            #[inline(always)]
            pub fn uh_dp_pin(&self) -> UhDpPinR {
                UhDpPinR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 7 - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable"]
            #[inline(always)]
            pub fn uh_pd_dis(&self) -> UhPdDisR {
                UhPdDisR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached"]
            #[inline(always)]
            pub fn uh_port_en(&mut self) -> UhPortEnW<U2hostCtrlSpec> {
                UhPortEnW::new(self, 0)
            }
            #[doc = "Bit 1 - control USB bus reset: 0=normal, 1=force bus reset"]
            #[inline(always)]
            pub fn uh_bus_reset(&mut self) -> UhBusResetW<U2hostCtrlSpec> {
                UhBusResetW::new(self, 1)
            }
            #[doc = "Bit 2 - enable USB port low speed: 0=full speed, 1=low speed"]
            #[inline(always)]
            pub fn uh_low_speed(&mut self) -> UhLowSpeedW<U2hostCtrlSpec> {
                UhLowSpeedW::new(self, 2)
            }
        }
        #[doc = "USB2 device physical prot control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2host_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2host_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2hostCtrlSpec;
        impl crate::RegisterSpec for U2hostCtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2host_ctrl::R`](R) reader structure"]
        impl crate::Readable for U2hostCtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2host_ctrl::W`](W) writer structure"]
        impl crate::Writable for U2hostCtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2HOST_CTRL to value 0"]
        impl crate::Resettable for U2hostCtrlSpec {}
    }
    #[doc = "INT_EN (rw) register accessor: USB2 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`int_en::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_en::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_en`] module"]
    #[doc(alias = "INT_EN")]
    pub type IntEn = crate::Reg<int_en::IntEnSpec>;
    #[doc = "USB2 interrupt enable"]
    pub mod int_en {
        #[doc = "Register `INT_EN` reader"]
        pub type R = crate::R<IntEnSpec>;
        #[doc = "Register `INT_EN` writer"]
        pub type W = crate::W<IntEnSpec>;
        #[doc = "Field `UIE_BUS_RST` reader - enable interrupt for USB bus reset event for USB device mode"]
        pub type UieBusRstR = crate::BitReader;
        #[doc = "Field `UIE_BUS_RST` writer - enable interrupt for USB bus reset event for USB device mode"]
        pub type UieBusRstW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UIE_DETECT` reader - enable interrupt for USB device detected event for USB host mode"]
        pub type UieDetectR = crate::BitReader;
        #[doc = "Field `UIE_DETECT` writer - enable interrupt for USB device detected event for USB host mode"]
        pub type UieDetectW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UIE_TRANSFER` reader - enable interrupt for USB transfer completion"]
        pub type UieTransferR = crate::BitReader;
        #[doc = "Field `UIE_TRANSFER` writer - enable interrupt for USB transfer completion"]
        pub type UieTransferW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UIE_SUSPEND` reader - enable interrupt for USB suspend or resume event"]
        pub type UieSuspendR = crate::BitReader;
        #[doc = "Field `UIE_SUSPEND` writer - enable interrupt for USB suspend or resume event"]
        pub type UieSuspendW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UIE_HST_SOF` reader - enable interrupt for host SOF timer action for USB host mode"]
        pub type UieHstSofR = crate::BitReader;
        #[doc = "Field `UIE_HST_SOF` writer - enable interrupt for host SOF timer action for USB host mode"]
        pub type UieHstSofW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UIE_FIFO_OV` reader - enable interrupt for FIFO overflow"]
        pub type UieFifoOvR = crate::BitReader;
        #[doc = "Field `UIE_FIFO_OV` writer - enable interrupt for FIFO overflow"]
        pub type UieFifoOvW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UIE_DEV_NAK` reader - enable interrupt for NAK responded for USB device mode"]
        pub type UieDevNakR = crate::BitReader;
        #[doc = "Field `UIE_DEV_NAK` writer - enable interrupt for NAK responded for USB device mode"]
        pub type UieDevNakW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - enable interrupt for USB bus reset event for USB device mode"]
            #[inline(always)]
            pub fn uie_bus_rst(&self) -> UieBusRstR {
                UieBusRstR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 0 - enable interrupt for USB device detected event for USB host mode"]
            #[inline(always)]
            pub fn uie_detect(&self) -> UieDetectR {
                UieDetectR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - enable interrupt for USB transfer completion"]
            #[inline(always)]
            pub fn uie_transfer(&self) -> UieTransferR {
                UieTransferR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - enable interrupt for USB suspend or resume event"]
            #[inline(always)]
            pub fn uie_suspend(&self) -> UieSuspendR {
                UieSuspendR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - enable interrupt for host SOF timer action for USB host mode"]
            #[inline(always)]
            pub fn uie_hst_sof(&self) -> UieHstSofR {
                UieHstSofR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - enable interrupt for FIFO overflow"]
            #[inline(always)]
            pub fn uie_fifo_ov(&self) -> UieFifoOvR {
                UieFifoOvR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - enable interrupt for NAK responded for USB device mode"]
            #[inline(always)]
            pub fn uie_dev_nak(&self) -> UieDevNakR {
                UieDevNakR::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - enable interrupt for USB bus reset event for USB device mode"]
            #[inline(always)]
            pub fn uie_bus_rst(&mut self) -> UieBusRstW<IntEnSpec> {
                UieBusRstW::new(self, 0)
            }
            #[doc = "Bit 0 - enable interrupt for USB device detected event for USB host mode"]
            #[inline(always)]
            pub fn uie_detect(&mut self) -> UieDetectW<IntEnSpec> {
                UieDetectW::new(self, 0)
            }
            #[doc = "Bit 1 - enable interrupt for USB transfer completion"]
            #[inline(always)]
            pub fn uie_transfer(&mut self) -> UieTransferW<IntEnSpec> {
                UieTransferW::new(self, 1)
            }
            #[doc = "Bit 2 - enable interrupt for USB suspend or resume event"]
            #[inline(always)]
            pub fn uie_suspend(&mut self) -> UieSuspendW<IntEnSpec> {
                UieSuspendW::new(self, 2)
            }
            #[doc = "Bit 3 - enable interrupt for host SOF timer action for USB host mode"]
            #[inline(always)]
            pub fn uie_hst_sof(&mut self) -> UieHstSofW<IntEnSpec> {
                UieHstSofW::new(self, 3)
            }
            #[doc = "Bit 4 - enable interrupt for FIFO overflow"]
            #[inline(always)]
            pub fn uie_fifo_ov(&mut self) -> UieFifoOvW<IntEnSpec> {
                UieFifoOvW::new(self, 4)
            }
            #[doc = "Bit 6 - enable interrupt for NAK responded for USB device mode"]
            #[inline(always)]
            pub fn uie_dev_nak(&mut self) -> UieDevNakW<IntEnSpec> {
                UieDevNakW::new(self, 6)
            }
        }
        #[doc = "USB2 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`int_en::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_en::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IntEnSpec;
        impl crate::RegisterSpec for IntEnSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`int_en::R`](R) reader structure"]
        impl crate::Readable for IntEnSpec {}
        #[doc = "`write(|w| ..)` method takes [`int_en::W`](W) writer structure"]
        impl crate::Writable for IntEnSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets INT_EN to value 0"]
        impl crate::Resettable for IntEnSpec {}
    }
    #[doc = "DEV_AD (rw) register accessor: USB2 device address\n\nYou can [`read`](crate::Reg::read) this register and get [`dev_ad::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dev_ad::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dev_ad`] module"]
    #[doc(alias = "DEV_AD")]
    pub type DevAd = crate::Reg<dev_ad::DevAdSpec>;
    #[doc = "USB2 device address"]
    pub mod dev_ad {
        #[doc = "Register `DEV_AD` reader"]
        pub type R = crate::R<DevAdSpec>;
        #[doc = "Register `DEV_AD` writer"]
        pub type W = crate::W<DevAdSpec>;
        #[doc = "Field `USB_ADDR` reader - bit mask for USB device address"]
        pub type UsbAddrR = crate::FieldReader;
        #[doc = "Field `USB_ADDR` writer - bit mask for USB device address"]
        pub type UsbAddrW<'a, REG> = crate::FieldWriter<'a, REG, 7>;
        #[doc = "Field `UDA_GP_BIT` reader - general purpose bit"]
        pub type UdaGpBitR = crate::BitReader;
        #[doc = "Field `UDA_GP_BIT` writer - general purpose bit"]
        pub type UdaGpBitW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:6 - bit mask for USB device address"]
            #[inline(always)]
            pub fn usb_addr(&self) -> UsbAddrR {
                UsbAddrR::new(self.bits & 0x7f)
            }
            #[doc = "Bit 7 - general purpose bit"]
            #[inline(always)]
            pub fn uda_gp_bit(&self) -> UdaGpBitR {
                UdaGpBitR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:6 - bit mask for USB device address"]
            #[inline(always)]
            pub fn usb_addr(&mut self) -> UsbAddrW<DevAdSpec> {
                UsbAddrW::new(self, 0)
            }
            #[doc = "Bit 7 - general purpose bit"]
            #[inline(always)]
            pub fn uda_gp_bit(&mut self) -> UdaGpBitW<DevAdSpec> {
                UdaGpBitW::new(self, 7)
            }
        }
        #[doc = "USB2 device address\n\nYou can [`read`](crate::Reg::read) this register and get [`dev_ad::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dev_ad::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct DevAdSpec;
        impl crate::RegisterSpec for DevAdSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`dev_ad::R`](R) reader structure"]
        impl crate::Readable for DevAdSpec {}
        #[doc = "`write(|w| ..)` method takes [`dev_ad::W`](W) writer structure"]
        impl crate::Writable for DevAdSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets DEV_AD to value 0"]
        impl crate::Resettable for DevAdSpec {}
    }
    #[doc = "MIS_ST (r) register accessor: USB2 miscellaneous status\n\nYou can [`read`](crate::Reg::read) this register and get [`mis_st::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mis_st`] module"]
    #[doc(alias = "MIS_ST")]
    pub type MisSt = crate::Reg<mis_st::MisStSpec>;
    #[doc = "USB2 miscellaneous status"]
    pub mod mis_st {
        #[doc = "Register `MIS_ST` reader"]
        pub type R = crate::R<MisStSpec>;
        #[doc = "Field `UMS_DEV_ATTACH` reader - RO, indicate device attached status on USB host"]
        pub type UmsDevAttachR = crate::BitReader;
        #[doc = "Field `UMS_DM_LEVEL` reader - RO, indicate UDM level saved at device attached to USB host"]
        pub type UmsDmLevelR = crate::BitReader;
        #[doc = "Field `UMS_SUSPEND` reader - RO, indicate USB suspend status"]
        pub type UmsSuspendR = crate::BitReader;
        #[doc = "Field `UMS_BUS_RESET` reader - RO, indicate USB bus reset status"]
        pub type UmsBusResetR = crate::BitReader;
        #[doc = "Field `UMS_R_FIFO_RDY` reader - RO, indicate USB receiving FIFO ready status (not empty)"]
        pub type UmsRFifoRdyR = crate::BitReader;
        #[doc = "Field `UMS_SIE_FREE` reader - RO, indicate USB SIE free status"]
        pub type UmsSieFreeR = crate::BitReader;
        #[doc = "Field `UMS_SOF_ACT` reader - RO, indicate host SOF timer action status for USB host"]
        pub type UmsSofActR = crate::BitReader;
        #[doc = "Field `UMS_SOF_PRES` reader - RO, indicate host SOF timer presage status"]
        pub type UmsSofPresR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - RO, indicate device attached status on USB host"]
            #[inline(always)]
            pub fn ums_dev_attach(&self) -> UmsDevAttachR {
                UmsDevAttachR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RO, indicate UDM level saved at device attached to USB host"]
            #[inline(always)]
            pub fn ums_dm_level(&self) -> UmsDmLevelR {
                UmsDmLevelR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RO, indicate USB suspend status"]
            #[inline(always)]
            pub fn ums_suspend(&self) -> UmsSuspendR {
                UmsSuspendR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RO, indicate USB bus reset status"]
            #[inline(always)]
            pub fn ums_bus_reset(&self) -> UmsBusResetR {
                UmsBusResetR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RO, indicate USB receiving FIFO ready status (not empty)"]
            #[inline(always)]
            pub fn ums_r_fifo_rdy(&self) -> UmsRFifoRdyR {
                UmsRFifoRdyR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RO, indicate USB SIE free status"]
            #[inline(always)]
            pub fn ums_sie_free(&self) -> UmsSieFreeR {
                UmsSieFreeR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RO, indicate host SOF timer action status for USB host"]
            #[inline(always)]
            pub fn ums_sof_act(&self) -> UmsSofActR {
                UmsSofActR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RO, indicate host SOF timer presage status"]
            #[inline(always)]
            pub fn ums_sof_pres(&self) -> UmsSofPresR {
                UmsSofPresR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        #[doc = "USB2 miscellaneous status\n\nYou can [`read`](crate::Reg::read) this register and get [`mis_st::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct MisStSpec;
        impl crate::RegisterSpec for MisStSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`mis_st::R`](R) reader structure"]
        impl crate::Readable for MisStSpec {}
        #[doc = "`reset()` method sets MIS_ST to value 0"]
        impl crate::Resettable for MisStSpec {}
    }
    #[doc = "INT_FG (rw) register accessor: USB2 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_fg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_fg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_fg`] module"]
    #[doc(alias = "INT_FG")]
    pub type IntFg = crate::Reg<int_fg::IntFgSpec>;
    #[doc = "USB2 interrupt flag"]
    pub mod int_fg {
        #[doc = "Register `INT_FG` reader"]
        pub type R = crate::R<IntFgSpec>;
        #[doc = "Register `INT_FG` writer"]
        pub type W = crate::W<IntFgSpec>;
        #[doc = "Field `UIF_BUS_RST` reader - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear"]
        pub type UifBusRstR = crate::BitReader;
        #[doc = "Field `UIF_BUS_RST` writer - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear"]
        pub type UifBusRstW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UIF_DETECT` reader - RW,device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear"]
        pub type UifDetectR = crate::BitReader;
        #[doc = "Field `UIF_DETECT` writer - RW,device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear"]
        pub type UifDetectW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UIF_TRANSFER` reader - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear"]
        pub type UifTransferR = crate::BitReader;
        #[doc = "Field `UIF_TRANSFER` writer - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear"]
        pub type UifTransferW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UIF_SUSPEND` reader - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear"]
        pub type UifSuspendR = crate::BitReader;
        #[doc = "Field `UIF_SUSPEND` writer - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear"]
        pub type UifSuspendW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UIF_HST_SOF` reader - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear"]
        pub type UifHstSofR = crate::BitReader;
        #[doc = "Field `UIF_HST_SOF` writer - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear"]
        pub type UifHstSofW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UIF_FIFO_OV` reader - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear"]
        pub type UifFifoOvR = crate::BitReader;
        #[doc = "Field `UIF_FIFO_OV` writer - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear"]
        pub type UifFifoOvW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `U_SIE_FREE` reader - RO, indicate USB SIE free status"]
        pub type USieFreeR = crate::BitReader;
        #[doc = "Field `U_TOG_OK` reader - RO, indicate current USB transfer toggle is OK"]
        pub type UTogOkR = crate::BitReader;
        #[doc = "Field `U_IS_NAK` reader - RO, indicate current USB transfer is NAK received"]
        pub type UIsNakR = crate::BitReader;
        impl R {
            #[doc = "Bit 0 - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear"]
            #[inline(always)]
            pub fn uif_bus_rst(&self) -> UifBusRstR {
                UifBusRstR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 0 - RW,device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear"]
            #[inline(always)]
            pub fn uif_detect(&self) -> UifDetectR {
                UifDetectR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear"]
            #[inline(always)]
            pub fn uif_transfer(&self) -> UifTransferR {
                UifTransferR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear"]
            #[inline(always)]
            pub fn uif_suspend(&self) -> UifSuspendR {
                UifSuspendR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear"]
            #[inline(always)]
            pub fn uif_hst_sof(&self) -> UifHstSofR {
                UifHstSofR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear"]
            #[inline(always)]
            pub fn uif_fifo_ov(&self) -> UifFifoOvR {
                UifFifoOvR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - RO, indicate USB SIE free status"]
            #[inline(always)]
            pub fn u_sie_free(&self) -> USieFreeR {
                USieFreeR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 6 - RO, indicate current USB transfer toggle is OK"]
            #[inline(always)]
            pub fn u_tog_ok(&self) -> UTogOkR {
                UTogOkR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RO, indicate current USB transfer is NAK received"]
            #[inline(always)]
            pub fn u_is_nak(&self) -> UIsNakR {
                UIsNakR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear"]
            #[inline(always)]
            pub fn uif_bus_rst(&mut self) -> UifBusRstW<IntFgSpec> {
                UifBusRstW::new(self, 0)
            }
            #[doc = "Bit 0 - RW,device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear"]
            #[inline(always)]
            pub fn uif_detect(&mut self) -> UifDetectW<IntFgSpec> {
                UifDetectW::new(self, 0)
            }
            #[doc = "Bit 1 - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear"]
            #[inline(always)]
            pub fn uif_transfer(&mut self) -> UifTransferW<IntFgSpec> {
                UifTransferW::new(self, 1)
            }
            #[doc = "Bit 2 - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear"]
            #[inline(always)]
            pub fn uif_suspend(&mut self) -> UifSuspendW<IntFgSpec> {
                UifSuspendW::new(self, 2)
            }
            #[doc = "Bit 3 - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear"]
            #[inline(always)]
            pub fn uif_hst_sof(&mut self) -> UifHstSofW<IntFgSpec> {
                UifHstSofW::new(self, 3)
            }
            #[doc = "Bit 4 - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear"]
            #[inline(always)]
            pub fn uif_fifo_ov(&mut self) -> UifFifoOvW<IntFgSpec> {
                UifFifoOvW::new(self, 4)
            }
        }
        #[doc = "USB2 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_fg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_fg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IntFgSpec;
        impl crate::RegisterSpec for IntFgSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`int_fg::R`](R) reader structure"]
        impl crate::Readable for IntFgSpec {}
        #[doc = "`write(|w| ..)` method takes [`int_fg::W`](W) writer structure"]
        impl crate::Writable for IntFgSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets INT_FG to value 0x20"]
        impl crate::Resettable for IntFgSpec {
            const RESET_VALUE: u8 = 0x20;
        }
    }
    #[doc = "INT_ST (r) register accessor: USB2 interrupt status\n\nYou can [`read`](crate::Reg::read) this register and get [`int_st::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_st`] module"]
    #[doc(alias = "INT_ST")]
    pub type IntSt = crate::Reg<int_st::IntStSpec>;
    #[doc = "USB2 interrupt status"]
    pub mod int_st {
        #[doc = "Register `INT_ST` reader"]
        pub type R = crate::R<IntStSpec>;
        #[doc = "Field `UIS_H_RES` reader - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received"]
        pub type UisHResR = crate::FieldReader;
        #[doc = "Field `UIS_ENDP` reader - RO, bit mask of current transfer endpoint number for USB device mode"]
        pub type UisEndpR = crate::FieldReader;
        #[doc = "Field `UIS_TOKEN` reader - RO, bit mask of current token PID code received for USB device mode"]
        pub type UisTokenR = crate::FieldReader;
        #[doc = "Field `UIS_TOG_OK` reader - RO, indicate current USB transfer toggle is OK"]
        pub type UisTogOkR = crate::BitReader;
        #[doc = "Field `UIS_SETUP_ACT` reader - RO, indicate current USB transfer is NAK received for USB device mode"]
        pub type UisSetupActR = crate::BitReader;
        impl R {
            #[doc = "Bits 0:3 - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received"]
            #[inline(always)]
            pub fn uis_h_res(&self) -> UisHResR {
                UisHResR::new(self.bits & 0x0f)
            }
            #[doc = "Bits 0:3 - RO, bit mask of current transfer endpoint number for USB device mode"]
            #[inline(always)]
            pub fn uis_endp(&self) -> UisEndpR {
                UisEndpR::new(self.bits & 0x0f)
            }
            #[doc = "Bits 4:5 - RO, bit mask of current token PID code received for USB device mode"]
            #[inline(always)]
            pub fn uis_token(&self) -> UisTokenR {
                UisTokenR::new((self.bits >> 4) & 3)
            }
            #[doc = "Bit 6 - RO, indicate current USB transfer toggle is OK"]
            #[inline(always)]
            pub fn uis_tog_ok(&self) -> UisTogOkR {
                UisTogOkR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - RO, indicate current USB transfer is NAK received for USB device mode"]
            #[inline(always)]
            pub fn uis_setup_act(&self) -> UisSetupActR {
                UisSetupActR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        #[doc = "USB2 interrupt status\n\nYou can [`read`](crate::Reg::read) this register and get [`int_st::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IntStSpec;
        impl crate::RegisterSpec for IntStSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`int_st::R`](R) reader structure"]
        impl crate::Readable for IntStSpec {}
        #[doc = "`reset()` method sets INT_ST to value 0"]
        impl crate::Resettable for IntStSpec {}
    }
    #[doc = "RX_LEN (r) register accessor: USB2 receiving length\n\nYou can [`read`](crate::Reg::read) this register and get [`rx_len::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rx_len`] module"]
    #[doc(alias = "RX_LEN")]
    pub type RxLen = crate::Reg<rx_len::RxLenSpec>;
    #[doc = "USB2 receiving length"]
    pub mod rx_len {
        #[doc = "Register `RX_LEN` reader"]
        pub type R = crate::R<RxLenSpec>;
        #[doc = "Field `USB_RX_LEN` reader - RO,USB receiving length"]
        pub type UsbRxLenR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:7 - RO,USB receiving length"]
            #[inline(always)]
            pub fn usb_rx_len(&self) -> UsbRxLenR {
                UsbRxLenR::new(self.bits)
            }
        }
        #[doc = "USB2 receiving length\n\nYou can [`read`](crate::Reg::read) this register and get [`rx_len::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct RxLenSpec;
        impl crate::RegisterSpec for RxLenSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`rx_len::R`](R) reader structure"]
        impl crate::Readable for RxLenSpec {}
        #[doc = "`reset()` method sets RX_LEN to value 0"]
        impl crate::Resettable for RxLenSpec {}
    }
    #[doc = "U2EP4_1_MOD (rw) register accessor: endpoint 4/1 mode\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep4_1_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep4_1_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep4_1_mod`] module"]
    #[doc(alias = "U2EP4_1_MOD")]
    pub type U2ep4_1Mod = crate::Reg<u2ep4_1_mod::U2ep4_1ModSpec>;
    #[doc = "endpoint 4/1 mode"]
    pub mod u2ep4_1_mod {
        #[doc = "Register `U2EP4_1_MOD` reader"]
        pub type R = crate::R<U2ep4_1ModSpec>;
        #[doc = "Register `U2EP4_1_MOD` writer"]
        pub type W = crate::W<U2ep4_1ModSpec>;
        #[doc = "Field `UEP4_TX_EN` reader - enable USB endpoint 4 transmittal (IN)"]
        pub type Uep4TxEnR = crate::BitReader;
        #[doc = "Field `UEP4_TX_EN` writer - enable USB endpoint 4 transmittal (IN)"]
        pub type Uep4TxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP4_RX_EN` reader - enable USB endpoint 4 receiving (OUT)"]
        pub type Uep4RxEnR = crate::BitReader;
        #[doc = "Field `UEP4_RX_EN` writer - enable USB endpoint 4 receiving (OUT)"]
        pub type Uep4RxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP1_BUF_MOD` reader - buffer mode of USB endpoint 1"]
        pub type Uep1BufModR = crate::BitReader;
        #[doc = "Field `UEP1_BUF_MOD` writer - buffer mode of USB endpoint 1"]
        pub type Uep1BufModW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP1_TX_EN` reader - enable USB endpoint 1 transmittal (IN)"]
        pub type Uep1TxEnR = crate::BitReader;
        #[doc = "Field `UEP1_TX_EN` writer - enable USB endpoint 1 transmittal (IN)"]
        pub type Uep1TxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP1_RX_EN` reader - enable USB endpoint 1 receiving (OUT)"]
        pub type Uep1RxEnR = crate::BitReader;
        #[doc = "Field `UEP1_RX_EN` writer - enable USB endpoint 1 receiving (OUT)"]
        pub type Uep1RxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 2 - enable USB endpoint 4 transmittal (IN)"]
            #[inline(always)]
            pub fn uep4_tx_en(&self) -> Uep4TxEnR {
                Uep4TxEnR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - enable USB endpoint 4 receiving (OUT)"]
            #[inline(always)]
            pub fn uep4_rx_en(&self) -> Uep4RxEnR {
                Uep4RxEnR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - buffer mode of USB endpoint 1"]
            #[inline(always)]
            pub fn uep1_buf_mod(&self) -> Uep1BufModR {
                Uep1BufModR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - enable USB endpoint 1 transmittal (IN)"]
            #[inline(always)]
            pub fn uep1_tx_en(&self) -> Uep1TxEnR {
                Uep1TxEnR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - enable USB endpoint 1 receiving (OUT)"]
            #[inline(always)]
            pub fn uep1_rx_en(&self) -> Uep1RxEnR {
                Uep1RxEnR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 2 - enable USB endpoint 4 transmittal (IN)"]
            #[inline(always)]
            pub fn uep4_tx_en(&mut self) -> Uep4TxEnW<U2ep4_1ModSpec> {
                Uep4TxEnW::new(self, 2)
            }
            #[doc = "Bit 3 - enable USB endpoint 4 receiving (OUT)"]
            #[inline(always)]
            pub fn uep4_rx_en(&mut self) -> Uep4RxEnW<U2ep4_1ModSpec> {
                Uep4RxEnW::new(self, 3)
            }
            #[doc = "Bit 4 - buffer mode of USB endpoint 1"]
            #[inline(always)]
            pub fn uep1_buf_mod(&mut self) -> Uep1BufModW<U2ep4_1ModSpec> {
                Uep1BufModW::new(self, 4)
            }
            #[doc = "Bit 6 - enable USB endpoint 1 transmittal (IN)"]
            #[inline(always)]
            pub fn uep1_tx_en(&mut self) -> Uep1TxEnW<U2ep4_1ModSpec> {
                Uep1TxEnW::new(self, 6)
            }
            #[doc = "Bit 7 - enable USB endpoint 1 receiving (OUT)"]
            #[inline(always)]
            pub fn uep1_rx_en(&mut self) -> Uep1RxEnW<U2ep4_1ModSpec> {
                Uep1RxEnW::new(self, 7)
            }
        }
        #[doc = "endpoint 4/1 mode\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep4_1_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep4_1_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep4_1ModSpec;
        impl crate::RegisterSpec for U2ep4_1ModSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2ep4_1_mod::R`](R) reader structure"]
        impl crate::Readable for U2ep4_1ModSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep4_1_mod::W`](W) writer structure"]
        impl crate::Writable for U2ep4_1ModSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP4_1_MOD to value 0"]
        impl crate::Resettable for U2ep4_1ModSpec {}
    }
    #[doc = "U2EP2_3_MOD (rw) register accessor: endpoint 2_3 mode\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep2_3_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep2_3_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep2_3_mod`] module"]
    #[doc(alias = "U2EP2_3_MOD")]
    pub type U2ep2_3Mod = crate::Reg<u2ep2_3_mod::U2ep2_3ModSpec>;
    #[doc = "endpoint 2_3 mode"]
    pub mod u2ep2_3_mod {
        #[doc = "Register `U2EP2_3_MOD` reader"]
        pub type R = crate::R<U2ep2_3ModSpec>;
        #[doc = "Register `U2EP2_3_MOD` writer"]
        pub type W = crate::W<U2ep2_3ModSpec>;
        #[doc = "Field `UEP2_BUF_MOD` reader - buffer mode of USB endpoint 2"]
        pub type Uep2BufModR = crate::BitReader;
        #[doc = "Field `UEP2_BUF_MOD` writer - buffer mode of USB endpoint 2"]
        pub type Uep2BufModW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP2_TX_EN` reader - enable USB endpoint 2 transmittal (IN)"]
        pub type Uep2TxEnR = crate::BitReader;
        #[doc = "Field `UEP2_TX_EN` writer - enable USB endpoint 2 transmittal (IN)"]
        pub type Uep2TxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP2_RX_EN` reader - enable USB endpoint 2 receiving (OUT)"]
        pub type Uep2RxEnR = crate::BitReader;
        #[doc = "Field `UEP2_RX_EN` writer - enable USB endpoint 2 receiving (OUT)"]
        pub type Uep2RxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP3_BUF_MOD` reader - buffer mode of USB endpoint 3"]
        pub type Uep3BufModR = crate::BitReader;
        #[doc = "Field `UEP3_BUF_MOD` writer - buffer mode of USB endpoint 3"]
        pub type Uep3BufModW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP3_TX_EN` reader - enable USB endpoint 3 transmittal (IN)"]
        pub type Uep3TxEnR = crate::BitReader;
        #[doc = "Field `UEP3_TX_EN` writer - enable USB endpoint 3 transmittal (IN)"]
        pub type Uep3TxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP3_RX_EN` reader - enable USB endpoint 3 receiving (OUT)"]
        pub type Uep3RxEnR = crate::BitReader;
        #[doc = "Field `UEP3_RX_EN` writer - enable USB endpoint 3 receiving (OUT)"]
        pub type Uep3RxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - buffer mode of USB endpoint 2"]
            #[inline(always)]
            pub fn uep2_buf_mod(&self) -> Uep2BufModR {
                Uep2BufModR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 2 - enable USB endpoint 2 transmittal (IN)"]
            #[inline(always)]
            pub fn uep2_tx_en(&self) -> Uep2TxEnR {
                Uep2TxEnR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - enable USB endpoint 2 receiving (OUT)"]
            #[inline(always)]
            pub fn uep2_rx_en(&self) -> Uep2RxEnR {
                Uep2RxEnR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - buffer mode of USB endpoint 3"]
            #[inline(always)]
            pub fn uep3_buf_mod(&self) -> Uep3BufModR {
                Uep3BufModR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - enable USB endpoint 3 transmittal (IN)"]
            #[inline(always)]
            pub fn uep3_tx_en(&self) -> Uep3TxEnR {
                Uep3TxEnR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - enable USB endpoint 3 receiving (OUT)"]
            #[inline(always)]
            pub fn uep3_rx_en(&self) -> Uep3RxEnR {
                Uep3RxEnR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - buffer mode of USB endpoint 2"]
            #[inline(always)]
            pub fn uep2_buf_mod(&mut self) -> Uep2BufModW<U2ep2_3ModSpec> {
                Uep2BufModW::new(self, 0)
            }
            #[doc = "Bit 2 - enable USB endpoint 2 transmittal (IN)"]
            #[inline(always)]
            pub fn uep2_tx_en(&mut self) -> Uep2TxEnW<U2ep2_3ModSpec> {
                Uep2TxEnW::new(self, 2)
            }
            #[doc = "Bit 3 - enable USB endpoint 2 receiving (OUT)"]
            #[inline(always)]
            pub fn uep2_rx_en(&mut self) -> Uep2RxEnW<U2ep2_3ModSpec> {
                Uep2RxEnW::new(self, 3)
            }
            #[doc = "Bit 4 - buffer mode of USB endpoint 3"]
            #[inline(always)]
            pub fn uep3_buf_mod(&mut self) -> Uep3BufModW<U2ep2_3ModSpec> {
                Uep3BufModW::new(self, 4)
            }
            #[doc = "Bit 6 - enable USB endpoint 3 transmittal (IN)"]
            #[inline(always)]
            pub fn uep3_tx_en(&mut self) -> Uep3TxEnW<U2ep2_3ModSpec> {
                Uep3TxEnW::new(self, 6)
            }
            #[doc = "Bit 7 - enable USB endpoint 3 receiving (OUT)"]
            #[inline(always)]
            pub fn uep3_rx_en(&mut self) -> Uep3RxEnW<U2ep2_3ModSpec> {
                Uep3RxEnW::new(self, 7)
            }
        }
        #[doc = "endpoint 2_3 mode\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep2_3_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep2_3_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep2_3ModSpec;
        impl crate::RegisterSpec for U2ep2_3ModSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2ep2_3_mod::R`](R) reader structure"]
        impl crate::Readable for U2ep2_3ModSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep2_3_mod::W`](W) writer structure"]
        impl crate::Writable for U2ep2_3ModSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP2_3_MOD to value 0"]
        impl crate::Resettable for U2ep2_3ModSpec {}
    }
    #[doc = "U2H_EP_MOD (rw) register accessor: host endpoint mode\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_ep_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_ep_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2h_ep_mod`] module"]
    #[doc(alias = "U2H_EP_MOD")]
    pub type U2hEpMod = crate::Reg<u2h_ep_mod::U2hEpModSpec>;
    #[doc = "host endpoint mode"]
    pub mod u2h_ep_mod {
        #[doc = "Register `U2H_EP_MOD` reader"]
        pub type R = crate::R<U2hEpModSpec>;
        #[doc = "Register `U2H_EP_MOD` writer"]
        pub type W = crate::W<U2hEpModSpec>;
        #[doc = "Field `UH_EP_RBUF_MOD` reader - buffer mode of USB host IN endpoint"]
        pub type UhEpRbufModR = crate::BitReader;
        #[doc = "Field `UH_EP_RBUF_MOD` writer - buffer mode of USB host IN endpoint"]
        pub type UhEpRbufModW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UH_EP_RX_EN` reader - enable USB host IN endpoint receiving"]
        pub type UhEpRxEnR = crate::BitReader;
        #[doc = "Field `UH_EP_RX_EN` writer - enable USB host IN endpoint receiving"]
        pub type UhEpRxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UH_EP_TBUF_MOD` reader - buffer mode of USB host OUT endpoint"]
        pub type UhEpTbufModR = crate::BitReader;
        #[doc = "Field `UH_EP_TBUF_MOD` writer - buffer mode of USB host OUT endpoint"]
        pub type UhEpTbufModW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UH_EP_TX_EN` reader - enable USB host OUT endpoint transmittal"]
        pub type UhEpTxEnR = crate::BitReader;
        #[doc = "Field `UH_EP_TX_EN` writer - enable USB host OUT endpoint transmittal"]
        pub type UhEpTxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - buffer mode of USB host IN endpoint"]
            #[inline(always)]
            pub fn uh_ep_rbuf_mod(&self) -> UhEpRbufModR {
                UhEpRbufModR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 3 - enable USB host IN endpoint receiving"]
            #[inline(always)]
            pub fn uh_ep_rx_en(&self) -> UhEpRxEnR {
                UhEpRxEnR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - buffer mode of USB host OUT endpoint"]
            #[inline(always)]
            pub fn uh_ep_tbuf_mod(&self) -> UhEpTbufModR {
                UhEpTbufModR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - enable USB host OUT endpoint transmittal"]
            #[inline(always)]
            pub fn uh_ep_tx_en(&self) -> UhEpTxEnR {
                UhEpTxEnR::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - buffer mode of USB host IN endpoint"]
            #[inline(always)]
            pub fn uh_ep_rbuf_mod(&mut self) -> UhEpRbufModW<U2hEpModSpec> {
                UhEpRbufModW::new(self, 0)
            }
            #[doc = "Bit 3 - enable USB host IN endpoint receiving"]
            #[inline(always)]
            pub fn uh_ep_rx_en(&mut self) -> UhEpRxEnW<U2hEpModSpec> {
                UhEpRxEnW::new(self, 3)
            }
            #[doc = "Bit 4 - buffer mode of USB host OUT endpoint"]
            #[inline(always)]
            pub fn uh_ep_tbuf_mod(&mut self) -> UhEpTbufModW<U2hEpModSpec> {
                UhEpTbufModW::new(self, 4)
            }
            #[doc = "Bit 6 - enable USB host OUT endpoint transmittal"]
            #[inline(always)]
            pub fn uh_ep_tx_en(&mut self) -> UhEpTxEnW<U2hEpModSpec> {
                UhEpTxEnW::new(self, 6)
            }
        }
        #[doc = "host endpoint mode\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_ep_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_ep_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2hEpModSpec;
        impl crate::RegisterSpec for U2hEpModSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2h_ep_mod::R`](R) reader structure"]
        impl crate::Readable for U2hEpModSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2h_ep_mod::W`](W) writer structure"]
        impl crate::Writable for U2hEpModSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2H_EP_MOD to value 0"]
        impl crate::Resettable for U2hEpModSpec {}
    }
    #[doc = "U2EP567_MOD (rw) register accessor: USB2 endpoint 5/6/7 mode\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep567_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep567_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep567_mod`] module"]
    #[doc(alias = "U2EP567_MOD")]
    pub type U2ep567Mod = crate::Reg<u2ep567_mod::U2ep567ModSpec>;
    #[doc = "USB2 endpoint 5/6/7 mode"]
    pub mod u2ep567_mod {
        #[doc = "Register `U2EP567_MOD` reader"]
        pub type R = crate::R<U2ep567ModSpec>;
        #[doc = "Register `U2EP567_MOD` writer"]
        pub type W = crate::W<U2ep567ModSpec>;
        #[doc = "Field `UEP5_TX_EN` reader - enable USB endpoint 5 transmittal (IN)"]
        pub type Uep5TxEnR = crate::BitReader;
        #[doc = "Field `UEP5_TX_EN` writer - enable USB endpoint 5 transmittal (IN)"]
        pub type Uep5TxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP5_RX_EN` reader - enable USB endpoint 5 receiving (OUT)"]
        pub type Uep5RxEnR = crate::BitReader;
        #[doc = "Field `UEP5_RX_EN` writer - enable USB endpoint 5 receiving (OUT)"]
        pub type Uep5RxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP6_TX_EN` reader - enable USB endpoint 6 transmittal (IN)"]
        pub type Uep6TxEnR = crate::BitReader;
        #[doc = "Field `UEP6_TX_EN` writer - enable USB endpoint 6 transmittal (IN)"]
        pub type Uep6TxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP6_RX_EN` reader - enable USB endpoint 6 receiving (OUT)"]
        pub type Uep6RxEnR = crate::BitReader;
        #[doc = "Field `UEP6_RX_EN` writer - enable USB endpoint 6 receiving (OUT)"]
        pub type Uep6RxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP7_TX_EN` reader - enable USB endpoint 7 transmittal (IN)"]
        pub type Uep7TxEnR = crate::BitReader;
        #[doc = "Field `UEP7_TX_EN` writer - enable USB endpoint 7 transmittal (IN)"]
        pub type Uep7TxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP7_RX_EN` reader - enable USB endpoint 7 receiving (OUT)"]
        pub type Uep7RxEnR = crate::BitReader;
        #[doc = "Field `UEP7_RX_EN` writer - enable USB endpoint 7 receiving (OUT)"]
        pub type Uep7RxEnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - enable USB endpoint 5 transmittal (IN)"]
            #[inline(always)]
            pub fn uep5_tx_en(&self) -> Uep5TxEnR {
                Uep5TxEnR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - enable USB endpoint 5 receiving (OUT)"]
            #[inline(always)]
            pub fn uep5_rx_en(&self) -> Uep5RxEnR {
                Uep5RxEnR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - enable USB endpoint 6 transmittal (IN)"]
            #[inline(always)]
            pub fn uep6_tx_en(&self) -> Uep6TxEnR {
                Uep6TxEnR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - enable USB endpoint 6 receiving (OUT)"]
            #[inline(always)]
            pub fn uep6_rx_en(&self) -> Uep6RxEnR {
                Uep6RxEnR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - enable USB endpoint 7 transmittal (IN)"]
            #[inline(always)]
            pub fn uep7_tx_en(&self) -> Uep7TxEnR {
                Uep7TxEnR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - enable USB endpoint 7 receiving (OUT)"]
            #[inline(always)]
            pub fn uep7_rx_en(&self) -> Uep7RxEnR {
                Uep7RxEnR::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - enable USB endpoint 5 transmittal (IN)"]
            #[inline(always)]
            pub fn uep5_tx_en(&mut self) -> Uep5TxEnW<U2ep567ModSpec> {
                Uep5TxEnW::new(self, 0)
            }
            #[doc = "Bit 1 - enable USB endpoint 5 receiving (OUT)"]
            #[inline(always)]
            pub fn uep5_rx_en(&mut self) -> Uep5RxEnW<U2ep567ModSpec> {
                Uep5RxEnW::new(self, 1)
            }
            #[doc = "Bit 2 - enable USB endpoint 6 transmittal (IN)"]
            #[inline(always)]
            pub fn uep6_tx_en(&mut self) -> Uep6TxEnW<U2ep567ModSpec> {
                Uep6TxEnW::new(self, 2)
            }
            #[doc = "Bit 3 - enable USB endpoint 6 receiving (OUT)"]
            #[inline(always)]
            pub fn uep6_rx_en(&mut self) -> Uep6RxEnW<U2ep567ModSpec> {
                Uep6RxEnW::new(self, 3)
            }
            #[doc = "Bit 4 - enable USB endpoint 7 transmittal (IN)"]
            #[inline(always)]
            pub fn uep7_tx_en(&mut self) -> Uep7TxEnW<U2ep567ModSpec> {
                Uep7TxEnW::new(self, 4)
            }
            #[doc = "Bit 5 - enable USB endpoint 7 receiving (OUT)"]
            #[inline(always)]
            pub fn uep7_rx_en(&mut self) -> Uep7RxEnW<U2ep567ModSpec> {
                Uep7RxEnW::new(self, 5)
            }
        }
        #[doc = "USB2 endpoint 5/6/7 mode\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep567_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep567_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep567ModSpec;
        impl crate::RegisterSpec for U2ep567ModSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2ep567_mod::R`](R) reader structure"]
        impl crate::Readable for U2ep567ModSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep567_mod::W`](W) writer structure"]
        impl crate::Writable for U2ep567ModSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP567_MOD to value 0"]
        impl crate::Resettable for U2ep567ModSpec {}
    }
    #[doc = "U2EP0_DMA (rw) register accessor: endpoint 0 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep0_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep0_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep0_dma`] module"]
    #[doc(alias = "U2EP0_DMA")]
    pub type U2ep0Dma = crate::Reg<u2ep0_dma::U2ep0DmaSpec>;
    #[doc = "endpoint 0 DMA buffer address"]
    pub mod u2ep0_dma {
        #[doc = "Register `U2EP0_DMA` reader"]
        pub type R = crate::R<U2ep0DmaSpec>;
        #[doc = "Register `U2EP0_DMA` writer"]
        pub type W = crate::W<U2ep0DmaSpec>;
        #[doc = "Field `UEP0_DMA` reader - RW,endpoint 0 DMA buffer address"]
        pub type Uep0DmaR = crate::FieldReader<u16>;
        #[doc = "Field `UEP0_DMA` writer - RW,endpoint 0 DMA buffer address"]
        pub type Uep0DmaW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW,endpoint 0 DMA buffer address"]
            #[inline(always)]
            pub fn uep0_dma(&self) -> Uep0DmaR {
                Uep0DmaR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW,endpoint 0 DMA buffer address"]
            #[inline(always)]
            pub fn uep0_dma(&mut self) -> Uep0DmaW<U2ep0DmaSpec> {
                Uep0DmaW::new(self, 0)
            }
        }
        #[doc = "endpoint 0 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep0_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep0_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep0DmaSpec;
        impl crate::RegisterSpec for U2ep0DmaSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`u2ep0_dma::R`](R) reader structure"]
        impl crate::Readable for U2ep0DmaSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep0_dma::W`](W) writer structure"]
        impl crate::Writable for U2ep0DmaSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP0_DMA to value 0"]
        impl crate::Resettable for U2ep0DmaSpec {}
    }
    #[doc = "U2EP1_DMA (rw) register accessor: USB2 endpoint 1 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep1_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep1_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep1_dma`] module"]
    #[doc(alias = "U2EP1_DMA")]
    pub type U2ep1Dma = crate::Reg<u2ep1_dma::U2ep1DmaSpec>;
    #[doc = "USB2 endpoint 1 DMA buffer address"]
    pub mod u2ep1_dma {
        #[doc = "Register `U2EP1_DMA` reader"]
        pub type R = crate::R<U2ep1DmaSpec>;
        #[doc = "Register `U2EP1_DMA` writer"]
        pub type W = crate::W<U2ep1DmaSpec>;
        #[doc = "Field `UEP1_DMA` reader - RW,endpoint 1 DMA buffer address"]
        pub type Uep1DmaR = crate::FieldReader<u16>;
        #[doc = "Field `UEP1_DMA` writer - RW,endpoint 1 DMA buffer address"]
        pub type Uep1DmaW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW,endpoint 1 DMA buffer address"]
            #[inline(always)]
            pub fn uep1_dma(&self) -> Uep1DmaR {
                Uep1DmaR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW,endpoint 1 DMA buffer address"]
            #[inline(always)]
            pub fn uep1_dma(&mut self) -> Uep1DmaW<U2ep1DmaSpec> {
                Uep1DmaW::new(self, 0)
            }
        }
        #[doc = "USB2 endpoint 1 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep1_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep1_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep1DmaSpec;
        impl crate::RegisterSpec for U2ep1DmaSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`u2ep1_dma::R`](R) reader structure"]
        impl crate::Readable for U2ep1DmaSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep1_dma::W`](W) writer structure"]
        impl crate::Writable for U2ep1DmaSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP1_DMA to value 0"]
        impl crate::Resettable for U2ep1DmaSpec {}
    }
    #[doc = "U2EP2_DMA (rw) register accessor: USB2 endpoint 2 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep2_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep2_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep2_dma`] module"]
    #[doc(alias = "U2EP2_DMA")]
    pub type U2ep2Dma = crate::Reg<u2ep2_dma::U2ep2DmaSpec>;
    #[doc = "USB2 endpoint 2 DMA buffer address"]
    pub mod u2ep2_dma {
        #[doc = "Register `U2EP2_DMA` reader"]
        pub type R = crate::R<U2ep2DmaSpec>;
        #[doc = "Register `U2EP2_DMA` writer"]
        pub type W = crate::W<U2ep2DmaSpec>;
        #[doc = "Field `UEP2_DMA` reader - RW,endpoint 2 DMA buffer address"]
        pub type Uep2DmaR = crate::FieldReader<u16>;
        #[doc = "Field `UEP2_DMA` writer - RW,endpoint 2 DMA buffer address"]
        pub type Uep2DmaW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW,endpoint 2 DMA buffer address"]
            #[inline(always)]
            pub fn uep2_dma(&self) -> Uep2DmaR {
                Uep2DmaR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW,endpoint 2 DMA buffer address"]
            #[inline(always)]
            pub fn uep2_dma(&mut self) -> Uep2DmaW<U2ep2DmaSpec> {
                Uep2DmaW::new(self, 0)
            }
        }
        #[doc = "USB2 endpoint 2 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep2_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep2_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep2DmaSpec;
        impl crate::RegisterSpec for U2ep2DmaSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`u2ep2_dma::R`](R) reader structure"]
        impl crate::Readable for U2ep2DmaSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep2_dma::W`](W) writer structure"]
        impl crate::Writable for U2ep2DmaSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP2_DMA to value 0"]
        impl crate::Resettable for U2ep2DmaSpec {}
    }
    #[doc = "U2H_RX_DMA (rw) register accessor: host rx endpoint buffer high address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_rx_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_rx_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2h_rx_dma`] module"]
    #[doc(alias = "U2H_RX_DMA")]
    pub type U2hRxDma = crate::Reg<u2h_rx_dma::U2hRxDmaSpec>;
    #[doc = "host rx endpoint buffer high address"]
    pub mod u2h_rx_dma {
        #[doc = "Register `U2H_RX_DMA` reader"]
        pub type R = crate::R<U2hRxDmaSpec>;
        #[doc = "Register `U2H_RX_DMA` writer"]
        pub type W = crate::W<U2hRxDmaSpec>;
        #[doc = "Field `UH_RX_DMA` reader - RW,host rx endpoint buffer high address"]
        pub type UhRxDmaR = crate::FieldReader<u16>;
        #[doc = "Field `UH_RX_DMA` writer - RW,host rx endpoint buffer high address"]
        pub type UhRxDmaW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW,host rx endpoint buffer high address"]
            #[inline(always)]
            pub fn uh_rx_dma(&self) -> UhRxDmaR {
                UhRxDmaR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW,host rx endpoint buffer high address"]
            #[inline(always)]
            pub fn uh_rx_dma(&mut self) -> UhRxDmaW<U2hRxDmaSpec> {
                UhRxDmaW::new(self, 0)
            }
        }
        #[doc = "host rx endpoint buffer high address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_rx_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_rx_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2hRxDmaSpec;
        impl crate::RegisterSpec for U2hRxDmaSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`u2h_rx_dma::R`](R) reader structure"]
        impl crate::Readable for U2hRxDmaSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2h_rx_dma::W`](W) writer structure"]
        impl crate::Writable for U2hRxDmaSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2H_RX_DMA to value 0"]
        impl crate::Resettable for U2hRxDmaSpec {}
    }
    #[doc = "U2EP3_DMA (rw) register accessor: USB2 endpoint 3 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep3_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep3_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep3_dma`] module"]
    #[doc(alias = "U2EP3_DMA")]
    pub type U2ep3Dma = crate::Reg<u2ep3_dma::U2ep3DmaSpec>;
    #[doc = "USB2 endpoint 3 DMA buffer address"]
    pub mod u2ep3_dma {
        #[doc = "Register `U2EP3_DMA` reader"]
        pub type R = crate::R<U2ep3DmaSpec>;
        #[doc = "Register `U2EP3_DMA` writer"]
        pub type W = crate::W<U2ep3DmaSpec>;
        #[doc = "Field `UEP3_DMA` reader - RW,endpoint 3 DMA buffer address"]
        pub type Uep3DmaR = crate::FieldReader<u16>;
        #[doc = "Field `UEP3_DMA` writer - RW,endpoint 3 DMA buffer address"]
        pub type Uep3DmaW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW,endpoint 3 DMA buffer address"]
            #[inline(always)]
            pub fn uep3_dma(&self) -> Uep3DmaR {
                Uep3DmaR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW,endpoint 3 DMA buffer address"]
            #[inline(always)]
            pub fn uep3_dma(&mut self) -> Uep3DmaW<U2ep3DmaSpec> {
                Uep3DmaW::new(self, 0)
            }
        }
        #[doc = "USB2 endpoint 3 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep3_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep3_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep3DmaSpec;
        impl crate::RegisterSpec for U2ep3DmaSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`u2ep3_dma::R`](R) reader structure"]
        impl crate::Readable for U2ep3DmaSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep3_dma::W`](W) writer structure"]
        impl crate::Writable for U2ep3DmaSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP3_DMA to value 0"]
        impl crate::Resettable for U2ep3DmaSpec {}
    }
    #[doc = "U2H_TX_DMA (rw) register accessor: host tx endpoint buffer high address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_tx_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_tx_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2h_tx_dma`] module"]
    #[doc(alias = "U2H_TX_DMA")]
    pub type U2hTxDma = crate::Reg<u2h_tx_dma::U2hTxDmaSpec>;
    #[doc = "host tx endpoint buffer high address"]
    pub mod u2h_tx_dma {
        #[doc = "Register `U2H_TX_DMA` reader"]
        pub type R = crate::R<U2hTxDmaSpec>;
        #[doc = "Register `U2H_TX_DMA` writer"]
        pub type W = crate::W<U2hTxDmaSpec>;
        #[doc = "Field `UH_TX_DMA` reader - RW,host tx endpoint buffer high address"]
        pub type UhTxDmaR = crate::FieldReader<u16>;
        #[doc = "Field `UH_TX_DMA` writer - RW,host tx endpoint buffer high address"]
        pub type UhTxDmaW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW,host tx endpoint buffer high address"]
            #[inline(always)]
            pub fn uh_tx_dma(&self) -> UhTxDmaR {
                UhTxDmaR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW,host tx endpoint buffer high address"]
            #[inline(always)]
            pub fn uh_tx_dma(&mut self) -> UhTxDmaW<U2hTxDmaSpec> {
                UhTxDmaW::new(self, 0)
            }
        }
        #[doc = "host tx endpoint buffer high address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_tx_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_tx_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2hTxDmaSpec;
        impl crate::RegisterSpec for U2hTxDmaSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`u2h_tx_dma::R`](R) reader structure"]
        impl crate::Readable for U2hTxDmaSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2h_tx_dma::W`](W) writer structure"]
        impl crate::Writable for U2hTxDmaSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2H_TX_DMA to value 0"]
        impl crate::Resettable for U2hTxDmaSpec {}
    }
    #[doc = "U2EP5_DMA (rw) register accessor: USB2 endpoint 5 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep5_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep5_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep5_dma`] module"]
    #[doc(alias = "U2EP5_DMA")]
    pub type U2ep5Dma = crate::Reg<u2ep5_dma::U2ep5DmaSpec>;
    #[doc = "USB2 endpoint 5 DMA buffer address"]
    pub mod u2ep5_dma {
        #[doc = "Register `U2EP5_DMA` reader"]
        pub type R = crate::R<U2ep5DmaSpec>;
        #[doc = "Register `U2EP5_DMA` writer"]
        pub type W = crate::W<U2ep5DmaSpec>;
        #[doc = "Field `UEP5_DMA` reader - RW,endpoint 5 DMA buffer address"]
        pub type Uep5DmaR = crate::FieldReader<u16>;
        #[doc = "Field `UEP5_DMA` writer - RW,endpoint 5 DMA buffer address"]
        pub type Uep5DmaW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW,endpoint 5 DMA buffer address"]
            #[inline(always)]
            pub fn uep5_dma(&self) -> Uep5DmaR {
                Uep5DmaR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW,endpoint 5 DMA buffer address"]
            #[inline(always)]
            pub fn uep5_dma(&mut self) -> Uep5DmaW<U2ep5DmaSpec> {
                Uep5DmaW::new(self, 0)
            }
        }
        #[doc = "USB2 endpoint 5 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep5_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep5_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep5DmaSpec;
        impl crate::RegisterSpec for U2ep5DmaSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`u2ep5_dma::R`](R) reader structure"]
        impl crate::Readable for U2ep5DmaSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep5_dma::W`](W) writer structure"]
        impl crate::Writable for U2ep5DmaSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP5_DMA to value 0"]
        impl crate::Resettable for U2ep5DmaSpec {}
    }
    #[doc = "U2EP6_DMA (rw) register accessor: USB2 endpoint 6 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep6_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep6_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep6_dma`] module"]
    #[doc(alias = "U2EP6_DMA")]
    pub type U2ep6Dma = crate::Reg<u2ep6_dma::U2ep6DmaSpec>;
    #[doc = "USB2 endpoint 6 DMA buffer address"]
    pub mod u2ep6_dma {
        #[doc = "Register `U2EP6_DMA` reader"]
        pub type R = crate::R<U2ep6DmaSpec>;
        #[doc = "Register `U2EP6_DMA` writer"]
        pub type W = crate::W<U2ep6DmaSpec>;
        #[doc = "Field `UEP6_DMA` reader - RW,endpoint 6 DMA buffer address"]
        pub type Uep6DmaR = crate::FieldReader<u16>;
        #[doc = "Field `UEP6_DMA` writer - RW,endpoint 6 DMA buffer address"]
        pub type Uep6DmaW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW,endpoint 6 DMA buffer address"]
            #[inline(always)]
            pub fn uep6_dma(&self) -> Uep6DmaR {
                Uep6DmaR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW,endpoint 6 DMA buffer address"]
            #[inline(always)]
            pub fn uep6_dma(&mut self) -> Uep6DmaW<U2ep6DmaSpec> {
                Uep6DmaW::new(self, 0)
            }
        }
        #[doc = "USB2 endpoint 6 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep6_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep6_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep6DmaSpec;
        impl crate::RegisterSpec for U2ep6DmaSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`u2ep6_dma::R`](R) reader structure"]
        impl crate::Readable for U2ep6DmaSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep6_dma::W`](W) writer structure"]
        impl crate::Writable for U2ep6DmaSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP6_DMA to value 0"]
        impl crate::Resettable for U2ep6DmaSpec {}
    }
    #[doc = "U2EP7_DMA (rw) register accessor: USB2 endpoint 7 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep7_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep7_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep7_dma`] module"]
    #[doc(alias = "U2EP7_DMA")]
    pub type U2ep7Dma = crate::Reg<u2ep7_dma::U2ep7DmaSpec>;
    #[doc = "USB2 endpoint 7 DMA buffer address"]
    pub mod u2ep7_dma {
        #[doc = "Register `U2EP7_DMA` reader"]
        pub type R = crate::R<U2ep7DmaSpec>;
        #[doc = "Register `U2EP7_DMA` writer"]
        pub type W = crate::W<U2ep7DmaSpec>;
        #[doc = "Field `UEP7_DMA` reader - RW,endpoint 7 DMA buffer address"]
        pub type Uep7DmaR = crate::FieldReader<u16>;
        #[doc = "Field `UEP7_DMA` writer - RW,endpoint 7 DMA buffer address"]
        pub type Uep7DmaW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl R {
            #[doc = "Bits 0:15 - RW,endpoint 7 DMA buffer address"]
            #[inline(always)]
            pub fn uep7_dma(&self) -> Uep7DmaR {
                Uep7DmaR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:15 - RW,endpoint 7 DMA buffer address"]
            #[inline(always)]
            pub fn uep7_dma(&mut self) -> Uep7DmaW<U2ep7DmaSpec> {
                Uep7DmaW::new(self, 0)
            }
        }
        #[doc = "USB2 endpoint 7 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep7_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep7_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep7DmaSpec;
        impl crate::RegisterSpec for U2ep7DmaSpec {
            type Ux = u16;
        }
        #[doc = "`read()` method returns [`u2ep7_dma::R`](R) reader structure"]
        impl crate::Readable for U2ep7DmaSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep7_dma::W`](W) writer structure"]
        impl crate::Writable for U2ep7DmaSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP7_DMA to value 0"]
        impl crate::Resettable for U2ep7DmaSpec {}
    }
    #[doc = "U2EP0_T_LEN (rw) register accessor: USB2 endpoint 0 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep0_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep0_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep0_t_len`] module"]
    #[doc(alias = "U2EP0_T_LEN")]
    pub type U2ep0TLen = crate::Reg<u2ep0_t_len::U2ep0TLenSpec>;
    #[doc = "USB2 endpoint 0 transmittal length"]
    pub mod u2ep0_t_len {
        #[doc = "Register `U2EP0_T_LEN` reader"]
        pub type R = crate::R<U2ep0TLenSpec>;
        #[doc = "Register `U2EP0_T_LEN` writer"]
        pub type W = crate::W<U2ep0TLenSpec>;
        #[doc = "Field `UEP0_T_LEN` reader - endpoint 0 transmittal length"]
        pub type Uep0TLenR = crate::FieldReader;
        #[doc = "Field `UEP0_T_LEN` writer - endpoint 0 transmittal length"]
        pub type Uep0TLenW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - endpoint 0 transmittal length"]
            #[inline(always)]
            pub fn uep0_t_len(&self) -> Uep0TLenR {
                Uep0TLenR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - endpoint 0 transmittal length"]
            #[inline(always)]
            pub fn uep0_t_len(&mut self) -> Uep0TLenW<U2ep0TLenSpec> {
                Uep0TLenW::new(self, 0)
            }
        }
        #[doc = "USB2 endpoint 0 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep0_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep0_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep0TLenSpec;
        impl crate::RegisterSpec for U2ep0TLenSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2ep0_t_len::R`](R) reader structure"]
        impl crate::Readable for U2ep0TLenSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep0_t_len::W`](W) writer structure"]
        impl crate::Writable for U2ep0TLenSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP0_T_LEN to value 0"]
        impl crate::Resettable for U2ep0TLenSpec {}
    }
    #[doc = "U2EP0_CTRL (rw) register accessor: USB2 endpoint 0 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep0_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep0_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep0_ctrl`] module"]
    #[doc(alias = "U2EP0_CTRL")]
    pub type U2ep0Ctrl = crate::Reg<u2ep0_ctrl::U2ep0CtrlSpec>;
    #[doc = "USB2 endpoint 0 control"]
    pub mod u2ep0_ctrl {
        #[doc = "Register `U2EP0_CTRL` reader"]
        pub type R = crate::R<U2ep0CtrlSpec>;
        #[doc = "Register `U2EP0_CTRL` writer"]
        pub type W = crate::W<U2ep0CtrlSpec>;
        #[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResR = crate::FieldReader;
        #[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResR = crate::FieldReader;
        #[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogR = crate::BitReader;
        #[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogR = crate::BitReader;
        #[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogR = crate::BitReader;
        #[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&self) -> UepTResR {
                UepTResR::new(self.bits & 3)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&self) -> UepRResR {
                UepRResR::new((self.bits >> 2) & 3)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UepAutoTogR {
                UepAutoTogR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UepTTogR {
                UepTTogR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UepRTogR {
                UepRTogR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&mut self) -> UepTResW<U2ep0CtrlSpec> {
                UepTResW::new(self, 0)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&mut self) -> UepRResW<U2ep0CtrlSpec> {
                UepRResW::new(self, 2)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&mut self) -> UepAutoTogW<U2ep0CtrlSpec> {
                UepAutoTogW::new(self, 4)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&mut self) -> UepTTogW<U2ep0CtrlSpec> {
                UepTTogW::new(self, 6)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&mut self) -> UepRTogW<U2ep0CtrlSpec> {
                UepRTogW::new(self, 7)
            }
        }
        #[doc = "USB2 endpoint 0 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep0_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep0_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep0CtrlSpec;
        impl crate::RegisterSpec for U2ep0CtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2ep0_ctrl::R`](R) reader structure"]
        impl crate::Readable for U2ep0CtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep0_ctrl::W`](W) writer structure"]
        impl crate::Writable for U2ep0CtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP0_CTRL to value 0"]
        impl crate::Resettable for U2ep0CtrlSpec {}
    }
    #[doc = "U2EP1_T_LEN (rw) register accessor: USB2 endpoint 1 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep1_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep1_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep1_t_len`] module"]
    #[doc(alias = "U2EP1_T_LEN")]
    pub type U2ep1TLen = crate::Reg<u2ep1_t_len::U2ep1TLenSpec>;
    #[doc = "USB2 endpoint 1 transmittal length"]
    pub mod u2ep1_t_len {
        #[doc = "Register `U2EP1_T_LEN` reader"]
        pub type R = crate::R<U2ep1TLenSpec>;
        #[doc = "Register `U2EP1_T_LEN` writer"]
        pub type W = crate::W<U2ep1TLenSpec>;
        #[doc = "Field `UEP1_T_LEN` reader - endpoint 1 transmittal length"]
        pub type Uep1TLenR = crate::FieldReader;
        #[doc = "Field `UEP1_T_LEN` writer - endpoint 1 transmittal length"]
        pub type Uep1TLenW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - endpoint 1 transmittal length"]
            #[inline(always)]
            pub fn uep1_t_len(&self) -> Uep1TLenR {
                Uep1TLenR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - endpoint 1 transmittal length"]
            #[inline(always)]
            pub fn uep1_t_len(&mut self) -> Uep1TLenW<U2ep1TLenSpec> {
                Uep1TLenW::new(self, 0)
            }
        }
        #[doc = "USB2 endpoint 1 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep1_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep1_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep1TLenSpec;
        impl crate::RegisterSpec for U2ep1TLenSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2ep1_t_len::R`](R) reader structure"]
        impl crate::Readable for U2ep1TLenSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep1_t_len::W`](W) writer structure"]
        impl crate::Writable for U2ep1TLenSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP1_T_LEN to value 0"]
        impl crate::Resettable for U2ep1TLenSpec {}
    }
    #[doc = "U2EP1_CTRL (rw) register accessor: USB2 endpoint 1 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep1_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep1_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep1_ctrl`] module"]
    #[doc(alias = "U2EP1_CTRL")]
    pub type U2ep1Ctrl = crate::Reg<u2ep1_ctrl::U2ep1CtrlSpec>;
    #[doc = "USB2 endpoint 1 control"]
    pub mod u2ep1_ctrl {
        #[doc = "Register `U2EP1_CTRL` reader"]
        pub type R = crate::R<U2ep1CtrlSpec>;
        #[doc = "Register `U2EP1_CTRL` writer"]
        pub type W = crate::W<U2ep1CtrlSpec>;
        #[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResR = crate::FieldReader;
        #[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResR = crate::FieldReader;
        #[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogR = crate::BitReader;
        #[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogR = crate::BitReader;
        #[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogR = crate::BitReader;
        #[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&self) -> UepTResR {
                UepTResR::new(self.bits & 3)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&self) -> UepRResR {
                UepRResR::new((self.bits >> 2) & 3)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UepAutoTogR {
                UepAutoTogR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UepTTogR {
                UepTTogR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UepRTogR {
                UepRTogR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&mut self) -> UepTResW<U2ep1CtrlSpec> {
                UepTResW::new(self, 0)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&mut self) -> UepRResW<U2ep1CtrlSpec> {
                UepRResW::new(self, 2)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&mut self) -> UepAutoTogW<U2ep1CtrlSpec> {
                UepAutoTogW::new(self, 4)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&mut self) -> UepTTogW<U2ep1CtrlSpec> {
                UepTTogW::new(self, 6)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&mut self) -> UepRTogW<U2ep1CtrlSpec> {
                UepRTogW::new(self, 7)
            }
        }
        #[doc = "USB2 endpoint 1 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep1_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep1_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep1CtrlSpec;
        impl crate::RegisterSpec for U2ep1CtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2ep1_ctrl::R`](R) reader structure"]
        impl crate::Readable for U2ep1CtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep1_ctrl::W`](W) writer structure"]
        impl crate::Writable for U2ep1CtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP1_CTRL to value 0"]
        impl crate::Resettable for U2ep1CtrlSpec {}
    }
    #[doc = "U2H_SETUP (rw) register accessor: host aux setup\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_setup::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_setup::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2h_setup`] module"]
    #[doc(alias = "U2H_SETUP")]
    pub type U2hSetup = crate::Reg<u2h_setup::U2hSetupSpec>;
    #[doc = "host aux setup"]
    pub mod u2h_setup {
        #[doc = "Register `U2H_SETUP` reader"]
        pub type R = crate::R<U2hSetupSpec>;
        #[doc = "Register `U2H_SETUP` writer"]
        pub type W = crate::W<U2hSetupSpec>;
        #[doc = "Field `UH_SOF_EN` reader - USB host automatic SOF enable"]
        pub type UhSofEnR = crate::BitReader;
        #[doc = "Field `UH_SOF_EN` writer - USB host automatic SOF enable"]
        pub type UhSofEnW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UH_PRE_PID_EN` reader - USB host PRE PID enable for low speed device via hub"]
        pub type UhPrePidEnR = crate::BitReader;
        #[doc = "Field `UH_PRE_PID_EN` writer - USB host PRE PID enable for low speed device via hub"]
        pub type UhPrePidEnW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 6 - USB host automatic SOF enable"]
            #[inline(always)]
            pub fn uh_sof_en(&self) -> UhSofEnR {
                UhSofEnR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - USB host PRE PID enable for low speed device via hub"]
            #[inline(always)]
            pub fn uh_pre_pid_en(&self) -> UhPrePidEnR {
                UhPrePidEnR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 6 - USB host automatic SOF enable"]
            #[inline(always)]
            pub fn uh_sof_en(&mut self) -> UhSofEnW<U2hSetupSpec> {
                UhSofEnW::new(self, 6)
            }
            #[doc = "Bit 7 - USB host PRE PID enable for low speed device via hub"]
            #[inline(always)]
            pub fn uh_pre_pid_en(&mut self) -> UhPrePidEnW<U2hSetupSpec> {
                UhPrePidEnW::new(self, 7)
            }
        }
        #[doc = "host aux setup\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_setup::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_setup::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2hSetupSpec;
        impl crate::RegisterSpec for U2hSetupSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2h_setup::R`](R) reader structure"]
        impl crate::Readable for U2hSetupSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2h_setup::W`](W) writer structure"]
        impl crate::Writable for U2hSetupSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2H_SETUP to value 0"]
        impl crate::Resettable for U2hSetupSpec {}
    }
    #[doc = "U2EP2_T_LEN (rw) register accessor: USB2 endpoint 2 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep2_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep2_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep2_t_len`] module"]
    #[doc(alias = "U2EP2_T_LEN")]
    pub type U2ep2TLen = crate::Reg<u2ep2_t_len::U2ep2TLenSpec>;
    #[doc = "USB2 endpoint 2 transmittal length"]
    pub mod u2ep2_t_len {
        #[doc = "Register `U2EP2_T_LEN` reader"]
        pub type R = crate::R<U2ep2TLenSpec>;
        #[doc = "Register `U2EP2_T_LEN` writer"]
        pub type W = crate::W<U2ep2TLenSpec>;
        #[doc = "Field `UEP2_T_LEN` reader - endpoint 2 transmittal length"]
        pub type Uep2TLenR = crate::FieldReader;
        #[doc = "Field `UEP2_T_LEN` writer - endpoint 2 transmittal length"]
        pub type Uep2TLenW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - endpoint 2 transmittal length"]
            #[inline(always)]
            pub fn uep2_t_len(&self) -> Uep2TLenR {
                Uep2TLenR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - endpoint 2 transmittal length"]
            #[inline(always)]
            pub fn uep2_t_len(&mut self) -> Uep2TLenW<U2ep2TLenSpec> {
                Uep2TLenW::new(self, 0)
            }
        }
        #[doc = "USB2 endpoint 2 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep2_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep2_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep2TLenSpec;
        impl crate::RegisterSpec for U2ep2TLenSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2ep2_t_len::R`](R) reader structure"]
        impl crate::Readable for U2ep2TLenSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep2_t_len::W`](W) writer structure"]
        impl crate::Writable for U2ep2TLenSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP2_T_LEN to value 0"]
        impl crate::Resettable for U2ep2TLenSpec {}
    }
    #[doc = "U2H_EP_PID (rw) register accessor: host endpoint and PID\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_ep_pid::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_ep_pid::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2h_ep_pid`] module"]
    #[doc(alias = "U2H_EP_PID")]
    pub type U2hEpPid = crate::Reg<u2h_ep_pid::U2hEpPidSpec>;
    #[doc = "host endpoint and PID"]
    pub mod u2h_ep_pid {
        #[doc = "Register `U2H_EP_PID` reader"]
        pub type R = crate::R<U2hEpPidSpec>;
        #[doc = "Register `U2H_EP_PID` writer"]
        pub type W = crate::W<U2hEpPidSpec>;
        #[doc = "Field `UH_ENDP` reader - bit mask of endpoint number for USB host transfer"]
        pub type UhEndpR = crate::FieldReader;
        #[doc = "Field `UH_ENDP` writer - bit mask of endpoint number for USB host transfer"]
        pub type UhEndpW<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        #[doc = "Field `UH_TOKEN` reader - bit mask of token PID for USB host transfer"]
        pub type UhTokenR = crate::FieldReader;
        #[doc = "Field `UH_TOKEN` writer - bit mask of token PID for USB host transfer"]
        pub type UhTokenW<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            #[doc = "Bits 0:3 - bit mask of endpoint number for USB host transfer"]
            #[inline(always)]
            pub fn uh_endp(&self) -> UhEndpR {
                UhEndpR::new(self.bits & 0x0f)
            }
            #[doc = "Bits 4:7 - bit mask of token PID for USB host transfer"]
            #[inline(always)]
            pub fn uh_token(&self) -> UhTokenR {
                UhTokenR::new((self.bits >> 4) & 0x0f)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - bit mask of endpoint number for USB host transfer"]
            #[inline(always)]
            pub fn uh_endp(&mut self) -> UhEndpW<U2hEpPidSpec> {
                UhEndpW::new(self, 0)
            }
            #[doc = "Bits 4:7 - bit mask of token PID for USB host transfer"]
            #[inline(always)]
            pub fn uh_token(&mut self) -> UhTokenW<U2hEpPidSpec> {
                UhTokenW::new(self, 4)
            }
        }
        #[doc = "host endpoint and PID\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_ep_pid::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_ep_pid::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2hEpPidSpec;
        impl crate::RegisterSpec for U2hEpPidSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2h_ep_pid::R`](R) reader structure"]
        impl crate::Readable for U2hEpPidSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2h_ep_pid::W`](W) writer structure"]
        impl crate::Writable for U2hEpPidSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2H_EP_PID to value 0"]
        impl crate::Resettable for U2hEpPidSpec {}
    }
    #[doc = "U2EP2_CTRL (rw) register accessor: USB2 endpoint 2 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep2_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep2_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep2_ctrl`] module"]
    #[doc(alias = "U2EP2_CTRL")]
    pub type U2ep2Ctrl = crate::Reg<u2ep2_ctrl::U2ep2CtrlSpec>;
    #[doc = "USB2 endpoint 2 control"]
    pub mod u2ep2_ctrl {
        #[doc = "Register `U2EP2_CTRL` reader"]
        pub type R = crate::R<U2ep2CtrlSpec>;
        #[doc = "Register `U2EP2_CTRL` writer"]
        pub type W = crate::W<U2ep2CtrlSpec>;
        #[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResR = crate::FieldReader;
        #[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResR = crate::FieldReader;
        #[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogR = crate::BitReader;
        #[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogR = crate::BitReader;
        #[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogR = crate::BitReader;
        #[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&self) -> UepTResR {
                UepTResR::new(self.bits & 3)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&self) -> UepRResR {
                UepRResR::new((self.bits >> 2) & 3)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UepAutoTogR {
                UepAutoTogR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UepTTogR {
                UepTTogR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UepRTogR {
                UepRTogR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&mut self) -> UepTResW<U2ep2CtrlSpec> {
                UepTResW::new(self, 0)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&mut self) -> UepRResW<U2ep2CtrlSpec> {
                UepRResW::new(self, 2)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&mut self) -> UepAutoTogW<U2ep2CtrlSpec> {
                UepAutoTogW::new(self, 4)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&mut self) -> UepTTogW<U2ep2CtrlSpec> {
                UepTTogW::new(self, 6)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&mut self) -> UepRTogW<U2ep2CtrlSpec> {
                UepRTogW::new(self, 7)
            }
        }
        #[doc = "USB2 endpoint 2 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep2_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep2_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep2CtrlSpec;
        impl crate::RegisterSpec for U2ep2CtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2ep2_ctrl::R`](R) reader structure"]
        impl crate::Readable for U2ep2CtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep2_ctrl::W`](W) writer structure"]
        impl crate::Writable for U2ep2CtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP2_CTRL to value 0"]
        impl crate::Resettable for U2ep2CtrlSpec {}
    }
    #[doc = "U2H_RX_CTRL (rw) register accessor: host receiver endpoint control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_rx_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_rx_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2h_rx_ctrl`] module"]
    #[doc(alias = "U2H_RX_CTRL")]
    pub type U2hRxCtrl = crate::Reg<u2h_rx_ctrl::U2hRxCtrlSpec>;
    #[doc = "host receiver endpoint control"]
    pub mod u2h_rx_ctrl {
        #[doc = "Register `U2H_RX_CTRL` reader"]
        pub type R = crate::R<U2hRxCtrlSpec>;
        #[doc = "Register `U2H_RX_CTRL` writer"]
        pub type W = crate::W<U2hRxCtrlSpec>;
        #[doc = "Field `UH_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UhRResR = crate::BitReader;
        #[doc = "Field `UH_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UhRResW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UH_R_AUTO_TOG` reader - enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle"]
        pub type UhRAutoTogR = crate::BitReader;
        #[doc = "Field `UH_R_AUTO_TOG` writer - enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle"]
        pub type UhRAutoTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UH_R_TOG` reader - expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1"]
        pub type UhRTogR = crate::BitReader;
        #[doc = "Field `UH_R_TOG` writer - expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1"]
        pub type UhRTogW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 2 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uh_r_res(&self) -> UhRResR {
                UhRResR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uh_r_auto_tog(&self) -> UhRAutoTogR {
                UhRAutoTogR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 7 - expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uh_r_tog(&self) -> UhRTogR {
                UhRTogR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 2 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uh_r_res(&mut self) -> UhRResW<U2hRxCtrlSpec> {
                UhRResW::new(self, 2)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uh_r_auto_tog(&mut self) -> UhRAutoTogW<U2hRxCtrlSpec> {
                UhRAutoTogW::new(self, 4)
            }
            #[doc = "Bit 7 - expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uh_r_tog(&mut self) -> UhRTogW<U2hRxCtrlSpec> {
                UhRTogW::new(self, 7)
            }
        }
        #[doc = "host receiver endpoint control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_rx_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_rx_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2hRxCtrlSpec;
        impl crate::RegisterSpec for U2hRxCtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2h_rx_ctrl::R`](R) reader structure"]
        impl crate::Readable for U2hRxCtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2h_rx_ctrl::W`](W) writer structure"]
        impl crate::Writable for U2hRxCtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2H_RX_CTRL to value 0"]
        impl crate::Resettable for U2hRxCtrlSpec {}
    }
    #[doc = "U2EP3_T_LEN (rw) register accessor: USB2 endpoint 3 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep3_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep3_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep3_t_len`] module"]
    #[doc(alias = "U2EP3_T_LEN")]
    pub type U2ep3TLen = crate::Reg<u2ep3_t_len::U2ep3TLenSpec>;
    #[doc = "USB2 endpoint 3 transmittal length"]
    pub mod u2ep3_t_len {
        #[doc = "Register `U2EP3_T_LEN` reader"]
        pub type R = crate::R<U2ep3TLenSpec>;
        #[doc = "Register `U2EP3_T_LEN` writer"]
        pub type W = crate::W<U2ep3TLenSpec>;
        #[doc = "Field `UEP3_T_LEN` reader - endpoint 3 transmittal length"]
        pub type Uep3TLenR = crate::FieldReader;
        #[doc = "Field `UEP3_T_LEN` writer - endpoint 3 transmittal length"]
        pub type Uep3TLenW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - endpoint 3 transmittal length"]
            #[inline(always)]
            pub fn uep3_t_len(&self) -> Uep3TLenR {
                Uep3TLenR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - endpoint 3 transmittal length"]
            #[inline(always)]
            pub fn uep3_t_len(&mut self) -> Uep3TLenW<U2ep3TLenSpec> {
                Uep3TLenW::new(self, 0)
            }
        }
        #[doc = "USB2 endpoint 3 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep3_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep3_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep3TLenSpec;
        impl crate::RegisterSpec for U2ep3TLenSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2ep3_t_len::R`](R) reader structure"]
        impl crate::Readable for U2ep3TLenSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep3_t_len::W`](W) writer structure"]
        impl crate::Writable for U2ep3TLenSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP3_T_LEN to value 0"]
        impl crate::Resettable for U2ep3TLenSpec {}
    }
    #[doc = "U2H_TX_LEN (rw) register accessor: host transmittal endpoint transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_tx_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_tx_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2h_tx_len`] module"]
    #[doc(alias = "U2H_TX_LEN")]
    pub type U2hTxLen = crate::Reg<u2h_tx_len::U2hTxLenSpec>;
    #[doc = "host transmittal endpoint transmittal length"]
    pub mod u2h_tx_len {
        #[doc = "Register `U2H_TX_LEN` reader"]
        pub type R = crate::R<U2hTxLenSpec>;
        #[doc = "Register `U2H_TX_LEN` writer"]
        pub type W = crate::W<U2hTxLenSpec>;
        #[doc = "Field `UH_TX_LEN` reader - host transmittal endpoint transmittal length"]
        pub type UhTxLenR = crate::FieldReader;
        #[doc = "Field `UH_TX_LEN` writer - host transmittal endpoint transmittal length"]
        pub type UhTxLenW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - host transmittal endpoint transmittal length"]
            #[inline(always)]
            pub fn uh_tx_len(&self) -> UhTxLenR {
                UhTxLenR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - host transmittal endpoint transmittal length"]
            #[inline(always)]
            pub fn uh_tx_len(&mut self) -> UhTxLenW<U2hTxLenSpec> {
                UhTxLenW::new(self, 0)
            }
        }
        #[doc = "host transmittal endpoint transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_tx_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_tx_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2hTxLenSpec;
        impl crate::RegisterSpec for U2hTxLenSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2h_tx_len::R`](R) reader structure"]
        impl crate::Readable for U2hTxLenSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2h_tx_len::W`](W) writer structure"]
        impl crate::Writable for U2hTxLenSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2H_TX_LEN to value 0"]
        impl crate::Resettable for U2hTxLenSpec {}
    }
    #[doc = "U2EP3_CTRL (rw) register accessor: USB2 endpoint 3 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep3_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep3_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep3_ctrl`] module"]
    #[doc(alias = "U2EP3_CTRL")]
    pub type U2ep3Ctrl = crate::Reg<u2ep3_ctrl::U2ep3CtrlSpec>;
    #[doc = "USB2 endpoint 3 control"]
    pub mod u2ep3_ctrl {
        #[doc = "Register `U2EP3_CTRL` reader"]
        pub type R = crate::R<U2ep3CtrlSpec>;
        #[doc = "Register `U2EP3_CTRL` writer"]
        pub type W = crate::W<U2ep3CtrlSpec>;
        #[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResR = crate::FieldReader;
        #[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResR = crate::FieldReader;
        #[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogR = crate::BitReader;
        #[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogR = crate::BitReader;
        #[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogR = crate::BitReader;
        #[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&self) -> UepTResR {
                UepTResR::new(self.bits & 3)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&self) -> UepRResR {
                UepRResR::new((self.bits >> 2) & 3)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UepAutoTogR {
                UepAutoTogR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UepTTogR {
                UepTTogR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UepRTogR {
                UepRTogR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&mut self) -> UepTResW<U2ep3CtrlSpec> {
                UepTResW::new(self, 0)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&mut self) -> UepRResW<U2ep3CtrlSpec> {
                UepRResW::new(self, 2)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&mut self) -> UepAutoTogW<U2ep3CtrlSpec> {
                UepAutoTogW::new(self, 4)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&mut self) -> UepTTogW<U2ep3CtrlSpec> {
                UepTTogW::new(self, 6)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&mut self) -> UepRTogW<U2ep3CtrlSpec> {
                UepRTogW::new(self, 7)
            }
        }
        #[doc = "USB2 endpoint 3 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep3_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep3_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep3CtrlSpec;
        impl crate::RegisterSpec for U2ep3CtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2ep3_ctrl::R`](R) reader structure"]
        impl crate::Readable for U2ep3CtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep3_ctrl::W`](W) writer structure"]
        impl crate::Writable for U2ep3CtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP3_CTRL to value 0"]
        impl crate::Resettable for U2ep3CtrlSpec {}
    }
    #[doc = "U2H_TX_CTRL (rw) register accessor: host transmittal endpoint control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_tx_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_tx_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2h_tx_ctrl`] module"]
    #[doc(alias = "U2H_TX_CTRL")]
    pub type U2hTxCtrl = crate::Reg<u2h_tx_ctrl::U2hTxCtrlSpec>;
    #[doc = "host transmittal endpoint control"]
    pub mod u2h_tx_ctrl {
        #[doc = "Register `U2H_TX_CTRL` reader"]
        pub type R = crate::R<U2hTxCtrlSpec>;
        #[doc = "Register `U2H_TX_CTRL` writer"]
        pub type W = crate::W<U2hTxCtrlSpec>;
        #[doc = "Field `UH_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UhTResR = crate::FieldReader;
        #[doc = "Field `UH_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UhTResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UH_T_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UhTAutoTogR = crate::BitReader;
        #[doc = "Field `UH_T_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UhTAutoTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UH_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UhTTogR = crate::BitReader;
        #[doc = "Field `UH_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UhTTogW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uh_t_res(&self) -> UhTResR {
                UhTResR::new(self.bits & 3)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uh_t_auto_tog(&self) -> UhTAutoTogR {
                UhTAutoTogR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uh_t_tog(&self) -> UhTTogR {
                UhTTogR::new(((self.bits >> 6) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uh_t_res(&mut self) -> UhTResW<U2hTxCtrlSpec> {
                UhTResW::new(self, 0)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uh_t_auto_tog(&mut self) -> UhTAutoTogW<U2hTxCtrlSpec> {
                UhTAutoTogW::new(self, 4)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uh_t_tog(&mut self) -> UhTTogW<U2hTxCtrlSpec> {
                UhTTogW::new(self, 6)
            }
        }
        #[doc = "host transmittal endpoint control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_tx_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_tx_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2hTxCtrlSpec;
        impl crate::RegisterSpec for U2hTxCtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2h_tx_ctrl::R`](R) reader structure"]
        impl crate::Readable for U2hTxCtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2h_tx_ctrl::W`](W) writer structure"]
        impl crate::Writable for U2hTxCtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2H_TX_CTRL to value 0"]
        impl crate::Resettable for U2hTxCtrlSpec {}
    }
    #[doc = "U2EP4_T_LEN (rw) register accessor: USB2 endpoint 4 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep4_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep4_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep4_t_len`] module"]
    #[doc(alias = "U2EP4_T_LEN")]
    pub type U2ep4TLen = crate::Reg<u2ep4_t_len::U2ep4TLenSpec>;
    #[doc = "USB2 endpoint 4 transmittal length"]
    pub mod u2ep4_t_len {
        #[doc = "Register `U2EP4_T_LEN` reader"]
        pub type R = crate::R<U2ep4TLenSpec>;
        #[doc = "Register `U2EP4_T_LEN` writer"]
        pub type W = crate::W<U2ep4TLenSpec>;
        #[doc = "Field `UEP4_T_LEN` reader - endpoint 4 transmittal length"]
        pub type Uep4TLenR = crate::FieldReader;
        #[doc = "Field `UEP4_T_LEN` writer - endpoint 4 transmittal length"]
        pub type Uep4TLenW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - endpoint 4 transmittal length"]
            #[inline(always)]
            pub fn uep4_t_len(&self) -> Uep4TLenR {
                Uep4TLenR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - endpoint 4 transmittal length"]
            #[inline(always)]
            pub fn uep4_t_len(&mut self) -> Uep4TLenW<U2ep4TLenSpec> {
                Uep4TLenW::new(self, 0)
            }
        }
        #[doc = "USB2 endpoint 4 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep4_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep4_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep4TLenSpec;
        impl crate::RegisterSpec for U2ep4TLenSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2ep4_t_len::R`](R) reader structure"]
        impl crate::Readable for U2ep4TLenSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep4_t_len::W`](W) writer structure"]
        impl crate::Writable for U2ep4TLenSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP4_T_LEN to value 0"]
        impl crate::Resettable for U2ep4TLenSpec {}
    }
    #[doc = "U2EP4_CTRL (rw) register accessor: USB2 endpoint 4 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep4_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep4_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep4_ctrl`] module"]
    #[doc(alias = "U2EP4_CTRL")]
    pub type U2ep4Ctrl = crate::Reg<u2ep4_ctrl::U2ep4CtrlSpec>;
    #[doc = "USB2 endpoint 4 control"]
    pub mod u2ep4_ctrl {
        #[doc = "Register `U2EP4_CTRL` reader"]
        pub type R = crate::R<U2ep4CtrlSpec>;
        #[doc = "Register `U2EP4_CTRL` writer"]
        pub type W = crate::W<U2ep4CtrlSpec>;
        #[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResR = crate::FieldReader;
        #[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResR = crate::FieldReader;
        #[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogR = crate::BitReader;
        #[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogR = crate::BitReader;
        #[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogR = crate::BitReader;
        #[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&self) -> UepTResR {
                UepTResR::new(self.bits & 3)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&self) -> UepRResR {
                UepRResR::new((self.bits >> 2) & 3)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UepAutoTogR {
                UepAutoTogR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UepTTogR {
                UepTTogR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UepRTogR {
                UepRTogR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&mut self) -> UepTResW<U2ep4CtrlSpec> {
                UepTResW::new(self, 0)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&mut self) -> UepRResW<U2ep4CtrlSpec> {
                UepRResW::new(self, 2)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&mut self) -> UepAutoTogW<U2ep4CtrlSpec> {
                UepAutoTogW::new(self, 4)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&mut self) -> UepTTogW<U2ep4CtrlSpec> {
                UepTTogW::new(self, 6)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&mut self) -> UepRTogW<U2ep4CtrlSpec> {
                UepRTogW::new(self, 7)
            }
        }
        #[doc = "USB2 endpoint 4 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep4_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep4_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep4CtrlSpec;
        impl crate::RegisterSpec for U2ep4CtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2ep4_ctrl::R`](R) reader structure"]
        impl crate::Readable for U2ep4CtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep4_ctrl::W`](W) writer structure"]
        impl crate::Writable for U2ep4CtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP4_CTRL to value 0"]
        impl crate::Resettable for U2ep4CtrlSpec {}
    }
    #[doc = "U2EP5_T_LEN (rw) register accessor: USB2 endpoint 5 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep5_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep5_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep5_t_len`] module"]
    #[doc(alias = "U2EP5_T_LEN")]
    pub type U2ep5TLen = crate::Reg<u2ep5_t_len::U2ep5TLenSpec>;
    #[doc = "USB2 endpoint 5 transmittal length"]
    pub mod u2ep5_t_len {
        #[doc = "Register `U2EP5_T_LEN` reader"]
        pub type R = crate::R<U2ep5TLenSpec>;
        #[doc = "Register `U2EP5_T_LEN` writer"]
        pub type W = crate::W<U2ep5TLenSpec>;
        #[doc = "Field `UEP5_T_LEN` reader - endpoint 5 transmittal length"]
        pub type Uep5TLenR = crate::FieldReader;
        #[doc = "Field `UEP5_T_LEN` writer - endpoint 5 transmittal length"]
        pub type Uep5TLenW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - endpoint 5 transmittal length"]
            #[inline(always)]
            pub fn uep5_t_len(&self) -> Uep5TLenR {
                Uep5TLenR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - endpoint 5 transmittal length"]
            #[inline(always)]
            pub fn uep5_t_len(&mut self) -> Uep5TLenW<U2ep5TLenSpec> {
                Uep5TLenW::new(self, 0)
            }
        }
        #[doc = "USB2 endpoint 5 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep5_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep5_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep5TLenSpec;
        impl crate::RegisterSpec for U2ep5TLenSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2ep5_t_len::R`](R) reader structure"]
        impl crate::Readable for U2ep5TLenSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep5_t_len::W`](W) writer structure"]
        impl crate::Writable for U2ep5TLenSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP5_T_LEN to value 0"]
        impl crate::Resettable for U2ep5TLenSpec {}
    }
    #[doc = "U2EP5_CTRL (rw) register accessor: USB2 endpoint 5 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep5_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep5_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep5_ctrl`] module"]
    #[doc(alias = "U2EP5_CTRL")]
    pub type U2ep5Ctrl = crate::Reg<u2ep5_ctrl::U2ep5CtrlSpec>;
    #[doc = "USB2 endpoint 5 control"]
    pub mod u2ep5_ctrl {
        #[doc = "Register `U2EP5_CTRL` reader"]
        pub type R = crate::R<U2ep5CtrlSpec>;
        #[doc = "Register `U2EP5_CTRL` writer"]
        pub type W = crate::W<U2ep5CtrlSpec>;
        #[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResR = crate::FieldReader;
        #[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResR = crate::FieldReader;
        #[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogR = crate::BitReader;
        #[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogR = crate::BitReader;
        #[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogR = crate::BitReader;
        #[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&self) -> UepTResR {
                UepTResR::new(self.bits & 3)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&self) -> UepRResR {
                UepRResR::new((self.bits >> 2) & 3)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UepAutoTogR {
                UepAutoTogR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UepTTogR {
                UepTTogR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UepRTogR {
                UepRTogR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&mut self) -> UepTResW<U2ep5CtrlSpec> {
                UepTResW::new(self, 0)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&mut self) -> UepRResW<U2ep5CtrlSpec> {
                UepRResW::new(self, 2)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&mut self) -> UepAutoTogW<U2ep5CtrlSpec> {
                UepAutoTogW::new(self, 4)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&mut self) -> UepTTogW<U2ep5CtrlSpec> {
                UepTTogW::new(self, 6)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&mut self) -> UepRTogW<U2ep5CtrlSpec> {
                UepRTogW::new(self, 7)
            }
        }
        #[doc = "USB2 endpoint 5 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep5_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep5_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep5CtrlSpec;
        impl crate::RegisterSpec for U2ep5CtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2ep5_ctrl::R`](R) reader structure"]
        impl crate::Readable for U2ep5CtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep5_ctrl::W`](W) writer structure"]
        impl crate::Writable for U2ep5CtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP5_CTRL to value 0"]
        impl crate::Resettable for U2ep5CtrlSpec {}
    }
    #[doc = "U2EP6_T_LEN (rw) register accessor: USB2 endpoint 6 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep6_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep6_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep6_t_len`] module"]
    #[doc(alias = "U2EP6_T_LEN")]
    pub type U2ep6TLen = crate::Reg<u2ep6_t_len::U2ep6TLenSpec>;
    #[doc = "USB2 endpoint 6 transmittal length"]
    pub mod u2ep6_t_len {
        #[doc = "Register `U2EP6_T_LEN` reader"]
        pub type R = crate::R<U2ep6TLenSpec>;
        #[doc = "Register `U2EP6_T_LEN` writer"]
        pub type W = crate::W<U2ep6TLenSpec>;
        #[doc = "Field `UEP6_T_LEN` reader - endpoint 6 transmittal length"]
        pub type Uep6TLenR = crate::FieldReader;
        #[doc = "Field `UEP6_T_LEN` writer - endpoint 6 transmittal length"]
        pub type Uep6TLenW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - endpoint 6 transmittal length"]
            #[inline(always)]
            pub fn uep6_t_len(&self) -> Uep6TLenR {
                Uep6TLenR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - endpoint 6 transmittal length"]
            #[inline(always)]
            pub fn uep6_t_len(&mut self) -> Uep6TLenW<U2ep6TLenSpec> {
                Uep6TLenW::new(self, 0)
            }
        }
        #[doc = "USB2 endpoint 6 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep6_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep6_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep6TLenSpec;
        impl crate::RegisterSpec for U2ep6TLenSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2ep6_t_len::R`](R) reader structure"]
        impl crate::Readable for U2ep6TLenSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep6_t_len::W`](W) writer structure"]
        impl crate::Writable for U2ep6TLenSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP6_T_LEN to value 0"]
        impl crate::Resettable for U2ep6TLenSpec {}
    }
    #[doc = "U2EP6_CTRL (rw) register accessor: USB2 endpoint 6 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep6_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep6_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep6_ctrl`] module"]
    #[doc(alias = "U2EP6_CTRL")]
    pub type U2ep6Ctrl = crate::Reg<u2ep6_ctrl::U2ep6CtrlSpec>;
    #[doc = "USB2 endpoint 6 control"]
    pub mod u2ep6_ctrl {
        #[doc = "Register `U2EP6_CTRL` reader"]
        pub type R = crate::R<U2ep6CtrlSpec>;
        #[doc = "Register `U2EP6_CTRL` writer"]
        pub type W = crate::W<U2ep6CtrlSpec>;
        #[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResR = crate::FieldReader;
        #[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResR = crate::FieldReader;
        #[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogR = crate::BitReader;
        #[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogR = crate::BitReader;
        #[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogR = crate::BitReader;
        #[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&self) -> UepTResR {
                UepTResR::new(self.bits & 3)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&self) -> UepRResR {
                UepRResR::new((self.bits >> 2) & 3)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UepAutoTogR {
                UepAutoTogR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UepTTogR {
                UepTTogR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UepRTogR {
                UepRTogR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&mut self) -> UepTResW<U2ep6CtrlSpec> {
                UepTResW::new(self, 0)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&mut self) -> UepRResW<U2ep6CtrlSpec> {
                UepRResW::new(self, 2)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&mut self) -> UepAutoTogW<U2ep6CtrlSpec> {
                UepAutoTogW::new(self, 4)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&mut self) -> UepTTogW<U2ep6CtrlSpec> {
                UepTTogW::new(self, 6)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&mut self) -> UepRTogW<U2ep6CtrlSpec> {
                UepRTogW::new(self, 7)
            }
        }
        #[doc = "USB2 endpoint 6 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep6_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep6_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep6CtrlSpec;
        impl crate::RegisterSpec for U2ep6CtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2ep6_ctrl::R`](R) reader structure"]
        impl crate::Readable for U2ep6CtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep6_ctrl::W`](W) writer structure"]
        impl crate::Writable for U2ep6CtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP6_CTRL to value 0"]
        impl crate::Resettable for U2ep6CtrlSpec {}
    }
    #[doc = "U2EP7_T_LEN (rw) register accessor: USB2 endpoint 7 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep7_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep7_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep7_t_len`] module"]
    #[doc(alias = "U2EP7_T_LEN")]
    pub type U2ep7TLen = crate::Reg<u2ep7_t_len::U2ep7TLenSpec>;
    #[doc = "USB2 endpoint 7 transmittal length"]
    pub mod u2ep7_t_len {
        #[doc = "Register `U2EP7_T_LEN` reader"]
        pub type R = crate::R<U2ep7TLenSpec>;
        #[doc = "Register `U2EP7_T_LEN` writer"]
        pub type W = crate::W<U2ep7TLenSpec>;
        #[doc = "Field `UEP7_T_LEN` reader - endpoint 7 transmittal length"]
        pub type Uep7TLenR = crate::FieldReader;
        #[doc = "Field `UEP7_T_LEN` writer - endpoint 7 transmittal length"]
        pub type Uep7TLenW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - endpoint 7 transmittal length"]
            #[inline(always)]
            pub fn uep7_t_len(&self) -> Uep7TLenR {
                Uep7TLenR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - endpoint 7 transmittal length"]
            #[inline(always)]
            pub fn uep7_t_len(&mut self) -> Uep7TLenW<U2ep7TLenSpec> {
                Uep7TLenW::new(self, 0)
            }
        }
        #[doc = "USB2 endpoint 7 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep7_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep7_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep7TLenSpec;
        impl crate::RegisterSpec for U2ep7TLenSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2ep7_t_len::R`](R) reader structure"]
        impl crate::Readable for U2ep7TLenSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep7_t_len::W`](W) writer structure"]
        impl crate::Writable for U2ep7TLenSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP7_T_LEN to value 0"]
        impl crate::Resettable for U2ep7TLenSpec {}
    }
    #[doc = "U2EP7_CTRL (rw) register accessor: USB2 endpoint 7 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep7_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep7_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep7_ctrl`] module"]
    #[doc(alias = "U2EP7_CTRL")]
    pub type U2ep7Ctrl = crate::Reg<u2ep7_ctrl::U2ep7CtrlSpec>;
    #[doc = "USB2 endpoint 7 control"]
    pub mod u2ep7_ctrl {
        #[doc = "Register `U2EP7_CTRL` reader"]
        pub type R = crate::R<U2ep7CtrlSpec>;
        #[doc = "Register `U2EP7_CTRL` writer"]
        pub type W = crate::W<U2ep7CtrlSpec>;
        #[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResR = crate::FieldReader;
        #[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
        pub type UepTResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResR = crate::FieldReader;
        #[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
        pub type UepRResW<'a, REG> = crate::FieldWriter<'a, REG, 2>;
        #[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogR = crate::BitReader;
        #[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
        pub type UepAutoTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogR = crate::BitReader;
        #[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
        pub type UepTTogW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogR = crate::BitReader;
        #[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
        pub type UepRTogW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&self) -> UepTResR {
                UepTResR::new(self.bits & 3)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&self) -> UepRResR {
                UepRResR::new((self.bits >> 2) & 3)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&self) -> UepAutoTogR {
                UepAutoTogR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&self) -> UepTTogR {
                UepTTogR::new(((self.bits >> 6) & 1) != 0)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&self) -> UepRTogR {
                UepRTogR::new(((self.bits >> 7) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
            #[inline(always)]
            pub fn uep_t_res(&mut self) -> UepTResW<U2ep7CtrlSpec> {
                UepTResW::new(self, 0)
            }
            #[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
            #[inline(always)]
            pub fn uep_r_res(&mut self) -> UepRResW<U2ep7CtrlSpec> {
                UepRResW::new(self, 2)
            }
            #[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
            #[inline(always)]
            pub fn uep_auto_tog(&mut self) -> UepAutoTogW<U2ep7CtrlSpec> {
                UepAutoTogW::new(self, 4)
            }
            #[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_t_tog(&mut self) -> UepTTogW<U2ep7CtrlSpec> {
                UepTTogW::new(self, 6)
            }
            #[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
            #[inline(always)]
            pub fn uep_r_tog(&mut self) -> UepRTogW<U2ep7CtrlSpec> {
                UepRTogW::new(self, 7)
            }
        }
        #[doc = "USB2 endpoint 7 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep7_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep7_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct U2ep7CtrlSpec;
        impl crate::RegisterSpec for U2ep7CtrlSpec {
            type Ux = u8;
        }
        #[doc = "`read()` method returns [`u2ep7_ctrl::R`](R) reader structure"]
        impl crate::Readable for U2ep7CtrlSpec {}
        #[doc = "`write(|w| ..)` method takes [`u2ep7_ctrl::W`](W) writer structure"]
        impl crate::Writable for U2ep7CtrlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets U2EP7_CTRL to value 0"]
        impl crate::Resettable for U2ep7CtrlSpec {}
    }
}
#[doc = "Program Fast Interrupt Controller"]
pub type Pfic = crate::Periph<pfic::RegisterBlock, 0xe000_e000>;
impl core::fmt::Debug for Pfic {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pfic").finish()
    }
}
#[doc = "Program Fast Interrupt Controller"]
pub mod pfic {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        isr1: Isr1,
        isr2: Isr2,
        _reserved2: [u8; 0x18],
        ipr1: Ipr1,
        ipr2: Ipr2,
        _reserved4: [u8; 0x18],
        ithresdr: Ithresdr,
        _reserved5: [u8; 0x04],
        cfgr: Cfgr,
        gisr: Gisr,
        idcfgr: Idcfgr,
        _reserved8: [u8; 0x0c],
        fiaddrr0: Fiaddrr0,
        fiaddrr1: Fiaddrr1,
        fiaddrr2: Fiaddrr2,
        fiaddrr3: Fiaddrr3,
        _reserved12: [u8; 0x90],
        ienr1: Ienr1,
        ienr2: Ienr2,
        _reserved14: [u8; 0x78],
        irer1: Irer1,
        irer2: Irer2,
        _reserved16: [u8; 0x78],
        ipsr1: Ipsr1,
        ipsr2: Ipsr2,
        _reserved18: [u8; 0x78],
        iprr1: Iprr1,
        iprr2: Iprr2,
        _reserved20: [u8; 0x78],
        iactr1: Iactr1,
        iactr2: Iactr2,
        _reserved22: [u8; 0xf8],
        iprior0: Iprior0,
        _reserved23: [u8; 0x1c],
        iprior1: Iprior1,
        _reserved24: [u8; 0x1c],
        iprior2: Iprior2,
        _reserved25: [u8; 0x1c],
        iprior3: Iprior3,
        _reserved26: [u8; 0x1c],
        iprior4: Iprior4,
        _reserved27: [u8; 0x1c],
        iprior5: Iprior5,
        _reserved28: [u8; 0x1c],
        iprior6: Iprior6,
        _reserved29: [u8; 0x1c],
        iprior7: Iprior7,
        _reserved30: [u8; 0x1c],
        iprior8: Iprior8,
        _reserved31: [u8; 0x1c],
        iprior9: Iprior9,
        _reserved32: [u8; 0x1c],
        iprior10: Iprior10,
        _reserved33: [u8; 0x1c],
        iprior11: Iprior11,
        _reserved34: [u8; 0x1c],
        iprior12: Iprior12,
        _reserved35: [u8; 0x1c],
        iprior13: Iprior13,
        _reserved36: [u8; 0x1c],
        iprior14: Iprior14,
        _reserved37: [u8; 0x1c],
        iprior15: Iprior15,
        _reserved38: [u8; 0x1c],
        iprior16: Iprior16,
        _reserved39: [u8; 0x1c],
        iprior17: Iprior17,
        _reserved40: [u8; 0x1c],
        iprior18: Iprior18,
        _reserved41: [u8; 0x1c],
        iprior19: Iprior19,
        _reserved42: [u8; 0x1c],
        iprior20: Iprior20,
        _reserved43: [u8; 0x1c],
        iprior21: Iprior21,
        _reserved44: [u8; 0x1c],
        iprior22: Iprior22,
        _reserved45: [u8; 0x1c],
        iprior23: Iprior23,
        _reserved46: [u8; 0x1c],
        iprior24: Iprior24,
        _reserved47: [u8; 0x1c],
        iprior25: Iprior25,
        _reserved48: [u8; 0x1c],
        iprior26: Iprior26,
        _reserved49: [u8; 0x1c],
        iprior27: Iprior27,
        _reserved50: [u8; 0x1c],
        iprior28: Iprior28,
        _reserved51: [u8; 0x1c],
        iprior29: Iprior29,
        _reserved52: [u8; 0x1c],
        iprior30: Iprior30,
        _reserved53: [u8; 0x1c],
        iprior31: Iprior31,
        _reserved54: [u8; 0x1c],
        iprior32: Iprior32,
        _reserved55: [u8; 0x1c],
        iprior33: Iprior33,
        _reserved56: [u8; 0x1c],
        iprior34: Iprior34,
        _reserved57: [u8; 0x1c],
        iprior35: Iprior35,
        _reserved58: [u8; 0x1c],
        iprior36: Iprior36,
        _reserved59: [u8; 0x1c],
        iprior37: Iprior37,
        _reserved60: [u8; 0x1c],
        iprior38: Iprior38,
        _reserved61: [u8; 0x1c],
        iprior39: Iprior39,
        _reserved62: [u8; 0x1c],
        iprior40: Iprior40,
        _reserved63: [u8; 0x1c],
        iprior41: Iprior41,
        _reserved64: [u8; 0x1c],
        iprior42: Iprior42,
        _reserved65: [u8; 0x1c],
        iprior43: Iprior43,
        _reserved66: [u8; 0x1c],
        iprior44: Iprior44,
        _reserved67: [u8; 0x1c],
        iprior45: Iprior45,
        _reserved68: [u8; 0x1c],
        iprior46: Iprior46,
        _reserved69: [u8; 0x1c],
        iprior47: Iprior47,
        _reserved70: [u8; 0x1c],
        iprior48: Iprior48,
        _reserved71: [u8; 0x1c],
        iprior49: Iprior49,
        _reserved72: [u8; 0x1c],
        iprior50: Iprior50,
        _reserved73: [u8; 0x1c],
        iprior51: Iprior51,
        _reserved74: [u8; 0x1c],
        iprior52: Iprior52,
        _reserved75: [u8; 0x1c],
        iprior53: Iprior53,
        _reserved76: [u8; 0x2c],
        iprior54: Iprior54,
        _reserved77: [u8; 0x0c],
        iprior55: Iprior55,
        _reserved78: [u8; 0x1c],
        iprior56: Iprior56,
        _reserved79: [u8; 0x1c],
        iprior57: Iprior57,
        _reserved80: [u8; 0x1c],
        iprior58: Iprior58,
        _reserved81: [u8; 0x1c],
        iprior59: Iprior59,
        _reserved82: [u8; 0x1c],
        iprior60: Iprior60,
        _reserved83: [u8; 0x1c],
        iprior61: Iprior61,
        _reserved84: [u8; 0x3c],
        iprior62: Iprior62,
        _reserved85: [u8; 0x1c],
        iprior63: Iprior63,
        _reserved86: [u8; 0x010c],
        sctlr: Sctlr,
    }
    impl RegisterBlock {
        #[doc = "0x00 - RO,Interrupt Status Register 1"]
        #[inline(always)]
        pub const fn isr1(&self) -> &Isr1 {
            &self.isr1
        }
        #[doc = "0x04 - RO,Interrupt Status Register 2"]
        #[inline(always)]
        pub const fn isr2(&self) -> &Isr2 {
            &self.isr2
        }
        #[doc = "0x20 - RO,Interrupt Pending Register 1"]
        #[inline(always)]
        pub const fn ipr1(&self) -> &Ipr1 {
            &self.ipr1
        }
        #[doc = "0x24 - RO,Interrupt Pending Register 2"]
        #[inline(always)]
        pub const fn ipr2(&self) -> &Ipr2 {
            &self.ipr2
        }
        #[doc = "0x40 - RW,Interrupt Priority Register"]
        #[inline(always)]
        pub const fn ithresdr(&self) -> &Ithresdr {
            &self.ithresdr
        }
        #[doc = "0x48 - Interrupt Config Register"]
        #[inline(always)]
        pub const fn cfgr(&self) -> &Cfgr {
            &self.cfgr
        }
        #[doc = "0x4c - Interrupt Global Register"]
        #[inline(always)]
        pub const fn gisr(&self) -> &Gisr {
            &self.gisr
        }
        #[doc = "0x50 - RW,Interrupt Fast ID Config Register"]
        #[inline(always)]
        pub const fn idcfgr(&self) -> &Idcfgr {
            &self.idcfgr
        }
        #[doc = "0x60 - Interrupt 0 address Register"]
        #[inline(always)]
        pub const fn fiaddrr0(&self) -> &Fiaddrr0 {
            &self.fiaddrr0
        }
        #[doc = "0x64 - Interrupt 1 address Register"]
        #[inline(always)]
        pub const fn fiaddrr1(&self) -> &Fiaddrr1 {
            &self.fiaddrr1
        }
        #[doc = "0x68 - Interrupt 2 address Register"]
        #[inline(always)]
        pub const fn fiaddrr2(&self) -> &Fiaddrr2 {
            &self.fiaddrr2
        }
        #[doc = "0x6c - Interrupt 3 address Register"]
        #[inline(always)]
        pub const fn fiaddrr3(&self) -> &Fiaddrr3 {
            &self.fiaddrr3
        }
        #[doc = "0x100 - Interrupt Setting Register"]
        #[inline(always)]
        pub const fn ienr1(&self) -> &Ienr1 {
            &self.ienr1
        }
        #[doc = "0x104 - Interrupt Setting Register"]
        #[inline(always)]
        pub const fn ienr2(&self) -> &Ienr2 {
            &self.ienr2
        }
        #[doc = "0x180 - Interrupt Clear Register"]
        #[inline(always)]
        pub const fn irer1(&self) -> &Irer1 {
            &self.irer1
        }
        #[doc = "0x184 - Interrupt Clear Register"]
        #[inline(always)]
        pub const fn irer2(&self) -> &Irer2 {
            &self.irer2
        }
        #[doc = "0x200 - Interrupt Pending Register"]
        #[inline(always)]
        pub const fn ipsr1(&self) -> &Ipsr1 {
            &self.ipsr1
        }
        #[doc = "0x204 - Interrupt Pending Register"]
        #[inline(always)]
        pub const fn ipsr2(&self) -> &Ipsr2 {
            &self.ipsr2
        }
        #[doc = "0x280 - Interrupt Pending Clear Register"]
        #[inline(always)]
        pub const fn iprr1(&self) -> &Iprr1 {
            &self.iprr1
        }
        #[doc = "0x284 - Interrupt Pending Clear Register"]
        #[inline(always)]
        pub const fn iprr2(&self) -> &Iprr2 {
            &self.iprr2
        }
        #[doc = "0x300 - Interrupt ACTIVE Register"]
        #[inline(always)]
        pub const fn iactr1(&self) -> &Iactr1 {
            &self.iactr1
        }
        #[doc = "0x304 - Interrupt ACTIVE Register"]
        #[inline(always)]
        pub const fn iactr2(&self) -> &Iactr2 {
            &self.iactr2
        }
        #[doc = "0x400 - Interrupt Priority configuration Register 0"]
        #[inline(always)]
        pub const fn iprior0(&self) -> &Iprior0 {
            &self.iprior0
        }
        #[doc = "0x420 - Interrupt Priority configuration Register 1"]
        #[inline(always)]
        pub const fn iprior1(&self) -> &Iprior1 {
            &self.iprior1
        }
        #[doc = "0x440 - Interrupt Priority configuration Register 2"]
        #[inline(always)]
        pub const fn iprior2(&self) -> &Iprior2 {
            &self.iprior2
        }
        #[doc = "0x460 - Interrupt Priority configuration Register 3"]
        #[inline(always)]
        pub const fn iprior3(&self) -> &Iprior3 {
            &self.iprior3
        }
        #[doc = "0x480 - Interrupt Priority configuration Register 4"]
        #[inline(always)]
        pub const fn iprior4(&self) -> &Iprior4 {
            &self.iprior4
        }
        #[doc = "0x4a0 - Interrupt Priority configuration Register 5"]
        #[inline(always)]
        pub const fn iprior5(&self) -> &Iprior5 {
            &self.iprior5
        }
        #[doc = "0x4c0 - Interrupt Priority configuration Register 6"]
        #[inline(always)]
        pub const fn iprior6(&self) -> &Iprior6 {
            &self.iprior6
        }
        #[doc = "0x4e0 - Interrupt Priority configuration Register 7"]
        #[inline(always)]
        pub const fn iprior7(&self) -> &Iprior7 {
            &self.iprior7
        }
        #[doc = "0x500 - Interrupt Priority configuration Register 8"]
        #[inline(always)]
        pub const fn iprior8(&self) -> &Iprior8 {
            &self.iprior8
        }
        #[doc = "0x520 - Interrupt Priority configuration Register 9"]
        #[inline(always)]
        pub const fn iprior9(&self) -> &Iprior9 {
            &self.iprior9
        }
        #[doc = "0x540 - Interrupt Priority configuration Register 10"]
        #[inline(always)]
        pub const fn iprior10(&self) -> &Iprior10 {
            &self.iprior10
        }
        #[doc = "0x560 - Interrupt Priority configuration Register 11"]
        #[inline(always)]
        pub const fn iprior11(&self) -> &Iprior11 {
            &self.iprior11
        }
        #[doc = "0x580 - Interrupt Priority configuration Register 12"]
        #[inline(always)]
        pub const fn iprior12(&self) -> &Iprior12 {
            &self.iprior12
        }
        #[doc = "0x5a0 - Interrupt Priority configuration Register 13"]
        #[inline(always)]
        pub const fn iprior13(&self) -> &Iprior13 {
            &self.iprior13
        }
        #[doc = "0x5c0 - Interrupt Priority configuration Register 14"]
        #[inline(always)]
        pub const fn iprior14(&self) -> &Iprior14 {
            &self.iprior14
        }
        #[doc = "0x5e0 - Interrupt Priority configuration Register 15"]
        #[inline(always)]
        pub const fn iprior15(&self) -> &Iprior15 {
            &self.iprior15
        }
        #[doc = "0x600 - Interrupt Priority configuration Register 16"]
        #[inline(always)]
        pub const fn iprior16(&self) -> &Iprior16 {
            &self.iprior16
        }
        #[doc = "0x620 - Interrupt Priority configuration Register 17"]
        #[inline(always)]
        pub const fn iprior17(&self) -> &Iprior17 {
            &self.iprior17
        }
        #[doc = "0x640 - Interrupt Priority configuration Register 18"]
        #[inline(always)]
        pub const fn iprior18(&self) -> &Iprior18 {
            &self.iprior18
        }
        #[doc = "0x660 - Interrupt Priority configuration Register 19"]
        #[inline(always)]
        pub const fn iprior19(&self) -> &Iprior19 {
            &self.iprior19
        }
        #[doc = "0x680 - Interrupt Priority configuration Register 20"]
        #[inline(always)]
        pub const fn iprior20(&self) -> &Iprior20 {
            &self.iprior20
        }
        #[doc = "0x6a0 - Interrupt Priority configuration Register 21"]
        #[inline(always)]
        pub const fn iprior21(&self) -> &Iprior21 {
            &self.iprior21
        }
        #[doc = "0x6c0 - Interrupt Priority configuration Register 22"]
        #[inline(always)]
        pub const fn iprior22(&self) -> &Iprior22 {
            &self.iprior22
        }
        #[doc = "0x6e0 - Interrupt Priority configuration Register 23"]
        #[inline(always)]
        pub const fn iprior23(&self) -> &Iprior23 {
            &self.iprior23
        }
        #[doc = "0x700 - Interrupt Priority configuration Register 24"]
        #[inline(always)]
        pub const fn iprior24(&self) -> &Iprior24 {
            &self.iprior24
        }
        #[doc = "0x720 - Interrupt Priority configuration Register 25"]
        #[inline(always)]
        pub const fn iprior25(&self) -> &Iprior25 {
            &self.iprior25
        }
        #[doc = "0x740 - Interrupt Priority configuration Register 26"]
        #[inline(always)]
        pub const fn iprior26(&self) -> &Iprior26 {
            &self.iprior26
        }
        #[doc = "0x760 - Interrupt Priority configuration Register 27"]
        #[inline(always)]
        pub const fn iprior27(&self) -> &Iprior27 {
            &self.iprior27
        }
        #[doc = "0x780 - Interrupt Priority configuration Register 28"]
        #[inline(always)]
        pub const fn iprior28(&self) -> &Iprior28 {
            &self.iprior28
        }
        #[doc = "0x7a0 - Interrupt Priority configuration Register 29"]
        #[inline(always)]
        pub const fn iprior29(&self) -> &Iprior29 {
            &self.iprior29
        }
        #[doc = "0x7c0 - Interrupt Priority configuration Register 30"]
        #[inline(always)]
        pub const fn iprior30(&self) -> &Iprior30 {
            &self.iprior30
        }
        #[doc = "0x7e0 - Interrupt Priority configuration Register 31"]
        #[inline(always)]
        pub const fn iprior31(&self) -> &Iprior31 {
            &self.iprior31
        }
        #[doc = "0x800 - Interrupt Priority configuration Register 32"]
        #[inline(always)]
        pub const fn iprior32(&self) -> &Iprior32 {
            &self.iprior32
        }
        #[doc = "0x820 - Interrupt Priority configuration Register 33"]
        #[inline(always)]
        pub const fn iprior33(&self) -> &Iprior33 {
            &self.iprior33
        }
        #[doc = "0x840 - Interrupt Priority configuration Register 34"]
        #[inline(always)]
        pub const fn iprior34(&self) -> &Iprior34 {
            &self.iprior34
        }
        #[doc = "0x860 - Interrupt Priority configuration Register 35"]
        #[inline(always)]
        pub const fn iprior35(&self) -> &Iprior35 {
            &self.iprior35
        }
        #[doc = "0x880 - Interrupt Priority configuration Register 36"]
        #[inline(always)]
        pub const fn iprior36(&self) -> &Iprior36 {
            &self.iprior36
        }
        #[doc = "0x8a0 - Interrupt Priority configuration Register 37"]
        #[inline(always)]
        pub const fn iprior37(&self) -> &Iprior37 {
            &self.iprior37
        }
        #[doc = "0x8c0 - Interrupt Priority configuration Register 38"]
        #[inline(always)]
        pub const fn iprior38(&self) -> &Iprior38 {
            &self.iprior38
        }
        #[doc = "0x8e0 - Interrupt Priority configuration Register 39"]
        #[inline(always)]
        pub const fn iprior39(&self) -> &Iprior39 {
            &self.iprior39
        }
        #[doc = "0x900 - Interrupt Priority configuration Register 40"]
        #[inline(always)]
        pub const fn iprior40(&self) -> &Iprior40 {
            &self.iprior40
        }
        #[doc = "0x920 - Interrupt Priority configuration Register 41"]
        #[inline(always)]
        pub const fn iprior41(&self) -> &Iprior41 {
            &self.iprior41
        }
        #[doc = "0x940 - Interrupt Priority configuration Register 42"]
        #[inline(always)]
        pub const fn iprior42(&self) -> &Iprior42 {
            &self.iprior42
        }
        #[doc = "0x960 - Interrupt Priority configuration Register 43"]
        #[inline(always)]
        pub const fn iprior43(&self) -> &Iprior43 {
            &self.iprior43
        }
        #[doc = "0x980 - Interrupt Priority configuration Register 44"]
        #[inline(always)]
        pub const fn iprior44(&self) -> &Iprior44 {
            &self.iprior44
        }
        #[doc = "0x9a0 - Interrupt Priority configuration Register 45"]
        #[inline(always)]
        pub const fn iprior45(&self) -> &Iprior45 {
            &self.iprior45
        }
        #[doc = "0x9c0 - Interrupt Priority configuration Register 46"]
        #[inline(always)]
        pub const fn iprior46(&self) -> &Iprior46 {
            &self.iprior46
        }
        #[doc = "0x9e0 - Interrupt Priority configuration Register 47"]
        #[inline(always)]
        pub const fn iprior47(&self) -> &Iprior47 {
            &self.iprior47
        }
        #[doc = "0xa00 - Interrupt Priority configuration Register 48"]
        #[inline(always)]
        pub const fn iprior48(&self) -> &Iprior48 {
            &self.iprior48
        }
        #[doc = "0xa20 - Interrupt Priority configuration Register 49"]
        #[inline(always)]
        pub const fn iprior49(&self) -> &Iprior49 {
            &self.iprior49
        }
        #[doc = "0xa40 - Interrupt Priority configuration Register 50"]
        #[inline(always)]
        pub const fn iprior50(&self) -> &Iprior50 {
            &self.iprior50
        }
        #[doc = "0xa60 - Interrupt Priority configuration Register 51"]
        #[inline(always)]
        pub const fn iprior51(&self) -> &Iprior51 {
            &self.iprior51
        }
        #[doc = "0xa80 - Interrupt Priority configuration Register 52"]
        #[inline(always)]
        pub const fn iprior52(&self) -> &Iprior52 {
            &self.iprior52
        }
        #[doc = "0xaa0 - Interrupt Priority configuration Register 53"]
        #[inline(always)]
        pub const fn iprior53(&self) -> &Iprior53 {
            &self.iprior53
        }
        #[doc = "0xad0 - Interrupt Priority configuration Register 54"]
        #[inline(always)]
        pub const fn iprior54(&self) -> &Iprior54 {
            &self.iprior54
        }
        #[doc = "0xae0 - Interrupt Priority configuration Register 55"]
        #[inline(always)]
        pub const fn iprior55(&self) -> &Iprior55 {
            &self.iprior55
        }
        #[doc = "0xb00 - Interrupt Priority configuration Register 56"]
        #[inline(always)]
        pub const fn iprior56(&self) -> &Iprior56 {
            &self.iprior56
        }
        #[doc = "0xb20 - Interrupt Priority configuration Register 57"]
        #[inline(always)]
        pub const fn iprior57(&self) -> &Iprior57 {
            &self.iprior57
        }
        #[doc = "0xb40 - Interrupt Priority configuration Register 58"]
        #[inline(always)]
        pub const fn iprior58(&self) -> &Iprior58 {
            &self.iprior58
        }
        #[doc = "0xb60 - Interrupt Priority configuration Register 59"]
        #[inline(always)]
        pub const fn iprior59(&self) -> &Iprior59 {
            &self.iprior59
        }
        #[doc = "0xb80 - Interrupt Priority configuration Register 60"]
        #[inline(always)]
        pub const fn iprior60(&self) -> &Iprior60 {
            &self.iprior60
        }
        #[doc = "0xba0 - Interrupt Priority configuration Register 61"]
        #[inline(always)]
        pub const fn iprior61(&self) -> &Iprior61 {
            &self.iprior61
        }
        #[doc = "0xbe0 - Interrupt Priority configuration Register 62"]
        #[inline(always)]
        pub const fn iprior62(&self) -> &Iprior62 {
            &self.iprior62
        }
        #[doc = "0xc00 - Interrupt Priority configuration Register 63"]
        #[inline(always)]
        pub const fn iprior63(&self) -> &Iprior63 {
            &self.iprior63
        }
        #[doc = "0xd10 - System Control Register"]
        #[inline(always)]
        pub const fn sctlr(&self) -> &Sctlr {
            &self.sctlr
        }
    }
    #[doc = "ISR1 (r) register accessor: RO,Interrupt Status Register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`isr1::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@isr1`] module"]
    #[doc(alias = "ISR1")]
    pub type Isr1 = crate::Reg<isr1::Isr1Spec>;
    #[doc = "RO,Interrupt Status Register 1"]
    pub mod isr1 {
        #[doc = "Register `ISR1` reader"]
        pub type R = crate::R<Isr1Spec>;
        #[doc = "Field `INTENSTA` reader - Interrupt ID Status"]
        pub type IntenstaR = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 12:31 - Interrupt ID Status"]
            #[inline(always)]
            pub fn intensta(&self) -> IntenstaR {
                IntenstaR::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        #[doc = "RO,Interrupt Status Register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`isr1::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Isr1Spec;
        impl crate::RegisterSpec for Isr1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`isr1::R`](R) reader structure"]
        impl crate::Readable for Isr1Spec {}
        #[doc = "`reset()` method sets ISR1 to value 0"]
        impl crate::Resettable for Isr1Spec {}
    }
    #[doc = "ISR2 (r) register accessor: RO,Interrupt Status Register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`isr2::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@isr2`] module"]
    #[doc(alias = "ISR2")]
    pub type Isr2 = crate::Reg<isr2::Isr2Spec>;
    #[doc = "RO,Interrupt Status Register 2"]
    pub mod isr2 {
        #[doc = "Register `ISR2` reader"]
        pub type R = crate::R<Isr2Spec>;
        #[doc = "Field `INTENSTA` reader - Interrupt ID Status"]
        pub type IntenstaR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:3 - Interrupt ID Status"]
            #[inline(always)]
            pub fn intensta(&self) -> IntenstaR {
                IntenstaR::new((self.bits & 0x0f) as u8)
            }
        }
        #[doc = "RO,Interrupt Status Register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`isr2::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Isr2Spec;
        impl crate::RegisterSpec for Isr2Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`isr2::R`](R) reader structure"]
        impl crate::Readable for Isr2Spec {}
        #[doc = "`reset()` method sets ISR2 to value 0"]
        impl crate::Resettable for Isr2Spec {}
    }
    #[doc = "IPR1 (r) register accessor: RO,Interrupt Pending Register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ipr1::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ipr1`] module"]
    #[doc(alias = "IPR1")]
    pub type Ipr1 = crate::Reg<ipr1::Ipr1Spec>;
    #[doc = "RO,Interrupt Pending Register 1"]
    pub mod ipr1 {
        #[doc = "Register `IPR1` reader"]
        pub type R = crate::R<Ipr1Spec>;
        #[doc = "Field `PENDSTA` reader - PENDSTA"]
        pub type PendstaR = crate::FieldReader<u32>;
        impl R {
            #[doc = "Bits 12:31 - PENDSTA"]
            #[inline(always)]
            pub fn pendsta(&self) -> PendstaR {
                PendstaR::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        #[doc = "RO,Interrupt Pending Register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ipr1::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ipr1Spec;
        impl crate::RegisterSpec for Ipr1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ipr1::R`](R) reader structure"]
        impl crate::Readable for Ipr1Spec {}
        #[doc = "`reset()` method sets IPR1 to value 0"]
        impl crate::Resettable for Ipr1Spec {}
    }
    #[doc = "IPR2 (r) register accessor: RO,Interrupt Pending Register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ipr2::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ipr2`] module"]
    #[doc(alias = "IPR2")]
    pub type Ipr2 = crate::Reg<ipr2::Ipr2Spec>;
    #[doc = "RO,Interrupt Pending Register 2"]
    pub mod ipr2 {
        #[doc = "Register `IPR2` reader"]
        pub type R = crate::R<Ipr2Spec>;
        #[doc = "Field `PENDSTA` reader - PENDSTA"]
        pub type PendstaR = crate::FieldReader;
        impl R {
            #[doc = "Bits 0:3 - PENDSTA"]
            #[inline(always)]
            pub fn pendsta(&self) -> PendstaR {
                PendstaR::new((self.bits & 0x0f) as u8)
            }
        }
        #[doc = "RO,Interrupt Pending Register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ipr2::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ipr2Spec;
        impl crate::RegisterSpec for Ipr2Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ipr2::R`](R) reader structure"]
        impl crate::Readable for Ipr2Spec {}
        #[doc = "`reset()` method sets IPR2 to value 0"]
        impl crate::Resettable for Ipr2Spec {}
    }
    #[doc = "ITHRESDR (rw) register accessor: RW,Interrupt Priority Register\n\nYou can [`read`](crate::Reg::read) this register and get [`ithresdr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ithresdr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ithresdr`] module"]
    #[doc(alias = "ITHRESDR")]
    pub type Ithresdr = crate::Reg<ithresdr::IthresdrSpec>;
    #[doc = "RW,Interrupt Priority Register"]
    pub mod ithresdr {
        #[doc = "Register `ITHRESDR` reader"]
        pub type R = crate::R<IthresdrSpec>;
        #[doc = "Register `ITHRESDR` writer"]
        pub type W = crate::W<IthresdrSpec>;
        #[doc = "Field `THRESHOLD` reader - RW,THRESHOLD"]
        pub type ThresholdR = crate::FieldReader;
        #[doc = "Field `THRESHOLD` writer - RW,THRESHOLD"]
        pub type ThresholdW<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW,THRESHOLD"]
            #[inline(always)]
            pub fn threshold(&self) -> ThresholdR {
                ThresholdR::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW,THRESHOLD"]
            #[inline(always)]
            pub fn threshold(&mut self) -> ThresholdW<IthresdrSpec> {
                ThresholdW::new(self, 0)
            }
        }
        #[doc = "RW,Interrupt Priority Register\n\nYou can [`read`](crate::Reg::read) this register and get [`ithresdr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ithresdr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IthresdrSpec;
        impl crate::RegisterSpec for IthresdrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ithresdr::R`](R) reader structure"]
        impl crate::Readable for IthresdrSpec {}
        #[doc = "`write(|w| ..)` method takes [`ithresdr::W`](W) writer structure"]
        impl crate::Writable for IthresdrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets ITHRESDR to value 0"]
        impl crate::Resettable for IthresdrSpec {}
    }
    #[doc = "CFGR (w) register accessor: Interrupt Config Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfgr`] module"]
    #[doc(alias = "CFGR")]
    pub type Cfgr = crate::Reg<cfgr::CfgrSpec>;
    #[doc = "Interrupt Config Register"]
    pub mod cfgr {
        #[doc = "Register `CFGR` writer"]
        pub type W = crate::W<CfgrSpec>;
        #[doc = "Field `RESETSYS` writer - WO,RESETSYS"]
        pub type ResetsysW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `KEYCODE` writer - WO,KEYCODE"]
        pub type KeycodeW<'a, REG> = crate::FieldWriter<'a, REG, 16, u16>;
        impl W {
            #[doc = "Bit 7 - WO,RESETSYS"]
            #[inline(always)]
            pub fn resetsys(&mut self) -> ResetsysW<CfgrSpec> {
                ResetsysW::new(self, 7)
            }
            #[doc = "Bits 16:31 - WO,KEYCODE"]
            #[inline(always)]
            pub fn keycode(&mut self) -> KeycodeW<CfgrSpec> {
                KeycodeW::new(self, 16)
            }
        }
        #[doc = "Interrupt Config Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CfgrSpec;
        impl crate::RegisterSpec for CfgrSpec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`cfgr::W`](W) writer structure"]
        impl crate::Writable for CfgrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CFGR to value 0"]
        impl crate::Resettable for CfgrSpec {}
    }
    #[doc = "GISR (r) register accessor: Interrupt Global Register\n\nYou can [`read`](crate::Reg::read) this register and get [`gisr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gisr`] module"]
    #[doc(alias = "GISR")]
    pub type Gisr = crate::Reg<gisr::GisrSpec>;
    #[doc = "Interrupt Global Register"]
    pub mod gisr {
        #[doc = "Register `GISR` reader"]
        pub type R = crate::R<GisrSpec>;
        #[doc = "Field `NESTSTA` reader - RO,NESTSTA"]
        pub type NeststaR = crate::FieldReader;
        #[doc = "Field `GACTSTA` reader - RO,GACTSTA"]
        pub type GactstaR = crate::BitReader;
        #[doc = "Field `GPENDSTA` reader - RO,GPENDSTA"]
        pub type GpendstaR = crate::BitReader;
        impl R {
            #[doc = "Bits 0:7 - RO,NESTSTA"]
            #[inline(always)]
            pub fn neststa(&self) -> NeststaR {
                NeststaR::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bit 8 - RO,GACTSTA"]
            #[inline(always)]
            pub fn gactsta(&self) -> GactstaR {
                GactstaR::new(((self.bits >> 8) & 1) != 0)
            }
            #[doc = "Bit 9 - RO,GPENDSTA"]
            #[inline(always)]
            pub fn gpendsta(&self) -> GpendstaR {
                GpendstaR::new(((self.bits >> 9) & 1) != 0)
            }
        }
        #[doc = "Interrupt Global Register\n\nYou can [`read`](crate::Reg::read) this register and get [`gisr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct GisrSpec;
        impl crate::RegisterSpec for GisrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`gisr::R`](R) reader structure"]
        impl crate::Readable for GisrSpec {}
        #[doc = "`reset()` method sets GISR to value 0"]
        impl crate::Resettable for GisrSpec {}
    }
    #[doc = "IDCFGR (rw) register accessor: RW,Interrupt Fast ID Config Register\n\nYou can [`read`](crate::Reg::read) this register and get [`idcfgr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`idcfgr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@idcfgr`] module"]
    #[doc(alias = "IDCFGR")]
    pub type Idcfgr = crate::Reg<idcfgr::IdcfgrSpec>;
    #[doc = "RW,Interrupt Fast ID Config Register"]
    pub mod idcfgr {
        #[doc = "Register `IDCFGR` reader"]
        pub type R = crate::R<IdcfgrSpec>;
        #[doc = "Register `IDCFGR` writer"]
        pub type W = crate::W<IdcfgrSpec>;
        #[doc = "Field `FIID0` reader - RW,FIID0"]
        pub type Fiid0R = crate::FieldReader;
        #[doc = "Field `FIID0` writer - RW,FIID0"]
        pub type Fiid0W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `FIID1` reader - RW,FIID1"]
        pub type Fiid1R = crate::FieldReader;
        #[doc = "Field `FIID1` writer - RW,FIID1"]
        pub type Fiid1W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `FIID2` reader - RW,FIID2"]
        pub type Fiid2R = crate::FieldReader;
        #[doc = "Field `FIID2` writer - RW,FIID2"]
        pub type Fiid2W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        #[doc = "Field `FIID3` reader - RW,FIID3"]
        pub type Fiid3R = crate::FieldReader;
        #[doc = "Field `FIID3` writer - RW,FIID3"]
        pub type Fiid3W<'a, REG> = crate::FieldWriter<'a, REG, 8>;
        impl R {
            #[doc = "Bits 0:7 - RW,FIID0"]
            #[inline(always)]
            pub fn fiid0(&self) -> Fiid0R {
                Fiid0R::new((self.bits & 0xff) as u8)
            }
            #[doc = "Bits 8:15 - RW,FIID1"]
            #[inline(always)]
            pub fn fiid1(&self) -> Fiid1R {
                Fiid1R::new(((self.bits >> 8) & 0xff) as u8)
            }
            #[doc = "Bits 16:23 - RW,FIID2"]
            #[inline(always)]
            pub fn fiid2(&self) -> Fiid2R {
                Fiid2R::new(((self.bits >> 16) & 0xff) as u8)
            }
            #[doc = "Bits 24:31 - RW,FIID3"]
            #[inline(always)]
            pub fn fiid3(&self) -> Fiid3R {
                Fiid3R::new(((self.bits >> 24) & 0xff) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:7 - RW,FIID0"]
            #[inline(always)]
            pub fn fiid0(&mut self) -> Fiid0W<IdcfgrSpec> {
                Fiid0W::new(self, 0)
            }
            #[doc = "Bits 8:15 - RW,FIID1"]
            #[inline(always)]
            pub fn fiid1(&mut self) -> Fiid1W<IdcfgrSpec> {
                Fiid1W::new(self, 8)
            }
            #[doc = "Bits 16:23 - RW,FIID2"]
            #[inline(always)]
            pub fn fiid2(&mut self) -> Fiid2W<IdcfgrSpec> {
                Fiid2W::new(self, 16)
            }
            #[doc = "Bits 24:31 - RW,FIID3"]
            #[inline(always)]
            pub fn fiid3(&mut self) -> Fiid3W<IdcfgrSpec> {
                Fiid3W::new(self, 24)
            }
        }
        #[doc = "RW,Interrupt Fast ID Config Register\n\nYou can [`read`](crate::Reg::read) this register and get [`idcfgr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`idcfgr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct IdcfgrSpec;
        impl crate::RegisterSpec for IdcfgrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`idcfgr::R`](R) reader structure"]
        impl crate::Readable for IdcfgrSpec {}
        #[doc = "`write(|w| ..)` method takes [`idcfgr::W`](W) writer structure"]
        impl crate::Writable for IdcfgrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IDCFGR to value 0"]
        impl crate::Resettable for IdcfgrSpec {}
    }
    #[doc = "FIADDRR0 (rw) register accessor: Interrupt 0 address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fiaddrr0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fiaddrr0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fiaddrr0`] module"]
    #[doc(alias = "FIADDRR0")]
    pub type Fiaddrr0 = crate::Reg<fiaddrr0::Fiaddrr0Spec>;
    #[doc = "Interrupt 0 address Register"]
    pub mod fiaddrr0 {
        #[doc = "Register `FIADDRR0` reader"]
        pub type R = crate::R<Fiaddrr0Spec>;
        #[doc = "Register `FIADDRR0` writer"]
        pub type W = crate::W<Fiaddrr0Spec>;
        #[doc = "Field `FI0EN` reader - RW,FI0EN"]
        pub type Fi0enR = crate::BitReader;
        #[doc = "Field `FI0EN` writer - RW,FI0EN"]
        pub type Fi0enW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ADDR0` reader - RW,ADDR0"]
        pub type Addr0R = crate::FieldReader<u32>;
        #[doc = "Field `ADDR0` writer - RW,ADDR0"]
        pub type Addr0W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32>;
        impl R {
            #[doc = "Bit 0 - RW,FI0EN"]
            #[inline(always)]
            pub fn fi0en(&self) -> Fi0enR {
                Fi0enR::new((self.bits & 1) != 0)
            }
            #[doc = "Bits 1:31 - RW,ADDR0"]
            #[inline(always)]
            pub fn addr0(&self) -> Addr0R {
                Addr0R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW,FI0EN"]
            #[inline(always)]
            pub fn fi0en(&mut self) -> Fi0enW<Fiaddrr0Spec> {
                Fi0enW::new(self, 0)
            }
            #[doc = "Bits 1:31 - RW,ADDR0"]
            #[inline(always)]
            pub fn addr0(&mut self) -> Addr0W<Fiaddrr0Spec> {
                Addr0W::new(self, 1)
            }
        }
        #[doc = "Interrupt 0 address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fiaddrr0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fiaddrr0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Fiaddrr0Spec;
        impl crate::RegisterSpec for Fiaddrr0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`fiaddrr0::R`](R) reader structure"]
        impl crate::Readable for Fiaddrr0Spec {}
        #[doc = "`write(|w| ..)` method takes [`fiaddrr0::W`](W) writer structure"]
        impl crate::Writable for Fiaddrr0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FIADDRR0 to value 0"]
        impl crate::Resettable for Fiaddrr0Spec {}
    }
    #[doc = "FIADDRR1 (rw) register accessor: Interrupt 1 address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fiaddrr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fiaddrr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fiaddrr1`] module"]
    #[doc(alias = "FIADDRR1")]
    pub type Fiaddrr1 = crate::Reg<fiaddrr1::Fiaddrr1Spec>;
    #[doc = "Interrupt 1 address Register"]
    pub mod fiaddrr1 {
        #[doc = "Register `FIADDRR1` reader"]
        pub type R = crate::R<Fiaddrr1Spec>;
        #[doc = "Register `FIADDRR1` writer"]
        pub type W = crate::W<Fiaddrr1Spec>;
        #[doc = "Field `FI1EN` reader - RW,FI1EN"]
        pub type Fi1enR = crate::BitReader;
        #[doc = "Field `FI1EN` writer - RW,FI1EN"]
        pub type Fi1enW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ADDR1` reader - RW,ADDR1"]
        pub type Addr1R = crate::FieldReader<u32>;
        #[doc = "Field `ADDR1` writer - RW,ADDR1"]
        pub type Addr1W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32>;
        impl R {
            #[doc = "Bit 0 - RW,FI1EN"]
            #[inline(always)]
            pub fn fi1en(&self) -> Fi1enR {
                Fi1enR::new((self.bits & 1) != 0)
            }
            #[doc = "Bits 1:31 - RW,ADDR1"]
            #[inline(always)]
            pub fn addr1(&self) -> Addr1R {
                Addr1R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW,FI1EN"]
            #[inline(always)]
            pub fn fi1en(&mut self) -> Fi1enW<Fiaddrr1Spec> {
                Fi1enW::new(self, 0)
            }
            #[doc = "Bits 1:31 - RW,ADDR1"]
            #[inline(always)]
            pub fn addr1(&mut self) -> Addr1W<Fiaddrr1Spec> {
                Addr1W::new(self, 1)
            }
        }
        #[doc = "Interrupt 1 address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fiaddrr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fiaddrr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Fiaddrr1Spec;
        impl crate::RegisterSpec for Fiaddrr1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`fiaddrr1::R`](R) reader structure"]
        impl crate::Readable for Fiaddrr1Spec {}
        #[doc = "`write(|w| ..)` method takes [`fiaddrr1::W`](W) writer structure"]
        impl crate::Writable for Fiaddrr1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FIADDRR1 to value 0"]
        impl crate::Resettable for Fiaddrr1Spec {}
    }
    #[doc = "FIADDRR2 (rw) register accessor: Interrupt 2 address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fiaddrr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fiaddrr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fiaddrr2`] module"]
    #[doc(alias = "FIADDRR2")]
    pub type Fiaddrr2 = crate::Reg<fiaddrr2::Fiaddrr2Spec>;
    #[doc = "Interrupt 2 address Register"]
    pub mod fiaddrr2 {
        #[doc = "Register `FIADDRR2` reader"]
        pub type R = crate::R<Fiaddrr2Spec>;
        #[doc = "Register `FIADDRR2` writer"]
        pub type W = crate::W<Fiaddrr2Spec>;
        #[doc = "Field `FI2EN` reader - RW,FI2EN"]
        pub type Fi2enR = crate::BitReader;
        #[doc = "Field `FI2EN` writer - RW,FI2EN"]
        pub type Fi2enW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ADDR2` reader - RW,ADDR2"]
        pub type Addr2R = crate::FieldReader<u32>;
        #[doc = "Field `ADDR2` writer - RW,ADDR2"]
        pub type Addr2W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32>;
        impl R {
            #[doc = "Bit 0 - RW,FI2EN"]
            #[inline(always)]
            pub fn fi2en(&self) -> Fi2enR {
                Fi2enR::new((self.bits & 1) != 0)
            }
            #[doc = "Bits 1:31 - RW,ADDR2"]
            #[inline(always)]
            pub fn addr2(&self) -> Addr2R {
                Addr2R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW,FI2EN"]
            #[inline(always)]
            pub fn fi2en(&mut self) -> Fi2enW<Fiaddrr2Spec> {
                Fi2enW::new(self, 0)
            }
            #[doc = "Bits 1:31 - RW,ADDR2"]
            #[inline(always)]
            pub fn addr2(&mut self) -> Addr2W<Fiaddrr2Spec> {
                Addr2W::new(self, 1)
            }
        }
        #[doc = "Interrupt 2 address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fiaddrr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fiaddrr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Fiaddrr2Spec;
        impl crate::RegisterSpec for Fiaddrr2Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`fiaddrr2::R`](R) reader structure"]
        impl crate::Readable for Fiaddrr2Spec {}
        #[doc = "`write(|w| ..)` method takes [`fiaddrr2::W`](W) writer structure"]
        impl crate::Writable for Fiaddrr2Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FIADDRR2 to value 0"]
        impl crate::Resettable for Fiaddrr2Spec {}
    }
    #[doc = "FIADDRR3 (rw) register accessor: Interrupt 3 address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fiaddrr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fiaddrr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fiaddrr3`] module"]
    #[doc(alias = "FIADDRR3")]
    pub type Fiaddrr3 = crate::Reg<fiaddrr3::Fiaddrr3Spec>;
    #[doc = "Interrupt 3 address Register"]
    pub mod fiaddrr3 {
        #[doc = "Register `FIADDRR3` reader"]
        pub type R = crate::R<Fiaddrr3Spec>;
        #[doc = "Register `FIADDRR3` writer"]
        pub type W = crate::W<Fiaddrr3Spec>;
        #[doc = "Field `FI3EN` reader - RW,FI3EN"]
        pub type Fi3enR = crate::BitReader;
        #[doc = "Field `FI3EN` writer - RW,FI3EN"]
        pub type Fi3enW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `ADDR3` reader - RW,ADDR3"]
        pub type Addr3R = crate::FieldReader<u32>;
        #[doc = "Field `ADDR3` writer - RW,ADDR3"]
        pub type Addr3W<'a, REG> = crate::FieldWriter<'a, REG, 31, u32>;
        impl R {
            #[doc = "Bit 0 - RW,FI3EN"]
            #[inline(always)]
            pub fn fi3en(&self) -> Fi3enR {
                Fi3enR::new((self.bits & 1) != 0)
            }
            #[doc = "Bits 1:31 - RW,ADDR3"]
            #[inline(always)]
            pub fn addr3(&self) -> Addr3R {
                Addr3R::new((self.bits >> 1) & 0x7fff_ffff)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW,FI3EN"]
            #[inline(always)]
            pub fn fi3en(&mut self) -> Fi3enW<Fiaddrr3Spec> {
                Fi3enW::new(self, 0)
            }
            #[doc = "Bits 1:31 - RW,ADDR3"]
            #[inline(always)]
            pub fn addr3(&mut self) -> Addr3W<Fiaddrr3Spec> {
                Addr3W::new(self, 1)
            }
        }
        #[doc = "Interrupt 3 address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fiaddrr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fiaddrr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Fiaddrr3Spec;
        impl crate::RegisterSpec for Fiaddrr3Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`fiaddrr3::R`](R) reader structure"]
        impl crate::Readable for Fiaddrr3Spec {}
        #[doc = "`write(|w| ..)` method takes [`fiaddrr3::W`](W) writer structure"]
        impl crate::Writable for Fiaddrr3Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets FIADDRR3 to value 0"]
        impl crate::Resettable for Fiaddrr3Spec {}
    }
    #[doc = "IENR1 (w) register accessor: Interrupt Setting Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ienr1::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ienr1`] module"]
    #[doc(alias = "IENR1")]
    pub type Ienr1 = crate::Reg<ienr1::Ienr1Spec>;
    #[doc = "Interrupt Setting Register"]
    pub mod ienr1 {
        #[doc = "Register `IENR1` writer"]
        pub type W = crate::W<Ienr1Spec>;
        #[doc = "Field `INTEN` writer - RW1,INTEN"]
        pub type IntenW<'a, REG> = crate::FieldWriter<'a, REG, 20, u32>;
        impl W {
            #[doc = "Bits 12:31 - RW1,INTEN"]
            #[inline(always)]
            pub fn inten(&mut self) -> IntenW<Ienr1Spec> {
                IntenW::new(self, 12)
            }
        }
        #[doc = "Interrupt Setting Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ienr1::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ienr1Spec;
        impl crate::RegisterSpec for Ienr1Spec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`ienr1::W`](W) writer structure"]
        impl crate::Writable for Ienr1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IENR1 to value 0"]
        impl crate::Resettable for Ienr1Spec {}
    }
    #[doc = "IENR2 (w) register accessor: Interrupt Setting Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ienr2::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ienr2`] module"]
    #[doc(alias = "IENR2")]
    pub type Ienr2 = crate::Reg<ienr2::Ienr2Spec>;
    #[doc = "Interrupt Setting Register"]
    pub mod ienr2 {
        #[doc = "Register `IENR2` writer"]
        pub type W = crate::W<Ienr2Spec>;
        #[doc = "Field `INTEN` writer - RW1,INTEN"]
        pub type IntenW<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl W {
            #[doc = "Bits 0:3 - RW1,INTEN"]
            #[inline(always)]
            pub fn inten(&mut self) -> IntenW<Ienr2Spec> {
                IntenW::new(self, 0)
            }
        }
        #[doc = "Interrupt Setting Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ienr2::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ienr2Spec;
        impl crate::RegisterSpec for Ienr2Spec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`ienr2::W`](W) writer structure"]
        impl crate::Writable for Ienr2Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IENR2 to value 0"]
        impl crate::Resettable for Ienr2Spec {}
    }
    #[doc = "IRER1 (w) register accessor: Interrupt Clear Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`irer1::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@irer1`] module"]
    #[doc(alias = "IRER1")]
    pub type Irer1 = crate::Reg<irer1::Irer1Spec>;
    #[doc = "Interrupt Clear Register"]
    pub mod irer1 {
        #[doc = "Register `IRER1` writer"]
        pub type W = crate::W<Irer1Spec>;
        #[doc = "Field `INTRESET` writer - RW1,INTRESET"]
        pub type IntresetW<'a, REG> = crate::FieldWriter<'a, REG, 20, u32>;
        impl W {
            #[doc = "Bits 12:31 - RW1,INTRESET"]
            #[inline(always)]
            pub fn intreset(&mut self) -> IntresetW<Irer1Spec> {
                IntresetW::new(self, 12)
            }
        }
        #[doc = "Interrupt Clear Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`irer1::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Irer1Spec;
        impl crate::RegisterSpec for Irer1Spec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`irer1::W`](W) writer structure"]
        impl crate::Writable for Irer1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IRER1 to value 0"]
        impl crate::Resettable for Irer1Spec {}
    }
    #[doc = "IRER2 (w) register accessor: Interrupt Clear Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`irer2::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@irer2`] module"]
    #[doc(alias = "IRER2")]
    pub type Irer2 = crate::Reg<irer2::Irer2Spec>;
    #[doc = "Interrupt Clear Register"]
    pub mod irer2 {
        #[doc = "Register `IRER2` writer"]
        pub type W = crate::W<Irer2Spec>;
        #[doc = "Field `INTRESET` writer - RW1,INTRESET"]
        pub type IntresetW<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl W {
            #[doc = "Bits 0:3 - RW1,INTRESET"]
            #[inline(always)]
            pub fn intreset(&mut self) -> IntresetW<Irer2Spec> {
                IntresetW::new(self, 0)
            }
        }
        #[doc = "Interrupt Clear Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`irer2::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Irer2Spec;
        impl crate::RegisterSpec for Irer2Spec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`irer2::W`](W) writer structure"]
        impl crate::Writable for Irer2Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IRER2 to value 0"]
        impl crate::Resettable for Irer2Spec {}
    }
    #[doc = "IPSR1 (w) register accessor: Interrupt Pending Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ipsr1::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ipsr1`] module"]
    #[doc(alias = "IPSR1")]
    pub type Ipsr1 = crate::Reg<ipsr1::Ipsr1Spec>;
    #[doc = "Interrupt Pending Register"]
    pub mod ipsr1 {
        #[doc = "Register `IPSR1` writer"]
        pub type W = crate::W<Ipsr1Spec>;
        #[doc = "Field `PENDSET` writer - RW1,PENDSET"]
        pub type PendsetW<'a, REG> = crate::FieldWriter<'a, REG, 20, u32>;
        impl W {
            #[doc = "Bits 12:31 - RW1,PENDSET"]
            #[inline(always)]
            pub fn pendset(&mut self) -> PendsetW<Ipsr1Spec> {
                PendsetW::new(self, 12)
            }
        }
        #[doc = "Interrupt Pending Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ipsr1::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ipsr1Spec;
        impl crate::RegisterSpec for Ipsr1Spec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`ipsr1::W`](W) writer structure"]
        impl crate::Writable for Ipsr1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPSR1 to value 0"]
        impl crate::Resettable for Ipsr1Spec {}
    }
    #[doc = "IPSR2 (w) register accessor: Interrupt Pending Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ipsr2::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ipsr2`] module"]
    #[doc(alias = "IPSR2")]
    pub type Ipsr2 = crate::Reg<ipsr2::Ipsr2Spec>;
    #[doc = "Interrupt Pending Register"]
    pub mod ipsr2 {
        #[doc = "Register `IPSR2` writer"]
        pub type W = crate::W<Ipsr2Spec>;
        #[doc = "Field `PENDSET` writer - RW1,PENDSET"]
        pub type PendsetW<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl W {
            #[doc = "Bits 0:3 - RW1,PENDSET"]
            #[inline(always)]
            pub fn pendset(&mut self) -> PendsetW<Ipsr2Spec> {
                PendsetW::new(self, 0)
            }
        }
        #[doc = "Interrupt Pending Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ipsr2::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Ipsr2Spec;
        impl crate::RegisterSpec for Ipsr2Spec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`ipsr2::W`](W) writer structure"]
        impl crate::Writable for Ipsr2Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPSR2 to value 0"]
        impl crate::Resettable for Ipsr2Spec {}
    }
    #[doc = "IPRR1 (w) register accessor: Interrupt Pending Clear Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprr1::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprr1`] module"]
    #[doc(alias = "IPRR1")]
    pub type Iprr1 = crate::Reg<iprr1::Iprr1Spec>;
    #[doc = "Interrupt Pending Clear Register"]
    pub mod iprr1 {
        #[doc = "Register `IPRR1` writer"]
        pub type W = crate::W<Iprr1Spec>;
        #[doc = "Field `PENDRESET` writer - RW1,PENDRESET"]
        pub type PendresetW<'a, REG> = crate::FieldWriter<'a, REG, 20, u32>;
        impl W {
            #[doc = "Bits 12:31 - RW1,PENDRESET"]
            #[inline(always)]
            pub fn pendreset(&mut self) -> PendresetW<Iprr1Spec> {
                PendresetW::new(self, 12)
            }
        }
        #[doc = "Interrupt Pending Clear Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprr1::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprr1Spec;
        impl crate::RegisterSpec for Iprr1Spec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`iprr1::W`](W) writer structure"]
        impl crate::Writable for Iprr1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRR1 to value 0"]
        impl crate::Resettable for Iprr1Spec {}
    }
    #[doc = "IPRR2 (w) register accessor: Interrupt Pending Clear Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprr2::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprr2`] module"]
    #[doc(alias = "IPRR2")]
    pub type Iprr2 = crate::Reg<iprr2::Iprr2Spec>;
    #[doc = "Interrupt Pending Clear Register"]
    pub mod iprr2 {
        #[doc = "Register `IPRR2` writer"]
        pub type W = crate::W<Iprr2Spec>;
        #[doc = "Field `PENDRESET` writer - RW1,PENDRESET"]
        pub type PendresetW<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl W {
            #[doc = "Bits 0:3 - RW1,PENDRESET"]
            #[inline(always)]
            pub fn pendreset(&mut self) -> PendresetW<Iprr2Spec> {
                PendresetW::new(self, 0)
            }
        }
        #[doc = "Interrupt Pending Clear Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprr2::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprr2Spec;
        impl crate::RegisterSpec for Iprr2Spec {
            type Ux = u32;
        }
        #[doc = "`write(|w| ..)` method takes [`iprr2::W`](W) writer structure"]
        impl crate::Writable for Iprr2Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRR2 to value 0"]
        impl crate::Resettable for Iprr2Spec {}
    }
    #[doc = "IACTR1 (rw) register accessor: Interrupt ACTIVE Register\n\nYou can [`read`](crate::Reg::read) this register and get [`iactr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iactr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iactr1`] module"]
    #[doc(alias = "IACTR1")]
    pub type Iactr1 = crate::Reg<iactr1::Iactr1Spec>;
    #[doc = "Interrupt ACTIVE Register"]
    pub mod iactr1 {
        #[doc = "Register `IACTR1` reader"]
        pub type R = crate::R<Iactr1Spec>;
        #[doc = "Register `IACTR1` writer"]
        pub type W = crate::W<Iactr1Spec>;
        #[doc = "Field `IACTS` reader - RW1,IACTS"]
        pub type IactsR = crate::FieldReader<u32>;
        #[doc = "Field `IACTS` writer - RW1,IACTS"]
        pub type IactsW<'a, REG> = crate::FieldWriter<'a, REG, 20, u32>;
        impl R {
            #[doc = "Bits 12:31 - RW1,IACTS"]
            #[inline(always)]
            pub fn iacts(&self) -> IactsR {
                IactsR::new((self.bits >> 12) & 0x000f_ffff)
            }
        }
        impl W {
            #[doc = "Bits 12:31 - RW1,IACTS"]
            #[inline(always)]
            pub fn iacts(&mut self) -> IactsW<Iactr1Spec> {
                IactsW::new(self, 12)
            }
        }
        #[doc = "Interrupt ACTIVE Register\n\nYou can [`read`](crate::Reg::read) this register and get [`iactr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iactr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iactr1Spec;
        impl crate::RegisterSpec for Iactr1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iactr1::R`](R) reader structure"]
        impl crate::Readable for Iactr1Spec {}
        #[doc = "`write(|w| ..)` method takes [`iactr1::W`](W) writer structure"]
        impl crate::Writable for Iactr1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IACTR1 to value 0"]
        impl crate::Resettable for Iactr1Spec {}
    }
    #[doc = "IACTR2 (rw) register accessor: Interrupt ACTIVE Register\n\nYou can [`read`](crate::Reg::read) this register and get [`iactr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iactr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iactr2`] module"]
    #[doc(alias = "IACTR2")]
    pub type Iactr2 = crate::Reg<iactr2::Iactr2Spec>;
    #[doc = "Interrupt ACTIVE Register"]
    pub mod iactr2 {
        #[doc = "Register `IACTR2` reader"]
        pub type R = crate::R<Iactr2Spec>;
        #[doc = "Register `IACTR2` writer"]
        pub type W = crate::W<Iactr2Spec>;
        #[doc = "Field `IACTS` reader - RW1,IACTS"]
        pub type IactsR = crate::FieldReader;
        #[doc = "Field `IACTS` writer - RW1,IACTS"]
        pub type IactsW<'a, REG> = crate::FieldWriter<'a, REG, 4>;
        impl R {
            #[doc = "Bits 0:3 - RW1,IACTS"]
            #[inline(always)]
            pub fn iacts(&self) -> IactsR {
                IactsR::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            #[doc = "Bits 0:3 - RW1,IACTS"]
            #[inline(always)]
            pub fn iacts(&mut self) -> IactsW<Iactr2Spec> {
                IactsW::new(self, 0)
            }
        }
        #[doc = "Interrupt ACTIVE Register\n\nYou can [`read`](crate::Reg::read) this register and get [`iactr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iactr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iactr2Spec;
        impl crate::RegisterSpec for Iactr2Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iactr2::R`](R) reader structure"]
        impl crate::Readable for Iactr2Spec {}
        #[doc = "`write(|w| ..)` method takes [`iactr2::W`](W) writer structure"]
        impl crate::Writable for Iactr2Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IACTR2 to value 0"]
        impl crate::Resettable for Iactr2Spec {}
    }
    #[doc = "IPRIOR0 (rw) register accessor: Interrupt Priority configuration Register 0\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior0`] module"]
    #[doc(alias = "IPRIOR0")]
    pub type Iprior0 = crate::Reg<iprior0::Iprior0Spec>;
    #[doc = "Interrupt Priority configuration Register 0"]
    pub mod iprior0 {
        #[doc = "Register `IPRIOR0` reader"]
        pub type R = crate::R<Iprior0Spec>;
        #[doc = "Register `IPRIOR0` writer"]
        pub type W = crate::W<Iprior0Spec>;
        #[doc = "Field `IPRIOR0` reader - RW,Interrupt priority for number 0-3"]
        pub type Iprior0R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR0` writer - RW,Interrupt priority for number 0-3"]
        pub type Iprior0W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 0-3"]
            #[inline(always)]
            pub fn iprior0(&self) -> Iprior0R {
                Iprior0R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 0-3"]
            #[inline(always)]
            pub fn iprior0(&mut self) -> Iprior0W<Iprior0Spec> {
                Iprior0W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 0\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior0Spec;
        impl crate::RegisterSpec for Iprior0Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior0::R`](R) reader structure"]
        impl crate::Readable for Iprior0Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior0::W`](W) writer structure"]
        impl crate::Writable for Iprior0Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR0 to value 0"]
        impl crate::Resettable for Iprior0Spec {}
    }
    #[doc = "IPRIOR1 (rw) register accessor: Interrupt Priority configuration Register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior1`] module"]
    #[doc(alias = "IPRIOR1")]
    pub type Iprior1 = crate::Reg<iprior1::Iprior1Spec>;
    #[doc = "Interrupt Priority configuration Register 1"]
    pub mod iprior1 {
        #[doc = "Register `IPRIOR1` reader"]
        pub type R = crate::R<Iprior1Spec>;
        #[doc = "Register `IPRIOR1` writer"]
        pub type W = crate::W<Iprior1Spec>;
        #[doc = "Field `IPRIOR1` reader - >RW,Interrupt priority for number 4-7"]
        pub type Iprior1R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR1` writer - >RW,Interrupt priority for number 4-7"]
        pub type Iprior1W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - >RW,Interrupt priority for number 4-7"]
            #[inline(always)]
            pub fn iprior1(&self) -> Iprior1R {
                Iprior1R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - >RW,Interrupt priority for number 4-7"]
            #[inline(always)]
            pub fn iprior1(&mut self) -> Iprior1W<Iprior1Spec> {
                Iprior1W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior1Spec;
        impl crate::RegisterSpec for Iprior1Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior1::R`](R) reader structure"]
        impl crate::Readable for Iprior1Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior1::W`](W) writer structure"]
        impl crate::Writable for Iprior1Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR1 to value 0"]
        impl crate::Resettable for Iprior1Spec {}
    }
    #[doc = "IPRIOR2 (rw) register accessor: Interrupt Priority configuration Register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior2`] module"]
    #[doc(alias = "IPRIOR2")]
    pub type Iprior2 = crate::Reg<iprior2::Iprior2Spec>;
    #[doc = "Interrupt Priority configuration Register 2"]
    pub mod iprior2 {
        #[doc = "Register `IPRIOR2` reader"]
        pub type R = crate::R<Iprior2Spec>;
        #[doc = "Register `IPRIOR2` writer"]
        pub type W = crate::W<Iprior2Spec>;
        #[doc = "Field `IPRIOR2` reader - >RW,Interrupt priority for number 8-11"]
        pub type Iprior2R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR2` writer - >RW,Interrupt priority for number 8-11"]
        pub type Iprior2W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - >RW,Interrupt priority for number 8-11"]
            #[inline(always)]
            pub fn iprior2(&self) -> Iprior2R {
                Iprior2R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - >RW,Interrupt priority for number 8-11"]
            #[inline(always)]
            pub fn iprior2(&mut self) -> Iprior2W<Iprior2Spec> {
                Iprior2W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior2Spec;
        impl crate::RegisterSpec for Iprior2Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior2::R`](R) reader structure"]
        impl crate::Readable for Iprior2Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior2::W`](W) writer structure"]
        impl crate::Writable for Iprior2Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR2 to value 0"]
        impl crate::Resettable for Iprior2Spec {}
    }
    #[doc = "IPRIOR3 (rw) register accessor: Interrupt Priority configuration Register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior3`] module"]
    #[doc(alias = "IPRIOR3")]
    pub type Iprior3 = crate::Reg<iprior3::Iprior3Spec>;
    #[doc = "Interrupt Priority configuration Register 3"]
    pub mod iprior3 {
        #[doc = "Register `IPRIOR3` reader"]
        pub type R = crate::R<Iprior3Spec>;
        #[doc = "Register `IPRIOR3` writer"]
        pub type W = crate::W<Iprior3Spec>;
        #[doc = "Field `IPRIOR3` reader - >RW,Interrupt priority for number 12-15"]
        pub type Iprior3R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR3` writer - >RW,Interrupt priority for number 12-15"]
        pub type Iprior3W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - >RW,Interrupt priority for number 12-15"]
            #[inline(always)]
            pub fn iprior3(&self) -> Iprior3R {
                Iprior3R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - >RW,Interrupt priority for number 12-15"]
            #[inline(always)]
            pub fn iprior3(&mut self) -> Iprior3W<Iprior3Spec> {
                Iprior3W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior3Spec;
        impl crate::RegisterSpec for Iprior3Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior3::R`](R) reader structure"]
        impl crate::Readable for Iprior3Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior3::W`](W) writer structure"]
        impl crate::Writable for Iprior3Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR3 to value 0"]
        impl crate::Resettable for Iprior3Spec {}
    }
    #[doc = "IPRIOR4 (rw) register accessor: Interrupt Priority configuration Register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior4`] module"]
    #[doc(alias = "IPRIOR4")]
    pub type Iprior4 = crate::Reg<iprior4::Iprior4Spec>;
    #[doc = "Interrupt Priority configuration Register 4"]
    pub mod iprior4 {
        #[doc = "Register `IPRIOR4` reader"]
        pub type R = crate::R<Iprior4Spec>;
        #[doc = "Register `IPRIOR4` writer"]
        pub type W = crate::W<Iprior4Spec>;
        #[doc = "Field `IPRIOR4` reader - >RW,Interrupt priority for number 16-19"]
        pub type Iprior4R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR4` writer - >RW,Interrupt priority for number 16-19"]
        pub type Iprior4W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - >RW,Interrupt priority for number 16-19"]
            #[inline(always)]
            pub fn iprior4(&self) -> Iprior4R {
                Iprior4R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - >RW,Interrupt priority for number 16-19"]
            #[inline(always)]
            pub fn iprior4(&mut self) -> Iprior4W<Iprior4Spec> {
                Iprior4W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior4Spec;
        impl crate::RegisterSpec for Iprior4Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior4::R`](R) reader structure"]
        impl crate::Readable for Iprior4Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior4::W`](W) writer structure"]
        impl crate::Writable for Iprior4Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR4 to value 0"]
        impl crate::Resettable for Iprior4Spec {}
    }
    #[doc = "IPRIOR5 (rw) register accessor: Interrupt Priority configuration Register 5\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior5`] module"]
    #[doc(alias = "IPRIOR5")]
    pub type Iprior5 = crate::Reg<iprior5::Iprior5Spec>;
    #[doc = "Interrupt Priority configuration Register 5"]
    pub mod iprior5 {
        #[doc = "Register `IPRIOR5` reader"]
        pub type R = crate::R<Iprior5Spec>;
        #[doc = "Register `IPRIOR5` writer"]
        pub type W = crate::W<Iprior5Spec>;
        #[doc = "Field `IPRIOR5` reader - >RW,Interrupt priority for number 20-23"]
        pub type Iprior5R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR5` writer - >RW,Interrupt priority for number 20-23"]
        pub type Iprior5W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - >RW,Interrupt priority for number 20-23"]
            #[inline(always)]
            pub fn iprior5(&self) -> Iprior5R {
                Iprior5R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - >RW,Interrupt priority for number 20-23"]
            #[inline(always)]
            pub fn iprior5(&mut self) -> Iprior5W<Iprior5Spec> {
                Iprior5W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 5\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior5Spec;
        impl crate::RegisterSpec for Iprior5Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior5::R`](R) reader structure"]
        impl crate::Readable for Iprior5Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior5::W`](W) writer structure"]
        impl crate::Writable for Iprior5Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR5 to value 0"]
        impl crate::Resettable for Iprior5Spec {}
    }
    #[doc = "IPRIOR6 (rw) register accessor: Interrupt Priority configuration Register 6\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior6`] module"]
    #[doc(alias = "IPRIOR6")]
    pub type Iprior6 = crate::Reg<iprior6::Iprior6Spec>;
    #[doc = "Interrupt Priority configuration Register 6"]
    pub mod iprior6 {
        #[doc = "Register `IPRIOR6` reader"]
        pub type R = crate::R<Iprior6Spec>;
        #[doc = "Register `IPRIOR6` writer"]
        pub type W = crate::W<Iprior6Spec>;
        #[doc = "Field `IPRIOR6` reader - >RW,Interrupt priority for number 24-27"]
        pub type Iprior6R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR6` writer - >RW,Interrupt priority for number 24-27"]
        pub type Iprior6W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - >RW,Interrupt priority for number 24-27"]
            #[inline(always)]
            pub fn iprior6(&self) -> Iprior6R {
                Iprior6R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - >RW,Interrupt priority for number 24-27"]
            #[inline(always)]
            pub fn iprior6(&mut self) -> Iprior6W<Iprior6Spec> {
                Iprior6W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 6\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior6Spec;
        impl crate::RegisterSpec for Iprior6Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior6::R`](R) reader structure"]
        impl crate::Readable for Iprior6Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior6::W`](W) writer structure"]
        impl crate::Writable for Iprior6Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR6 to value 0"]
        impl crate::Resettable for Iprior6Spec {}
    }
    #[doc = "IPRIOR7 (rw) register accessor: Interrupt Priority configuration Register 7\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior7`] module"]
    #[doc(alias = "IPRIOR7")]
    pub type Iprior7 = crate::Reg<iprior7::Iprior7Spec>;
    #[doc = "Interrupt Priority configuration Register 7"]
    pub mod iprior7 {
        #[doc = "Register `IPRIOR7` reader"]
        pub type R = crate::R<Iprior7Spec>;
        #[doc = "Register `IPRIOR7` writer"]
        pub type W = crate::W<Iprior7Spec>;
        #[doc = "Field `IPRIOR7` reader - >RW,Interrupt priority for number 28-31"]
        pub type Iprior7R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR7` writer - >RW,Interrupt priority for number 28-31"]
        pub type Iprior7W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - >RW,Interrupt priority for number 28-31"]
            #[inline(always)]
            pub fn iprior7(&self) -> Iprior7R {
                Iprior7R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - >RW,Interrupt priority for number 28-31"]
            #[inline(always)]
            pub fn iprior7(&mut self) -> Iprior7W<Iprior7Spec> {
                Iprior7W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 7\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior7Spec;
        impl crate::RegisterSpec for Iprior7Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior7::R`](R) reader structure"]
        impl crate::Readable for Iprior7Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior7::W`](W) writer structure"]
        impl crate::Writable for Iprior7Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR7 to value 0"]
        impl crate::Resettable for Iprior7Spec {}
    }
    #[doc = "IPRIOR8 (rw) register accessor: Interrupt Priority configuration Register 8\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior8::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior8::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior8`] module"]
    #[doc(alias = "IPRIOR8")]
    pub type Iprior8 = crate::Reg<iprior8::Iprior8Spec>;
    #[doc = "Interrupt Priority configuration Register 8"]
    pub mod iprior8 {
        #[doc = "Register `IPRIOR8` reader"]
        pub type R = crate::R<Iprior8Spec>;
        #[doc = "Register `IPRIOR8` writer"]
        pub type W = crate::W<Iprior8Spec>;
        #[doc = "Field `IPRIOR8` reader - >RW,Interrupt priority for number 32-35"]
        pub type Iprior8R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR8` writer - >RW,Interrupt priority for number 32-35"]
        pub type Iprior8W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - >RW,Interrupt priority for number 32-35"]
            #[inline(always)]
            pub fn iprior8(&self) -> Iprior8R {
                Iprior8R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - >RW,Interrupt priority for number 32-35"]
            #[inline(always)]
            pub fn iprior8(&mut self) -> Iprior8W<Iprior8Spec> {
                Iprior8W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 8\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior8::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior8::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior8Spec;
        impl crate::RegisterSpec for Iprior8Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior8::R`](R) reader structure"]
        impl crate::Readable for Iprior8Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior8::W`](W) writer structure"]
        impl crate::Writable for Iprior8Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR8 to value 0"]
        impl crate::Resettable for Iprior8Spec {}
    }
    #[doc = "IPRIOR9 (rw) register accessor: Interrupt Priority configuration Register 9\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior9::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior9::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior9`] module"]
    #[doc(alias = "IPRIOR9")]
    pub type Iprior9 = crate::Reg<iprior9::Iprior9Spec>;
    #[doc = "Interrupt Priority configuration Register 9"]
    pub mod iprior9 {
        #[doc = "Register `IPRIOR9` reader"]
        pub type R = crate::R<Iprior9Spec>;
        #[doc = "Register `IPRIOR9` writer"]
        pub type W = crate::W<Iprior9Spec>;
        #[doc = "Field `IPRIOR9` reader - >RW,Interrupt priority for number 36-39"]
        pub type Iprior9R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR9` writer - >RW,Interrupt priority for number 36-39"]
        pub type Iprior9W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - >RW,Interrupt priority for number 36-39"]
            #[inline(always)]
            pub fn iprior9(&self) -> Iprior9R {
                Iprior9R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - >RW,Interrupt priority for number 36-39"]
            #[inline(always)]
            pub fn iprior9(&mut self) -> Iprior9W<Iprior9Spec> {
                Iprior9W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 9\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior9::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior9::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior9Spec;
        impl crate::RegisterSpec for Iprior9Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior9::R`](R) reader structure"]
        impl crate::Readable for Iprior9Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior9::W`](W) writer structure"]
        impl crate::Writable for Iprior9Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR9 to value 0"]
        impl crate::Resettable for Iprior9Spec {}
    }
    #[doc = "IPRIOR10 (rw) register accessor: Interrupt Priority configuration Register 10\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior10::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior10::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior10`] module"]
    #[doc(alias = "IPRIOR10")]
    pub type Iprior10 = crate::Reg<iprior10::Iprior10Spec>;
    #[doc = "Interrupt Priority configuration Register 10"]
    pub mod iprior10 {
        #[doc = "Register `IPRIOR10` reader"]
        pub type R = crate::R<Iprior10Spec>;
        #[doc = "Register `IPRIOR10` writer"]
        pub type W = crate::W<Iprior10Spec>;
        #[doc = "Field `IPRIOR10` reader - >RW,Interrupt priority for number 40-43"]
        pub type Iprior10R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR10` writer - >RW,Interrupt priority for number 40-43"]
        pub type Iprior10W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - >RW,Interrupt priority for number 40-43"]
            #[inline(always)]
            pub fn iprior10(&self) -> Iprior10R {
                Iprior10R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - >RW,Interrupt priority for number 40-43"]
            #[inline(always)]
            pub fn iprior10(&mut self) -> Iprior10W<Iprior10Spec> {
                Iprior10W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 10\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior10::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior10::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior10Spec;
        impl crate::RegisterSpec for Iprior10Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior10::R`](R) reader structure"]
        impl crate::Readable for Iprior10Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior10::W`](W) writer structure"]
        impl crate::Writable for Iprior10Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR10 to value 0"]
        impl crate::Resettable for Iprior10Spec {}
    }
    #[doc = "IPRIOR11 (rw) register accessor: Interrupt Priority configuration Register 11\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior11::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior11::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior11`] module"]
    #[doc(alias = "IPRIOR11")]
    pub type Iprior11 = crate::Reg<iprior11::Iprior11Spec>;
    #[doc = "Interrupt Priority configuration Register 11"]
    pub mod iprior11 {
        #[doc = "Register `IPRIOR11` reader"]
        pub type R = crate::R<Iprior11Spec>;
        #[doc = "Register `IPRIOR11` writer"]
        pub type W = crate::W<Iprior11Spec>;
        #[doc = "Field `IPRIOR11` reader - RW,Interrupt priority for number 44-47"]
        pub type Iprior11R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR11` writer - RW,Interrupt priority for number 44-47"]
        pub type Iprior11W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 44-47"]
            #[inline(always)]
            pub fn iprior11(&self) -> Iprior11R {
                Iprior11R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 44-47"]
            #[inline(always)]
            pub fn iprior11(&mut self) -> Iprior11W<Iprior11Spec> {
                Iprior11W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 11\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior11::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior11::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior11Spec;
        impl crate::RegisterSpec for Iprior11Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior11::R`](R) reader structure"]
        impl crate::Readable for Iprior11Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior11::W`](W) writer structure"]
        impl crate::Writable for Iprior11Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR11 to value 0"]
        impl crate::Resettable for Iprior11Spec {}
    }
    #[doc = "IPRIOR12 (rw) register accessor: Interrupt Priority configuration Register 12\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior12::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior12::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior12`] module"]
    #[doc(alias = "IPRIOR12")]
    pub type Iprior12 = crate::Reg<iprior12::Iprior12Spec>;
    #[doc = "Interrupt Priority configuration Register 12"]
    pub mod iprior12 {
        #[doc = "Register `IPRIOR12` reader"]
        pub type R = crate::R<Iprior12Spec>;
        #[doc = "Register `IPRIOR12` writer"]
        pub type W = crate::W<Iprior12Spec>;
        #[doc = "Field `IPRIOR12` reader - RW,Interrupt priority for number 48-51"]
        pub type Iprior12R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR12` writer - RW,Interrupt priority for number 48-51"]
        pub type Iprior12W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 48-51"]
            #[inline(always)]
            pub fn iprior12(&self) -> Iprior12R {
                Iprior12R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 48-51"]
            #[inline(always)]
            pub fn iprior12(&mut self) -> Iprior12W<Iprior12Spec> {
                Iprior12W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 12\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior12::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior12::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior12Spec;
        impl crate::RegisterSpec for Iprior12Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior12::R`](R) reader structure"]
        impl crate::Readable for Iprior12Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior12::W`](W) writer structure"]
        impl crate::Writable for Iprior12Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR12 to value 0"]
        impl crate::Resettable for Iprior12Spec {}
    }
    #[doc = "IPRIOR13 (rw) register accessor: Interrupt Priority configuration Register 13\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior13::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior13::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior13`] module"]
    #[doc(alias = "IPRIOR13")]
    pub type Iprior13 = crate::Reg<iprior13::Iprior13Spec>;
    #[doc = "Interrupt Priority configuration Register 13"]
    pub mod iprior13 {
        #[doc = "Register `IPRIOR13` reader"]
        pub type R = crate::R<Iprior13Spec>;
        #[doc = "Register `IPRIOR13` writer"]
        pub type W = crate::W<Iprior13Spec>;
        #[doc = "Field `IPRIOR13` reader - RW,Interrupt priority for number 52-55"]
        pub type Iprior13R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR13` writer - RW,Interrupt priority for number 52-55"]
        pub type Iprior13W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 52-55"]
            #[inline(always)]
            pub fn iprior13(&self) -> Iprior13R {
                Iprior13R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 52-55"]
            #[inline(always)]
            pub fn iprior13(&mut self) -> Iprior13W<Iprior13Spec> {
                Iprior13W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 13\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior13::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior13::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior13Spec;
        impl crate::RegisterSpec for Iprior13Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior13::R`](R) reader structure"]
        impl crate::Readable for Iprior13Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior13::W`](W) writer structure"]
        impl crate::Writable for Iprior13Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR13 to value 0"]
        impl crate::Resettable for Iprior13Spec {}
    }
    #[doc = "IPRIOR14 (rw) register accessor: Interrupt Priority configuration Register 14\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior14::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior14::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior14`] module"]
    #[doc(alias = "IPRIOR14")]
    pub type Iprior14 = crate::Reg<iprior14::Iprior14Spec>;
    #[doc = "Interrupt Priority configuration Register 14"]
    pub mod iprior14 {
        #[doc = "Register `IPRIOR14` reader"]
        pub type R = crate::R<Iprior14Spec>;
        #[doc = "Register `IPRIOR14` writer"]
        pub type W = crate::W<Iprior14Spec>;
        #[doc = "Field `IPRIOR14` reader - RW,Interrupt priority for number 56-59"]
        pub type Iprior14R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR14` writer - RW,Interrupt priority for number 56-59"]
        pub type Iprior14W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 56-59"]
            #[inline(always)]
            pub fn iprior14(&self) -> Iprior14R {
                Iprior14R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 56-59"]
            #[inline(always)]
            pub fn iprior14(&mut self) -> Iprior14W<Iprior14Spec> {
                Iprior14W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 14\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior14::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior14::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior14Spec;
        impl crate::RegisterSpec for Iprior14Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior14::R`](R) reader structure"]
        impl crate::Readable for Iprior14Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior14::W`](W) writer structure"]
        impl crate::Writable for Iprior14Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR14 to value 0"]
        impl crate::Resettable for Iprior14Spec {}
    }
    #[doc = "IPRIOR15 (rw) register accessor: Interrupt Priority configuration Register 15\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior15::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior15::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior15`] module"]
    #[doc(alias = "IPRIOR15")]
    pub type Iprior15 = crate::Reg<iprior15::Iprior15Spec>;
    #[doc = "Interrupt Priority configuration Register 15"]
    pub mod iprior15 {
        #[doc = "Register `IPRIOR15` reader"]
        pub type R = crate::R<Iprior15Spec>;
        #[doc = "Register `IPRIOR15` writer"]
        pub type W = crate::W<Iprior15Spec>;
        #[doc = "Field `IPRIOR15` reader - RW,Interrupt priority for number 60-63"]
        pub type Iprior15R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR15` writer - RW,Interrupt priority for number 60-63"]
        pub type Iprior15W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 60-63"]
            #[inline(always)]
            pub fn iprior15(&self) -> Iprior15R {
                Iprior15R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 60-63"]
            #[inline(always)]
            pub fn iprior15(&mut self) -> Iprior15W<Iprior15Spec> {
                Iprior15W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 15\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior15::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior15::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior15Spec;
        impl crate::RegisterSpec for Iprior15Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior15::R`](R) reader structure"]
        impl crate::Readable for Iprior15Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior15::W`](W) writer structure"]
        impl crate::Writable for Iprior15Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR15 to value 0"]
        impl crate::Resettable for Iprior15Spec {}
    }
    #[doc = "IPRIOR16 (rw) register accessor: Interrupt Priority configuration Register 16\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior16::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior16::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior16`] module"]
    #[doc(alias = "IPRIOR16")]
    pub type Iprior16 = crate::Reg<iprior16::Iprior16Spec>;
    #[doc = "Interrupt Priority configuration Register 16"]
    pub mod iprior16 {
        #[doc = "Register `IPRIOR16` reader"]
        pub type R = crate::R<Iprior16Spec>;
        #[doc = "Register `IPRIOR16` writer"]
        pub type W = crate::W<Iprior16Spec>;
        #[doc = "Field `IPRIOR16` reader - RW,Interrupt priority for number 64-67"]
        pub type Iprior16R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR16` writer - RW,Interrupt priority for number 64-67"]
        pub type Iprior16W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 64-67"]
            #[inline(always)]
            pub fn iprior16(&self) -> Iprior16R {
                Iprior16R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 64-67"]
            #[inline(always)]
            pub fn iprior16(&mut self) -> Iprior16W<Iprior16Spec> {
                Iprior16W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 16\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior16::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior16::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior16Spec;
        impl crate::RegisterSpec for Iprior16Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior16::R`](R) reader structure"]
        impl crate::Readable for Iprior16Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior16::W`](W) writer structure"]
        impl crate::Writable for Iprior16Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR16 to value 0"]
        impl crate::Resettable for Iprior16Spec {}
    }
    #[doc = "IPRIOR17 (rw) register accessor: Interrupt Priority configuration Register 17\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior17::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior17::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior17`] module"]
    #[doc(alias = "IPRIOR17")]
    pub type Iprior17 = crate::Reg<iprior17::Iprior17Spec>;
    #[doc = "Interrupt Priority configuration Register 17"]
    pub mod iprior17 {
        #[doc = "Register `IPRIOR17` reader"]
        pub type R = crate::R<Iprior17Spec>;
        #[doc = "Register `IPRIOR17` writer"]
        pub type W = crate::W<Iprior17Spec>;
        #[doc = "Field `IPRIOR17` reader - RW,Interrupt priority for number 68-71"]
        pub type Iprior17R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR17` writer - RW,Interrupt priority for number 68-71"]
        pub type Iprior17W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 68-71"]
            #[inline(always)]
            pub fn iprior17(&self) -> Iprior17R {
                Iprior17R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 68-71"]
            #[inline(always)]
            pub fn iprior17(&mut self) -> Iprior17W<Iprior17Spec> {
                Iprior17W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 17\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior17::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior17::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior17Spec;
        impl crate::RegisterSpec for Iprior17Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior17::R`](R) reader structure"]
        impl crate::Readable for Iprior17Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior17::W`](W) writer structure"]
        impl crate::Writable for Iprior17Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR17 to value 0"]
        impl crate::Resettable for Iprior17Spec {}
    }
    #[doc = "IPRIOR18 (rw) register accessor: Interrupt Priority configuration Register 18\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior18::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior18::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior18`] module"]
    #[doc(alias = "IPRIOR18")]
    pub type Iprior18 = crate::Reg<iprior18::Iprior18Spec>;
    #[doc = "Interrupt Priority configuration Register 18"]
    pub mod iprior18 {
        #[doc = "Register `IPRIOR18` reader"]
        pub type R = crate::R<Iprior18Spec>;
        #[doc = "Register `IPRIOR18` writer"]
        pub type W = crate::W<Iprior18Spec>;
        #[doc = "Field `IPRIOR18` reader - RW,Interrupt priority for number 72-75"]
        pub type Iprior18R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR18` writer - RW,Interrupt priority for number 72-75"]
        pub type Iprior18W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 72-75"]
            #[inline(always)]
            pub fn iprior18(&self) -> Iprior18R {
                Iprior18R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 72-75"]
            #[inline(always)]
            pub fn iprior18(&mut self) -> Iprior18W<Iprior18Spec> {
                Iprior18W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 18\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior18::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior18::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior18Spec;
        impl crate::RegisterSpec for Iprior18Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior18::R`](R) reader structure"]
        impl crate::Readable for Iprior18Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior18::W`](W) writer structure"]
        impl crate::Writable for Iprior18Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR18 to value 0"]
        impl crate::Resettable for Iprior18Spec {}
    }
    #[doc = "IPRIOR19 (rw) register accessor: Interrupt Priority configuration Register 19\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior19::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior19::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior19`] module"]
    #[doc(alias = "IPRIOR19")]
    pub type Iprior19 = crate::Reg<iprior19::Iprior19Spec>;
    #[doc = "Interrupt Priority configuration Register 19"]
    pub mod iprior19 {
        #[doc = "Register `IPRIOR19` reader"]
        pub type R = crate::R<Iprior19Spec>;
        #[doc = "Register `IPRIOR19` writer"]
        pub type W = crate::W<Iprior19Spec>;
        #[doc = "Field `IPRIOR19` reader - RW,Interrupt priority for number 76-79"]
        pub type Iprior19R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR19` writer - RW,Interrupt priority for number 76-79"]
        pub type Iprior19W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 76-79"]
            #[inline(always)]
            pub fn iprior19(&self) -> Iprior19R {
                Iprior19R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 76-79"]
            #[inline(always)]
            pub fn iprior19(&mut self) -> Iprior19W<Iprior19Spec> {
                Iprior19W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 19\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior19::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior19::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior19Spec;
        impl crate::RegisterSpec for Iprior19Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior19::R`](R) reader structure"]
        impl crate::Readable for Iprior19Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior19::W`](W) writer structure"]
        impl crate::Writable for Iprior19Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR19 to value 0"]
        impl crate::Resettable for Iprior19Spec {}
    }
    #[doc = "IPRIOR20 (rw) register accessor: Interrupt Priority configuration Register 20\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior20::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior20::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior20`] module"]
    #[doc(alias = "IPRIOR20")]
    pub type Iprior20 = crate::Reg<iprior20::Iprior20Spec>;
    #[doc = "Interrupt Priority configuration Register 20"]
    pub mod iprior20 {
        #[doc = "Register `IPRIOR20` reader"]
        pub type R = crate::R<Iprior20Spec>;
        #[doc = "Register `IPRIOR20` writer"]
        pub type W = crate::W<Iprior20Spec>;
        #[doc = "Field `IPRIOR20` reader - RW,RW,Interrupt priority for number 80-83"]
        pub type Iprior20R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR20` writer - RW,RW,Interrupt priority for number 80-83"]
        pub type Iprior20W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,RW,Interrupt priority for number 80-83"]
            #[inline(always)]
            pub fn iprior20(&self) -> Iprior20R {
                Iprior20R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,RW,Interrupt priority for number 80-83"]
            #[inline(always)]
            pub fn iprior20(&mut self) -> Iprior20W<Iprior20Spec> {
                Iprior20W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 20\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior20::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior20::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior20Spec;
        impl crate::RegisterSpec for Iprior20Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior20::R`](R) reader structure"]
        impl crate::Readable for Iprior20Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior20::W`](W) writer structure"]
        impl crate::Writable for Iprior20Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR20 to value 0"]
        impl crate::Resettable for Iprior20Spec {}
    }
    #[doc = "IPRIOR21 (rw) register accessor: Interrupt Priority configuration Register 21\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior21::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior21::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior21`] module"]
    #[doc(alias = "IPRIOR21")]
    pub type Iprior21 = crate::Reg<iprior21::Iprior21Spec>;
    #[doc = "Interrupt Priority configuration Register 21"]
    pub mod iprior21 {
        #[doc = "Register `IPRIOR21` reader"]
        pub type R = crate::R<Iprior21Spec>;
        #[doc = "Register `IPRIOR21` writer"]
        pub type W = crate::W<Iprior21Spec>;
        #[doc = "Field `IPRIOR21` reader - RW,Interrupt priority for number 84-87"]
        pub type Iprior21R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR21` writer - RW,Interrupt priority for number 84-87"]
        pub type Iprior21W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 84-87"]
            #[inline(always)]
            pub fn iprior21(&self) -> Iprior21R {
                Iprior21R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 84-87"]
            #[inline(always)]
            pub fn iprior21(&mut self) -> Iprior21W<Iprior21Spec> {
                Iprior21W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 21\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior21::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior21::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior21Spec;
        impl crate::RegisterSpec for Iprior21Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior21::R`](R) reader structure"]
        impl crate::Readable for Iprior21Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior21::W`](W) writer structure"]
        impl crate::Writable for Iprior21Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR21 to value 0"]
        impl crate::Resettable for Iprior21Spec {}
    }
    #[doc = "IPRIOR22 (rw) register accessor: Interrupt Priority configuration Register 22\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior22::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior22::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior22`] module"]
    #[doc(alias = "IPRIOR22")]
    pub type Iprior22 = crate::Reg<iprior22::Iprior22Spec>;
    #[doc = "Interrupt Priority configuration Register 22"]
    pub mod iprior22 {
        #[doc = "Register `IPRIOR22` reader"]
        pub type R = crate::R<Iprior22Spec>;
        #[doc = "Register `IPRIOR22` writer"]
        pub type W = crate::W<Iprior22Spec>;
        #[doc = "Field `IPRIOR22` reader - RW,Interrupt priority for number 88-91"]
        pub type Iprior22R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR22` writer - RW,Interrupt priority for number 88-91"]
        pub type Iprior22W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 88-91"]
            #[inline(always)]
            pub fn iprior22(&self) -> Iprior22R {
                Iprior22R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 88-91"]
            #[inline(always)]
            pub fn iprior22(&mut self) -> Iprior22W<Iprior22Spec> {
                Iprior22W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 22\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior22::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior22::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior22Spec;
        impl crate::RegisterSpec for Iprior22Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior22::R`](R) reader structure"]
        impl crate::Readable for Iprior22Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior22::W`](W) writer structure"]
        impl crate::Writable for Iprior22Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR22 to value 0"]
        impl crate::Resettable for Iprior22Spec {}
    }
    #[doc = "IPRIOR23 (rw) register accessor: Interrupt Priority configuration Register 23\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior23::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior23::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior23`] module"]
    #[doc(alias = "IPRIOR23")]
    pub type Iprior23 = crate::Reg<iprior23::Iprior23Spec>;
    #[doc = "Interrupt Priority configuration Register 23"]
    pub mod iprior23 {
        #[doc = "Register `IPRIOR23` reader"]
        pub type R = crate::R<Iprior23Spec>;
        #[doc = "Register `IPRIOR23` writer"]
        pub type W = crate::W<Iprior23Spec>;
        #[doc = "Field `IPRIOR23` reader - RW,Interrupt priority for number 92-95"]
        pub type Iprior23R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR23` writer - RW,Interrupt priority for number 92-95"]
        pub type Iprior23W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 92-95"]
            #[inline(always)]
            pub fn iprior23(&self) -> Iprior23R {
                Iprior23R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 92-95"]
            #[inline(always)]
            pub fn iprior23(&mut self) -> Iprior23W<Iprior23Spec> {
                Iprior23W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 23\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior23::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior23::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior23Spec;
        impl crate::RegisterSpec for Iprior23Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior23::R`](R) reader structure"]
        impl crate::Readable for Iprior23Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior23::W`](W) writer structure"]
        impl crate::Writable for Iprior23Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR23 to value 0"]
        impl crate::Resettable for Iprior23Spec {}
    }
    #[doc = "IPRIOR24 (rw) register accessor: Interrupt Priority configuration Register 24\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior24::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior24::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior24`] module"]
    #[doc(alias = "IPRIOR24")]
    pub type Iprior24 = crate::Reg<iprior24::Iprior24Spec>;
    #[doc = "Interrupt Priority configuration Register 24"]
    pub mod iprior24 {
        #[doc = "Register `IPRIOR24` reader"]
        pub type R = crate::R<Iprior24Spec>;
        #[doc = "Register `IPRIOR24` writer"]
        pub type W = crate::W<Iprior24Spec>;
        #[doc = "Field `IPRIOR24` reader - RW,Interrupt priority for number 96-99"]
        pub type Iprior24R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR24` writer - RW,Interrupt priority for number 96-99"]
        pub type Iprior24W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 96-99"]
            #[inline(always)]
            pub fn iprior24(&self) -> Iprior24R {
                Iprior24R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 96-99"]
            #[inline(always)]
            pub fn iprior24(&mut self) -> Iprior24W<Iprior24Spec> {
                Iprior24W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 24\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior24::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior24::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior24Spec;
        impl crate::RegisterSpec for Iprior24Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior24::R`](R) reader structure"]
        impl crate::Readable for Iprior24Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior24::W`](W) writer structure"]
        impl crate::Writable for Iprior24Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR24 to value 0"]
        impl crate::Resettable for Iprior24Spec {}
    }
    #[doc = "IPRIOR25 (rw) register accessor: Interrupt Priority configuration Register 25\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior25::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior25::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior25`] module"]
    #[doc(alias = "IPRIOR25")]
    pub type Iprior25 = crate::Reg<iprior25::Iprior25Spec>;
    #[doc = "Interrupt Priority configuration Register 25"]
    pub mod iprior25 {
        #[doc = "Register `IPRIOR25` reader"]
        pub type R = crate::R<Iprior25Spec>;
        #[doc = "Register `IPRIOR25` writer"]
        pub type W = crate::W<Iprior25Spec>;
        #[doc = "Field `IPRIOR25` reader - RW,Interrupt priority for number 100-103"]
        pub type Iprior25R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR25` writer - RW,Interrupt priority for number 100-103"]
        pub type Iprior25W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 100-103"]
            #[inline(always)]
            pub fn iprior25(&self) -> Iprior25R {
                Iprior25R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 100-103"]
            #[inline(always)]
            pub fn iprior25(&mut self) -> Iprior25W<Iprior25Spec> {
                Iprior25W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 25\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior25::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior25::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior25Spec;
        impl crate::RegisterSpec for Iprior25Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior25::R`](R) reader structure"]
        impl crate::Readable for Iprior25Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior25::W`](W) writer structure"]
        impl crate::Writable for Iprior25Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR25 to value 0"]
        impl crate::Resettable for Iprior25Spec {}
    }
    #[doc = "IPRIOR26 (rw) register accessor: Interrupt Priority configuration Register 26\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior26::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior26::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior26`] module"]
    #[doc(alias = "IPRIOR26")]
    pub type Iprior26 = crate::Reg<iprior26::Iprior26Spec>;
    #[doc = "Interrupt Priority configuration Register 26"]
    pub mod iprior26 {
        #[doc = "Register `IPRIOR26` reader"]
        pub type R = crate::R<Iprior26Spec>;
        #[doc = "Register `IPRIOR26` writer"]
        pub type W = crate::W<Iprior26Spec>;
        #[doc = "Field `IPRIOR26` reader - RW,Interrupt priority for number 104-107"]
        pub type Iprior26R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR26` writer - RW,Interrupt priority for number 104-107"]
        pub type Iprior26W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 104-107"]
            #[inline(always)]
            pub fn iprior26(&self) -> Iprior26R {
                Iprior26R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 104-107"]
            #[inline(always)]
            pub fn iprior26(&mut self) -> Iprior26W<Iprior26Spec> {
                Iprior26W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 26\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior26::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior26::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior26Spec;
        impl crate::RegisterSpec for Iprior26Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior26::R`](R) reader structure"]
        impl crate::Readable for Iprior26Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior26::W`](W) writer structure"]
        impl crate::Writable for Iprior26Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR26 to value 0"]
        impl crate::Resettable for Iprior26Spec {}
    }
    #[doc = "IPRIOR27 (rw) register accessor: Interrupt Priority configuration Register 27\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior27::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior27::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior27`] module"]
    #[doc(alias = "IPRIOR27")]
    pub type Iprior27 = crate::Reg<iprior27::Iprior27Spec>;
    #[doc = "Interrupt Priority configuration Register 27"]
    pub mod iprior27 {
        #[doc = "Register `IPRIOR27` reader"]
        pub type R = crate::R<Iprior27Spec>;
        #[doc = "Register `IPRIOR27` writer"]
        pub type W = crate::W<Iprior27Spec>;
        #[doc = "Field `IPRIOR27` reader - RW,Interrupt priority for number 108-111"]
        pub type Iprior27R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR27` writer - RW,Interrupt priority for number 108-111"]
        pub type Iprior27W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 108-111"]
            #[inline(always)]
            pub fn iprior27(&self) -> Iprior27R {
                Iprior27R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 108-111"]
            #[inline(always)]
            pub fn iprior27(&mut self) -> Iprior27W<Iprior27Spec> {
                Iprior27W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 27\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior27::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior27::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior27Spec;
        impl crate::RegisterSpec for Iprior27Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior27::R`](R) reader structure"]
        impl crate::Readable for Iprior27Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior27::W`](W) writer structure"]
        impl crate::Writable for Iprior27Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR27 to value 0"]
        impl crate::Resettable for Iprior27Spec {}
    }
    #[doc = "IPRIOR28 (rw) register accessor: Interrupt Priority configuration Register 28\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior28::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior28::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior28`] module"]
    #[doc(alias = "IPRIOR28")]
    pub type Iprior28 = crate::Reg<iprior28::Iprior28Spec>;
    #[doc = "Interrupt Priority configuration Register 28"]
    pub mod iprior28 {
        #[doc = "Register `IPRIOR28` reader"]
        pub type R = crate::R<Iprior28Spec>;
        #[doc = "Register `IPRIOR28` writer"]
        pub type W = crate::W<Iprior28Spec>;
        #[doc = "Field `IPRIOR28` reader - RW,Interrupt priority for number 112-115"]
        pub type Iprior28R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR28` writer - RW,Interrupt priority for number 112-115"]
        pub type Iprior28W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 112-115"]
            #[inline(always)]
            pub fn iprior28(&self) -> Iprior28R {
                Iprior28R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 112-115"]
            #[inline(always)]
            pub fn iprior28(&mut self) -> Iprior28W<Iprior28Spec> {
                Iprior28W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 28\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior28::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior28::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior28Spec;
        impl crate::RegisterSpec for Iprior28Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior28::R`](R) reader structure"]
        impl crate::Readable for Iprior28Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior28::W`](W) writer structure"]
        impl crate::Writable for Iprior28Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR28 to value 0"]
        impl crate::Resettable for Iprior28Spec {}
    }
    #[doc = "IPRIOR29 (rw) register accessor: Interrupt Priority configuration Register 29\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior29::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior29::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior29`] module"]
    #[doc(alias = "IPRIOR29")]
    pub type Iprior29 = crate::Reg<iprior29::Iprior29Spec>;
    #[doc = "Interrupt Priority configuration Register 29"]
    pub mod iprior29 {
        #[doc = "Register `IPRIOR29` reader"]
        pub type R = crate::R<Iprior29Spec>;
        #[doc = "Register `IPRIOR29` writer"]
        pub type W = crate::W<Iprior29Spec>;
        #[doc = "Field `IPRIOR29` reader - RW,Interrupt priority for number 116-119"]
        pub type Iprior29R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR29` writer - RW,Interrupt priority for number 116-119"]
        pub type Iprior29W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 116-119"]
            #[inline(always)]
            pub fn iprior29(&self) -> Iprior29R {
                Iprior29R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 116-119"]
            #[inline(always)]
            pub fn iprior29(&mut self) -> Iprior29W<Iprior29Spec> {
                Iprior29W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 29\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior29::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior29::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior29Spec;
        impl crate::RegisterSpec for Iprior29Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior29::R`](R) reader structure"]
        impl crate::Readable for Iprior29Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior29::W`](W) writer structure"]
        impl crate::Writable for Iprior29Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR29 to value 0"]
        impl crate::Resettable for Iprior29Spec {}
    }
    #[doc = "IPRIOR30 (rw) register accessor: Interrupt Priority configuration Register 30\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior30::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior30::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior30`] module"]
    #[doc(alias = "IPRIOR30")]
    pub type Iprior30 = crate::Reg<iprior30::Iprior30Spec>;
    #[doc = "Interrupt Priority configuration Register 30"]
    pub mod iprior30 {
        #[doc = "Register `IPRIOR30` reader"]
        pub type R = crate::R<Iprior30Spec>;
        #[doc = "Register `IPRIOR30` writer"]
        pub type W = crate::W<Iprior30Spec>;
        #[doc = "Field `IPRIOR30` reader - RW,Interrupt priority for number 120-123"]
        pub type Iprior30R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR30` writer - RW,Interrupt priority for number 120-123"]
        pub type Iprior30W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 120-123"]
            #[inline(always)]
            pub fn iprior30(&self) -> Iprior30R {
                Iprior30R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 120-123"]
            #[inline(always)]
            pub fn iprior30(&mut self) -> Iprior30W<Iprior30Spec> {
                Iprior30W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 30\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior30::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior30::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior30Spec;
        impl crate::RegisterSpec for Iprior30Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior30::R`](R) reader structure"]
        impl crate::Readable for Iprior30Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior30::W`](W) writer structure"]
        impl crate::Writable for Iprior30Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR30 to value 0"]
        impl crate::Resettable for Iprior30Spec {}
    }
    #[doc = "IPRIOR31 (rw) register accessor: Interrupt Priority configuration Register 31\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior31::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior31::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior31`] module"]
    #[doc(alias = "IPRIOR31")]
    pub type Iprior31 = crate::Reg<iprior31::Iprior31Spec>;
    #[doc = "Interrupt Priority configuration Register 31"]
    pub mod iprior31 {
        #[doc = "Register `IPRIOR31` reader"]
        pub type R = crate::R<Iprior31Spec>;
        #[doc = "Register `IPRIOR31` writer"]
        pub type W = crate::W<Iprior31Spec>;
        #[doc = "Field `IPRIOR31` reader - RW,Interrupt priority for number 124-127"]
        pub type Iprior31R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR31` writer - RW,Interrupt priority for number 124-127"]
        pub type Iprior31W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 124-127"]
            #[inline(always)]
            pub fn iprior31(&self) -> Iprior31R {
                Iprior31R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 124-127"]
            #[inline(always)]
            pub fn iprior31(&mut self) -> Iprior31W<Iprior31Spec> {
                Iprior31W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 31\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior31::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior31::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior31Spec;
        impl crate::RegisterSpec for Iprior31Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior31::R`](R) reader structure"]
        impl crate::Readable for Iprior31Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior31::W`](W) writer structure"]
        impl crate::Writable for Iprior31Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR31 to value 0"]
        impl crate::Resettable for Iprior31Spec {}
    }
    #[doc = "IPRIOR32 (rw) register accessor: Interrupt Priority configuration Register 32\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior32::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior32::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior32`] module"]
    #[doc(alias = "IPRIOR32")]
    pub type Iprior32 = crate::Reg<iprior32::Iprior32Spec>;
    #[doc = "Interrupt Priority configuration Register 32"]
    pub mod iprior32 {
        #[doc = "Register `IPRIOR32` reader"]
        pub type R = crate::R<Iprior32Spec>;
        #[doc = "Register `IPRIOR32` writer"]
        pub type W = crate::W<Iprior32Spec>;
        #[doc = "Field `IPRIOR32` reader - RW,Interrupt priority for number 128-131"]
        pub type Iprior32R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR32` writer - RW,Interrupt priority for number 128-131"]
        pub type Iprior32W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 128-131"]
            #[inline(always)]
            pub fn iprior32(&self) -> Iprior32R {
                Iprior32R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 128-131"]
            #[inline(always)]
            pub fn iprior32(&mut self) -> Iprior32W<Iprior32Spec> {
                Iprior32W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 32\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior32::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior32::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior32Spec;
        impl crate::RegisterSpec for Iprior32Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior32::R`](R) reader structure"]
        impl crate::Readable for Iprior32Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior32::W`](W) writer structure"]
        impl crate::Writable for Iprior32Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR32 to value 0"]
        impl crate::Resettable for Iprior32Spec {}
    }
    #[doc = "IPRIOR33 (rw) register accessor: Interrupt Priority configuration Register 33\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior33::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior33::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior33`] module"]
    #[doc(alias = "IPRIOR33")]
    pub type Iprior33 = crate::Reg<iprior33::Iprior33Spec>;
    #[doc = "Interrupt Priority configuration Register 33"]
    pub mod iprior33 {
        #[doc = "Register `IPRIOR33` reader"]
        pub type R = crate::R<Iprior33Spec>;
        #[doc = "Register `IPRIOR33` writer"]
        pub type W = crate::W<Iprior33Spec>;
        #[doc = "Field `IPRIOR33` reader - RW,Interrupt priority for number 132-135"]
        pub type Iprior33R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR33` writer - RW,Interrupt priority for number 132-135"]
        pub type Iprior33W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 132-135"]
            #[inline(always)]
            pub fn iprior33(&self) -> Iprior33R {
                Iprior33R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 132-135"]
            #[inline(always)]
            pub fn iprior33(&mut self) -> Iprior33W<Iprior33Spec> {
                Iprior33W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 33\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior33::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior33::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior33Spec;
        impl crate::RegisterSpec for Iprior33Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior33::R`](R) reader structure"]
        impl crate::Readable for Iprior33Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior33::W`](W) writer structure"]
        impl crate::Writable for Iprior33Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR33 to value 0"]
        impl crate::Resettable for Iprior33Spec {}
    }
    #[doc = "IPRIOR34 (rw) register accessor: Interrupt Priority configuration Register 34\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior34::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior34::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior34`] module"]
    #[doc(alias = "IPRIOR34")]
    pub type Iprior34 = crate::Reg<iprior34::Iprior34Spec>;
    #[doc = "Interrupt Priority configuration Register 34"]
    pub mod iprior34 {
        #[doc = "Register `IPRIOR34` reader"]
        pub type R = crate::R<Iprior34Spec>;
        #[doc = "Register `IPRIOR34` writer"]
        pub type W = crate::W<Iprior34Spec>;
        #[doc = "Field `IPRIOR34` reader - RW,Interrupt priority for number 136-139"]
        pub type Iprior34R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR34` writer - RW,Interrupt priority for number 136-139"]
        pub type Iprior34W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 136-139"]
            #[inline(always)]
            pub fn iprior34(&self) -> Iprior34R {
                Iprior34R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 136-139"]
            #[inline(always)]
            pub fn iprior34(&mut self) -> Iprior34W<Iprior34Spec> {
                Iprior34W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 34\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior34::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior34::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior34Spec;
        impl crate::RegisterSpec for Iprior34Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior34::R`](R) reader structure"]
        impl crate::Readable for Iprior34Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior34::W`](W) writer structure"]
        impl crate::Writable for Iprior34Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR34 to value 0"]
        impl crate::Resettable for Iprior34Spec {}
    }
    #[doc = "IPRIOR35 (rw) register accessor: Interrupt Priority configuration Register 35\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior35::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior35::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior35`] module"]
    #[doc(alias = "IPRIOR35")]
    pub type Iprior35 = crate::Reg<iprior35::Iprior35Spec>;
    #[doc = "Interrupt Priority configuration Register 35"]
    pub mod iprior35 {
        #[doc = "Register `IPRIOR35` reader"]
        pub type R = crate::R<Iprior35Spec>;
        #[doc = "Register `IPRIOR35` writer"]
        pub type W = crate::W<Iprior35Spec>;
        #[doc = "Field `IPRIOR35` reader - RW,Interrupt priority for number 140-143"]
        pub type Iprior35R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR35` writer - RW,Interrupt priority for number 140-143"]
        pub type Iprior35W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 140-143"]
            #[inline(always)]
            pub fn iprior35(&self) -> Iprior35R {
                Iprior35R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 140-143"]
            #[inline(always)]
            pub fn iprior35(&mut self) -> Iprior35W<Iprior35Spec> {
                Iprior35W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 35\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior35::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior35::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior35Spec;
        impl crate::RegisterSpec for Iprior35Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior35::R`](R) reader structure"]
        impl crate::Readable for Iprior35Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior35::W`](W) writer structure"]
        impl crate::Writable for Iprior35Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR35 to value 0"]
        impl crate::Resettable for Iprior35Spec {}
    }
    #[doc = "IPRIOR36 (rw) register accessor: Interrupt Priority configuration Register 36\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior36::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior36::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior36`] module"]
    #[doc(alias = "IPRIOR36")]
    pub type Iprior36 = crate::Reg<iprior36::Iprior36Spec>;
    #[doc = "Interrupt Priority configuration Register 36"]
    pub mod iprior36 {
        #[doc = "Register `IPRIOR36` reader"]
        pub type R = crate::R<Iprior36Spec>;
        #[doc = "Register `IPRIOR36` writer"]
        pub type W = crate::W<Iprior36Spec>;
        #[doc = "Field `IPRIOR36` reader - RW,Interrupt priority for number 144-147"]
        pub type Iprior36R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR36` writer - RW,Interrupt priority for number 144-147"]
        pub type Iprior36W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 144-147"]
            #[inline(always)]
            pub fn iprior36(&self) -> Iprior36R {
                Iprior36R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 144-147"]
            #[inline(always)]
            pub fn iprior36(&mut self) -> Iprior36W<Iprior36Spec> {
                Iprior36W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 36\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior36::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior36::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior36Spec;
        impl crate::RegisterSpec for Iprior36Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior36::R`](R) reader structure"]
        impl crate::Readable for Iprior36Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior36::W`](W) writer structure"]
        impl crate::Writable for Iprior36Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR36 to value 0"]
        impl crate::Resettable for Iprior36Spec {}
    }
    #[doc = "IPRIOR37 (rw) register accessor: Interrupt Priority configuration Register 37\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior37::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior37::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior37`] module"]
    #[doc(alias = "IPRIOR37")]
    pub type Iprior37 = crate::Reg<iprior37::Iprior37Spec>;
    #[doc = "Interrupt Priority configuration Register 37"]
    pub mod iprior37 {
        #[doc = "Register `IPRIOR37` reader"]
        pub type R = crate::R<Iprior37Spec>;
        #[doc = "Register `IPRIOR37` writer"]
        pub type W = crate::W<Iprior37Spec>;
        #[doc = "Field `IPRIOR37` reader - RW,Interrupt priority for number 148-151"]
        pub type Iprior37R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR37` writer - RW,Interrupt priority for number 148-151"]
        pub type Iprior37W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 148-151"]
            #[inline(always)]
            pub fn iprior37(&self) -> Iprior37R {
                Iprior37R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 148-151"]
            #[inline(always)]
            pub fn iprior37(&mut self) -> Iprior37W<Iprior37Spec> {
                Iprior37W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 37\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior37::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior37::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior37Spec;
        impl crate::RegisterSpec for Iprior37Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior37::R`](R) reader structure"]
        impl crate::Readable for Iprior37Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior37::W`](W) writer structure"]
        impl crate::Writable for Iprior37Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR37 to value 0"]
        impl crate::Resettable for Iprior37Spec {}
    }
    #[doc = "IPRIOR38 (rw) register accessor: Interrupt Priority configuration Register 38\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior38::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior38::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior38`] module"]
    #[doc(alias = "IPRIOR38")]
    pub type Iprior38 = crate::Reg<iprior38::Iprior38Spec>;
    #[doc = "Interrupt Priority configuration Register 38"]
    pub mod iprior38 {
        #[doc = "Register `IPRIOR38` reader"]
        pub type R = crate::R<Iprior38Spec>;
        #[doc = "Register `IPRIOR38` writer"]
        pub type W = crate::W<Iprior38Spec>;
        #[doc = "Field `IPRIOR38` reader - RW,Interrupt priority for number 152-155"]
        pub type Iprior38R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR38` writer - RW,Interrupt priority for number 152-155"]
        pub type Iprior38W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 152-155"]
            #[inline(always)]
            pub fn iprior38(&self) -> Iprior38R {
                Iprior38R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 152-155"]
            #[inline(always)]
            pub fn iprior38(&mut self) -> Iprior38W<Iprior38Spec> {
                Iprior38W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 38\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior38::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior38::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior38Spec;
        impl crate::RegisterSpec for Iprior38Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior38::R`](R) reader structure"]
        impl crate::Readable for Iprior38Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior38::W`](W) writer structure"]
        impl crate::Writable for Iprior38Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR38 to value 0"]
        impl crate::Resettable for Iprior38Spec {}
    }
    #[doc = "IPRIOR39 (rw) register accessor: Interrupt Priority configuration Register 39\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior39::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior39::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior39`] module"]
    #[doc(alias = "IPRIOR39")]
    pub type Iprior39 = crate::Reg<iprior39::Iprior39Spec>;
    #[doc = "Interrupt Priority configuration Register 39"]
    pub mod iprior39 {
        #[doc = "Register `IPRIOR39` reader"]
        pub type R = crate::R<Iprior39Spec>;
        #[doc = "Register `IPRIOR39` writer"]
        pub type W = crate::W<Iprior39Spec>;
        #[doc = "Field `IPRIOR39` reader - RW,Interrupt priority for number 156-159"]
        pub type Iprior39R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR39` writer - RW,Interrupt priority for number 156-159"]
        pub type Iprior39W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 156-159"]
            #[inline(always)]
            pub fn iprior39(&self) -> Iprior39R {
                Iprior39R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 156-159"]
            #[inline(always)]
            pub fn iprior39(&mut self) -> Iprior39W<Iprior39Spec> {
                Iprior39W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 39\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior39::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior39::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior39Spec;
        impl crate::RegisterSpec for Iprior39Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior39::R`](R) reader structure"]
        impl crate::Readable for Iprior39Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior39::W`](W) writer structure"]
        impl crate::Writable for Iprior39Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR39 to value 0"]
        impl crate::Resettable for Iprior39Spec {}
    }
    #[doc = "IPRIOR40 (rw) register accessor: Interrupt Priority configuration Register 40\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior40::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior40::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior40`] module"]
    #[doc(alias = "IPRIOR40")]
    pub type Iprior40 = crate::Reg<iprior40::Iprior40Spec>;
    #[doc = "Interrupt Priority configuration Register 40"]
    pub mod iprior40 {
        #[doc = "Register `IPRIOR40` reader"]
        pub type R = crate::R<Iprior40Spec>;
        #[doc = "Register `IPRIOR40` writer"]
        pub type W = crate::W<Iprior40Spec>;
        #[doc = "Field `IPRIOR40` reader - RW,Interrupt priority for number 160-163"]
        pub type Iprior40R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR40` writer - RW,Interrupt priority for number 160-163"]
        pub type Iprior40W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 160-163"]
            #[inline(always)]
            pub fn iprior40(&self) -> Iprior40R {
                Iprior40R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 160-163"]
            #[inline(always)]
            pub fn iprior40(&mut self) -> Iprior40W<Iprior40Spec> {
                Iprior40W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 40\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior40::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior40::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior40Spec;
        impl crate::RegisterSpec for Iprior40Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior40::R`](R) reader structure"]
        impl crate::Readable for Iprior40Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior40::W`](W) writer structure"]
        impl crate::Writable for Iprior40Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR40 to value 0"]
        impl crate::Resettable for Iprior40Spec {}
    }
    #[doc = "IPRIOR41 (rw) register accessor: Interrupt Priority configuration Register 41\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior41::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior41::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior41`] module"]
    #[doc(alias = "IPRIOR41")]
    pub type Iprior41 = crate::Reg<iprior41::Iprior41Spec>;
    #[doc = "Interrupt Priority configuration Register 41"]
    pub mod iprior41 {
        #[doc = "Register `IPRIOR41` reader"]
        pub type R = crate::R<Iprior41Spec>;
        #[doc = "Register `IPRIOR41` writer"]
        pub type W = crate::W<Iprior41Spec>;
        #[doc = "Field `IPRIOR41` reader - RW,Interrupt priority for number 164-167"]
        pub type Iprior41R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR41` writer - RW,Interrupt priority for number 164-167"]
        pub type Iprior41W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 164-167"]
            #[inline(always)]
            pub fn iprior41(&self) -> Iprior41R {
                Iprior41R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 164-167"]
            #[inline(always)]
            pub fn iprior41(&mut self) -> Iprior41W<Iprior41Spec> {
                Iprior41W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 41\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior41::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior41::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior41Spec;
        impl crate::RegisterSpec for Iprior41Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior41::R`](R) reader structure"]
        impl crate::Readable for Iprior41Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior41::W`](W) writer structure"]
        impl crate::Writable for Iprior41Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR41 to value 0"]
        impl crate::Resettable for Iprior41Spec {}
    }
    #[doc = "IPRIOR42 (rw) register accessor: Interrupt Priority configuration Register 42\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior42::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior42::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior42`] module"]
    #[doc(alias = "IPRIOR42")]
    pub type Iprior42 = crate::Reg<iprior42::Iprior42Spec>;
    #[doc = "Interrupt Priority configuration Register 42"]
    pub mod iprior42 {
        #[doc = "Register `IPRIOR42` reader"]
        pub type R = crate::R<Iprior42Spec>;
        #[doc = "Register `IPRIOR42` writer"]
        pub type W = crate::W<Iprior42Spec>;
        #[doc = "Field `IPRIOR42` reader - RW,Interrupt priority for number 168-171"]
        pub type Iprior42R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR42` writer - RW,Interrupt priority for number 168-171"]
        pub type Iprior42W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 168-171"]
            #[inline(always)]
            pub fn iprior42(&self) -> Iprior42R {
                Iprior42R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 168-171"]
            #[inline(always)]
            pub fn iprior42(&mut self) -> Iprior42W<Iprior42Spec> {
                Iprior42W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 42\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior42::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior42::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior42Spec;
        impl crate::RegisterSpec for Iprior42Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior42::R`](R) reader structure"]
        impl crate::Readable for Iprior42Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior42::W`](W) writer structure"]
        impl crate::Writable for Iprior42Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR42 to value 0"]
        impl crate::Resettable for Iprior42Spec {}
    }
    #[doc = "IPRIOR43 (rw) register accessor: Interrupt Priority configuration Register 43\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior43::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior43::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior43`] module"]
    #[doc(alias = "IPRIOR43")]
    pub type Iprior43 = crate::Reg<iprior43::Iprior43Spec>;
    #[doc = "Interrupt Priority configuration Register 43"]
    pub mod iprior43 {
        #[doc = "Register `IPRIOR43` reader"]
        pub type R = crate::R<Iprior43Spec>;
        #[doc = "Register `IPRIOR43` writer"]
        pub type W = crate::W<Iprior43Spec>;
        #[doc = "Field `IPRIOR43` reader - RW,Interrupt priority for number 172-175"]
        pub type Iprior43R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR43` writer - RW,Interrupt priority for number 172-175"]
        pub type Iprior43W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 172-175"]
            #[inline(always)]
            pub fn iprior43(&self) -> Iprior43R {
                Iprior43R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 172-175"]
            #[inline(always)]
            pub fn iprior43(&mut self) -> Iprior43W<Iprior43Spec> {
                Iprior43W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 43\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior43::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior43::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior43Spec;
        impl crate::RegisterSpec for Iprior43Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior43::R`](R) reader structure"]
        impl crate::Readable for Iprior43Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior43::W`](W) writer structure"]
        impl crate::Writable for Iprior43Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR43 to value 0"]
        impl crate::Resettable for Iprior43Spec {}
    }
    #[doc = "IPRIOR44 (rw) register accessor: Interrupt Priority configuration Register 44\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior44::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior44::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior44`] module"]
    #[doc(alias = "IPRIOR44")]
    pub type Iprior44 = crate::Reg<iprior44::Iprior44Spec>;
    #[doc = "Interrupt Priority configuration Register 44"]
    pub mod iprior44 {
        #[doc = "Register `IPRIOR44` reader"]
        pub type R = crate::R<Iprior44Spec>;
        #[doc = "Register `IPRIOR44` writer"]
        pub type W = crate::W<Iprior44Spec>;
        #[doc = "Field `IPRIOR44` reader - RW,Interrupt priority for number 176-179"]
        pub type Iprior44R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR44` writer - RW,Interrupt priority for number 176-179"]
        pub type Iprior44W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 176-179"]
            #[inline(always)]
            pub fn iprior44(&self) -> Iprior44R {
                Iprior44R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 176-179"]
            #[inline(always)]
            pub fn iprior44(&mut self) -> Iprior44W<Iprior44Spec> {
                Iprior44W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 44\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior44::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior44::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior44Spec;
        impl crate::RegisterSpec for Iprior44Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior44::R`](R) reader structure"]
        impl crate::Readable for Iprior44Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior44::W`](W) writer structure"]
        impl crate::Writable for Iprior44Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR44 to value 0"]
        impl crate::Resettable for Iprior44Spec {}
    }
    #[doc = "IPRIOR45 (rw) register accessor: Interrupt Priority configuration Register 45\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior45::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior45::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior45`] module"]
    #[doc(alias = "IPRIOR45")]
    pub type Iprior45 = crate::Reg<iprior45::Iprior45Spec>;
    #[doc = "Interrupt Priority configuration Register 45"]
    pub mod iprior45 {
        #[doc = "Register `IPRIOR45` reader"]
        pub type R = crate::R<Iprior45Spec>;
        #[doc = "Register `IPRIOR45` writer"]
        pub type W = crate::W<Iprior45Spec>;
        #[doc = "Field `IPRIOR45` reader - RW,Interrupt priority for number 180-183"]
        pub type Iprior45R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR45` writer - RW,Interrupt priority for number 180-183"]
        pub type Iprior45W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 180-183"]
            #[inline(always)]
            pub fn iprior45(&self) -> Iprior45R {
                Iprior45R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 180-183"]
            #[inline(always)]
            pub fn iprior45(&mut self) -> Iprior45W<Iprior45Spec> {
                Iprior45W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 45\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior45::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior45::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior45Spec;
        impl crate::RegisterSpec for Iprior45Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior45::R`](R) reader structure"]
        impl crate::Readable for Iprior45Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior45::W`](W) writer structure"]
        impl crate::Writable for Iprior45Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR45 to value 0"]
        impl crate::Resettable for Iprior45Spec {}
    }
    #[doc = "IPRIOR46 (rw) register accessor: Interrupt Priority configuration Register 46\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior46::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior46::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior46`] module"]
    #[doc(alias = "IPRIOR46")]
    pub type Iprior46 = crate::Reg<iprior46::Iprior46Spec>;
    #[doc = "Interrupt Priority configuration Register 46"]
    pub mod iprior46 {
        #[doc = "Register `IPRIOR46` reader"]
        pub type R = crate::R<Iprior46Spec>;
        #[doc = "Register `IPRIOR46` writer"]
        pub type W = crate::W<Iprior46Spec>;
        #[doc = "Field `IPRIOR46` reader - RW,Interrupt priority for number 184-187"]
        pub type Iprior46R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR46` writer - RW,Interrupt priority for number 184-187"]
        pub type Iprior46W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 184-187"]
            #[inline(always)]
            pub fn iprior46(&self) -> Iprior46R {
                Iprior46R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 184-187"]
            #[inline(always)]
            pub fn iprior46(&mut self) -> Iprior46W<Iprior46Spec> {
                Iprior46W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 46\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior46::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior46::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior46Spec;
        impl crate::RegisterSpec for Iprior46Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior46::R`](R) reader structure"]
        impl crate::Readable for Iprior46Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior46::W`](W) writer structure"]
        impl crate::Writable for Iprior46Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR46 to value 0"]
        impl crate::Resettable for Iprior46Spec {}
    }
    #[doc = "IPRIOR47 (rw) register accessor: Interrupt Priority configuration Register 47\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior47::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior47::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior47`] module"]
    #[doc(alias = "IPRIOR47")]
    pub type Iprior47 = crate::Reg<iprior47::Iprior47Spec>;
    #[doc = "Interrupt Priority configuration Register 47"]
    pub mod iprior47 {
        #[doc = "Register `IPRIOR47` reader"]
        pub type R = crate::R<Iprior47Spec>;
        #[doc = "Register `IPRIOR47` writer"]
        pub type W = crate::W<Iprior47Spec>;
        #[doc = "Field `IPRIOR47` reader - RW,Interrupt priority for number 188-191"]
        pub type Iprior47R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR47` writer - RW,Interrupt priority for number 188-191"]
        pub type Iprior47W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 188-191"]
            #[inline(always)]
            pub fn iprior47(&self) -> Iprior47R {
                Iprior47R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 188-191"]
            #[inline(always)]
            pub fn iprior47(&mut self) -> Iprior47W<Iprior47Spec> {
                Iprior47W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 47\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior47::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior47::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior47Spec;
        impl crate::RegisterSpec for Iprior47Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior47::R`](R) reader structure"]
        impl crate::Readable for Iprior47Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior47::W`](W) writer structure"]
        impl crate::Writable for Iprior47Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR47 to value 0"]
        impl crate::Resettable for Iprior47Spec {}
    }
    #[doc = "IPRIOR48 (rw) register accessor: Interrupt Priority configuration Register 48\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior48::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior48::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior48`] module"]
    #[doc(alias = "IPRIOR48")]
    pub type Iprior48 = crate::Reg<iprior48::Iprior48Spec>;
    #[doc = "Interrupt Priority configuration Register 48"]
    pub mod iprior48 {
        #[doc = "Register `IPRIOR48` reader"]
        pub type R = crate::R<Iprior48Spec>;
        #[doc = "Register `IPRIOR48` writer"]
        pub type W = crate::W<Iprior48Spec>;
        #[doc = "Field `IPRIOR48` reader - RW,Interrupt priority for number 192-195"]
        pub type Iprior48R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR48` writer - RW,Interrupt priority for number 192-195"]
        pub type Iprior48W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 192-195"]
            #[inline(always)]
            pub fn iprior48(&self) -> Iprior48R {
                Iprior48R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 192-195"]
            #[inline(always)]
            pub fn iprior48(&mut self) -> Iprior48W<Iprior48Spec> {
                Iprior48W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 48\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior48::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior48::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior48Spec;
        impl crate::RegisterSpec for Iprior48Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior48::R`](R) reader structure"]
        impl crate::Readable for Iprior48Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior48::W`](W) writer structure"]
        impl crate::Writable for Iprior48Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR48 to value 0"]
        impl crate::Resettable for Iprior48Spec {}
    }
    #[doc = "IPRIOR49 (rw) register accessor: Interrupt Priority configuration Register 49\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior49::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior49::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior49`] module"]
    #[doc(alias = "IPRIOR49")]
    pub type Iprior49 = crate::Reg<iprior49::Iprior49Spec>;
    #[doc = "Interrupt Priority configuration Register 49"]
    pub mod iprior49 {
        #[doc = "Register `IPRIOR49` reader"]
        pub type R = crate::R<Iprior49Spec>;
        #[doc = "Register `IPRIOR49` writer"]
        pub type W = crate::W<Iprior49Spec>;
        #[doc = "Field `IPRIOR49` reader - RW,Interrupt priority for number 196-199"]
        pub type Iprior49R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR49` writer - RW,Interrupt priority for number 196-199"]
        pub type Iprior49W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 196-199"]
            #[inline(always)]
            pub fn iprior49(&self) -> Iprior49R {
                Iprior49R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 196-199"]
            #[inline(always)]
            pub fn iprior49(&mut self) -> Iprior49W<Iprior49Spec> {
                Iprior49W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 49\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior49::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior49::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior49Spec;
        impl crate::RegisterSpec for Iprior49Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior49::R`](R) reader structure"]
        impl crate::Readable for Iprior49Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior49::W`](W) writer structure"]
        impl crate::Writable for Iprior49Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR49 to value 0"]
        impl crate::Resettable for Iprior49Spec {}
    }
    #[doc = "IPRIOR50 (rw) register accessor: Interrupt Priority configuration Register 50\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior50::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior50::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior50`] module"]
    #[doc(alias = "IPRIOR50")]
    pub type Iprior50 = crate::Reg<iprior50::Iprior50Spec>;
    #[doc = "Interrupt Priority configuration Register 50"]
    pub mod iprior50 {
        #[doc = "Register `IPRIOR50` reader"]
        pub type R = crate::R<Iprior50Spec>;
        #[doc = "Register `IPRIOR50` writer"]
        pub type W = crate::W<Iprior50Spec>;
        #[doc = "Field `IPRIOR50` reader - RW,Interrupt priority for number 200-203"]
        pub type Iprior50R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR50` writer - RW,Interrupt priority for number 200-203"]
        pub type Iprior50W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 200-203"]
            #[inline(always)]
            pub fn iprior50(&self) -> Iprior50R {
                Iprior50R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 200-203"]
            #[inline(always)]
            pub fn iprior50(&mut self) -> Iprior50W<Iprior50Spec> {
                Iprior50W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 50\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior50::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior50::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior50Spec;
        impl crate::RegisterSpec for Iprior50Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior50::R`](R) reader structure"]
        impl crate::Readable for Iprior50Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior50::W`](W) writer structure"]
        impl crate::Writable for Iprior50Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR50 to value 0"]
        impl crate::Resettable for Iprior50Spec {}
    }
    #[doc = "IPRIOR51 (rw) register accessor: Interrupt Priority configuration Register 51\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior51::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior51::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior51`] module"]
    #[doc(alias = "IPRIOR51")]
    pub type Iprior51 = crate::Reg<iprior51::Iprior51Spec>;
    #[doc = "Interrupt Priority configuration Register 51"]
    pub mod iprior51 {
        #[doc = "Register `IPRIOR51` reader"]
        pub type R = crate::R<Iprior51Spec>;
        #[doc = "Register `IPRIOR51` writer"]
        pub type W = crate::W<Iprior51Spec>;
        #[doc = "Field `IPRIOR51` reader - RW,Interrupt priority for number 204-207"]
        pub type Iprior51R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR51` writer - RW,Interrupt priority for number 204-207"]
        pub type Iprior51W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 204-207"]
            #[inline(always)]
            pub fn iprior51(&self) -> Iprior51R {
                Iprior51R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 204-207"]
            #[inline(always)]
            pub fn iprior51(&mut self) -> Iprior51W<Iprior51Spec> {
                Iprior51W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 51\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior51::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior51::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior51Spec;
        impl crate::RegisterSpec for Iprior51Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior51::R`](R) reader structure"]
        impl crate::Readable for Iprior51Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior51::W`](W) writer structure"]
        impl crate::Writable for Iprior51Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR51 to value 0"]
        impl crate::Resettable for Iprior51Spec {}
    }
    #[doc = "IPRIOR52 (rw) register accessor: Interrupt Priority configuration Register 52\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior52::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior52::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior52`] module"]
    #[doc(alias = "IPRIOR52")]
    pub type Iprior52 = crate::Reg<iprior52::Iprior52Spec>;
    #[doc = "Interrupt Priority configuration Register 52"]
    pub mod iprior52 {
        #[doc = "Register `IPRIOR52` reader"]
        pub type R = crate::R<Iprior52Spec>;
        #[doc = "Register `IPRIOR52` writer"]
        pub type W = crate::W<Iprior52Spec>;
        #[doc = "Field `IPRIOR52` reader - RW,Interrupt priority for number 208-211"]
        pub type Iprior52R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR52` writer - RW,Interrupt priority for number 208-211"]
        pub type Iprior52W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 208-211"]
            #[inline(always)]
            pub fn iprior52(&self) -> Iprior52R {
                Iprior52R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 208-211"]
            #[inline(always)]
            pub fn iprior52(&mut self) -> Iprior52W<Iprior52Spec> {
                Iprior52W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 52\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior52::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior52::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior52Spec;
        impl crate::RegisterSpec for Iprior52Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior52::R`](R) reader structure"]
        impl crate::Readable for Iprior52Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior52::W`](W) writer structure"]
        impl crate::Writable for Iprior52Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR52 to value 0"]
        impl crate::Resettable for Iprior52Spec {}
    }
    #[doc = "IPRIOR53 (rw) register accessor: Interrupt Priority configuration Register 53\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior53::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior53::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior53`] module"]
    #[doc(alias = "IPRIOR53")]
    pub type Iprior53 = crate::Reg<iprior53::Iprior53Spec>;
    #[doc = "Interrupt Priority configuration Register 53"]
    pub mod iprior53 {
        #[doc = "Register `IPRIOR53` reader"]
        pub type R = crate::R<Iprior53Spec>;
        #[doc = "Register `IPRIOR53` writer"]
        pub type W = crate::W<Iprior53Spec>;
        #[doc = "Field `IPRIOR53` reader - RW,Interrupt priority for number 212-215"]
        pub type Iprior53R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR53` writer - RW,Interrupt priority for number 212-215"]
        pub type Iprior53W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 212-215"]
            #[inline(always)]
            pub fn iprior53(&self) -> Iprior53R {
                Iprior53R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 212-215"]
            #[inline(always)]
            pub fn iprior53(&mut self) -> Iprior53W<Iprior53Spec> {
                Iprior53W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 53\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior53::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior53::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior53Spec;
        impl crate::RegisterSpec for Iprior53Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior53::R`](R) reader structure"]
        impl crate::Readable for Iprior53Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior53::W`](W) writer structure"]
        impl crate::Writable for Iprior53Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR53 to value 0"]
        impl crate::Resettable for Iprior53Spec {}
    }
    #[doc = "IPRIOR54 (rw) register accessor: Interrupt Priority configuration Register 54\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior54::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior54::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior54`] module"]
    #[doc(alias = "IPRIOR54")]
    pub type Iprior54 = crate::Reg<iprior54::Iprior54Spec>;
    #[doc = "Interrupt Priority configuration Register 54"]
    pub mod iprior54 {
        #[doc = "Register `IPRIOR54` reader"]
        pub type R = crate::R<Iprior54Spec>;
        #[doc = "Register `IPRIOR54` writer"]
        pub type W = crate::W<Iprior54Spec>;
        #[doc = "Field `IPRIOR54` reader - RW,Interrupt priority for number 216-219"]
        pub type Iprior54R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR54` writer - RW,Interrupt priority for number 216-219"]
        pub type Iprior54W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 216-219"]
            #[inline(always)]
            pub fn iprior54(&self) -> Iprior54R {
                Iprior54R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 216-219"]
            #[inline(always)]
            pub fn iprior54(&mut self) -> Iprior54W<Iprior54Spec> {
                Iprior54W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 54\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior54::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior54::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior54Spec;
        impl crate::RegisterSpec for Iprior54Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior54::R`](R) reader structure"]
        impl crate::Readable for Iprior54Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior54::W`](W) writer structure"]
        impl crate::Writable for Iprior54Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR54 to value 0"]
        impl crate::Resettable for Iprior54Spec {}
    }
    #[doc = "IPRIOR55 (rw) register accessor: Interrupt Priority configuration Register 55\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior55::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior55::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior55`] module"]
    #[doc(alias = "IPRIOR55")]
    pub type Iprior55 = crate::Reg<iprior55::Iprior55Spec>;
    #[doc = "Interrupt Priority configuration Register 55"]
    pub mod iprior55 {
        #[doc = "Register `IPRIOR55` reader"]
        pub type R = crate::R<Iprior55Spec>;
        #[doc = "Register `IPRIOR55` writer"]
        pub type W = crate::W<Iprior55Spec>;
        #[doc = "Field `IPRIOR55` reader - RW,Interrupt priority for number 220-223"]
        pub type Iprior55R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR55` writer - RW,Interrupt priority for number 220-223"]
        pub type Iprior55W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 220-223"]
            #[inline(always)]
            pub fn iprior55(&self) -> Iprior55R {
                Iprior55R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 220-223"]
            #[inline(always)]
            pub fn iprior55(&mut self) -> Iprior55W<Iprior55Spec> {
                Iprior55W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 55\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior55::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior55::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior55Spec;
        impl crate::RegisterSpec for Iprior55Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior55::R`](R) reader structure"]
        impl crate::Readable for Iprior55Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior55::W`](W) writer structure"]
        impl crate::Writable for Iprior55Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR55 to value 0"]
        impl crate::Resettable for Iprior55Spec {}
    }
    #[doc = "IPRIOR56 (rw) register accessor: Interrupt Priority configuration Register 56\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior56::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior56::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior56`] module"]
    #[doc(alias = "IPRIOR56")]
    pub type Iprior56 = crate::Reg<iprior56::Iprior56Spec>;
    #[doc = "Interrupt Priority configuration Register 56"]
    pub mod iprior56 {
        #[doc = "Register `IPRIOR56` reader"]
        pub type R = crate::R<Iprior56Spec>;
        #[doc = "Register `IPRIOR56` writer"]
        pub type W = crate::W<Iprior56Spec>;
        #[doc = "Field `IPRIOR56` reader - RW,Interrupt priority for number 224-227"]
        pub type Iprior56R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR56` writer - RW,Interrupt priority for number 224-227"]
        pub type Iprior56W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 224-227"]
            #[inline(always)]
            pub fn iprior56(&self) -> Iprior56R {
                Iprior56R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 224-227"]
            #[inline(always)]
            pub fn iprior56(&mut self) -> Iprior56W<Iprior56Spec> {
                Iprior56W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 56\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior56::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior56::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior56Spec;
        impl crate::RegisterSpec for Iprior56Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior56::R`](R) reader structure"]
        impl crate::Readable for Iprior56Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior56::W`](W) writer structure"]
        impl crate::Writable for Iprior56Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR56 to value 0"]
        impl crate::Resettable for Iprior56Spec {}
    }
    #[doc = "IPRIOR57 (rw) register accessor: Interrupt Priority configuration Register 57\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior57::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior57::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior57`] module"]
    #[doc(alias = "IPRIOR57")]
    pub type Iprior57 = crate::Reg<iprior57::Iprior57Spec>;
    #[doc = "Interrupt Priority configuration Register 57"]
    pub mod iprior57 {
        #[doc = "Register `IPRIOR57` reader"]
        pub type R = crate::R<Iprior57Spec>;
        #[doc = "Register `IPRIOR57` writer"]
        pub type W = crate::W<Iprior57Spec>;
        #[doc = "Field `IPRIOR57` reader - RW,Interrupt priority for number 228-231"]
        pub type Iprior57R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR57` writer - RW,Interrupt priority for number 228-231"]
        pub type Iprior57W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 228-231"]
            #[inline(always)]
            pub fn iprior57(&self) -> Iprior57R {
                Iprior57R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 228-231"]
            #[inline(always)]
            pub fn iprior57(&mut self) -> Iprior57W<Iprior57Spec> {
                Iprior57W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 57\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior57::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior57::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior57Spec;
        impl crate::RegisterSpec for Iprior57Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior57::R`](R) reader structure"]
        impl crate::Readable for Iprior57Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior57::W`](W) writer structure"]
        impl crate::Writable for Iprior57Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR57 to value 0"]
        impl crate::Resettable for Iprior57Spec {}
    }
    #[doc = "IPRIOR58 (rw) register accessor: Interrupt Priority configuration Register 58\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior58::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior58::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior58`] module"]
    #[doc(alias = "IPRIOR58")]
    pub type Iprior58 = crate::Reg<iprior58::Iprior58Spec>;
    #[doc = "Interrupt Priority configuration Register 58"]
    pub mod iprior58 {
        #[doc = "Register `IPRIOR58` reader"]
        pub type R = crate::R<Iprior58Spec>;
        #[doc = "Register `IPRIOR58` writer"]
        pub type W = crate::W<Iprior58Spec>;
        #[doc = "Field `IPRIOR58` reader - RW,Interrupt priority for number 232-235"]
        pub type Iprior58R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR58` writer - RW,Interrupt priority for number 232-235"]
        pub type Iprior58W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 232-235"]
            #[inline(always)]
            pub fn iprior58(&self) -> Iprior58R {
                Iprior58R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 232-235"]
            #[inline(always)]
            pub fn iprior58(&mut self) -> Iprior58W<Iprior58Spec> {
                Iprior58W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 58\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior58::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior58::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior58Spec;
        impl crate::RegisterSpec for Iprior58Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior58::R`](R) reader structure"]
        impl crate::Readable for Iprior58Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior58::W`](W) writer structure"]
        impl crate::Writable for Iprior58Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR58 to value 0"]
        impl crate::Resettable for Iprior58Spec {}
    }
    #[doc = "IPRIOR59 (rw) register accessor: Interrupt Priority configuration Register 59\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior59::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior59::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior59`] module"]
    #[doc(alias = "IPRIOR59")]
    pub type Iprior59 = crate::Reg<iprior59::Iprior59Spec>;
    #[doc = "Interrupt Priority configuration Register 59"]
    pub mod iprior59 {
        #[doc = "Register `IPRIOR59` reader"]
        pub type R = crate::R<Iprior59Spec>;
        #[doc = "Register `IPRIOR59` writer"]
        pub type W = crate::W<Iprior59Spec>;
        #[doc = "Field `IPRIOR59` reader - RW,Interrupt priority for number 236-239"]
        pub type Iprior59R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR59` writer - RW,Interrupt priority for number 236-239"]
        pub type Iprior59W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 236-239"]
            #[inline(always)]
            pub fn iprior59(&self) -> Iprior59R {
                Iprior59R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 236-239"]
            #[inline(always)]
            pub fn iprior59(&mut self) -> Iprior59W<Iprior59Spec> {
                Iprior59W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 59\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior59::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior59::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior59Spec;
        impl crate::RegisterSpec for Iprior59Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior59::R`](R) reader structure"]
        impl crate::Readable for Iprior59Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior59::W`](W) writer structure"]
        impl crate::Writable for Iprior59Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR59 to value 0"]
        impl crate::Resettable for Iprior59Spec {}
    }
    #[doc = "IPRIOR60 (rw) register accessor: Interrupt Priority configuration Register 60\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior60::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior60::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior60`] module"]
    #[doc(alias = "IPRIOR60")]
    pub type Iprior60 = crate::Reg<iprior60::Iprior60Spec>;
    #[doc = "Interrupt Priority configuration Register 60"]
    pub mod iprior60 {
        #[doc = "Register `IPRIOR60` reader"]
        pub type R = crate::R<Iprior60Spec>;
        #[doc = "Register `IPRIOR60` writer"]
        pub type W = crate::W<Iprior60Spec>;
        #[doc = "Field `IPRIOR60` reader - RW,Interrupt priority for number 240-243"]
        pub type Iprior60R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR60` writer - RW,Interrupt priority for number 240-243"]
        pub type Iprior60W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 240-243"]
            #[inline(always)]
            pub fn iprior60(&self) -> Iprior60R {
                Iprior60R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 240-243"]
            #[inline(always)]
            pub fn iprior60(&mut self) -> Iprior60W<Iprior60Spec> {
                Iprior60W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 60\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior60::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior60::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior60Spec;
        impl crate::RegisterSpec for Iprior60Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior60::R`](R) reader structure"]
        impl crate::Readable for Iprior60Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior60::W`](W) writer structure"]
        impl crate::Writable for Iprior60Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR60 to value 0"]
        impl crate::Resettable for Iprior60Spec {}
    }
    #[doc = "IPRIOR61 (rw) register accessor: Interrupt Priority configuration Register 61\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior61::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior61::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior61`] module"]
    #[doc(alias = "IPRIOR61")]
    pub type Iprior61 = crate::Reg<iprior61::Iprior61Spec>;
    #[doc = "Interrupt Priority configuration Register 61"]
    pub mod iprior61 {
        #[doc = "Register `IPRIOR61` reader"]
        pub type R = crate::R<Iprior61Spec>;
        #[doc = "Register `IPRIOR61` writer"]
        pub type W = crate::W<Iprior61Spec>;
        #[doc = "Field `IPRIOR61` reader - RW,Interrupt priority for number 244-247"]
        pub type Iprior61R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR61` writer - RW,Interrupt priority for number 244-247"]
        pub type Iprior61W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 244-247"]
            #[inline(always)]
            pub fn iprior61(&self) -> Iprior61R {
                Iprior61R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 244-247"]
            #[inline(always)]
            pub fn iprior61(&mut self) -> Iprior61W<Iprior61Spec> {
                Iprior61W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 61\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior61::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior61::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior61Spec;
        impl crate::RegisterSpec for Iprior61Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior61::R`](R) reader structure"]
        impl crate::Readable for Iprior61Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior61::W`](W) writer structure"]
        impl crate::Writable for Iprior61Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR61 to value 0"]
        impl crate::Resettable for Iprior61Spec {}
    }
    #[doc = "IPRIOR62 (rw) register accessor: Interrupt Priority configuration Register 62\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior62::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior62::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior62`] module"]
    #[doc(alias = "IPRIOR62")]
    pub type Iprior62 = crate::Reg<iprior62::Iprior62Spec>;
    #[doc = "Interrupt Priority configuration Register 62"]
    pub mod iprior62 {
        #[doc = "Register `IPRIOR62` reader"]
        pub type R = crate::R<Iprior62Spec>;
        #[doc = "Register `IPRIOR62` writer"]
        pub type W = crate::W<Iprior62Spec>;
        #[doc = "Field `IPRIOR62` reader - RW,Interrupt priority for number 248-251"]
        pub type Iprior62R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR62` writer - RW,Interrupt priority for number 248-251"]
        pub type Iprior62W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 248-251"]
            #[inline(always)]
            pub fn iprior62(&self) -> Iprior62R {
                Iprior62R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 248-251"]
            #[inline(always)]
            pub fn iprior62(&mut self) -> Iprior62W<Iprior62Spec> {
                Iprior62W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 62\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior62::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior62::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior62Spec;
        impl crate::RegisterSpec for Iprior62Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior62::R`](R) reader structure"]
        impl crate::Readable for Iprior62Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior62::W`](W) writer structure"]
        impl crate::Writable for Iprior62Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR62 to value 0"]
        impl crate::Resettable for Iprior62Spec {}
    }
    #[doc = "IPRIOR63 (rw) register accessor: Interrupt Priority configuration Register 63\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior63::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior63::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior63`] module"]
    #[doc(alias = "IPRIOR63")]
    pub type Iprior63 = crate::Reg<iprior63::Iprior63Spec>;
    #[doc = "Interrupt Priority configuration Register 63"]
    pub mod iprior63 {
        #[doc = "Register `IPRIOR63` reader"]
        pub type R = crate::R<Iprior63Spec>;
        #[doc = "Register `IPRIOR63` writer"]
        pub type W = crate::W<Iprior63Spec>;
        #[doc = "Field `IPRIOR63` reader - RW,Interrupt priority for number 252-255"]
        pub type Iprior63R = crate::FieldReader<u32>;
        #[doc = "Field `IPRIOR63` writer - RW,Interrupt priority for number 252-255"]
        pub type Iprior63W<'a, REG> = crate::FieldWriter<'a, REG, 32, u32>;
        impl R {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 252-255"]
            #[inline(always)]
            pub fn iprior63(&self) -> Iprior63R {
                Iprior63R::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:31 - RW,Interrupt priority for number 252-255"]
            #[inline(always)]
            pub fn iprior63(&mut self) -> Iprior63W<Iprior63Spec> {
                Iprior63W::new(self, 0)
            }
        }
        #[doc = "Interrupt Priority configuration Register 63\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior63::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior63::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct Iprior63Spec;
        impl crate::RegisterSpec for Iprior63Spec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`iprior63::R`](R) reader structure"]
        impl crate::Readable for Iprior63Spec {}
        #[doc = "`write(|w| ..)` method takes [`iprior63::W`](W) writer structure"]
        impl crate::Writable for Iprior63Spec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets IPRIOR63 to value 0"]
        impl crate::Resettable for Iprior63Spec {}
    }
    #[doc = "SCTLR (rw) register accessor: System Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`sctlr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sctlr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sctlr`] module"]
    #[doc(alias = "SCTLR")]
    pub type Sctlr = crate::Reg<sctlr::SctlrSpec>;
    #[doc = "System Control Register"]
    pub mod sctlr {
        #[doc = "Register `SCTLR` reader"]
        pub type R = crate::R<SctlrSpec>;
        #[doc = "Register `SCTLR` writer"]
        pub type W = crate::W<SctlrSpec>;
        #[doc = "Field `SLEEPONEXIT` reader - RW,SLEEPONEXIT"]
        pub type SleeponexitR = crate::BitReader;
        #[doc = "Field `SLEEPONEXIT` writer - RW,SLEEPONEXIT"]
        pub type SleeponexitW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SLEEPDEEP` reader - RW,SLEEPDEEP"]
        pub type SleepdeepR = crate::BitReader;
        #[doc = "Field `SLEEPDEEP` writer - RW,SLEEPDEEP"]
        pub type SleepdeepW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `WFITOWFE` reader - RW,WFITOWFE"]
        pub type WfitowfeR = crate::BitReader;
        #[doc = "Field `WFITOWFE` writer - RW,WFITOWFE"]
        pub type WfitowfeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SEVONPEND` reader - RW,SEVONPEND"]
        pub type SevonpendR = crate::BitReader;
        #[doc = "Field `SEVONPEND` writer - RW,SEVONPEND"]
        pub type SevonpendW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SETEVENT` reader - WO,SETEVENT"]
        pub type SeteventR = crate::BitReader;
        #[doc = "Field `SETEVENT` writer - WO,SETEVENT"]
        pub type SeteventW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 1 - RW,SLEEPONEXIT"]
            #[inline(always)]
            pub fn sleeponexit(&self) -> SleeponexitR {
                SleeponexitR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - RW,SLEEPDEEP"]
            #[inline(always)]
            pub fn sleepdeep(&self) -> SleepdeepR {
                SleepdeepR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - RW,WFITOWFE"]
            #[inline(always)]
            pub fn wfitowfe(&self) -> WfitowfeR {
                WfitowfeR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - RW,SEVONPEND"]
            #[inline(always)]
            pub fn sevonpend(&self) -> SevonpendR {
                SevonpendR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - WO,SETEVENT"]
            #[inline(always)]
            pub fn setevent(&self) -> SeteventR {
                SeteventR::new(((self.bits >> 5) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 1 - RW,SLEEPONEXIT"]
            #[inline(always)]
            pub fn sleeponexit(&mut self) -> SleeponexitW<SctlrSpec> {
                SleeponexitW::new(self, 1)
            }
            #[doc = "Bit 2 - RW,SLEEPDEEP"]
            #[inline(always)]
            pub fn sleepdeep(&mut self) -> SleepdeepW<SctlrSpec> {
                SleepdeepW::new(self, 2)
            }
            #[doc = "Bit 3 - RW,WFITOWFE"]
            #[inline(always)]
            pub fn wfitowfe(&mut self) -> WfitowfeW<SctlrSpec> {
                WfitowfeW::new(self, 3)
            }
            #[doc = "Bit 4 - RW,SEVONPEND"]
            #[inline(always)]
            pub fn sevonpend(&mut self) -> SevonpendW<SctlrSpec> {
                SevonpendW::new(self, 4)
            }
            #[doc = "Bit 5 - WO,SETEVENT"]
            #[inline(always)]
            pub fn setevent(&mut self) -> SeteventW<SctlrSpec> {
                SeteventW::new(self, 5)
            }
        }
        #[doc = "System Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`sctlr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sctlr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SctlrSpec;
        impl crate::RegisterSpec for SctlrSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`sctlr::R`](R) reader structure"]
        impl crate::Readable for SctlrSpec {}
        #[doc = "`write(|w| ..)` method takes [`sctlr::W`](W) writer structure"]
        impl crate::Writable for SctlrSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets SCTLR to value 0"]
        impl crate::Resettable for SctlrSpec {}
    }
}
#[doc = "Systick register"]
pub type Systick = crate::Periph<systick::RegisterBlock, 0xe000_f000>;
impl core::fmt::Debug for Systick {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Systick").finish()
    }
}
#[doc = "Systick register"]
pub mod systick {
    #[repr(C)]
    #[doc = "Register block"]
    pub struct RegisterBlock {
        ctl: Ctl,
        s: S,
        cnt: Cnt,
        cmp: Cmp,
    }
    impl RegisterBlock {
        #[doc = "0x00 - Systick counter control register"]
        #[inline(always)]
        pub const fn ctl(&self) -> &Ctl {
            &self.ctl
        }
        #[doc = "0x04 - Systick count status register"]
        #[inline(always)]
        pub const fn s(&self) -> &S {
            &self.s
        }
        #[doc = "0x08..0x10 - Systick counter register"]
        #[inline(always)]
        pub const fn cnt(&self) -> &Cnt {
            &self.cnt
        }
        #[doc = "0x10..0x18 - Systick compare register"]
        #[inline(always)]
        pub const fn cmp(&self) -> &Cmp {
            &self.cmp
        }
    }
    #[doc = "CTL (rw) register accessor: Systick counter control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctl`] module"]
    #[doc(alias = "CTL")]
    pub type Ctl = crate::Reg<ctl::CtlSpec>;
    #[doc = "Systick counter control register"]
    pub mod ctl {
        #[doc = "Register `CTL` reader"]
        pub type R = crate::R<CtlSpec>;
        #[doc = "Register `CTL` writer"]
        pub type W = crate::W<CtlSpec>;
        #[doc = "Field `STE` reader - Systick counter enable"]
        pub type SteR = crate::BitReader;
        #[doc = "Field `STE` writer - Systick counter enable"]
        pub type SteW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `STIE` reader - Systick counter interrupt enable"]
        pub type StieR = crate::BitReader;
        #[doc = "Field `STIE` writer - Systick counter interrupt enable"]
        pub type StieW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `STCLK` reader - System counter clock Source selection"]
        pub type StclkR = crate::BitReader;
        #[doc = "Field `STCLK` writer - System counter clock Source selection"]
        pub type StclkW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `STRE` reader - System counter reload control"]
        pub type StreR = crate::BitReader;
        #[doc = "Field `STRE` writer - System counter reload control"]
        pub type StreW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `MODE` reader - counter mode"]
        pub type ModeR = crate::BitReader;
        #[doc = "Field `MODE` writer - counter mode"]
        pub type ModeW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `INIT` reader - Initial counter value updated"]
        pub type InitR = crate::BitReader;
        #[doc = "Field `INIT` writer - Initial counter value updated"]
        pub type InitW<'a, REG> = crate::BitWriter<'a, REG>;
        #[doc = "Field `SWIE` reader - RW0,System soft interrupt enable"]
        pub type SwieR = crate::BitReader;
        #[doc = "Field `SWIE` writer - RW0,System soft interrupt enable"]
        pub type SwieW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - Systick counter enable"]
            #[inline(always)]
            pub fn ste(&self) -> SteR {
                SteR::new((self.bits & 1) != 0)
            }
            #[doc = "Bit 1 - Systick counter interrupt enable"]
            #[inline(always)]
            pub fn stie(&self) -> StieR {
                StieR::new(((self.bits >> 1) & 1) != 0)
            }
            #[doc = "Bit 2 - System counter clock Source selection"]
            #[inline(always)]
            pub fn stclk(&self) -> StclkR {
                StclkR::new(((self.bits >> 2) & 1) != 0)
            }
            #[doc = "Bit 3 - System counter reload control"]
            #[inline(always)]
            pub fn stre(&self) -> StreR {
                StreR::new(((self.bits >> 3) & 1) != 0)
            }
            #[doc = "Bit 4 - counter mode"]
            #[inline(always)]
            pub fn mode(&self) -> ModeR {
                ModeR::new(((self.bits >> 4) & 1) != 0)
            }
            #[doc = "Bit 5 - Initial counter value updated"]
            #[inline(always)]
            pub fn init(&self) -> InitR {
                InitR::new(((self.bits >> 5) & 1) != 0)
            }
            #[doc = "Bit 31 - RW0,System soft interrupt enable"]
            #[inline(always)]
            pub fn swie(&self) -> SwieR {
                SwieR::new(((self.bits >> 31) & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - Systick counter enable"]
            #[inline(always)]
            pub fn ste(&mut self) -> SteW<CtlSpec> {
                SteW::new(self, 0)
            }
            #[doc = "Bit 1 - Systick counter interrupt enable"]
            #[inline(always)]
            pub fn stie(&mut self) -> StieW<CtlSpec> {
                StieW::new(self, 1)
            }
            #[doc = "Bit 2 - System counter clock Source selection"]
            #[inline(always)]
            pub fn stclk(&mut self) -> StclkW<CtlSpec> {
                StclkW::new(self, 2)
            }
            #[doc = "Bit 3 - System counter reload control"]
            #[inline(always)]
            pub fn stre(&mut self) -> StreW<CtlSpec> {
                StreW::new(self, 3)
            }
            #[doc = "Bit 4 - counter mode"]
            #[inline(always)]
            pub fn mode(&mut self) -> ModeW<CtlSpec> {
                ModeW::new(self, 4)
            }
            #[doc = "Bit 5 - Initial counter value updated"]
            #[inline(always)]
            pub fn init(&mut self) -> InitW<CtlSpec> {
                InitW::new(self, 5)
            }
            #[doc = "Bit 31 - RW0,System soft interrupt enable"]
            #[inline(always)]
            pub fn swie(&mut self) -> SwieW<CtlSpec> {
                SwieW::new(self, 31)
            }
        }
        #[doc = "Systick counter control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CtlSpec;
        impl crate::RegisterSpec for CtlSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`ctl::R`](R) reader structure"]
        impl crate::Readable for CtlSpec {}
        #[doc = "`write(|w| ..)` method takes [`ctl::W`](W) writer structure"]
        impl crate::Writable for CtlSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CTL to value 0"]
        impl crate::Resettable for CtlSpec {}
    }
    #[doc = "S (rw) register accessor: Systick count status register\n\nYou can [`read`](crate::Reg::read) this register and get [`s::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`s::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@s`] module"]
    pub type S = crate::Reg<s::SSpec>;
    #[doc = "Systick count status register"]
    pub mod s {
        #[doc = "Register `S` reader"]
        pub type R = crate::R<SSpec>;
        #[doc = "Register `S` writer"]
        pub type W = crate::W<SSpec>;
        #[doc = "Field `CNTIF` reader - RW,CNTIF"]
        pub type CntifR = crate::BitReader;
        #[doc = "Field `CNTIF` writer - RW,CNTIF"]
        pub type CntifW<'a, REG> = crate::BitWriter<'a, REG>;
        impl R {
            #[doc = "Bit 0 - RW,CNTIF"]
            #[inline(always)]
            pub fn cntif(&self) -> CntifR {
                CntifR::new((self.bits & 1) != 0)
            }
        }
        impl W {
            #[doc = "Bit 0 - RW,CNTIF"]
            #[inline(always)]
            pub fn cntif(&mut self) -> CntifW<SSpec> {
                CntifW::new(self, 0)
            }
        }
        #[doc = "Systick count status register\n\nYou can [`read`](crate::Reg::read) this register and get [`s::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`s::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct SSpec;
        impl crate::RegisterSpec for SSpec {
            type Ux = u32;
        }
        #[doc = "`read()` method returns [`s::R`](R) reader structure"]
        impl crate::Readable for SSpec {}
        #[doc = "`write(|w| ..)` method takes [`s::W`](W) writer structure"]
        impl crate::Writable for SSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets S to value 0"]
        impl crate::Resettable for SSpec {}
    }
    #[doc = "CNT (rw) register accessor: Systick counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt`] module"]
    #[doc(alias = "CNT")]
    pub type Cnt = crate::Reg<cnt::CntSpec>;
    #[doc = "Systick counter register"]
    pub mod cnt {
        #[doc = "Register `CNT` reader"]
        pub type R = crate::R<CntSpec>;
        #[doc = "Register `CNT` writer"]
        pub type W = crate::W<CntSpec>;
        #[doc = "Field `CNT` reader - RW,CNT"]
        pub type CntR = crate::FieldReader<u64>;
        #[doc = "Field `CNT` writer - RW,CNT"]
        pub type CntW<'a, REG> = crate::FieldWriter<'a, REG, 64, u64>;
        impl R {
            #[doc = "Bits 0:63 - RW,CNT"]
            #[inline(always)]
            pub fn cnt(&self) -> CntR {
                CntR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:63 - RW,CNT"]
            #[inline(always)]
            pub fn cnt(&mut self) -> CntW<CntSpec> {
                CntW::new(self, 0)
            }
        }
        #[doc = "Systick counter register\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CntSpec;
        impl crate::RegisterSpec for CntSpec {
            type Ux = u64;
        }
        #[doc = "`read()` method returns [`cnt::R`](R) reader structure"]
        impl crate::Readable for CntSpec {}
        #[doc = "`write(|w| ..)` method takes [`cnt::W`](W) writer structure"]
        impl crate::Writable for CntSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CNT to value 0"]
        impl crate::Resettable for CntSpec {}
    }
    #[doc = "CMP (rw) register accessor: Systick compare register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmp::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmp::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmp`] module"]
    #[doc(alias = "CMP")]
    pub type Cmp = crate::Reg<cmp::CmpSpec>;
    #[doc = "Systick compare register"]
    pub mod cmp {
        #[doc = "Register `CMP` reader"]
        pub type R = crate::R<CmpSpec>;
        #[doc = "Register `CMP` writer"]
        pub type W = crate::W<CmpSpec>;
        #[doc = "Field `CMP` reader - RW,CMP"]
        pub type CmpR = crate::FieldReader<u64>;
        #[doc = "Field `CMP` writer - RW,CMP"]
        pub type CmpW<'a, REG> = crate::FieldWriter<'a, REG, 64, u64>;
        impl R {
            #[doc = "Bits 0:63 - RW,CMP"]
            #[inline(always)]
            pub fn cmp(&self) -> CmpR {
                CmpR::new(self.bits)
            }
        }
        impl W {
            #[doc = "Bits 0:63 - RW,CMP"]
            #[inline(always)]
            pub fn cmp(&mut self) -> CmpW<CmpSpec> {
                CmpW::new(self, 0)
            }
        }
        #[doc = "Systick compare register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmp::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmp::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
        pub struct CmpSpec;
        impl crate::RegisterSpec for CmpSpec {
            type Ux = u64;
        }
        #[doc = "`read()` method returns [`cmp::R`](R) reader structure"]
        impl crate::Readable for CmpSpec {}
        #[doc = "`write(|w| ..)` method takes [`cmp::W`](W) writer structure"]
        impl crate::Writable for CmpSpec {
            type Safety = crate::Unsafe;
        }
        #[doc = "`reset()` method sets CMP to value 0"]
        impl crate::Resettable for CmpSpec {}
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "SYS"]
    pub sys: Sys,
    #[doc = "ADC"]
    pub adc: Adc,
    #[doc = "GPIOA"]
    pub gpioa: Gpioa,
    #[doc = "GPIOB"]
    pub gpiob: Gpiob,
    #[doc = "TMR0"]
    pub tmr0: Tmr0,
    #[doc = "TMR1"]
    pub tmr1: Tmr1,
    #[doc = "TMR2"]
    pub tmr2: Tmr2,
    #[doc = "TMR3"]
    pub tmr3: Tmr3,
    #[doc = "UART0"]
    pub uart0: Uart0,
    #[doc = "UART1"]
    pub uart1: Uart1,
    #[doc = "UART2"]
    pub uart2: Uart2,
    #[doc = "UART3"]
    pub uart3: Uart3,
    #[doc = "SPI0"]
    pub spi0: Spi0,
    #[doc = "SPI1"]
    pub spi1: Spi1,
    #[doc = "I2C"]
    pub i2c: I2c,
    #[doc = "PWMx"]
    pub pwmx: Pwmx,
    #[doc = "USB"]
    pub usb: Usb,
    #[doc = "USB2"]
    pub usb2: Usb2,
    #[doc = "PFIC"]
    pub pfic: Pfic,
    #[doc = "Systick"]
    pub systick: Systick,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            sys: Sys::steal(),
            adc: Adc::steal(),
            gpioa: Gpioa::steal(),
            gpiob: Gpiob::steal(),
            tmr0: Tmr0::steal(),
            tmr1: Tmr1::steal(),
            tmr2: Tmr2::steal(),
            tmr3: Tmr3::steal(),
            uart0: Uart0::steal(),
            uart1: Uart1::steal(),
            uart2: Uart2::steal(),
            uart3: Uart3::steal(),
            spi0: Spi0::steal(),
            spi1: Spi1::steal(),
            i2c: I2c::steal(),
            pwmx: Pwmx::steal(),
            usb: Usb::steal(),
            usb2: Usb2::steal(),
            pfic: Pfic::steal(),
            systick: Systick::steal(),
        }
    }
}
