# ! [doc = "Peripheral access API for CH583SFR microcontrollers (generated using svd2rust v0.36.1 (untracked))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next] svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.36.1/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"] # ! [allow (non_camel_case_types)] # ! [allow (non_snake_case)] # ! [no_std] # ! [cfg_attr (docsrs , feature (doc_auto_cfg))]
#[doc = r"Number available in the NVIC for configuring priority"] pub const NVIC_PRIO_BITS : u8 = 2 ;
#[allow (unused_imports)] use generic :: * ;
#[doc = "Common register and bit access and modify traits"] pub mod generic ;
#[doc = r" Interrupt numbers, priority levels, and HART IDs."] pub mod interrupt {
#[doc = r" Core interrupts. These interrupts are handled by the core itself."]
#[riscv :: pac_enum (unsafe CoreInterruptNumber)]
#[derive (Debug , Clone , Copy , PartialEq , Eq)] pub enum CoreInterrupt {
#[doc = "2 - NonMaskable"] NonMaskable = 2 ,
#[doc = "3 - Exception"] Exception = 3 ,
#[doc = "5 - MachineEnvCall"] MachineEnvCall = 5 ,
#[doc = "8 - UserEnvCall"] UserEnvCall = 8 ,
#[doc = "9 - Breakpoint"] Breakpoint = 9 ,
#[doc = "12 - SysTick"] SysTick = 12 ,
#[doc = "14 - Software"] Software = 14 , } pub use riscv :: interrupt :: Exception ;
#[doc = r" Priority levels in the device"]
#[riscv :: pac_enum (unsafe PriorityNumber)]
#[derive (Debug , Clone , Copy , PartialEq , Eq)] pub enum Priority {
#[doc = "0 - P0"] P0 = 0 ,
#[doc = "16 - P1"] P1 = 16 ,
#[doc = "32 - P2"] P2 = 32 ,
#[doc = "48 - P3"] P3 = 48 ,
#[doc = "64 - P4"] P4 = 64 ,
#[doc = "80 - P5"] P5 = 80 ,
#[doc = "96 - P6"] P6 = 96 ,
#[doc = "112 - P7"] P7 = 112 ,
#[doc = "128 - P8"] P8 = 128 ,
#[doc = "144 - P9"] P9 = 144 ,
#[doc = "160 - P10"] P10 = 160 ,
#[doc = "176 - P11"] P11 = 176 ,
#[doc = "192 - P12"] P12 = 192 ,
#[doc = "208 - P13"] P13 = 208 ,
#[doc = "224 - P14"] P14 = 224 ,
#[doc = "240 - P15"] P15 = 240 , } pub use riscv :: { InterruptNumber , ExceptionNumber , PriorityNumber , HartIdNumber , interrupt :: { enable , disable , free , nested } } ; pub type Trap = riscv :: interrupt :: Trap < CoreInterrupt , Exception > ;
#[doc = r" Retrieves the cause of a trap in the current hart."]
#[doc = r""]
#[doc = r" If the raw cause is not a valid interrupt or exception for the target, it returns an error."]
#[inline] pub fn try_cause () -> riscv :: result :: Result < Trap > { riscv :: interrupt :: try_cause () }
#[doc = r" Retrieves the cause of a trap in the current hart (machine mode)."]
#[doc = r""]
#[doc = r" If the raw cause is not a valid interrupt or exception for the target, it panics."]
#[inline] pub fn cause () -> Trap { try_cause () . unwrap () }
#[doc = r" External interrupts. These interrupts are handled by the external peripherals."]
#[riscv :: pac_enum (unsafe ExternalInterruptNumber)]
#[derive (Debug , Clone , Copy , PartialEq , Eq)] pub enum ExternalInterrupt {
#[doc = "16 - TMR0_IRQHandler"] TMR0 = 16 ,
#[doc = "17 - GPIO_IRQHandler"] GPIOA = 17 ,
#[doc = "18 - GPIO_IRQHandler"] GPIOB = 18 ,
#[doc = "19 - SPI0_IRQHandler"] SPI0 = 19 ,
#[doc = "20 - BB_IRQHandler"] BLEB = 20 ,
#[doc = "21 - LLE_IRQHandler"] BLEL = 21 ,
#[doc = "22 - USB_IRQHandler"] USB = 22 ,
#[doc = "23 - USB2_IRQHandler"] USB2 = 23 ,
#[doc = "24 - TMR1_IRQHandler"] TMR1 = 24 ,
#[doc = "25 - TMR2_IRQHandler"] TMR2 = 25 ,
#[doc = "26 - UART0_IRQHandler"] UART0 = 26 ,
#[doc = "27 - UART1_IRQHandler"] UART1 = 27 ,
#[doc = "28 - RTC_IRQHandler"] RTC = 28 ,
#[doc = "29 - ADC_IRQHandler"] ADC = 29 ,
#[doc = "30 - I2C_IRQHandler"] I2C = 30 ,
#[doc = "31 - PPWMX_SPI1_IRQHandler"] PWMx = 31 ,
#[doc = "32 - TMR3_IRQHandler"] TMR3 = 32 ,
#[doc = "33 - UART1_IRQHandler"] UART2 = 33 ,
#[doc = "34 - UART3_IRQHandler"] UART3 = 34 ,
#[doc = "35 - WDT_IRQHandler"] WDOG_BAT = 35 , } }
#[doc = "System Control Register"] pub type SYS = crate :: Periph < sys :: RegisterBlock , 0x4000_1000 > ; impl core :: fmt :: Debug for SYS { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SYS") . finish () } }
#[doc = "System Control Register"] pub mod sys {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { _reserved0 : [u8 ; 0x08] , clk_sys_cfg : CLK_SYS_CFG , hfck_pwr_ctrl : HFCK_PWR_CTRL , _reserved2 : [u8 ; 0x01] , slp_clk_off0 : SLP_CLK_OFF0 , slp_clk_off1 : SLP_CLK_OFF1 , slp_wake_ctrl : SLP_WAKE_CTRL , slp_power_ctrl : SLP_POWER_CTRL , _reserved6 : [u8 ; 0x08] , pin_alternate : PIN_ALTERNATE , pin_analog_ie : PIN_ANALOG_IE , _reserved8 : [u8 ; 0x04] , power_plan : POWER_PLAN , aux_power_adj : AUX_POWER_ADJ , _reserved10 : [u8 ; 0x01] , bat_det_ctrl : BAT_DET_CTRL , bat_det_cfg : BAT_DET_CFG , bat_status : BAT_STATUS , _reserved13 : [u8 ; 0x05] , int32k_tune : INT32K_TUNE , xt32k_tune : XT32K_TUNE , ck32k_config : CK32K_CONFIG , rtc_flag_ctrl : RTC_FLAG_CTRL , rtc_mode_ctrl : RTC_MODE_CTRL , _reserved18 : [u8 ; 0x02] , rtc_trig : RTC_TRIG , rtc_cnt_32k : RTC_CNT_32K , rtc_cnt_2s : RTC_CNT_2S , rtc_cnt_day : RTC_CNT_DAY , safe_access_sig : SAFE_ACCESS_SIG , chip_id : CHIP_ID , safe_access_id : SAFE_ACCESS_ID , wdog_count : WDOG_COUNT , reset_status_r8_glob_rom_cfg : RESET_STATUS_R8_GLOB_ROM_CFG , glob_cfg_info : GLOB_CFG_INFO , rst_wdog_ctrl : RST_WDOG_CTRL , glob_reset_keep : GLOB_RESET_KEEP , _reserved30 : [u8 ; 0x03] , pll_config : PLL_CONFIG , _reserved31 : [u8 ; 0x02] , xt32m_tune : XT32M_TUNE , _reserved32 : [u8 ; 0x01] , osc_cal_cnt : OSC_CAL_CNT , osc_cal_ov_cnt : OSC_CAL_OV_CNT , osc_cal_ctrl : OSC_CAL_CTRL , tkey_count : TKEY_COUNT , _reserved36 : [u8 ; 0x01] , tkey_convert : TKEY_CONVERT , tkey_cfg : TKEY_CFG , } impl RegisterBlock {
#[doc = "0x08 - RWA, system clock configuration, SAM"]
#[inline (always)] pub const fn clk_sys_cfg (& self) -> & CLK_SYS_CFG { & self . clk_sys_cfg }
#[doc = "0x0a - RWA, high frequency clock module power control, SAM"]
#[inline (always)] pub const fn hfck_pwr_ctrl (& self) -> & HFCK_PWR_CTRL { & self . hfck_pwr_ctrl }
#[doc = "0x0c - RWA, sleep clock off control byte 0, SAM"]
#[inline (always)] pub const fn slp_clk_off0 (& self) -> & SLP_CLK_OFF0 { & self . slp_clk_off0 }
#[doc = "0x0d - RWA, sleep clock off control byte 1, SAM"]
#[inline (always)] pub const fn slp_clk_off1 (& self) -> & SLP_CLK_OFF1 { & self . slp_clk_off1 }
#[doc = "0x0e - RWA, wake control, SAM"]
#[inline (always)] pub const fn slp_wake_ctrl (& self) -> & SLP_WAKE_CTRL { & self . slp_wake_ctrl }
#[doc = "0x0f - RWA, peripherals power down control, SAM"]
#[inline (always)] pub const fn slp_power_ctrl (& self) -> & SLP_POWER_CTRL { & self . slp_power_ctrl }
#[doc = "0x18 - RW, function pin alternate configuration"]
#[inline (always)] pub const fn pin_alternate (& self) -> & PIN_ALTERNATE { & self . pin_alternate }
#[doc = "0x1a - RW, analog pin enable and digital input disable"]
#[inline (always)] pub const fn pin_analog_ie (& self) -> & PIN_ANALOG_IE { & self . pin_analog_ie }
#[doc = "0x20 - RWA, power plan before sleep instruction, SAM"]
#[inline (always)] pub const fn power_plan (& self) -> & POWER_PLAN { & self . power_plan }
#[doc = "0x22 - RWA, aux power adjust control, SAM"]
#[inline (always)] pub const fn aux_power_adj (& self) -> & AUX_POWER_ADJ { & self . aux_power_adj }
#[doc = "0x24 - RWA, battery voltage detector control, SAM"]
#[inline (always)] pub const fn bat_det_ctrl (& self) -> & BAT_DET_CTRL { & self . bat_det_ctrl }
#[doc = "0x25 - RWA, battery voltage detector configuration, SAM"]
#[inline (always)] pub const fn bat_det_cfg (& self) -> & BAT_DET_CFG { & self . bat_det_cfg }
#[doc = "0x26 - RO, battery status"]
#[inline (always)] pub const fn bat_status (& self) -> & BAT_STATUS { & self . bat_status }
#[doc = "0x2c - RWA, internal 32KHz oscillator tune control, SAM"]
#[inline (always)] pub const fn int32k_tune (& self) -> & INT32K_TUNE { & self . int32k_tune }
#[doc = "0x2e - RWA, external 32KHz oscillator tune control, SAM"]
#[inline (always)] pub const fn xt32k_tune (& self) -> & XT32K_TUNE { & self . xt32k_tune }
#[doc = "0x2f - RWA, 32KHz oscillator configure"]
#[inline (always)] pub const fn ck32k_config (& self) -> & CK32K_CONFIG { & self . ck32k_config }
#[doc = "0x30 - RW, RTC flag and clear control"]
#[inline (always)] pub const fn rtc_flag_ctrl (& self) -> & RTC_FLAG_CTRL { & self . rtc_flag_ctrl }
#[doc = "0x31 - RWA, RTC mode control, SAM"]
#[inline (always)] pub const fn rtc_mode_ctrl (& self) -> & RTC_MODE_CTRL { & self . rtc_mode_ctrl }
#[doc = "0x34 - RWA, RTC trigger value, SAM"]
#[inline (always)] pub const fn rtc_trig (& self) -> & RTC_TRIG { & self . rtc_trig }
#[doc = "0x38 - RO, RTC count based 32KHz"]
#[inline (always)] pub const fn rtc_cnt_32k (& self) -> & RTC_CNT_32K { & self . rtc_cnt_32k }
#[doc = "0x3a - RO, RTC count based 2 second"]
#[inline (always)] pub const fn rtc_cnt_2s (& self) -> & RTC_CNT_2S { & self . rtc_cnt_2s }
#[doc = "0x3c - RO, RTC count based one day, only low 14 bit"]
#[inline (always)] pub const fn rtc_cnt_day (& self) -> & RTC_CNT_DAY { & self . rtc_cnt_day }
#[doc = "0x40 - WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode"]
#[inline (always)] pub const fn safe_access_sig (& self) -> & SAFE_ACCESS_SIG { & self . safe_access_sig }
#[doc = "0x41 - RF, chip ID register, always is ID_CH58*"]
#[inline (always)] pub const fn chip_id (& self) -> & CHIP_ID { & self . chip_id }
#[doc = "0x42 - RF, safe accessing ID register, always 0x0C"]
#[inline (always)] pub const fn safe_access_id (& self) -> & SAFE_ACCESS_ID { & self . safe_access_id }
#[doc = "0x43 - RW, watch-dog count, count by clock frequency Fsys/131072"]
#[inline (always)] pub const fn wdog_count (& self) -> & WDOG_COUNT { & self . wdog_count }
#[doc = "0x44 - RWA, reset status, SAM or flash ROM configuration"]
#[inline (always)] pub const fn reset_status_r8_glob_rom_cfg (& self) -> & RESET_STATUS_R8_GLOB_ROM_CFG { & self . reset_status_r8_glob_rom_cfg }
#[doc = "0x45 - RO, global configuration information and status"]
#[inline (always)] pub const fn glob_cfg_info (& self) -> & GLOB_CFG_INFO { & self . glob_cfg_info }
#[doc = "0x46 - RWA, reset and watch-dog control, SAM"]
#[inline (always)] pub const fn rst_wdog_ctrl (& self) -> & RST_WDOG_CTRL { & self . rst_wdog_ctrl }
#[doc = "0x47 - RW, value keeper during global reset"]
#[inline (always)] pub const fn glob_reset_keep (& self) -> & GLOB_RESET_KEEP { & self . glob_reset_keep }
#[doc = "0x4b - RWA, PLL configuration control, SAM"]
#[inline (always)] pub const fn pll_config (& self) -> & PLL_CONFIG { & self . pll_config }
#[doc = "0x4e - RWA, external 32MHz oscillator tune control, SAM"]
#[inline (always)] pub const fn xt32m_tune (& self) -> & XT32M_TUNE { & self . xt32m_tune }
#[doc = "0x50 - RO, system clock count value for 32KHz multi-cycles"]
#[inline (always)] pub const fn osc_cal_cnt (& self) -> & OSC_CAL_CNT { & self . osc_cal_cnt }
#[doc = "0x52 - RO, oscillator frequency calibration overflow times"]
#[inline (always)] pub const fn osc_cal_ov_cnt (& self) -> & OSC_CAL_OV_CNT { & self . osc_cal_ov_cnt }
#[doc = "0x53 - RWA, oscillator frequency calibration control, SAM"]
#[inline (always)] pub const fn osc_cal_ctrl (& self) -> & OSC_CAL_CTRL { & self . osc_cal_ctrl }
#[doc = "0x54 - RW, Touchkey charge and discharge count"]
#[inline (always)] pub const fn tkey_count (& self) -> & TKEY_COUNT { & self . tkey_count }
#[doc = "0x56 - RW, Touchkey convert start control"]
#[inline (always)] pub const fn tkey_convert (& self) -> & TKEY_CONVERT { & self . tkey_convert }
#[doc = "0x57 - RW, Touchkey configure"]
#[inline (always)] pub const fn tkey_cfg (& self) -> & TKEY_CFG { & self . tkey_cfg } }
#[doc = "CLK_SYS_CFG (rw) register accessor: RWA, system clock configuration, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_sys_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_sys_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clk_sys_cfg`] module"] pub type CLK_SYS_CFG = crate :: Reg < clk_sys_cfg :: CLK_SYS_CFG_SPEC > ;
#[doc = "RWA, system clock configuration, SAM"] pub mod clk_sys_cfg {
#[doc = "Register `CLK_SYS_CFG` reader"] pub type R = crate :: R < CLK_SYS_CFG_SPEC > ;
#[doc = "Register `CLK_SYS_CFG` writer"] pub type W = crate :: W < CLK_SYS_CFG_SPEC > ;
#[doc = "Field `CLK_PLL_DIV` reader - RWA, output clock divider from PLL or CK32M"] pub type CLK_PLL_DIV_R = crate :: FieldReader ;
#[doc = "Field `CLK_PLL_DIV` writer - RWA, output clock divider from PLL or CK32M"] pub type CLK_PLL_DIV_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `CLK_SYS_MOD` reader - RWA, system clock source mode: 00=divided from 32MHz, 01=divided from PLL-480MHz, 10=directly from 32MHz, 11=directly from 32KHz"] pub type CLK_SYS_MOD_R = crate :: FieldReader ;
#[doc = "Field `CLK_SYS_MOD` writer - RWA, system clock source mode: 00=divided from 32MHz, 01=divided from PLL-480MHz, 10=directly from 32MHz, 11=directly from 32KHz"] pub type CLK_SYS_MOD_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:4 - RWA, output clock divider from PLL or CK32M"]
#[inline (always)] pub fn clk_pll_div (& self) -> CLK_PLL_DIV_R { CLK_PLL_DIV_R :: new ((self . bits & 0x1f) as u8) }
#[doc = "Bits 6:7 - RWA, system clock source mode: 00=divided from 32MHz, 01=divided from PLL-480MHz, 10=directly from 32MHz, 11=directly from 32KHz"]
#[inline (always)] pub fn clk_sys_mod (& self) -> CLK_SYS_MOD_R { CLK_SYS_MOD_R :: new (((self . bits >> 6) & 3) as u8) } } impl W {
#[doc = "Bits 0:4 - RWA, output clock divider from PLL or CK32M"]
#[inline (always)] pub fn clk_pll_div (& mut self) -> CLK_PLL_DIV_W < CLK_SYS_CFG_SPEC > { CLK_PLL_DIV_W :: new (self , 0) }
#[doc = "Bits 6:7 - RWA, system clock source mode: 00=divided from 32MHz, 01=divided from PLL-480MHz, 10=directly from 32MHz, 11=directly from 32KHz"]
#[inline (always)] pub fn clk_sys_mod (& mut self) -> CLK_SYS_MOD_W < CLK_SYS_CFG_SPEC > { CLK_SYS_MOD_W :: new (self , 6) } }
#[doc = "RWA, system clock configuration, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_sys_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_sys_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CLK_SYS_CFG_SPEC ; impl crate :: RegisterSpec for CLK_SYS_CFG_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`clk_sys_cfg::R`](R) reader structure"] impl crate :: Readable for CLK_SYS_CFG_SPEC { }
#[doc = "`write(|w| ..)` method takes [`clk_sys_cfg::W`](W) writer structure"] impl crate :: Writable for CLK_SYS_CFG_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CLK_SYS_CFG to value 0x05"] impl crate :: Resettable for CLK_SYS_CFG_SPEC { const RESET_VALUE : u16 = 0x05 ; } }
#[doc = "HFCK_PWR_CTRL (rw) register accessor: RWA, high frequency clock module power control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`hfck_pwr_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`hfck_pwr_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@hfck_pwr_ctrl`] module"] pub type HFCK_PWR_CTRL = crate :: Reg < hfck_pwr_ctrl :: HFCK_PWR_CTRL_SPEC > ;
#[doc = "RWA, high frequency clock module power control, SAM"] pub mod hfck_pwr_ctrl {
#[doc = "Register `HFCK_PWR_CTRL` reader"] pub type R = crate :: R < HFCK_PWR_CTRL_SPEC > ;
#[doc = "Register `HFCK_PWR_CTRL` writer"] pub type W = crate :: W < HFCK_PWR_CTRL_SPEC > ;
#[doc = "Field `CLK_XT32M_PON` reader - RWA, external 32MHz oscillator power control: 0=power down, 1-power on"] pub type CLK_XT32M_PON_R = crate :: BitReader ;
#[doc = "Field `CLK_XT32M_PON` writer - RWA, external 32MHz oscillator power control: 0=power down, 1-power on"] pub type CLK_XT32M_PON_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CLK_XT32M_KEEP` reader - RWA, external 32MHz oscillator power keep under halt mode: 0=auto stop, 1=keep running"] pub type CLK_XT32M_KEEP_R = crate :: BitReader ;
#[doc = "Field `CLK_XT32M_KEEP` writer - RWA, external 32MHz oscillator power keep under halt mode: 0=auto stop, 1=keep running"] pub type CLK_XT32M_KEEP_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CLK_PLL_PON` reader - RWA, PLL power control: 0=power down, 1-power on"] pub type CLK_PLL_PON_R = crate :: BitReader ;
#[doc = "Field `CLK_PLL_PON` writer - RWA, PLL power control: 0=power down, 1-power on"] pub type CLK_PLL_PON_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 2 - RWA, external 32MHz oscillator power control: 0=power down, 1-power on"]
#[inline (always)] pub fn clk_xt32m_pon (& self) -> CLK_XT32M_PON_R { CLK_XT32M_PON_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RWA, external 32MHz oscillator power keep under halt mode: 0=auto stop, 1=keep running"]
#[inline (always)] pub fn clk_xt32m_keep (& self) -> CLK_XT32M_KEEP_R { CLK_XT32M_KEEP_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RWA, PLL power control: 0=power down, 1-power on"]
#[inline (always)] pub fn clk_pll_pon (& self) -> CLK_PLL_PON_R { CLK_PLL_PON_R :: new (((self . bits >> 4) & 1) != 0) } } impl W {
#[doc = "Bit 2 - RWA, external 32MHz oscillator power control: 0=power down, 1-power on"]
#[inline (always)] pub fn clk_xt32m_pon (& mut self) -> CLK_XT32M_PON_W < HFCK_PWR_CTRL_SPEC > { CLK_XT32M_PON_W :: new (self , 2) }
#[doc = "Bit 3 - RWA, external 32MHz oscillator power keep under halt mode: 0=auto stop, 1=keep running"]
#[inline (always)] pub fn clk_xt32m_keep (& mut self) -> CLK_XT32M_KEEP_W < HFCK_PWR_CTRL_SPEC > { CLK_XT32M_KEEP_W :: new (self , 3) }
#[doc = "Bit 4 - RWA, PLL power control: 0=power down, 1-power on"]
#[inline (always)] pub fn clk_pll_pon (& mut self) -> CLK_PLL_PON_W < HFCK_PWR_CTRL_SPEC > { CLK_PLL_PON_W :: new (self , 4) } }
#[doc = "RWA, high frequency clock module power control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`hfck_pwr_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`hfck_pwr_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct HFCK_PWR_CTRL_SPEC ; impl crate :: RegisterSpec for HFCK_PWR_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`hfck_pwr_ctrl::R`](R) reader structure"] impl crate :: Readable for HFCK_PWR_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`hfck_pwr_ctrl::W`](W) writer structure"] impl crate :: Writable for HFCK_PWR_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets HFCK_PWR_CTRL to value 0x14"] impl crate :: Resettable for HFCK_PWR_CTRL_SPEC { const RESET_VALUE : u8 = 0x14 ; } }
#[doc = "SLP_CLK_OFF0 (rw) register accessor: RWA, sleep clock off control byte 0, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`slp_clk_off0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slp_clk_off0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@slp_clk_off0`] module"] pub type SLP_CLK_OFF0 = crate :: Reg < slp_clk_off0 :: SLP_CLK_OFF0_SPEC > ;
#[doc = "RWA, sleep clock off control byte 0, SAM"] pub mod slp_clk_off0 {
#[doc = "Register `SLP_CLK_OFF0` reader"] pub type R = crate :: R < SLP_CLK_OFF0_SPEC > ;
#[doc = "Register `SLP_CLK_OFF0` writer"] pub type W = crate :: W < SLP_CLK_OFF0_SPEC > ;
#[doc = "Field `SLP_CLK_TMR0` reader - RWA, close TMR0 clock"] pub type SLP_CLK_TMR0_R = crate :: BitReader ;
#[doc = "Field `SLP_CLK_TMR0` writer - RWA, close TMR0 clock"] pub type SLP_CLK_TMR0_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLP_CLK_TMR1` reader - RWA, close TMR1 clock"] pub type SLP_CLK_TMR1_R = crate :: BitReader ;
#[doc = "Field `SLP_CLK_TMR1` writer - RWA, close TMR1 clock"] pub type SLP_CLK_TMR1_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLP_CLK_TMR2` reader - RWA, close TMR2 clock"] pub type SLP_CLK_TMR2_R = crate :: BitReader ;
#[doc = "Field `SLP_CLK_TMR2` writer - RWA, close TMR2 clock"] pub type SLP_CLK_TMR2_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLP_CLK_TMR3` reader - RWA, close TMR3 clock"] pub type SLP_CLK_TMR3_R = crate :: BitReader ;
#[doc = "Field `SLP_CLK_TMR3` writer - RWA, close TMR3 clock"] pub type SLP_CLK_TMR3_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLP_CLK_UART0` reader - RWA, close UART0 clock"] pub type SLP_CLK_UART0_R = crate :: BitReader ;
#[doc = "Field `SLP_CLK_UART0` writer - RWA, close UART0 clock"] pub type SLP_CLK_UART0_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLP_CLK_UART1` reader - RWA, close UART1 clock"] pub type SLP_CLK_UART1_R = crate :: BitReader ;
#[doc = "Field `SLP_CLK_UART1` writer - RWA, close UART1 clock"] pub type SLP_CLK_UART1_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLP_CLK_UART2` reader - RWA, close UART2 clock"] pub type SLP_CLK_UART2_R = crate :: BitReader ;
#[doc = "Field `SLP_CLK_UART2` writer - RWA, close UART2 clock"] pub type SLP_CLK_UART2_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLP_CLK_UART3` reader - RWA, close UART3 clock"] pub type SLP_CLK_UART3_R = crate :: BitReader ;
#[doc = "Field `SLP_CLK_UART3` writer - RWA, close UART3 clock"] pub type SLP_CLK_UART3_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RWA, close TMR0 clock"]
#[inline (always)] pub fn slp_clk_tmr0 (& self) -> SLP_CLK_TMR0_R { SLP_CLK_TMR0_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RWA, close TMR1 clock"]
#[inline (always)] pub fn slp_clk_tmr1 (& self) -> SLP_CLK_TMR1_R { SLP_CLK_TMR1_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RWA, close TMR2 clock"]
#[inline (always)] pub fn slp_clk_tmr2 (& self) -> SLP_CLK_TMR2_R { SLP_CLK_TMR2_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RWA, close TMR3 clock"]
#[inline (always)] pub fn slp_clk_tmr3 (& self) -> SLP_CLK_TMR3_R { SLP_CLK_TMR3_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RWA, close UART0 clock"]
#[inline (always)] pub fn slp_clk_uart0 (& self) -> SLP_CLK_UART0_R { SLP_CLK_UART0_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RWA, close UART1 clock"]
#[inline (always)] pub fn slp_clk_uart1 (& self) -> SLP_CLK_UART1_R { SLP_CLK_UART1_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RWA, close UART2 clock"]
#[inline (always)] pub fn slp_clk_uart2 (& self) -> SLP_CLK_UART2_R { SLP_CLK_UART2_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RWA, close UART3 clock"]
#[inline (always)] pub fn slp_clk_uart3 (& self) -> SLP_CLK_UART3_R { SLP_CLK_UART3_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RWA, close TMR0 clock"]
#[inline (always)] pub fn slp_clk_tmr0 (& mut self) -> SLP_CLK_TMR0_W < SLP_CLK_OFF0_SPEC > { SLP_CLK_TMR0_W :: new (self , 0) }
#[doc = "Bit 1 - RWA, close TMR1 clock"]
#[inline (always)] pub fn slp_clk_tmr1 (& mut self) -> SLP_CLK_TMR1_W < SLP_CLK_OFF0_SPEC > { SLP_CLK_TMR1_W :: new (self , 1) }
#[doc = "Bit 2 - RWA, close TMR2 clock"]
#[inline (always)] pub fn slp_clk_tmr2 (& mut self) -> SLP_CLK_TMR2_W < SLP_CLK_OFF0_SPEC > { SLP_CLK_TMR2_W :: new (self , 2) }
#[doc = "Bit 3 - RWA, close TMR3 clock"]
#[inline (always)] pub fn slp_clk_tmr3 (& mut self) -> SLP_CLK_TMR3_W < SLP_CLK_OFF0_SPEC > { SLP_CLK_TMR3_W :: new (self , 3) }
#[doc = "Bit 4 - RWA, close UART0 clock"]
#[inline (always)] pub fn slp_clk_uart0 (& mut self) -> SLP_CLK_UART0_W < SLP_CLK_OFF0_SPEC > { SLP_CLK_UART0_W :: new (self , 4) }
#[doc = "Bit 5 - RWA, close UART1 clock"]
#[inline (always)] pub fn slp_clk_uart1 (& mut self) -> SLP_CLK_UART1_W < SLP_CLK_OFF0_SPEC > { SLP_CLK_UART1_W :: new (self , 5) }
#[doc = "Bit 6 - RWA, close UART2 clock"]
#[inline (always)] pub fn slp_clk_uart2 (& mut self) -> SLP_CLK_UART2_W < SLP_CLK_OFF0_SPEC > { SLP_CLK_UART2_W :: new (self , 6) }
#[doc = "Bit 7 - RWA, close UART3 clock"]
#[inline (always)] pub fn slp_clk_uart3 (& mut self) -> SLP_CLK_UART3_W < SLP_CLK_OFF0_SPEC > { SLP_CLK_UART3_W :: new (self , 7) } }
#[doc = "RWA, sleep clock off control byte 0, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`slp_clk_off0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slp_clk_off0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SLP_CLK_OFF0_SPEC ; impl crate :: RegisterSpec for SLP_CLK_OFF0_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`slp_clk_off0::R`](R) reader structure"] impl crate :: Readable for SLP_CLK_OFF0_SPEC { }
#[doc = "`write(|w| ..)` method takes [`slp_clk_off0::W`](W) writer structure"] impl crate :: Writable for SLP_CLK_OFF0_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SLP_CLK_OFF0 to value 0"] impl crate :: Resettable for SLP_CLK_OFF0_SPEC { } }
#[doc = "SLP_CLK_OFF1 (rw) register accessor: RWA, sleep clock off control byte 1, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`slp_clk_off1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slp_clk_off1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@slp_clk_off1`] module"] pub type SLP_CLK_OFF1 = crate :: Reg < slp_clk_off1 :: SLP_CLK_OFF1_SPEC > ;
#[doc = "RWA, sleep clock off control byte 1, SAM"] pub mod slp_clk_off1 {
#[doc = "Register `SLP_CLK_OFF1` reader"] pub type R = crate :: R < SLP_CLK_OFF1_SPEC > ;
#[doc = "Register `SLP_CLK_OFF1` writer"] pub type W = crate :: W < SLP_CLK_OFF1_SPEC > ;
#[doc = "Field `SLP_CLK_SPI0` reader - RWA, close SPI0 clock"] pub type SLP_CLK_SPI0_R = crate :: BitReader ;
#[doc = "Field `SLP_CLK_SPI0` writer - RWA, close SPI0 clock"] pub type SLP_CLK_SPI0_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLP_CLK_SPI1` reader - RWA, close SPI1 clock"] pub type SLP_CLK_SPI1_R = crate :: BitReader ;
#[doc = "Field `SLP_CLK_SPI1` writer - RWA, close SPI1 clock"] pub type SLP_CLK_SPI1_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLP_CLK_PWMX` reader - RWA, close PWMx clock"] pub type SLP_CLK_PWMX_R = crate :: BitReader ;
#[doc = "Field `SLP_CLK_PWMX` writer - RWA, close PWMx clock"] pub type SLP_CLK_PWMX_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLP_CLK_I2C` reader - RWA, close I2C clock"] pub type SLP_CLK_I2C_R = crate :: BitReader ;
#[doc = "Field `SLP_CLK_I2C` writer - RWA, close I2C clock"] pub type SLP_CLK_I2C_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLP_CLK_USB` reader - RWA, close USB clock"] pub type SLP_CLK_USB_R = crate :: BitReader ;
#[doc = "Field `SLP_CLK_USB` writer - RWA, close USB clock"] pub type SLP_CLK_USB_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLP_CLK_BLE` reader - RWA, close BLE clock"] pub type SLP_CLK_BLE_R = crate :: BitReader ;
#[doc = "Field `SLP_CLK_BLE` writer - RWA, close BLE clock"] pub type SLP_CLK_BLE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RWA, close SPI0 clock"]
#[inline (always)] pub fn slp_clk_spi0 (& self) -> SLP_CLK_SPI0_R { SLP_CLK_SPI0_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RWA, close SPI1 clock"]
#[inline (always)] pub fn slp_clk_spi1 (& self) -> SLP_CLK_SPI1_R { SLP_CLK_SPI1_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RWA, close PWMx clock"]
#[inline (always)] pub fn slp_clk_pwmx (& self) -> SLP_CLK_PWMX_R { SLP_CLK_PWMX_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RWA, close I2C clock"]
#[inline (always)] pub fn slp_clk_i2c (& self) -> SLP_CLK_I2C_R { SLP_CLK_I2C_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RWA, close USB clock"]
#[inline (always)] pub fn slp_clk_usb (& self) -> SLP_CLK_USB_R { SLP_CLK_USB_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 7 - RWA, close BLE clock"]
#[inline (always)] pub fn slp_clk_ble (& self) -> SLP_CLK_BLE_R { SLP_CLK_BLE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RWA, close SPI0 clock"]
#[inline (always)] pub fn slp_clk_spi0 (& mut self) -> SLP_CLK_SPI0_W < SLP_CLK_OFF1_SPEC > { SLP_CLK_SPI0_W :: new (self , 0) }
#[doc = "Bit 1 - RWA, close SPI1 clock"]
#[inline (always)] pub fn slp_clk_spi1 (& mut self) -> SLP_CLK_SPI1_W < SLP_CLK_OFF1_SPEC > { SLP_CLK_SPI1_W :: new (self , 1) }
#[doc = "Bit 2 - RWA, close PWMx clock"]
#[inline (always)] pub fn slp_clk_pwmx (& mut self) -> SLP_CLK_PWMX_W < SLP_CLK_OFF1_SPEC > { SLP_CLK_PWMX_W :: new (self , 2) }
#[doc = "Bit 3 - RWA, close I2C clock"]
#[inline (always)] pub fn slp_clk_i2c (& mut self) -> SLP_CLK_I2C_W < SLP_CLK_OFF1_SPEC > { SLP_CLK_I2C_W :: new (self , 3) }
#[doc = "Bit 4 - RWA, close USB clock"]
#[inline (always)] pub fn slp_clk_usb (& mut self) -> SLP_CLK_USB_W < SLP_CLK_OFF1_SPEC > { SLP_CLK_USB_W :: new (self , 4) }
#[doc = "Bit 7 - RWA, close BLE clock"]
#[inline (always)] pub fn slp_clk_ble (& mut self) -> SLP_CLK_BLE_W < SLP_CLK_OFF1_SPEC > { SLP_CLK_BLE_W :: new (self , 7) } }
#[doc = "RWA, sleep clock off control byte 1, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`slp_clk_off1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slp_clk_off1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SLP_CLK_OFF1_SPEC ; impl crate :: RegisterSpec for SLP_CLK_OFF1_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`slp_clk_off1::R`](R) reader structure"] impl crate :: Readable for SLP_CLK_OFF1_SPEC { }
#[doc = "`write(|w| ..)` method takes [`slp_clk_off1::W`](W) writer structure"] impl crate :: Writable for SLP_CLK_OFF1_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SLP_CLK_OFF1 to value 0"] impl crate :: Resettable for SLP_CLK_OFF1_SPEC { } }
#[doc = "SLP_WAKE_CTRL (rw) register accessor: RWA, wake control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`slp_wake_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slp_wake_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@slp_wake_ctrl`] module"] pub type SLP_WAKE_CTRL = crate :: Reg < slp_wake_ctrl :: SLP_WAKE_CTRL_SPEC > ;
#[doc = "RWA, wake control, SAM"] pub mod slp_wake_ctrl {
#[doc = "Register `SLP_WAKE_CTRL` reader"] pub type R = crate :: R < SLP_WAKE_CTRL_SPEC > ;
#[doc = "Register `SLP_WAKE_CTRL` writer"] pub type W = crate :: W < SLP_WAKE_CTRL_SPEC > ;
#[doc = "Field `SLP_USB_WAKE` reader - RWA, enable USB waking"] pub type SLP_USB_WAKE_R = crate :: BitReader ;
#[doc = "Field `SLP_USB_WAKE` writer - RWA, enable USB waking"] pub type SLP_USB_WAKE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLP_USB2_WAKE` reader - RWA, enable USB2 waking"] pub type SLP_USB2_WAKE_R = crate :: BitReader ;
#[doc = "Field `SLP_USB2_WAKE` writer - RWA, enable USB2 waking"] pub type SLP_USB2_WAKE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLP_RTC_WAKE` reader - RWA, enable RTC waking"] pub type SLP_RTC_WAKE_R = crate :: BitReader ;
#[doc = "Field `SLP_RTC_WAKE` writer - RWA, enable RTC waking"] pub type SLP_RTC_WAKE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLP_GPIO_WAKE` reader - RWA, enable GPIO waking"] pub type SLP_GPIO_WAKE_R = crate :: BitReader ;
#[doc = "Field `SLP_GPIO_WAKE` writer - RWA, enable GPIO waking"] pub type SLP_GPIO_WAKE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLP_BAT_WAKE` reader - RWA, enable BAT waking"] pub type SLP_BAT_WAKE_R = crate :: BitReader ;
#[doc = "Field `SLP_BAT_WAKE` writer - RWA, enable BAT waking"] pub type SLP_BAT_WAKE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WAKE_EV_MODE` reader - RWA, event wakeup mode"] pub type WAKE_EV_MODE_R = crate :: BitReader ;
#[doc = "Field `WAKE_EV_MODE` writer - RWA, event wakeup mode"] pub type WAKE_EV_MODE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RWA, enable USB waking"]
#[inline (always)] pub fn slp_usb_wake (& self) -> SLP_USB_WAKE_R { SLP_USB_WAKE_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RWA, enable USB2 waking"]
#[inline (always)] pub fn slp_usb2_wake (& self) -> SLP_USB2_WAKE_R { SLP_USB2_WAKE_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - RWA, enable RTC waking"]
#[inline (always)] pub fn slp_rtc_wake (& self) -> SLP_RTC_WAKE_R { SLP_RTC_WAKE_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RWA, enable GPIO waking"]
#[inline (always)] pub fn slp_gpio_wake (& self) -> SLP_GPIO_WAKE_R { SLP_GPIO_WAKE_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RWA, enable BAT waking"]
#[inline (always)] pub fn slp_bat_wake (& self) -> SLP_BAT_WAKE_R { SLP_BAT_WAKE_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RWA, event wakeup mode"]
#[inline (always)] pub fn wake_ev_mode (& self) -> WAKE_EV_MODE_R { WAKE_EV_MODE_R :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RWA, enable USB waking"]
#[inline (always)] pub fn slp_usb_wake (& mut self) -> SLP_USB_WAKE_W < SLP_WAKE_CTRL_SPEC > { SLP_USB_WAKE_W :: new (self , 0) }
#[doc = "Bit 1 - RWA, enable USB2 waking"]
#[inline (always)] pub fn slp_usb2_wake (& mut self) -> SLP_USB2_WAKE_W < SLP_WAKE_CTRL_SPEC > { SLP_USB2_WAKE_W :: new (self , 1) }
#[doc = "Bit 3 - RWA, enable RTC waking"]
#[inline (always)] pub fn slp_rtc_wake (& mut self) -> SLP_RTC_WAKE_W < SLP_WAKE_CTRL_SPEC > { SLP_RTC_WAKE_W :: new (self , 3) }
#[doc = "Bit 4 - RWA, enable GPIO waking"]
#[inline (always)] pub fn slp_gpio_wake (& mut self) -> SLP_GPIO_WAKE_W < SLP_WAKE_CTRL_SPEC > { SLP_GPIO_WAKE_W :: new (self , 4) }
#[doc = "Bit 5 - RWA, enable BAT waking"]
#[inline (always)] pub fn slp_bat_wake (& mut self) -> SLP_BAT_WAKE_W < SLP_WAKE_CTRL_SPEC > { SLP_BAT_WAKE_W :: new (self , 5) }
#[doc = "Bit 6 - RWA, event wakeup mode"]
#[inline (always)] pub fn wake_ev_mode (& mut self) -> WAKE_EV_MODE_W < SLP_WAKE_CTRL_SPEC > { WAKE_EV_MODE_W :: new (self , 6) } }
#[doc = "RWA, wake control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`slp_wake_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slp_wake_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SLP_WAKE_CTRL_SPEC ; impl crate :: RegisterSpec for SLP_WAKE_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`slp_wake_ctrl::R`](R) reader structure"] impl crate :: Readable for SLP_WAKE_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`slp_wake_ctrl::W`](W) writer structure"] impl crate :: Writable for SLP_WAKE_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SLP_WAKE_CTRL to value 0x20"] impl crate :: Resettable for SLP_WAKE_CTRL_SPEC { const RESET_VALUE : u8 = 0x20 ; } }
#[doc = "SLP_POWER_CTRL (rw) register accessor: RWA, peripherals power down control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`slp_power_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slp_power_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@slp_power_ctrl`] module"] pub type SLP_POWER_CTRL = crate :: Reg < slp_power_ctrl :: SLP_POWER_CTRL_SPEC > ;
#[doc = "RWA, peripherals power down control, SAM"] pub mod slp_power_ctrl {
#[doc = "Register `SLP_POWER_CTRL` reader"] pub type R = crate :: R < SLP_POWER_CTRL_SPEC > ;
#[doc = "Register `SLP_POWER_CTRL` writer"] pub type W = crate :: W < SLP_POWER_CTRL_SPEC > ;
#[doc = "Field `WAKE_DLY_MOD` reader - RWA, wakeup delay time selection"] pub type WAKE_DLY_MOD_R = crate :: FieldReader ;
#[doc = "Field `WAKE_DLY_MOD` writer - RWA, wakeup delay time selection"] pub type WAKE_DLY_MOD_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SLP_CLK_RAMX` reader - RWA, close main SRAM clock"] pub type SLP_CLK_RAMX_R = crate :: BitReader ;
#[doc = "Field `SLP_CLK_RAMX` writer - RWA, close main SRAM clock"] pub type SLP_CLK_RAMX_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLP_CLK_RAM2K` reader - RWA, close retention 2KB SRAM clock"] pub type SLP_CLK_RAM2K_R = crate :: BitReader ;
#[doc = "Field `SLP_CLK_RAM2K` writer - RWA, close retention 2KB SRAM clock"] pub type SLP_CLK_RAM2K_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RAM_RET_LV` reader - RWA, SRAM retention voltage selection"] pub type RAM_RET_LV_R = crate :: BitReader ;
#[doc = "Field `RAM_RET_LV` writer - RWA, SRAM retention voltage selection"] pub type RAM_RET_LV_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - RWA, wakeup delay time selection"]
#[inline (always)] pub fn wake_dly_mod (& self) -> WAKE_DLY_MOD_R { WAKE_DLY_MOD_R :: new (self . bits & 3) }
#[doc = "Bit 4 - RWA, close main SRAM clock"]
#[inline (always)] pub fn slp_clk_ramx (& self) -> SLP_CLK_RAMX_R { SLP_CLK_RAMX_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RWA, close retention 2KB SRAM clock"]
#[inline (always)] pub fn slp_clk_ram2k (& self) -> SLP_CLK_RAM2K_R { SLP_CLK_RAM2K_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RWA, SRAM retention voltage selection"]
#[inline (always)] pub fn ram_ret_lv (& self) -> RAM_RET_LV_R { RAM_RET_LV_R :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - RWA, wakeup delay time selection"]
#[inline (always)] pub fn wake_dly_mod (& mut self) -> WAKE_DLY_MOD_W < SLP_POWER_CTRL_SPEC > { WAKE_DLY_MOD_W :: new (self , 0) }
#[doc = "Bit 4 - RWA, close main SRAM clock"]
#[inline (always)] pub fn slp_clk_ramx (& mut self) -> SLP_CLK_RAMX_W < SLP_POWER_CTRL_SPEC > { SLP_CLK_RAMX_W :: new (self , 4) }
#[doc = "Bit 5 - RWA, close retention 2KB SRAM clock"]
#[inline (always)] pub fn slp_clk_ram2k (& mut self) -> SLP_CLK_RAM2K_W < SLP_POWER_CTRL_SPEC > { SLP_CLK_RAM2K_W :: new (self , 5) }
#[doc = "Bit 6 - RWA, SRAM retention voltage selection"]
#[inline (always)] pub fn ram_ret_lv (& mut self) -> RAM_RET_LV_W < SLP_POWER_CTRL_SPEC > { RAM_RET_LV_W :: new (self , 6) } }
#[doc = "RWA, peripherals power down control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`slp_power_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slp_power_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SLP_POWER_CTRL_SPEC ; impl crate :: RegisterSpec for SLP_POWER_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`slp_power_ctrl::R`](R) reader structure"] impl crate :: Readable for SLP_POWER_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`slp_power_ctrl::W`](W) writer structure"] impl crate :: Writable for SLP_POWER_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SLP_POWER_CTRL to value 0"] impl crate :: Resettable for SLP_POWER_CTRL_SPEC { } }
#[doc = "PIN_ALTERNATE (rw) register accessor: RW, function pin alternate configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`pin_alternate::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pin_alternate::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pin_alternate`] module"] pub type PIN_ALTERNATE = crate :: Reg < pin_alternate :: PIN_ALTERNATE_SPEC > ;
#[doc = "RW, function pin alternate configuration"] pub mod pin_alternate {
#[doc = "Register `PIN_ALTERNATE` reader"] pub type R = crate :: R < PIN_ALTERNATE_SPEC > ;
#[doc = "Register `PIN_ALTERNATE` writer"] pub type W = crate :: W < PIN_ALTERNATE_SPEC > ;
#[doc = "Field `PIN_TMR0` reader - RW, TMR0 alternate pin enable"] pub type PIN_TMR0_R = crate :: BitReader ;
#[doc = "Field `PIN_TMR0` writer - RW, TMR0 alternate pin enable"] pub type PIN_TMR0_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_TMR1` reader - RW, TMR1 alternate pin enable"] pub type PIN_TMR1_R = crate :: BitReader ;
#[doc = "Field `PIN_TMR1` writer - RW, TMR1 alternate pin enable"] pub type PIN_TMR1_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_TMR2` reader - RW, TMR2 alternate pin enable"] pub type PIN_TMR2_R = crate :: BitReader ;
#[doc = "Field `PIN_TMR2` writer - RW, TMR2 alternate pin enable"] pub type PIN_TMR2_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_TMR3` reader - RW, TMR3 alternate pin enable"] pub type PIN_TMR3_R = crate :: BitReader ;
#[doc = "Field `PIN_TMR3` writer - RW, TMR3 alternate pin enable"] pub type PIN_TMR3_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_UART0` reader - RW, RXD0/TXD0 alternate pin enable"] pub type PIN_UART0_R = crate :: BitReader ;
#[doc = "Field `PIN_UART0` writer - RW, RXD0/TXD0 alternate pin enable"] pub type PIN_UART0_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_UART1` reader - RW, RXD1/TXD1 alternate pin enable"] pub type PIN_UART1_R = crate :: BitReader ;
#[doc = "Field `PIN_UART1` writer - RW, RXD1/TXD1 alternate pin enable"] pub type PIN_UART1_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_UART2` reader - RW, RXD2/TXD2 alternate pin enable"] pub type PIN_UART2_R = crate :: BitReader ;
#[doc = "Field `PIN_UART2` writer - RW, RXD2/TXD2 alternate pin enable"] pub type PIN_UART2_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_UART3` reader - RW, RXD3/TXD3 alternate pin enable"] pub type PIN_UART3_R = crate :: BitReader ;
#[doc = "Field `PIN_UART3` writer - RW, RXD3/TXD3 alternate pin enable"] pub type PIN_UART3_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_SPI0` reader - RW, SCS/SCK0/MOSI/MISO alternate pin enable"] pub type PIN_SPI0_R = crate :: BitReader ;
#[doc = "Field `PIN_SPI0` writer - RW, SCS/SCK0/MOSI/MISO alternate pin enable"] pub type PIN_SPI0_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_PWMX` reader - RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable"] pub type PIN_PWMX_R = crate :: BitReader ;
#[doc = "Field `PIN_PWMX` writer - RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable"] pub type PIN_PWMX_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_I2C` reader - RW, SCL/SDA alternate pin enable"] pub type PIN_I2C_R = crate :: BitReader ;
#[doc = "Field `PIN_I2C` writer - RW, SCL/SDA alternate pin enable"] pub type PIN_I2C_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_MODEM` reader - RW, DSR/DTR alternate pin enable"] pub type PIN_MODEM_R = crate :: BitReader ;
#[doc = "Field `PIN_MODEM` writer - RW, DSR/DTR alternate pin enable"] pub type PIN_MODEM_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_INTX` reader - RW, interrupt INT24/INT25 alternate pin enable"] pub type PIN_INTX_R = crate :: BitReader ;
#[doc = "Field `PIN_INTX` writer - RW, interrupt INT24/INT25 alternate pin enable"] pub type PIN_INTX_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_U0_INV` reader - RW, SCL/SDA alternRW, RXD0/RXD0_/TXD0/TXD0_ invert input/output enableate pin enable"] pub type PIN_U0_INV_R = crate :: BitReader ;
#[doc = "Field `PIN_U0_INV` writer - RW, SCL/SDA alternRW, RXD0/RXD0_/TXD0/TXD0_ invert input/output enableate pin enable"] pub type PIN_U0_INV_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RF_ANT_SW_EN` reader - RW, RF antenna switch control output enable"] pub type RF_ANT_SW_EN_R = crate :: BitReader ;
#[doc = "Field `RF_ANT_SW_EN` writer - RW, RF antenna switch control output enable"] pub type RF_ANT_SW_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, TMR0 alternate pin enable"]
#[inline (always)] pub fn pin_tmr0 (& self) -> PIN_TMR0_R { PIN_TMR0_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, TMR1 alternate pin enable"]
#[inline (always)] pub fn pin_tmr1 (& self) -> PIN_TMR1_R { PIN_TMR1_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW, TMR2 alternate pin enable"]
#[inline (always)] pub fn pin_tmr2 (& self) -> PIN_TMR2_R { PIN_TMR2_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, TMR3 alternate pin enable"]
#[inline (always)] pub fn pin_tmr3 (& self) -> PIN_TMR3_R { PIN_TMR3_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW, RXD0/TXD0 alternate pin enable"]
#[inline (always)] pub fn pin_uart0 (& self) -> PIN_UART0_R { PIN_UART0_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RW, RXD1/TXD1 alternate pin enable"]
#[inline (always)] pub fn pin_uart1 (& self) -> PIN_UART1_R { PIN_UART1_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RW, RXD2/TXD2 alternate pin enable"]
#[inline (always)] pub fn pin_uart2 (& self) -> PIN_UART2_R { PIN_UART2_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RW, RXD3/TXD3 alternate pin enable"]
#[inline (always)] pub fn pin_uart3 (& self) -> PIN_UART3_R { PIN_UART3_R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - RW, SCS/SCK0/MOSI/MISO alternate pin enable"]
#[inline (always)] pub fn pin_spi0 (& self) -> PIN_SPI0_R { PIN_SPI0_R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 10 - RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable"]
#[inline (always)] pub fn pin_pwmx (& self) -> PIN_PWMX_R { PIN_PWMX_R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - RW, SCL/SDA alternate pin enable"]
#[inline (always)] pub fn pin_i2c (& self) -> PIN_I2C_R { PIN_I2C_R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - RW, DSR/DTR alternate pin enable"]
#[inline (always)] pub fn pin_modem (& self) -> PIN_MODEM_R { PIN_MODEM_R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - RW, interrupt INT24/INT25 alternate pin enable"]
#[inline (always)] pub fn pin_intx (& self) -> PIN_INTX_R { PIN_INTX_R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - RW, SCL/SDA alternRW, RXD0/RXD0_/TXD0/TXD0_ invert input/output enableate pin enable"]
#[inline (always)] pub fn pin_u0_inv (& self) -> PIN_U0_INV_R { PIN_U0_INV_R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - RW, RF antenna switch control output enable"]
#[inline (always)] pub fn rf_ant_sw_en (& self) -> RF_ANT_SW_EN_R { RF_ANT_SW_EN_R :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, TMR0 alternate pin enable"]
#[inline (always)] pub fn pin_tmr0 (& mut self) -> PIN_TMR0_W < PIN_ALTERNATE_SPEC > { PIN_TMR0_W :: new (self , 0) }
#[doc = "Bit 1 - RW, TMR1 alternate pin enable"]
#[inline (always)] pub fn pin_tmr1 (& mut self) -> PIN_TMR1_W < PIN_ALTERNATE_SPEC > { PIN_TMR1_W :: new (self , 1) }
#[doc = "Bit 2 - RW, TMR2 alternate pin enable"]
#[inline (always)] pub fn pin_tmr2 (& mut self) -> PIN_TMR2_W < PIN_ALTERNATE_SPEC > { PIN_TMR2_W :: new (self , 2) }
#[doc = "Bit 3 - RW, TMR3 alternate pin enable"]
#[inline (always)] pub fn pin_tmr3 (& mut self) -> PIN_TMR3_W < PIN_ALTERNATE_SPEC > { PIN_TMR3_W :: new (self , 3) }
#[doc = "Bit 4 - RW, RXD0/TXD0 alternate pin enable"]
#[inline (always)] pub fn pin_uart0 (& mut self) -> PIN_UART0_W < PIN_ALTERNATE_SPEC > { PIN_UART0_W :: new (self , 4) }
#[doc = "Bit 5 - RW, RXD1/TXD1 alternate pin enable"]
#[inline (always)] pub fn pin_uart1 (& mut self) -> PIN_UART1_W < PIN_ALTERNATE_SPEC > { PIN_UART1_W :: new (self , 5) }
#[doc = "Bit 6 - RW, RXD2/TXD2 alternate pin enable"]
#[inline (always)] pub fn pin_uart2 (& mut self) -> PIN_UART2_W < PIN_ALTERNATE_SPEC > { PIN_UART2_W :: new (self , 6) }
#[doc = "Bit 7 - RW, RXD3/TXD3 alternate pin enable"]
#[inline (always)] pub fn pin_uart3 (& mut self) -> PIN_UART3_W < PIN_ALTERNATE_SPEC > { PIN_UART3_W :: new (self , 7) }
#[doc = "Bit 8 - RW, SCS/SCK0/MOSI/MISO alternate pin enable"]
#[inline (always)] pub fn pin_spi0 (& mut self) -> PIN_SPI0_W < PIN_ALTERNATE_SPEC > { PIN_SPI0_W :: new (self , 8) }
#[doc = "Bit 10 - RW, PWM4/PWM5/PWM7/PWM8/PWM9 alternate pin enable"]
#[inline (always)] pub fn pin_pwmx (& mut self) -> PIN_PWMX_W < PIN_ALTERNATE_SPEC > { PIN_PWMX_W :: new (self , 10) }
#[doc = "Bit 11 - RW, SCL/SDA alternate pin enable"]
#[inline (always)] pub fn pin_i2c (& mut self) -> PIN_I2C_W < PIN_ALTERNATE_SPEC > { PIN_I2C_W :: new (self , 11) }
#[doc = "Bit 12 - RW, DSR/DTR alternate pin enable"]
#[inline (always)] pub fn pin_modem (& mut self) -> PIN_MODEM_W < PIN_ALTERNATE_SPEC > { PIN_MODEM_W :: new (self , 12) }
#[doc = "Bit 13 - RW, interrupt INT24/INT25 alternate pin enable"]
#[inline (always)] pub fn pin_intx (& mut self) -> PIN_INTX_W < PIN_ALTERNATE_SPEC > { PIN_INTX_W :: new (self , 13) }
#[doc = "Bit 14 - RW, SCL/SDA alternRW, RXD0/RXD0_/TXD0/TXD0_ invert input/output enableate pin enable"]
#[inline (always)] pub fn pin_u0_inv (& mut self) -> PIN_U0_INV_W < PIN_ALTERNATE_SPEC > { PIN_U0_INV_W :: new (self , 14) }
#[doc = "Bit 15 - RW, RF antenna switch control output enable"]
#[inline (always)] pub fn rf_ant_sw_en (& mut self) -> RF_ANT_SW_EN_W < PIN_ALTERNATE_SPEC > { RF_ANT_SW_EN_W :: new (self , 15) } }
#[doc = "RW, function pin alternate configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`pin_alternate::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pin_alternate::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PIN_ALTERNATE_SPEC ; impl crate :: RegisterSpec for PIN_ALTERNATE_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`pin_alternate::R`](R) reader structure"] impl crate :: Readable for PIN_ALTERNATE_SPEC { }
#[doc = "`write(|w| ..)` method takes [`pin_alternate::W`](W) writer structure"] impl crate :: Writable for PIN_ALTERNATE_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PIN_ALTERNATE to value 0"] impl crate :: Resettable for PIN_ALTERNATE_SPEC { } }
#[doc = "PIN_ANALOG_IE (rw) register accessor: RW, analog pin enable and digital input disable\n\nYou can [`read`](crate::Reg::read) this register and get [`pin_analog_ie::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pin_analog_ie::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pin_analog_ie`] module"] pub type PIN_ANALOG_IE = crate :: Reg < pin_analog_ie :: PIN_ANALOG_IE_SPEC > ;
#[doc = "RW, analog pin enable and digital input disable"] pub mod pin_analog_ie {
#[doc = "Register `PIN_ANALOG_IE` reader"] pub type R = crate :: R < PIN_ANALOG_IE_SPEC > ;
#[doc = "Register `PIN_ANALOG_IE` writer"] pub type W = crate :: W < PIN_ANALOG_IE_SPEC > ;
#[doc = "Field `PIN_ADC8_9_IE` reader - RW, ADC/TouchKey channel 9/8 digital input disable"] pub type PIN_ADC8_9_IE_R = crate :: BitReader ;
#[doc = "Field `PIN_ADC8_9_IE` writer - RW, ADC/TouchKey channel 9/8 digital input disable"] pub type PIN_ADC8_9_IE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_ADC6_7_IE` reader - RW, ADC/TouchKey channel 7/6 digital input disable"] pub type PIN_ADC6_7_IE_R = crate :: BitReader ;
#[doc = "Field `PIN_ADC6_7_IE` writer - RW, ADC/TouchKey channel 7/6 digital input disable"] pub type PIN_ADC6_7_IE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_ADC10_IE` reader - RW, ADC/TouchKey channel 10 digital input disable"] pub type PIN_ADC10_IE_R = crate :: BitReader ;
#[doc = "Field `PIN_ADC10_IE` writer - RW, ADC/TouchKey channel 10 digital input disable"] pub type PIN_ADC10_IE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_ADC11_IE` reader - RW, ADC/TouchKey channel 11 digital input disable"] pub type PIN_ADC11_IE_R = crate :: BitReader ;
#[doc = "Field `PIN_ADC11_IE` writer - RW, ADC/TouchKey channel 11 digital input disable"] pub type PIN_ADC11_IE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_USB2_DP_PU` reader - RW,USB2 UDP internal pullup resistance enable"] pub type PIN_USB2_DP_PU_R = crate :: BitReader ;
#[doc = "Field `PIN_USB2_DP_PU` writer - RW,USB2 UDP internal pullup resistance enable"] pub type PIN_USB2_DP_PU_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_USB2_IE` reader - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable"] pub type PIN_USB2_IE_R = crate :: BitReader ;
#[doc = "Field `PIN_USB2_IE` writer - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable"] pub type PIN_USB2_IE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_USB_DP_PU` reader - RW,USB UDP internal pullup resistance enable"] pub type PIN_USB_DP_PU_R = crate :: BitReader ;
#[doc = "Field `PIN_USB_DP_PU` writer - RW,USB UDP internal pullup resistance enable"] pub type PIN_USB_DP_PU_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_USB_IE` reader - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable"] pub type PIN_USB_IE_R = crate :: BitReader ;
#[doc = "Field `PIN_USB_IE` writer - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable"] pub type PIN_USB_IE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_ADC0_IE` reader - RW, ADC/TouchKey channel0 digital input disable: 0=digital input enable, 1=digital input disable"] pub type PIN_ADC0_IE_R = crate :: BitReader ;
#[doc = "Field `PIN_ADC0_IE` writer - RW, ADC/TouchKey channel0 digital input disable: 0=digital input enable, 1=digital input disable"] pub type PIN_ADC0_IE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_ADC1_IE` reader - RW, ADC/TouchKey channel1 digital input disable: 0=digital input enable, 1=digital input disable"] pub type PIN_ADC1_IE_R = crate :: BitReader ;
#[doc = "Field `PIN_ADC1_IE` writer - RW, ADC/TouchKey channel1 digital input disable: 0=digital input enable, 1=digital input disable"] pub type PIN_ADC1_IE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_ADC12_IE` reader - RW, ADC/TouchKey channel12 digital input disable: 0=digital input enable, 1=digital input disable"] pub type PIN_ADC12_IE_R = crate :: BitReader ;
#[doc = "Field `PIN_ADC12_IE` writer - RW, ADC/TouchKey channel12 digital input disable: 0=digital input enable, 1=digital input disable"] pub type PIN_ADC12_IE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_ADC13_IE` reader - RW, ADC/TouchKey channel13 digital input disable: 0=digital input enable, 1=digital input disable"] pub type PIN_ADC13_IE_R = crate :: BitReader ;
#[doc = "Field `PIN_ADC13_IE` writer - RW, ADC/TouchKey channel13 digital input disable: 0=digital input enable, 1=digital input disable"] pub type PIN_ADC13_IE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_XT32K_IE` reader - RW, external 32KHz oscillator digital input disable: 0=digital input enable, 1=digital input disable"] pub type PIN_XT32K_IE_R = crate :: BitReader ;
#[doc = "Field `PIN_XT32K_IE` writer - RW, external 32KHz oscillator digital input disable: 0=digital input enable, 1=digital input disable"] pub type PIN_XT32K_IE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_ADC2_3_IE` reader - RW, ADC/TouchKey channel 2/3 digital input disable: 0=digital input enable, 1=digital input disable"] pub type PIN_ADC2_3_IE_R = crate :: BitReader ;
#[doc = "Field `PIN_ADC2_3_IE` writer - RW, ADC/TouchKey channel 2/3 digital input disable: 0=digital input enable, 1=digital input disable"] pub type PIN_ADC2_3_IE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PIN_ADC4_5_IE` reader - RW, ADC/TouchKey channel 4/5 digital input disable: 0=digital input enable, 1=digital input disable"] pub type PIN_ADC4_5_IE_R = crate :: BitReader ;
#[doc = "Field `PIN_ADC4_5_IE` writer - RW, ADC/TouchKey channel 4/5 digital input disable: 0=digital input enable, 1=digital input disable"] pub type PIN_ADC4_5_IE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, ADC/TouchKey channel 9/8 digital input disable"]
#[inline (always)] pub fn pin_adc8_9_ie (& self) -> PIN_ADC8_9_IE_R { PIN_ADC8_9_IE_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, ADC/TouchKey channel 7/6 digital input disable"]
#[inline (always)] pub fn pin_adc6_7_ie (& self) -> PIN_ADC6_7_IE_R { PIN_ADC6_7_IE_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW, ADC/TouchKey channel 10 digital input disable"]
#[inline (always)] pub fn pin_adc10_ie (& self) -> PIN_ADC10_IE_R { PIN_ADC10_IE_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, ADC/TouchKey channel 11 digital input disable"]
#[inline (always)] pub fn pin_adc11_ie (& self) -> PIN_ADC11_IE_R { PIN_ADC11_IE_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW,USB2 UDP internal pullup resistance enable"]
#[inline (always)] pub fn pin_usb2_dp_pu (& self) -> PIN_USB2_DP_PU_R { PIN_USB2_DP_PU_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable"]
#[inline (always)] pub fn pin_usb2_ie (& self) -> PIN_USB2_IE_R { PIN_USB2_IE_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RW,USB UDP internal pullup resistance enable"]
#[inline (always)] pub fn pin_usb_dp_pu (& self) -> PIN_USB_DP_PU_R { PIN_USB_DP_PU_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable"]
#[inline (always)] pub fn pin_usb_ie (& self) -> PIN_USB_IE_R { PIN_USB_IE_R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 9 - RW, ADC/TouchKey channel0 digital input disable: 0=digital input enable, 1=digital input disable"]
#[inline (always)] pub fn pin_adc0_ie (& self) -> PIN_ADC0_IE_R { PIN_ADC0_IE_R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - RW, ADC/TouchKey channel1 digital input disable: 0=digital input enable, 1=digital input disable"]
#[inline (always)] pub fn pin_adc1_ie (& self) -> PIN_ADC1_IE_R { PIN_ADC1_IE_R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - RW, ADC/TouchKey channel12 digital input disable: 0=digital input enable, 1=digital input disable"]
#[inline (always)] pub fn pin_adc12_ie (& self) -> PIN_ADC12_IE_R { PIN_ADC12_IE_R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - RW, ADC/TouchKey channel13 digital input disable: 0=digital input enable, 1=digital input disable"]
#[inline (always)] pub fn pin_adc13_ie (& self) -> PIN_ADC13_IE_R { PIN_ADC13_IE_R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - RW, external 32KHz oscillator digital input disable: 0=digital input enable, 1=digital input disable"]
#[inline (always)] pub fn pin_xt32k_ie (& self) -> PIN_XT32K_IE_R { PIN_XT32K_IE_R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 14 - RW, ADC/TouchKey channel 2/3 digital input disable: 0=digital input enable, 1=digital input disable"]
#[inline (always)] pub fn pin_adc2_3_ie (& self) -> PIN_ADC2_3_IE_R { PIN_ADC2_3_IE_R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - RW, ADC/TouchKey channel 4/5 digital input disable: 0=digital input enable, 1=digital input disable"]
#[inline (always)] pub fn pin_adc4_5_ie (& self) -> PIN_ADC4_5_IE_R { PIN_ADC4_5_IE_R :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, ADC/TouchKey channel 9/8 digital input disable"]
#[inline (always)] pub fn pin_adc8_9_ie (& mut self) -> PIN_ADC8_9_IE_W < PIN_ANALOG_IE_SPEC > { PIN_ADC8_9_IE_W :: new (self , 0) }
#[doc = "Bit 1 - RW, ADC/TouchKey channel 7/6 digital input disable"]
#[inline (always)] pub fn pin_adc6_7_ie (& mut self) -> PIN_ADC6_7_IE_W < PIN_ANALOG_IE_SPEC > { PIN_ADC6_7_IE_W :: new (self , 1) }
#[doc = "Bit 2 - RW, ADC/TouchKey channel 10 digital input disable"]
#[inline (always)] pub fn pin_adc10_ie (& mut self) -> PIN_ADC10_IE_W < PIN_ANALOG_IE_SPEC > { PIN_ADC10_IE_W :: new (self , 2) }
#[doc = "Bit 3 - RW, ADC/TouchKey channel 11 digital input disable"]
#[inline (always)] pub fn pin_adc11_ie (& mut self) -> PIN_ADC11_IE_W < PIN_ANALOG_IE_SPEC > { PIN_ADC11_IE_W :: new (self , 3) }
#[doc = "Bit 4 - RW,USB2 UDP internal pullup resistance enable"]
#[inline (always)] pub fn pin_usb2_dp_pu (& mut self) -> PIN_USB2_DP_PU_W < PIN_ANALOG_IE_SPEC > { PIN_USB2_DP_PU_W :: new (self , 4) }
#[doc = "Bit 5 - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable"]
#[inline (always)] pub fn pin_usb2_ie (& mut self) -> PIN_USB2_IE_W < PIN_ANALOG_IE_SPEC > { PIN_USB2_IE_W :: new (self , 5) }
#[doc = "Bit 6 - RW,USB UDP internal pullup resistance enable"]
#[inline (always)] pub fn pin_usb_dp_pu (& mut self) -> PIN_USB_DP_PU_W < PIN_ANALOG_IE_SPEC > { PIN_USB_DP_PU_W :: new (self , 6) }
#[doc = "Bit 7 - RW, USB analog I/O enable: 0=analog I/O disable, 1=analog I/O enable"]
#[inline (always)] pub fn pin_usb_ie (& mut self) -> PIN_USB_IE_W < PIN_ANALOG_IE_SPEC > { PIN_USB_IE_W :: new (self , 7) }
#[doc = "Bit 9 - RW, ADC/TouchKey channel0 digital input disable: 0=digital input enable, 1=digital input disable"]
#[inline (always)] pub fn pin_adc0_ie (& mut self) -> PIN_ADC0_IE_W < PIN_ANALOG_IE_SPEC > { PIN_ADC0_IE_W :: new (self , 9) }
#[doc = "Bit 10 - RW, ADC/TouchKey channel1 digital input disable: 0=digital input enable, 1=digital input disable"]
#[inline (always)] pub fn pin_adc1_ie (& mut self) -> PIN_ADC1_IE_W < PIN_ANALOG_IE_SPEC > { PIN_ADC1_IE_W :: new (self , 10) }
#[doc = "Bit 11 - RW, ADC/TouchKey channel12 digital input disable: 0=digital input enable, 1=digital input disable"]
#[inline (always)] pub fn pin_adc12_ie (& mut self) -> PIN_ADC12_IE_W < PIN_ANALOG_IE_SPEC > { PIN_ADC12_IE_W :: new (self , 11) }
#[doc = "Bit 12 - RW, ADC/TouchKey channel13 digital input disable: 0=digital input enable, 1=digital input disable"]
#[inline (always)] pub fn pin_adc13_ie (& mut self) -> PIN_ADC13_IE_W < PIN_ANALOG_IE_SPEC > { PIN_ADC13_IE_W :: new (self , 12) }
#[doc = "Bit 13 - RW, external 32KHz oscillator digital input disable: 0=digital input enable, 1=digital input disable"]
#[inline (always)] pub fn pin_xt32k_ie (& mut self) -> PIN_XT32K_IE_W < PIN_ANALOG_IE_SPEC > { PIN_XT32K_IE_W :: new (self , 13) }
#[doc = "Bit 14 - RW, ADC/TouchKey channel 2/3 digital input disable: 0=digital input enable, 1=digital input disable"]
#[inline (always)] pub fn pin_adc2_3_ie (& mut self) -> PIN_ADC2_3_IE_W < PIN_ANALOG_IE_SPEC > { PIN_ADC2_3_IE_W :: new (self , 14) }
#[doc = "Bit 15 - RW, ADC/TouchKey channel 4/5 digital input disable: 0=digital input enable, 1=digital input disable"]
#[inline (always)] pub fn pin_adc4_5_ie (& mut self) -> PIN_ADC4_5_IE_W < PIN_ANALOG_IE_SPEC > { PIN_ADC4_5_IE_W :: new (self , 15) } }
#[doc = "RW, analog pin enable and digital input disable\n\nYou can [`read`](crate::Reg::read) this register and get [`pin_analog_ie::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pin_analog_ie::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PIN_ANALOG_IE_SPEC ; impl crate :: RegisterSpec for PIN_ANALOG_IE_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`pin_analog_ie::R`](R) reader structure"] impl crate :: Readable for PIN_ANALOG_IE_SPEC { }
#[doc = "`write(|w| ..)` method takes [`pin_analog_ie::W`](W) writer structure"] impl crate :: Writable for PIN_ANALOG_IE_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PIN_ANALOG_IE to value 0"] impl crate :: Resettable for PIN_ANALOG_IE_SPEC { } }
#[doc = "POWER_PLAN (rw) register accessor: RWA, power plan before sleep instruction, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`power_plan::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`power_plan::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@power_plan`] module"] pub type POWER_PLAN = crate :: Reg < power_plan :: POWER_PLAN_SPEC > ;
#[doc = "RWA, power plan before sleep instruction, SAM"] pub mod power_plan {
#[doc = "Register `POWER_PLAN` reader"] pub type R = crate :: R < POWER_PLAN_SPEC > ;
#[doc = "Register `POWER_PLAN` writer"] pub type W = crate :: W < POWER_PLAN_SPEC > ;
#[doc = "Field `PWR_XROM` reader - RWA, power for retention 2KB SRAM"] pub type PWR_XROM_R = crate :: BitReader ;
#[doc = "Field `PWR_XROM` writer - RWA, power for retention 2KB SRAM"] pub type PWR_XROM_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWR_RAM2K` reader - RWA, power for retention 2KB SRAM"] pub type PWR_RAM2K_R = crate :: BitReader ;
#[doc = "Field `PWR_RAM2K` writer - RWA, power for retention 2KB SRAM"] pub type PWR_RAM2K_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWR_CORE` reader - RWA, power retention for core and base peripherals"] pub type PWR_CORE_R = crate :: BitReader ;
#[doc = "Field `PWR_CORE` writer - RWA, power retention for core and base peripherals"] pub type PWR_CORE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWR_EXTEND` reader - RWA, power retention for USB and BLE"] pub type PWR_EXTEND_R = crate :: BitReader ;
#[doc = "Field `PWR_EXTEND` writer - RWA, power retention for USB and BLE"] pub type PWR_EXTEND_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWR_RAM30K` reader - RWA, power for main SRAM"] pub type PWR_RAM30K_R = crate :: BitReader ;
#[doc = "Field `PWR_RAM30K` writer - RWA, power for main SRAM"] pub type PWR_RAM30K_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWR_SYS_EN` reader - RWA, power for system"] pub type PWR_SYS_EN_R = crate :: BitReader ;
#[doc = "Field `PWR_SYS_EN` writer - RWA, power for system"] pub type PWR_SYS_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWR_DCDC_EN` reader - RWA, DC/DC converter enable: 0=DC/DC disable and bypass, 1=DC/DC enable"] pub type PWR_DCDC_EN_R = crate :: BitReader ;
#[doc = "Field `PWR_DCDC_EN` writer - RWA, DC/DC converter enable: 0=DC/DC disable and bypass, 1=DC/DC enable"] pub type PWR_DCDC_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWR_DCDC_PRE` reader - RWA, DC/DC converter pre-enable"] pub type PWR_DCDC_PRE_R = crate :: BitReader ;
#[doc = "Field `PWR_DCDC_PRE` writer - RWA, DC/DC converter pre-enable"] pub type PWR_DCDC_PRE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWR_MUST_0010` reader - RWA, power plan enable, auto clear after sleep executed"] pub type PWR_MUST_0010_R = crate :: FieldReader ;
#[doc = "Field `PWR_PLAN_EN` reader - RWA, must write 0010"] pub type PWR_PLAN_EN_R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - RWA, power for retention 2KB SRAM"]
#[inline (always)] pub fn pwr_xrom (& self) -> PWR_XROM_R { PWR_XROM_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RWA, power for retention 2KB SRAM"]
#[inline (always)] pub fn pwr_ram2k (& self) -> PWR_RAM2K_R { PWR_RAM2K_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RWA, power retention for core and base peripherals"]
#[inline (always)] pub fn pwr_core (& self) -> PWR_CORE_R { PWR_CORE_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RWA, power retention for USB and BLE"]
#[inline (always)] pub fn pwr_extend (& self) -> PWR_EXTEND_R { PWR_EXTEND_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RWA, power for main SRAM"]
#[inline (always)] pub fn pwr_ram30k (& self) -> PWR_RAM30K_R { PWR_RAM30K_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 7 - RWA, power for system"]
#[inline (always)] pub fn pwr_sys_en (& self) -> PWR_SYS_EN_R { PWR_SYS_EN_R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 9 - RWA, DC/DC converter enable: 0=DC/DC disable and bypass, 1=DC/DC enable"]
#[inline (always)] pub fn pwr_dcdc_en (& self) -> PWR_DCDC_EN_R { PWR_DCDC_EN_R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - RWA, DC/DC converter pre-enable"]
#[inline (always)] pub fn pwr_dcdc_pre (& self) -> PWR_DCDC_PRE_R { PWR_DCDC_PRE_R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bits 11:14 - RWA, power plan enable, auto clear after sleep executed"]
#[inline (always)] pub fn pwr_must_0010 (& self) -> PWR_MUST_0010_R { PWR_MUST_0010_R :: new (((self . bits >> 11) & 0x0f) as u8) }
#[doc = "Bit 15 - RWA, must write 0010"]
#[inline (always)] pub fn pwr_plan_en (& self) -> PWR_PLAN_EN_R { PWR_PLAN_EN_R :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RWA, power for retention 2KB SRAM"]
#[inline (always)] pub fn pwr_xrom (& mut self) -> PWR_XROM_W < POWER_PLAN_SPEC > { PWR_XROM_W :: new (self , 0) }
#[doc = "Bit 1 - RWA, power for retention 2KB SRAM"]
#[inline (always)] pub fn pwr_ram2k (& mut self) -> PWR_RAM2K_W < POWER_PLAN_SPEC > { PWR_RAM2K_W :: new (self , 1) }
#[doc = "Bit 2 - RWA, power retention for core and base peripherals"]
#[inline (always)] pub fn pwr_core (& mut self) -> PWR_CORE_W < POWER_PLAN_SPEC > { PWR_CORE_W :: new (self , 2) }
#[doc = "Bit 3 - RWA, power retention for USB and BLE"]
#[inline (always)] pub fn pwr_extend (& mut self) -> PWR_EXTEND_W < POWER_PLAN_SPEC > { PWR_EXTEND_W :: new (self , 3) }
#[doc = "Bit 4 - RWA, power for main SRAM"]
#[inline (always)] pub fn pwr_ram30k (& mut self) -> PWR_RAM30K_W < POWER_PLAN_SPEC > { PWR_RAM30K_W :: new (self , 4) }
#[doc = "Bit 7 - RWA, power for system"]
#[inline (always)] pub fn pwr_sys_en (& mut self) -> PWR_SYS_EN_W < POWER_PLAN_SPEC > { PWR_SYS_EN_W :: new (self , 7) }
#[doc = "Bit 9 - RWA, DC/DC converter enable: 0=DC/DC disable and bypass, 1=DC/DC enable"]
#[inline (always)] pub fn pwr_dcdc_en (& mut self) -> PWR_DCDC_EN_W < POWER_PLAN_SPEC > { PWR_DCDC_EN_W :: new (self , 9) }
#[doc = "Bit 10 - RWA, DC/DC converter pre-enable"]
#[inline (always)] pub fn pwr_dcdc_pre (& mut self) -> PWR_DCDC_PRE_W < POWER_PLAN_SPEC > { PWR_DCDC_PRE_W :: new (self , 10) } }
#[doc = "RWA, power plan before sleep instruction, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`power_plan::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`power_plan::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct POWER_PLAN_SPEC ; impl crate :: RegisterSpec for POWER_PLAN_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`power_plan::R`](R) reader structure"] impl crate :: Readable for POWER_PLAN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`power_plan::W`](W) writer structure"] impl crate :: Writable for POWER_PLAN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets POWER_PLAN to value 0x11df"] impl crate :: Resettable for POWER_PLAN_SPEC { const RESET_VALUE : u16 = 0x11df ; } }
#[doc = "AUX_POWER_ADJ (rw) register accessor: RWA, aux power adjust control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`aux_power_adj::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`aux_power_adj::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@aux_power_adj`] module"] pub type AUX_POWER_ADJ = crate :: Reg < aux_power_adj :: AUX_POWER_ADJ_SPEC > ;
#[doc = "RWA, aux power adjust control, SAM"] pub mod aux_power_adj {
#[doc = "Register `AUX_POWER_ADJ` reader"] pub type R = crate :: R < AUX_POWER_ADJ_SPEC > ;
#[doc = "Register `AUX_POWER_ADJ` writer"] pub type W = crate :: W < AUX_POWER_ADJ_SPEC > ;
#[doc = "Field `ULPLDO_ADJ` reader - RWA, Ultra-Low-Power LDO voltage adjust"] pub type ULPLDO_ADJ_R = crate :: FieldReader ;
#[doc = "Field `ULPLDO_ADJ` writer - RWA, Ultra-Low-Power LDO voltage adjust"] pub type ULPLDO_ADJ_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `DCDC_CHARGE` reader - RWA, Ultra-Low-Power LDO voltage adjust"] pub type DCDC_CHARGE_R = crate :: BitReader ;
#[doc = "Field `DCDC_CHARGE` writer - RWA, Ultra-Low-Power LDO voltage adjust"] pub type DCDC_CHARGE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:2 - RWA, Ultra-Low-Power LDO voltage adjust"]
#[inline (always)] pub fn ulpldo_adj (& self) -> ULPLDO_ADJ_R { ULPLDO_ADJ_R :: new (self . bits & 7) }
#[doc = "Bit 7 - RWA, Ultra-Low-Power LDO voltage adjust"]
#[inline (always)] pub fn dcdc_charge (& self) -> DCDC_CHARGE_R { DCDC_CHARGE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:2 - RWA, Ultra-Low-Power LDO voltage adjust"]
#[inline (always)] pub fn ulpldo_adj (& mut self) -> ULPLDO_ADJ_W < AUX_POWER_ADJ_SPEC > { ULPLDO_ADJ_W :: new (self , 0) }
#[doc = "Bit 7 - RWA, Ultra-Low-Power LDO voltage adjust"]
#[inline (always)] pub fn dcdc_charge (& mut self) -> DCDC_CHARGE_W < AUX_POWER_ADJ_SPEC > { DCDC_CHARGE_W :: new (self , 7) } }
#[doc = "RWA, aux power adjust control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`aux_power_adj::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`aux_power_adj::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AUX_POWER_ADJ_SPEC ; impl crate :: RegisterSpec for AUX_POWER_ADJ_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`aux_power_adj::R`](R) reader structure"] impl crate :: Readable for AUX_POWER_ADJ_SPEC { }
#[doc = "`write(|w| ..)` method takes [`aux_power_adj::W`](W) writer structure"] impl crate :: Writable for AUX_POWER_ADJ_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AUX_POWER_ADJ to value 0"] impl crate :: Resettable for AUX_POWER_ADJ_SPEC { } }
#[doc = "BAT_DET_CTRL (rw) register accessor: RWA, battery voltage detector control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`bat_det_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bat_det_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bat_det_ctrl`] module"] pub type BAT_DET_CTRL = crate :: Reg < bat_det_ctrl :: BAT_DET_CTRL_SPEC > ;
#[doc = "RWA, battery voltage detector control, SAM"] pub mod bat_det_ctrl {
#[doc = "Register `BAT_DET_CTRL` reader"] pub type R = crate :: R < BAT_DET_CTRL_SPEC > ;
#[doc = "Register `BAT_DET_CTRL` writer"] pub type W = crate :: W < BAT_DET_CTRL_SPEC > ;
#[doc = "Field `BAT_DET_EN` reader - RWA, battery voltage detector enable/select monitor threshold voltage"] pub type BAT_DET_EN_R = crate :: BitReader ;
#[doc = "Field `BAT_DET_EN` writer - RWA, battery voltage detector enable/select monitor threshold voltage"] pub type BAT_DET_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BAT_LOW_VTHX` reader - RWA, battery voltage detector enable/select monitor threshold voltage"] pub type BAT_LOW_VTHX_R = crate :: BitReader ;
#[doc = "Field `BAT_LOW_VTHX` writer - RWA, battery voltage detector enable/select monitor threshold voltage"] pub type BAT_LOW_VTHX_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BAT_MON_EN` reader - RWA, battery voltage monitor enable under sleep mode"] pub type BAT_MON_EN_R = crate :: BitReader ;
#[doc = "Field `BAT_MON_EN` writer - RWA, battery voltage monitor enable under sleep mode"] pub type BAT_MON_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BAT_LOWER_IE` reader - RWA, interrupt enable for battery lower voltage"] pub type BAT_LOWER_IE_R = crate :: BitReader ;
#[doc = "Field `BAT_LOWER_IE` writer - RWA, interrupt enable for battery lower voltage"] pub type BAT_LOWER_IE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BAT_LOW_IE` reader - RWA, interrupt enable for battery low voltage"] pub type BAT_LOW_IE_R = crate :: BitReader ;
#[doc = "Field `BAT_LOW_IE` writer - RWA, interrupt enable for battery low voltage"] pub type BAT_LOW_IE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RWA, battery voltage detector enable/select monitor threshold voltage"]
#[inline (always)] pub fn bat_det_en (& self) -> BAT_DET_EN_R { BAT_DET_EN_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 0 - RWA, battery voltage detector enable/select monitor threshold voltage"]
#[inline (always)] pub fn bat_low_vthx (& self) -> BAT_LOW_VTHX_R { BAT_LOW_VTHX_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RWA, battery voltage monitor enable under sleep mode"]
#[inline (always)] pub fn bat_mon_en (& self) -> BAT_MON_EN_R { BAT_MON_EN_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RWA, interrupt enable for battery lower voltage"]
#[inline (always)] pub fn bat_lower_ie (& self) -> BAT_LOWER_IE_R { BAT_LOWER_IE_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RWA, interrupt enable for battery low voltage"]
#[inline (always)] pub fn bat_low_ie (& self) -> BAT_LOW_IE_R { BAT_LOW_IE_R :: new (((self . bits >> 3) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RWA, battery voltage detector enable/select monitor threshold voltage"]
#[inline (always)] pub fn bat_det_en (& mut self) -> BAT_DET_EN_W < BAT_DET_CTRL_SPEC > { BAT_DET_EN_W :: new (self , 0) }
#[doc = "Bit 0 - RWA, battery voltage detector enable/select monitor threshold voltage"]
#[inline (always)] pub fn bat_low_vthx (& mut self) -> BAT_LOW_VTHX_W < BAT_DET_CTRL_SPEC > { BAT_LOW_VTHX_W :: new (self , 0) }
#[doc = "Bit 1 - RWA, battery voltage monitor enable under sleep mode"]
#[inline (always)] pub fn bat_mon_en (& mut self) -> BAT_MON_EN_W < BAT_DET_CTRL_SPEC > { BAT_MON_EN_W :: new (self , 1) }
#[doc = "Bit 2 - RWA, interrupt enable for battery lower voltage"]
#[inline (always)] pub fn bat_lower_ie (& mut self) -> BAT_LOWER_IE_W < BAT_DET_CTRL_SPEC > { BAT_LOWER_IE_W :: new (self , 2) }
#[doc = "Bit 3 - RWA, interrupt enable for battery low voltage"]
#[inline (always)] pub fn bat_low_ie (& mut self) -> BAT_LOW_IE_W < BAT_DET_CTRL_SPEC > { BAT_LOW_IE_W :: new (self , 3) } }
#[doc = "RWA, battery voltage detector control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`bat_det_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bat_det_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BAT_DET_CTRL_SPEC ; impl crate :: RegisterSpec for BAT_DET_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`bat_det_ctrl::R`](R) reader structure"] impl crate :: Readable for BAT_DET_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`bat_det_ctrl::W`](W) writer structure"] impl crate :: Writable for BAT_DET_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BAT_DET_CTRL to value 0"] impl crate :: Resettable for BAT_DET_CTRL_SPEC { } }
#[doc = "BAT_DET_CFG (rw) register accessor: RWA, battery voltage detector configuration, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`bat_det_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bat_det_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bat_det_cfg`] module"] pub type BAT_DET_CFG = crate :: Reg < bat_det_cfg :: BAT_DET_CFG_SPEC > ;
#[doc = "RWA, battery voltage detector configuration, SAM"] pub mod bat_det_cfg {
#[doc = "Register `BAT_DET_CFG` reader"] pub type R = crate :: R < BAT_DET_CFG_SPEC > ;
#[doc = "Register `BAT_DET_CFG` writer"] pub type W = crate :: W < BAT_DET_CFG_SPEC > ;
#[doc = "Field `BAT_LOW_VTH` reader - RWA, select threshold voltage of battery voltage low"] pub type BAT_LOW_VTH_R = crate :: FieldReader ;
#[doc = "Field `BAT_LOW_VTH` writer - RWA, select threshold voltage of battery voltage low"] pub type BAT_LOW_VTH_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bits 0:1 - RWA, select threshold voltage of battery voltage low"]
#[inline (always)] pub fn bat_low_vth (& self) -> BAT_LOW_VTH_R { BAT_LOW_VTH_R :: new (self . bits & 3) } } impl W {
#[doc = "Bits 0:1 - RWA, select threshold voltage of battery voltage low"]
#[inline (always)] pub fn bat_low_vth (& mut self) -> BAT_LOW_VTH_W < BAT_DET_CFG_SPEC > { BAT_LOW_VTH_W :: new (self , 0) } }
#[doc = "RWA, battery voltage detector configuration, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`bat_det_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`bat_det_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BAT_DET_CFG_SPEC ; impl crate :: RegisterSpec for BAT_DET_CFG_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`bat_det_cfg::R`](R) reader structure"] impl crate :: Readable for BAT_DET_CFG_SPEC { }
#[doc = "`write(|w| ..)` method takes [`bat_det_cfg::W`](W) writer structure"] impl crate :: Writable for BAT_DET_CFG_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BAT_DET_CFG to value 0x01"] impl crate :: Resettable for BAT_DET_CFG_SPEC { const RESET_VALUE : u8 = 0x01 ; } }
#[doc = "BAT_STATUS (r) register accessor: RO, battery status\n\nYou can [`read`](crate::Reg::read) this register and get [`bat_status::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@bat_status`] module"] pub type BAT_STATUS = crate :: Reg < bat_status :: BAT_STATUS_SPEC > ;
#[doc = "RO, battery status"] pub mod bat_status {
#[doc = "Register `BAT_STATUS` reader"] pub type R = crate :: R < BAT_STATUS_SPEC > ;
#[doc = "Field `BAT_STAT_LOWER` reader - RO, battery lower voltage status, high action"] pub type BAT_STAT_LOWER_R = crate :: BitReader ;
#[doc = "Field `BAT_STAT_LOW` reader - RO, battery low voltage status, high action"] pub type BAT_STAT_LOW_R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - RO, battery lower voltage status, high action"]
#[inline (always)] pub fn bat_stat_lower (& self) -> BAT_STAT_LOWER_R { BAT_STAT_LOWER_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RO, battery low voltage status, high action"]
#[inline (always)] pub fn bat_stat_low (& self) -> BAT_STAT_LOW_R { BAT_STAT_LOW_R :: new (((self . bits >> 1) & 1) != 0) } }
#[doc = "RO, battery status\n\nYou can [`read`](crate::Reg::read) this register and get [`bat_status::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BAT_STATUS_SPEC ; impl crate :: RegisterSpec for BAT_STATUS_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`bat_status::R`](R) reader structure"] impl crate :: Readable for BAT_STATUS_SPEC { }
#[doc = "`reset()` method sets BAT_STATUS to value 0"] impl crate :: Resettable for BAT_STATUS_SPEC { } }
#[doc = "INT32K_TUNE (rw) register accessor: RWA, internal 32KHz oscillator tune control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`int32k_tune::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int32k_tune::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int32k_tune`] module"] pub type INT32K_TUNE = crate :: Reg < int32k_tune :: INT32K_TUNE_SPEC > ;
#[doc = "RWA, internal 32KHz oscillator tune control, SAM"] pub mod int32k_tune {
#[doc = "Register `INT32K_TUNE` reader"] pub type R = crate :: R < INT32K_TUNE_SPEC > ;
#[doc = "Register `INT32K_TUNE` writer"] pub type W = crate :: W < INT32K_TUNE_SPEC > ;
#[doc = "Field `INT32K_TUNE` reader - RWA, internal 32KHz oscillator frequency tune"] pub type INT32K_TUNE_R = crate :: FieldReader < u16 > ;
#[doc = "Field `INT32K_TUNE` writer - RWA, internal 32KHz oscillator frequency tune"] pub type INT32K_TUNE_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 13 , u16 > ; impl R {
#[doc = "Bits 0:12 - RWA, internal 32KHz oscillator frequency tune"]
#[inline (always)] pub fn int32k_tune (& self) -> INT32K_TUNE_R { INT32K_TUNE_R :: new (self . bits & 0x1fff) } } impl W {
#[doc = "Bits 0:12 - RWA, internal 32KHz oscillator frequency tune"]
#[inline (always)] pub fn int32k_tune (& mut self) -> INT32K_TUNE_W < INT32K_TUNE_SPEC > { INT32K_TUNE_W :: new (self , 0) } }
#[doc = "RWA, internal 32KHz oscillator tune control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`int32k_tune::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int32k_tune::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT32K_TUNE_SPEC ; impl crate :: RegisterSpec for INT32K_TUNE_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`int32k_tune::R`](R) reader structure"] impl crate :: Readable for INT32K_TUNE_SPEC { }
#[doc = "`write(|w| ..)` method takes [`int32k_tune::W`](W) writer structure"] impl crate :: Writable for INT32K_TUNE_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INT32K_TUNE to value 0x1011"] impl crate :: Resettable for INT32K_TUNE_SPEC { const RESET_VALUE : u16 = 0x1011 ; } }
#[doc = "XT32K_TUNE (rw) register accessor: RWA, external 32KHz oscillator tune control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`xt32k_tune::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`xt32k_tune::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@xt32k_tune`] module"] pub type XT32K_TUNE = crate :: Reg < xt32k_tune :: XT32K_TUNE_SPEC > ;
#[doc = "RWA, external 32KHz oscillator tune control, SAM"] pub mod xt32k_tune {
#[doc = "Register `XT32K_TUNE` reader"] pub type R = crate :: R < XT32K_TUNE_SPEC > ;
#[doc = "Register `XT32K_TUNE` writer"] pub type W = crate :: W < XT32K_TUNE_SPEC > ;
#[doc = "Field `XT32K_I_TUNE` reader - RWA, external 32KHz oscillator current tune: 00=75% current, 01=standard current, 10=150% current, 11=200% current"] pub type XT32K_I_TUNE_R = crate :: FieldReader ;
#[doc = "Field `XT32K_I_TUNE` writer - RWA, external 32KHz oscillator current tune: 00=75% current, 01=standard current, 10=150% current, 11=200% current"] pub type XT32K_I_TUNE_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `XT32K_C_LOAD` reader - RWA, external 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF"] pub type XT32K_C_LOAD_R = crate :: FieldReader ;
#[doc = "Field `XT32K_C_LOAD` writer - RWA, external 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF"] pub type XT32K_C_LOAD_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:1 - RWA, external 32KHz oscillator current tune: 00=75% current, 01=standard current, 10=150% current, 11=200% current"]
#[inline (always)] pub fn xt32k_i_tune (& self) -> XT32K_I_TUNE_R { XT32K_I_TUNE_R :: new (self . bits & 3) }
#[doc = "Bits 4:7 - RWA, external 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF"]
#[inline (always)] pub fn xt32k_c_load (& self) -> XT32K_C_LOAD_R { XT32K_C_LOAD_R :: new ((self . bits >> 4) & 0x0f) } } impl W {
#[doc = "Bits 0:1 - RWA, external 32KHz oscillator current tune: 00=75% current, 01=standard current, 10=150% current, 11=200% current"]
#[inline (always)] pub fn xt32k_i_tune (& mut self) -> XT32K_I_TUNE_W < XT32K_TUNE_SPEC > { XT32K_I_TUNE_W :: new (self , 0) }
#[doc = "Bits 4:7 - RWA, external 32KHz oscillator load capacitor tune: Cap = RB_XT32K_C_LOAD + 12pF"]
#[inline (always)] pub fn xt32k_c_load (& mut self) -> XT32K_C_LOAD_W < XT32K_TUNE_SPEC > { XT32K_C_LOAD_W :: new (self , 4) } }
#[doc = "RWA, external 32KHz oscillator tune control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`xt32k_tune::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`xt32k_tune::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct XT32K_TUNE_SPEC ; impl crate :: RegisterSpec for XT32K_TUNE_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`xt32k_tune::R`](R) reader structure"] impl crate :: Readable for XT32K_TUNE_SPEC { }
#[doc = "`write(|w| ..)` method takes [`xt32k_tune::W`](W) writer structure"] impl crate :: Writable for XT32K_TUNE_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets XT32K_TUNE to value 0xc3"] impl crate :: Resettable for XT32K_TUNE_SPEC { const RESET_VALUE : u8 = 0xc3 ; } }
#[doc = "CK32K_CONFIG (rw) register accessor: RWA, 32KHz oscillator configure\n\nYou can [`read`](crate::Reg::read) this register and get [`ck32k_config::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ck32k_config::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ck32k_config`] module"] pub type CK32K_CONFIG = crate :: Reg < ck32k_config :: CK32K_CONFIG_SPEC > ;
#[doc = "RWA, 32KHz oscillator configure"] pub mod ck32k_config {
#[doc = "Register `CK32K_CONFIG` reader"] pub type R = crate :: R < CK32K_CONFIG_SPEC > ;
#[doc = "Register `CK32K_CONFIG` writer"] pub type W = crate :: W < CK32K_CONFIG_SPEC > ;
#[doc = "Field `CLK_XT32K_PON` reader - RWA, external 32KHz oscillator power on"] pub type CLK_XT32K_PON_R = crate :: BitReader ;
#[doc = "Field `CLK_XT32K_PON` writer - RWA, external 32KHz oscillator power on"] pub type CLK_XT32K_PON_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CLK_INT32K_PON` reader - RWA, internal 32KHz oscillator power on"] pub type CLK_INT32K_PON_R = crate :: BitReader ;
#[doc = "Field `CLK_INT32K_PON` writer - RWA, internal 32KHz oscillator power on"] pub type CLK_INT32K_PON_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CLK_OSC32K_XT` reader - RWA, 32KHz oscillator source selection: 0=RC, 1=XT"] pub type CLK_OSC32K_XT_R = crate :: BitReader ;
#[doc = "Field `CLK_OSC32K_XT` writer - RWA, 32KHz oscillator source selection: 0=RC, 1=XT"] pub type CLK_OSC32K_XT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CLK_OSC32K_FILT` reader - RWA, internal 32KHz oscillator low noise mode enable"] pub type CLK_OSC32K_FILT_R = crate :: BitReader ;
#[doc = "Field `CLK_OSC32K_FILT` writer - RWA, internal 32KHz oscillator low noise mode enable"] pub type CLK_OSC32K_FILT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CLK_32K_PIN` reader - RO, 32KHz oscillator clock pin status"] pub type CLK_32K_PIN_R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - RWA, external 32KHz oscillator power on"]
#[inline (always)] pub fn clk_xt32k_pon (& self) -> CLK_XT32K_PON_R { CLK_XT32K_PON_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RWA, internal 32KHz oscillator power on"]
#[inline (always)] pub fn clk_int32k_pon (& self) -> CLK_INT32K_PON_R { CLK_INT32K_PON_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RWA, 32KHz oscillator source selection: 0=RC, 1=XT"]
#[inline (always)] pub fn clk_osc32k_xt (& self) -> CLK_OSC32K_XT_R { CLK_OSC32K_XT_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RWA, internal 32KHz oscillator low noise mode enable"]
#[inline (always)] pub fn clk_osc32k_filt (& self) -> CLK_OSC32K_FILT_R { CLK_OSC32K_FILT_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 7 - RO, 32KHz oscillator clock pin status"]
#[inline (always)] pub fn clk_32k_pin (& self) -> CLK_32K_PIN_R { CLK_32K_PIN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RWA, external 32KHz oscillator power on"]
#[inline (always)] pub fn clk_xt32k_pon (& mut self) -> CLK_XT32K_PON_W < CK32K_CONFIG_SPEC > { CLK_XT32K_PON_W :: new (self , 0) }
#[doc = "Bit 1 - RWA, internal 32KHz oscillator power on"]
#[inline (always)] pub fn clk_int32k_pon (& mut self) -> CLK_INT32K_PON_W < CK32K_CONFIG_SPEC > { CLK_INT32K_PON_W :: new (self , 1) }
#[doc = "Bit 2 - RWA, 32KHz oscillator source selection: 0=RC, 1=XT"]
#[inline (always)] pub fn clk_osc32k_xt (& mut self) -> CLK_OSC32K_XT_W < CK32K_CONFIG_SPEC > { CLK_OSC32K_XT_W :: new (self , 2) }
#[doc = "Bit 3 - RWA, internal 32KHz oscillator low noise mode enable"]
#[inline (always)] pub fn clk_osc32k_filt (& mut self) -> CLK_OSC32K_FILT_W < CK32K_CONFIG_SPEC > { CLK_OSC32K_FILT_W :: new (self , 3) } }
#[doc = "RWA, 32KHz oscillator configure\n\nYou can [`read`](crate::Reg::read) this register and get [`ck32k_config::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ck32k_config::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CK32K_CONFIG_SPEC ; impl crate :: RegisterSpec for CK32K_CONFIG_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`ck32k_config::R`](R) reader structure"] impl crate :: Readable for CK32K_CONFIG_SPEC { }
#[doc = "`write(|w| ..)` method takes [`ck32k_config::W`](W) writer structure"] impl crate :: Writable for CK32K_CONFIG_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CK32K_CONFIG to value 0x02"] impl crate :: Resettable for CK32K_CONFIG_SPEC { const RESET_VALUE : u8 = 0x02 ; } }
#[doc = "RTC_FLAG_CTRL (rw) register accessor: RW, RTC flag and clear control\n\nYou can [`read`](crate::Reg::read) this register and get [`rtc_flag_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtc_flag_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rtc_flag_ctrl`] module"] pub type RTC_FLAG_CTRL = crate :: Reg < rtc_flag_ctrl :: RTC_FLAG_CTRL_SPEC > ;
#[doc = "RW, RTC flag and clear control"] pub mod rtc_flag_ctrl {
#[doc = "Register `RTC_FLAG_CTRL` reader"] pub type R = crate :: R < RTC_FLAG_CTRL_SPEC > ;
#[doc = "Register `RTC_FLAG_CTRL` writer"] pub type W = crate :: W < RTC_FLAG_CTRL_SPEC > ;
#[doc = "Field `RTC_TMR_CLR` reader - RW, set 1 to clear RTC timer action flag, auto clear"] pub type RTC_TMR_CLR_R = crate :: BitReader ;
#[doc = "Field `RTC_TMR_CLR` writer - RW, set 1 to clear RTC timer action flag, auto clear"] pub type RTC_TMR_CLR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RTC_TRIG_CLR` reader - RW, set 1 to clear RTC trigger action flag, auto clear"] pub type RTC_TRIG_CLR_R = crate :: BitReader ;
#[doc = "Field `RTC_TRIG_CLR` writer - RW, set 1 to clear RTC trigger action flag, auto clear"] pub type RTC_TRIG_CLR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RTC_TMR_FLAG` reader - RO, RTC timer action flag"] pub type RTC_TMR_FLAG_R = crate :: BitReader ;
#[doc = "Field `RTC_TRIG_FLAG` reader - RO, RTC trigger action flag"] pub type RTC_TRIG_FLAG_R = crate :: BitReader ; impl R {
#[doc = "Bit 4 - RW, set 1 to clear RTC timer action flag, auto clear"]
#[inline (always)] pub fn rtc_tmr_clr (& self) -> RTC_TMR_CLR_R { RTC_TMR_CLR_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RW, set 1 to clear RTC trigger action flag, auto clear"]
#[inline (always)] pub fn rtc_trig_clr (& self) -> RTC_TRIG_CLR_R { RTC_TRIG_CLR_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RO, RTC timer action flag"]
#[inline (always)] pub fn rtc_tmr_flag (& self) -> RTC_TMR_FLAG_R { RTC_TMR_FLAG_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RO, RTC trigger action flag"]
#[inline (always)] pub fn rtc_trig_flag (& self) -> RTC_TRIG_FLAG_R { RTC_TRIG_FLAG_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 4 - RW, set 1 to clear RTC timer action flag, auto clear"]
#[inline (always)] pub fn rtc_tmr_clr (& mut self) -> RTC_TMR_CLR_W < RTC_FLAG_CTRL_SPEC > { RTC_TMR_CLR_W :: new (self , 4) }
#[doc = "Bit 5 - RW, set 1 to clear RTC trigger action flag, auto clear"]
#[inline (always)] pub fn rtc_trig_clr (& mut self) -> RTC_TRIG_CLR_W < RTC_FLAG_CTRL_SPEC > { RTC_TRIG_CLR_W :: new (self , 5) } }
#[doc = "RW, RTC flag and clear control\n\nYou can [`read`](crate::Reg::read) this register and get [`rtc_flag_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtc_flag_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RTC_FLAG_CTRL_SPEC ; impl crate :: RegisterSpec for RTC_FLAG_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`rtc_flag_ctrl::R`](R) reader structure"] impl crate :: Readable for RTC_FLAG_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`rtc_flag_ctrl::W`](W) writer structure"] impl crate :: Writable for RTC_FLAG_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RTC_FLAG_CTRL to value 0x30"] impl crate :: Resettable for RTC_FLAG_CTRL_SPEC { const RESET_VALUE : u8 = 0x30 ; } }
#[doc = "RTC_MODE_CTRL (rw) register accessor: RWA, RTC mode control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`rtc_mode_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtc_mode_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rtc_mode_ctrl`] module"] pub type RTC_MODE_CTRL = crate :: Reg < rtc_mode_ctrl :: RTC_MODE_CTRL_SPEC > ;
#[doc = "RWA, RTC mode control, SAM"] pub mod rtc_mode_ctrl {
#[doc = "Register `RTC_MODE_CTRL` reader"] pub type R = crate :: R < RTC_MODE_CTRL_SPEC > ;
#[doc = "Register `RTC_MODE_CTRL` writer"] pub type W = crate :: W < RTC_MODE_CTRL_SPEC > ;
#[doc = "Field `RTC_TMR_MODE` reader - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S"] pub type RTC_TMR_MODE_R = crate :: FieldReader ;
#[doc = "Field `RTC_TMR_MODE` writer - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S"] pub type RTC_TMR_MODE_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `RTC_IGNORE_B0` reader - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0"] pub type RTC_IGNORE_B0_R = crate :: BitReader ;
#[doc = "Field `RTC_IGNORE_B0` writer - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0"] pub type RTC_IGNORE_B0_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RTC_TMR_EN` reader - RWA, RTC timer mode enable"] pub type RTC_TMR_EN_R = crate :: BitReader ;
#[doc = "Field `RTC_TMR_EN` writer - RWA, RTC timer mode enable"] pub type RTC_TMR_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RTC_TRIG_EN` reader - RWA, RTC trigger mode enable"] pub type RTC_TRIG_EN_R = crate :: BitReader ;
#[doc = "Field `RTC_TRIG_EN` writer - RWA, RTC trigger mode enable"] pub type RTC_TRIG_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RTC_LOAD_LO` reader - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded"] pub type RTC_LOAD_LO_R = crate :: BitReader ;
#[doc = "Field `RTC_LOAD_LO` writer - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded"] pub type RTC_LOAD_LO_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `RTC_LOAD_HI` reader - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded"] pub type RTC_LOAD_HI_R = crate :: BitReader ;
#[doc = "Field `RTC_LOAD_HI` writer - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded"] pub type RTC_LOAD_HI_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:2 - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S"]
#[inline (always)] pub fn rtc_tmr_mode (& self) -> RTC_TMR_MODE_R { RTC_TMR_MODE_R :: new (self . bits & 7) }
#[doc = "Bit 3 - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0"]
#[inline (always)] pub fn rtc_ignore_b0 (& self) -> RTC_IGNORE_B0_R { RTC_IGNORE_B0_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RWA, RTC timer mode enable"]
#[inline (always)] pub fn rtc_tmr_en (& self) -> RTC_TMR_EN_R { RTC_TMR_EN_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RWA, RTC trigger mode enable"]
#[inline (always)] pub fn rtc_trig_en (& self) -> RTC_TRIG_EN_R { RTC_TRIG_EN_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded"]
#[inline (always)] pub fn rtc_load_lo (& self) -> RTC_LOAD_LO_R { RTC_LOAD_LO_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded"]
#[inline (always)] pub fn rtc_load_hi (& self) -> RTC_LOAD_HI_R { RTC_LOAD_HI_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:2 - RWA, RTC timer mode: 000=0.125S, 001=0.25S, 010=0.5S, 011=1S, 100=2S, 101=4S, 110=8S, 111=16S"]
#[inline (always)] pub fn rtc_tmr_mode (& mut self) -> RTC_TMR_MODE_W < RTC_MODE_CTRL_SPEC > { RTC_TMR_MODE_W :: new (self , 0) }
#[doc = "Bit 3 - RWA, force ignore bit0 for trigger mode: 0=compare bit0, 1=ignore bit0"]
#[inline (always)] pub fn rtc_ignore_b0 (& mut self) -> RTC_IGNORE_B0_W < RTC_MODE_CTRL_SPEC > { RTC_IGNORE_B0_W :: new (self , 3) }
#[doc = "Bit 4 - RWA, RTC timer mode enable"]
#[inline (always)] pub fn rtc_tmr_en (& mut self) -> RTC_TMR_EN_W < RTC_MODE_CTRL_SPEC > { RTC_TMR_EN_W :: new (self , 4) }
#[doc = "Bit 5 - RWA, RTC trigger mode enable"]
#[inline (always)] pub fn rtc_trig_en (& mut self) -> RTC_TRIG_EN_W < RTC_MODE_CTRL_SPEC > { RTC_TRIG_EN_W :: new (self , 5) }
#[doc = "Bit 6 - RWA, set 1 to load RTC count low word R32_RTC_CNT_32K, auto clear after loaded"]
#[inline (always)] pub fn rtc_load_lo (& mut self) -> RTC_LOAD_LO_W < RTC_MODE_CTRL_SPEC > { RTC_LOAD_LO_W :: new (self , 6) }
#[doc = "Bit 7 - RWA, set 1 to load RTC count high word R32_RTC_CNT_DAY, auto clear after loaded"]
#[inline (always)] pub fn rtc_load_hi (& mut self) -> RTC_LOAD_HI_W < RTC_MODE_CTRL_SPEC > { RTC_LOAD_HI_W :: new (self , 7) } }
#[doc = "RWA, RTC mode control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`rtc_mode_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtc_mode_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RTC_MODE_CTRL_SPEC ; impl crate :: RegisterSpec for RTC_MODE_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`rtc_mode_ctrl::R`](R) reader structure"] impl crate :: Readable for RTC_MODE_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`rtc_mode_ctrl::W`](W) writer structure"] impl crate :: Writable for RTC_MODE_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RTC_MODE_CTRL to value 0x02"] impl crate :: Resettable for RTC_MODE_CTRL_SPEC { const RESET_VALUE : u8 = 0x02 ; } }
#[doc = "RTC_TRIG (rw) register accessor: RWA, RTC trigger value, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`rtc_trig::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtc_trig::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rtc_trig`] module"] pub type RTC_TRIG = crate :: Reg < rtc_trig :: RTC_TRIG_SPEC > ;
#[doc = "RWA, RTC trigger value, SAM"] pub mod rtc_trig {
#[doc = "Register `RTC_TRIG` reader"] pub type R = crate :: R < RTC_TRIG_SPEC > ;
#[doc = "Register `RTC_TRIG` writer"] pub type W = crate :: W < RTC_TRIG_SPEC > ;
#[doc = "Field `RTC_TRIG` reader - RWA, RTC trigger value"] pub type RTC_TRIG_R = crate :: FieldReader < u32 > ;
#[doc = "Field `RTC_TRIG` writer - RWA, RTC trigger value"] pub type RTC_TRIG_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RWA, RTC trigger value"]
#[inline (always)] pub fn rtc_trig (& self) -> RTC_TRIG_R { RTC_TRIG_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RWA, RTC trigger value"]
#[inline (always)] pub fn rtc_trig (& mut self) -> RTC_TRIG_W < RTC_TRIG_SPEC > { RTC_TRIG_W :: new (self , 0) } }
#[doc = "RWA, RTC trigger value, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`rtc_trig::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtc_trig::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RTC_TRIG_SPEC ; impl crate :: RegisterSpec for RTC_TRIG_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`rtc_trig::R`](R) reader structure"] impl crate :: Readable for RTC_TRIG_SPEC { }
#[doc = "`write(|w| ..)` method takes [`rtc_trig::W`](W) writer structure"] impl crate :: Writable for RTC_TRIG_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RTC_TRIG to value 0"] impl crate :: Resettable for RTC_TRIG_SPEC { } }
#[doc = "RTC_CNT_32K (r) register accessor: RO, RTC count based 32KHz\n\nYou can [`read`](crate::Reg::read) this register and get [`rtc_cnt_32k::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rtc_cnt_32k`] module"] pub type RTC_CNT_32K = crate :: Reg < rtc_cnt_32k :: RTC_CNT_32K_SPEC > ;
#[doc = "RO, RTC count based 32KHz"] pub mod rtc_cnt_32k {
#[doc = "Register `RTC_CNT_32K` reader"] pub type R = crate :: R < RTC_CNT_32K_SPEC > ;
#[doc = "Field `RTC_CNT_32K` reader - RWA,RTC count based 32KHz"] pub type RTC_CNT_32K_R = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - RWA,RTC count based 32KHz"]
#[inline (always)] pub fn rtc_cnt_32k (& self) -> RTC_CNT_32K_R { RTC_CNT_32K_R :: new (self . bits) } }
#[doc = "RO, RTC count based 32KHz\n\nYou can [`read`](crate::Reg::read) this register and get [`rtc_cnt_32k::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RTC_CNT_32K_SPEC ; impl crate :: RegisterSpec for RTC_CNT_32K_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`rtc_cnt_32k::R`](R) reader structure"] impl crate :: Readable for RTC_CNT_32K_SPEC { }
#[doc = "`reset()` method sets RTC_CNT_32K to value 0"] impl crate :: Resettable for RTC_CNT_32K_SPEC { } }
#[doc = "RTC_CNT_2S (r) register accessor: RO, RTC count based 2 second\n\nYou can [`read`](crate::Reg::read) this register and get [`rtc_cnt_2s::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rtc_cnt_2s`] module"] pub type RTC_CNT_2S = crate :: Reg < rtc_cnt_2s :: RTC_CNT_2S_SPEC > ;
#[doc = "RO, RTC count based 2 second"] pub mod rtc_cnt_2s {
#[doc = "Register `RTC_CNT_2S` reader"] pub type R = crate :: R < RTC_CNT_2S_SPEC > ;
#[doc = "Field `RTC_CNT_2S` reader - RO, RTC count based 2 second"] pub type RTC_CNT_2S_R = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - RO, RTC count based 2 second"]
#[inline (always)] pub fn rtc_cnt_2s (& self) -> RTC_CNT_2S_R { RTC_CNT_2S_R :: new (self . bits) } }
#[doc = "RO, RTC count based 2 second\n\nYou can [`read`](crate::Reg::read) this register and get [`rtc_cnt_2s::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RTC_CNT_2S_SPEC ; impl crate :: RegisterSpec for RTC_CNT_2S_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`rtc_cnt_2s::R`](R) reader structure"] impl crate :: Readable for RTC_CNT_2S_SPEC { }
#[doc = "`reset()` method sets RTC_CNT_2S to value 0"] impl crate :: Resettable for RTC_CNT_2S_SPEC { } }
#[doc = "RTC_CNT_DAY (r) register accessor: RO, RTC count based one day, only low 14 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`rtc_cnt_day::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rtc_cnt_day`] module"] pub type RTC_CNT_DAY = crate :: Reg < rtc_cnt_day :: RTC_CNT_DAY_SPEC > ;
#[doc = "RO, RTC count based one day, only low 14 bit"] pub mod rtc_cnt_day {
#[doc = "Register `RTC_CNT_DAY` reader"] pub type R = crate :: R < RTC_CNT_DAY_SPEC > ;
#[doc = "Field `RTC_CNT_DAY` reader - RWA,RTC count based one day"] pub type RTC_CNT_DAY_R = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:13 - RWA,RTC count based one day"]
#[inline (always)] pub fn rtc_cnt_day (& self) -> RTC_CNT_DAY_R { RTC_CNT_DAY_R :: new ((self . bits & 0x3fff) as u16) } }
#[doc = "RO, RTC count based one day, only low 14 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`rtc_cnt_day::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RTC_CNT_DAY_SPEC ; impl crate :: RegisterSpec for RTC_CNT_DAY_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`rtc_cnt_day::R`](R) reader structure"] impl crate :: Readable for RTC_CNT_DAY_SPEC { }
#[doc = "`reset()` method sets RTC_CNT_DAY to value 0"] impl crate :: Resettable for RTC_CNT_DAY_SPEC { } }
#[doc = "SAFE_ACCESS_SIG (rw) register accessor: WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode\n\nYou can [`read`](crate::Reg::read) this register and get [`safe_access_sig::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`safe_access_sig::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@safe_access_sig`] module"] pub type SAFE_ACCESS_SIG = crate :: Reg < safe_access_sig :: SAFE_ACCESS_SIG_SPEC > ;
#[doc = "WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode"] pub mod safe_access_sig {
#[doc = "Register `SAFE_ACCESS_SIG` reader"] pub type R = crate :: R < SAFE_ACCESS_SIG_SPEC > ;
#[doc = "Register `SAFE_ACCESS_SIG` writer"] pub type W = crate :: W < SAFE_ACCESS_SIG_SPEC > ;
#[doc = "Field `SAFE_ACC_MODE` reader - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)"] pub type SAFE_ACC_MODE_R = crate :: FieldReader ;
#[doc = "Field `SAFE_ACC_MODE` writer - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)"] pub type SAFE_ACC_MODE_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `SAFE_ACCESS_SIG` reader - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode"] pub type SAFE_ACCESS_SIG_R = crate :: FieldReader ;
#[doc = "Field `SAFE_ACCESS_SIG` writer - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode"] pub type SAFE_ACCESS_SIG_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `SAFE_ACC_ACT` reader - RO, indicate safe accessing status now: 0=locked, read only, 1=safe/unlocked (SAM), write enabled"] pub type SAFE_ACC_ACT_R = crate :: BitReader ;
#[doc = "Field `SAFE_ACC_ACT` writer - RO, indicate safe accessing status now: 0=locked, read only, 1=safe/unlocked (SAM), write enabled"] pub type SAFE_ACC_ACT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SAFE_ACC_TIMER` reader - RO, safe accessing timer bit mask (16*clock number)"] pub type SAFE_ACC_TIMER_R = crate :: FieldReader ;
#[doc = "Field `SAFE_ACC_TIMER` writer - RO, safe accessing timer bit mask (16*clock number)"] pub type SAFE_ACC_TIMER_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:1 - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)"]
#[inline (always)] pub fn safe_acc_mode (& self) -> SAFE_ACC_MODE_R { SAFE_ACC_MODE_R :: new (self . bits & 3) }
#[doc = "Bits 0:7 - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode"]
#[inline (always)] pub fn safe_access_sig (& self) -> SAFE_ACCESS_SIG_R { SAFE_ACCESS_SIG_R :: new (self . bits) }
#[doc = "Bit 3 - RO, indicate safe accessing status now: 0=locked, read only, 1=safe/unlocked (SAM), write enabled"]
#[inline (always)] pub fn safe_acc_act (& self) -> SAFE_ACC_ACT_R { SAFE_ACC_ACT_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:6 - RO, safe accessing timer bit mask (16*clock number)"]
#[inline (always)] pub fn safe_acc_timer (& self) -> SAFE_ACC_TIMER_R { SAFE_ACC_TIMER_R :: new ((self . bits >> 4) & 7) } } impl W {
#[doc = "Bits 0:1 - RO, current safe accessing mode: 11=safe unlocked (SAM), other=locked (00..01..10..11)"]
#[inline (always)] pub fn safe_acc_mode (& mut self) -> SAFE_ACC_MODE_W < SAFE_ACCESS_SIG_SPEC > { SAFE_ACC_MODE_W :: new (self , 0) }
#[doc = "Bits 0:7 - WO, safe accessing sign register, must write 0x57 then 0xA8 to enter safe accessing mode"]
#[inline (always)] pub fn safe_access_sig (& mut self) -> SAFE_ACCESS_SIG_W < SAFE_ACCESS_SIG_SPEC > { SAFE_ACCESS_SIG_W :: new (self , 0) }
#[doc = "Bit 3 - RO, indicate safe accessing status now: 0=locked, read only, 1=safe/unlocked (SAM), write enabled"]
#[inline (always)] pub fn safe_acc_act (& mut self) -> SAFE_ACC_ACT_W < SAFE_ACCESS_SIG_SPEC > { SAFE_ACC_ACT_W :: new (self , 3) }
#[doc = "Bits 4:6 - RO, safe accessing timer bit mask (16*clock number)"]
#[inline (always)] pub fn safe_acc_timer (& mut self) -> SAFE_ACC_TIMER_W < SAFE_ACCESS_SIG_SPEC > { SAFE_ACC_TIMER_W :: new (self , 4) } }
#[doc = "WO, safe accessing sign register, must write SAFE_ACCESS_SIG1 then SAFE_ACCESS_SIG2 to enter safe accessing mode\n\nYou can [`read`](crate::Reg::read) this register and get [`safe_access_sig::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`safe_access_sig::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SAFE_ACCESS_SIG_SPEC ; impl crate :: RegisterSpec for SAFE_ACCESS_SIG_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`safe_access_sig::R`](R) reader structure"] impl crate :: Readable for SAFE_ACCESS_SIG_SPEC { }
#[doc = "`write(|w| ..)` method takes [`safe_access_sig::W`](W) writer structure"] impl crate :: Writable for SAFE_ACCESS_SIG_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SAFE_ACCESS_SIG to value 0"] impl crate :: Resettable for SAFE_ACCESS_SIG_SPEC { } }
#[doc = "CHIP_ID (r) register accessor: RF, chip ID register, always is ID_CH58*\n\nYou can [`read`](crate::Reg::read) this register and get [`chip_id::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@chip_id`] module"] pub type CHIP_ID = crate :: Reg < chip_id :: CHIP_ID_SPEC > ;
#[doc = "RF, chip ID register, always is ID_CH58*"] pub mod chip_id {
#[doc = "Register `CHIP_ID` reader"] pub type R = crate :: R < CHIP_ID_SPEC > ;
#[doc = "Field `CHIP_ID` reader - RF,chip ID register"] pub type CHIP_ID_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RF,chip ID register"]
#[inline (always)] pub fn chip_id (& self) -> CHIP_ID_R { CHIP_ID_R :: new (self . bits) } }
#[doc = "RF, chip ID register, always is ID_CH58*\n\nYou can [`read`](crate::Reg::read) this register and get [`chip_id::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CHIP_ID_SPEC ; impl crate :: RegisterSpec for CHIP_ID_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`chip_id::R`](R) reader structure"] impl crate :: Readable for CHIP_ID_SPEC { }
#[doc = "`reset()` method sets CHIP_ID to value 0x83"] impl crate :: Resettable for CHIP_ID_SPEC { const RESET_VALUE : u8 = 0x83 ; } }
#[doc = "SAFE_ACCESS_ID (r) register accessor: RF, safe accessing ID register, always 0x0C\n\nYou can [`read`](crate::Reg::read) this register and get [`safe_access_id::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@safe_access_id`] module"] pub type SAFE_ACCESS_ID = crate :: Reg < safe_access_id :: SAFE_ACCESS_ID_SPEC > ;
#[doc = "RF, safe accessing ID register, always 0x0C"] pub mod safe_access_id {
#[doc = "Register `SAFE_ACCESS_ID` reader"] pub type R = crate :: R < SAFE_ACCESS_ID_SPEC > ;
#[doc = "Field `SAFE_ACCESS_ID` reader - RF,safe accessing ID register"] pub type SAFE_ACCESS_ID_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RF,safe accessing ID register"]
#[inline (always)] pub fn safe_access_id (& self) -> SAFE_ACCESS_ID_R { SAFE_ACCESS_ID_R :: new (self . bits) } }
#[doc = "RF, safe accessing ID register, always 0x0C\n\nYou can [`read`](crate::Reg::read) this register and get [`safe_access_id::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SAFE_ACCESS_ID_SPEC ; impl crate :: RegisterSpec for SAFE_ACCESS_ID_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`safe_access_id::R`](R) reader structure"] impl crate :: Readable for SAFE_ACCESS_ID_SPEC { }
#[doc = "`reset()` method sets SAFE_ACCESS_ID to value 0x0c"] impl crate :: Resettable for SAFE_ACCESS_ID_SPEC { const RESET_VALUE : u8 = 0x0c ; } }
#[doc = "WDOG_COUNT (rw) register accessor: RW, watch-dog count, count by clock frequency Fsys/131072\n\nYou can [`read`](crate::Reg::read) this register and get [`wdog_count::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`wdog_count::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@wdog_count`] module"] pub type WDOG_COUNT = crate :: Reg < wdog_count :: WDOG_COUNT_SPEC > ;
#[doc = "RW, watch-dog count, count by clock frequency Fsys/131072"] pub mod wdog_count {
#[doc = "Register `WDOG_COUNT` reader"] pub type R = crate :: R < WDOG_COUNT_SPEC > ;
#[doc = "Register `WDOG_COUNT` writer"] pub type W = crate :: W < WDOG_COUNT_SPEC > ;
#[doc = "Field `WDOG_COUNT` reader - RF,watch-dog count, count by clock frequency Fsys/131072"] pub type WDOG_COUNT_R = crate :: FieldReader ;
#[doc = "Field `WDOG_COUNT` writer - RF,watch-dog count, count by clock frequency Fsys/131072"] pub type WDOG_COUNT_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RF,watch-dog count, count by clock frequency Fsys/131072"]
#[inline (always)] pub fn wdog_count (& self) -> WDOG_COUNT_R { WDOG_COUNT_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RF,watch-dog count, count by clock frequency Fsys/131072"]
#[inline (always)] pub fn wdog_count (& mut self) -> WDOG_COUNT_W < WDOG_COUNT_SPEC > { WDOG_COUNT_W :: new (self , 0) } }
#[doc = "RW, watch-dog count, count by clock frequency Fsys/131072\n\nYou can [`read`](crate::Reg::read) this register and get [`wdog_count::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`wdog_count::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct WDOG_COUNT_SPEC ; impl crate :: RegisterSpec for WDOG_COUNT_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`wdog_count::R`](R) reader structure"] impl crate :: Readable for WDOG_COUNT_SPEC { }
#[doc = "`write(|w| ..)` method takes [`wdog_count::W`](W) writer structure"] impl crate :: Writable for WDOG_COUNT_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets WDOG_COUNT to value 0"] impl crate :: Resettable for WDOG_COUNT_SPEC { } }
#[doc = "RESET_STATUS_R8_GLOB_ROM_CFG (r) register accessor: RWA, reset status, SAM or flash ROM configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`reset_status_r8_glob_rom_cfg::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@reset_status_r8_glob_rom_cfg`] module"] pub type RESET_STATUS_R8_GLOB_ROM_CFG = crate :: Reg < reset_status_r8_glob_rom_cfg :: RESET_STATUS_R8_GLOB_ROM_CFG_SPEC > ;
#[doc = "RWA, reset status, SAM or flash ROM configuration"] pub mod reset_status_r8_glob_rom_cfg {
#[doc = "Register `RESET_STATUS_R8_GLOB_ROM_CFG` reader"] pub type R = crate :: R < RESET_STATUS_R8_GLOB_ROM_CFG_SPEC > ;
#[doc = "Field `RESET_FLAG` reader - RO, recent reset flag"] pub type RESET_FLAG_R = crate :: FieldReader ;
#[doc = "Field `ROM_CODE_OFS` reader - RWA, code offset address selection in Flash ROM: 0=start address 0x000000, 1=start address 0x008000"] pub type ROM_CODE_OFS_R = crate :: BitReader ;
#[doc = "Field `ROM_CTRL_EN` reader - RWA, enable flash ROM control interface enable"] pub type ROM_CTRL_EN_R = crate :: BitReader ;
#[doc = "Field `ROM_DATA_WE` reader - RWA,enable flash ROM data and code area being erase/write"] pub type ROM_DATA_WE_R = crate :: BitReader ;
#[doc = "Field `ROM_CODE_WE` reader - RWA, enable flash ROM code area being erase or write"] pub type ROM_CODE_WE_R = crate :: BitReader ; impl R {
#[doc = "Bits 0:2 - RO, recent reset flag"]
#[inline (always)] pub fn reset_flag (& self) -> RESET_FLAG_R { RESET_FLAG_R :: new (self . bits & 7) }
#[doc = "Bit 4 - RWA, code offset address selection in Flash ROM: 0=start address 0x000000, 1=start address 0x008000"]
#[inline (always)] pub fn rom_code_ofs (& self) -> ROM_CODE_OFS_R { ROM_CODE_OFS_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RWA, enable flash ROM control interface enable"]
#[inline (always)] pub fn rom_ctrl_en (& self) -> ROM_CTRL_EN_R { ROM_CTRL_EN_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RWA,enable flash ROM data and code area being erase/write"]
#[inline (always)] pub fn rom_data_we (& self) -> ROM_DATA_WE_R { ROM_DATA_WE_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RWA, enable flash ROM code area being erase or write"]
#[inline (always)] pub fn rom_code_we (& self) -> ROM_CODE_WE_R { ROM_CODE_WE_R :: new (((self . bits >> 7) & 1) != 0) } }
#[doc = "RWA, reset status, SAM or flash ROM configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`reset_status_r8_glob_rom_cfg::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RESET_STATUS_R8_GLOB_ROM_CFG_SPEC ; impl crate :: RegisterSpec for RESET_STATUS_R8_GLOB_ROM_CFG_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`reset_status_r8_glob_rom_cfg::R`](R) reader structure"] impl crate :: Readable for RESET_STATUS_R8_GLOB_ROM_CFG_SPEC { }
#[doc = "`reset()` method sets RESET_STATUS_R8_GLOB_ROM_CFG to value 0x01"] impl crate :: Resettable for RESET_STATUS_R8_GLOB_ROM_CFG_SPEC { const RESET_VALUE : u8 = 0x01 ; } }
#[doc = "GLOB_CFG_INFO (r) register accessor: RO, global configuration information and status\n\nYou can [`read`](crate::Reg::read) this register and get [`glob_cfg_info::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@glob_cfg_info`] module"] pub type GLOB_CFG_INFO = crate :: Reg < glob_cfg_info :: GLOB_CFG_INFO_SPEC > ;
#[doc = "RO, global configuration information and status"] pub mod glob_cfg_info {
#[doc = "Register `GLOB_CFG_INFO` reader"] pub type R = crate :: R < GLOB_CFG_INFO_SPEC > ;
#[doc = "Field `CFG_ROM_READ` reader - RO, indicate protected status of Flash ROM code and data: 0=reading protect, 1=enable read by external programmer"] pub type CFG_ROM_READ_R = crate :: BitReader ;
#[doc = "Field `CFG_RESET_EN` reader - RO, manual reset input enable status"] pub type CFG_RESET_EN_R = crate :: BitReader ;
#[doc = "Field `CFG_BOOT_EN` reader - RO, boot-loader enable status"] pub type CFG_BOOT_EN_R = crate :: BitReader ;
#[doc = "Field `CFG_DEBUG_EN` reader - RO, debug enable status"] pub type CFG_DEBUG_EN_R = crate :: BitReader ;
#[doc = "Field `BOOT_LOADER` reader - RO, indicate boot loader status: 0=application status (by software reset), 1=boot loader status"] pub type BOOT_LOADER_R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - RO, indicate protected status of Flash ROM code and data: 0=reading protect, 1=enable read by external programmer"]
#[inline (always)] pub fn cfg_rom_read (& self) -> CFG_ROM_READ_R { CFG_ROM_READ_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 2 - RO, manual reset input enable status"]
#[inline (always)] pub fn cfg_reset_en (& self) -> CFG_RESET_EN_R { CFG_RESET_EN_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RO, boot-loader enable status"]
#[inline (always)] pub fn cfg_boot_en (& self) -> CFG_BOOT_EN_R { CFG_BOOT_EN_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RO, debug enable status"]
#[inline (always)] pub fn cfg_debug_en (& self) -> CFG_DEBUG_EN_R { CFG_DEBUG_EN_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RO, indicate boot loader status: 0=application status (by software reset), 1=boot loader status"]
#[inline (always)] pub fn boot_loader (& self) -> BOOT_LOADER_R { BOOT_LOADER_R :: new (((self . bits >> 5) & 1) != 0) } }
#[doc = "RO, global configuration information and status\n\nYou can [`read`](crate::Reg::read) this register and get [`glob_cfg_info::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct GLOB_CFG_INFO_SPEC ; impl crate :: RegisterSpec for GLOB_CFG_INFO_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`glob_cfg_info::R`](R) reader structure"] impl crate :: Readable for GLOB_CFG_INFO_SPEC { }
#[doc = "`reset()` method sets GLOB_CFG_INFO to value 0xe0"] impl crate :: Resettable for GLOB_CFG_INFO_SPEC { const RESET_VALUE : u8 = 0xe0 ; } }
#[doc = "RST_WDOG_CTRL (rw) register accessor: RWA, reset and watch-dog control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`rst_wdog_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rst_wdog_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rst_wdog_ctrl`] module"] pub type RST_WDOG_CTRL = crate :: Reg < rst_wdog_ctrl :: RST_WDOG_CTRL_SPEC > ;
#[doc = "RWA, reset and watch-dog control, SAM"] pub mod rst_wdog_ctrl {
#[doc = "Register `RST_WDOG_CTRL` reader"] pub type R = crate :: R < RST_WDOG_CTRL_SPEC > ;
#[doc = "Register `RST_WDOG_CTRL` writer"] pub type W = crate :: W < RST_WDOG_CTRL_SPEC > ;
#[doc = "Field `SOFTWARE_RESET` reader - WA or WZ, global software reset, high action, auto clear"] pub type SOFTWARE_RESET_R = crate :: BitReader ;
#[doc = "Field `SOFTWARE_RESET` writer - WA or WZ, global software reset, high action, auto clear"] pub type SOFTWARE_RESET_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WDOG_RST_EN` reader - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow"] pub type WDOG_RST_EN_R = crate :: BitReader ;
#[doc = "Field `WDOG_RST_EN` writer - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow"] pub type WDOG_RST_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WDOG_INT_EN` reader - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable"] pub type WDOG_INT_EN_R = crate :: BitReader ;
#[doc = "Field `WDOG_INT_EN` writer - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable"] pub type WDOG_INT_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WDOG_INT_FLAG` reader - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)"] pub type WDOG_INT_FLAG_R = crate :: BitReader ;
#[doc = "Field `WDOG_INT_FLAG` writer - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)"] pub type WDOG_INT_FLAG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - WA or WZ, global software reset, high action, auto clear"]
#[inline (always)] pub fn software_reset (& self) -> SOFTWARE_RESET_R { SOFTWARE_RESET_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow"]
#[inline (always)] pub fn wdog_rst_en (& self) -> WDOG_RST_EN_R { WDOG_RST_EN_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable"]
#[inline (always)] pub fn wdog_int_en (& self) -> WDOG_INT_EN_R { WDOG_INT_EN_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 4 - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)"]
#[inline (always)] pub fn wdog_int_flag (& self) -> WDOG_INT_FLAG_R { WDOG_INT_FLAG_R :: new (((self . bits >> 4) & 1) != 0) } } impl W {
#[doc = "Bit 0 - WA or WZ, global software reset, high action, auto clear"]
#[inline (always)] pub fn software_reset (& mut self) -> SOFTWARE_RESET_W < RST_WDOG_CTRL_SPEC > { SOFTWARE_RESET_W :: new (self , 0) }
#[doc = "Bit 1 - RWA, enable watch-dog reset if watch-dog timer overflow: 0=as timer only, 1=enable reset if timer overflow"]
#[inline (always)] pub fn wdog_rst_en (& mut self) -> WDOG_RST_EN_W < RST_WDOG_CTRL_SPEC > { WDOG_RST_EN_W :: new (self , 1) }
#[doc = "Bit 2 - RWA, watch-dog timer overflow interrupt enable: 0=disable, 1=enable"]
#[inline (always)] pub fn wdog_int_en (& mut self) -> WDOG_INT_EN_W < RST_WDOG_CTRL_SPEC > { WDOG_INT_EN_W :: new (self , 2) }
#[doc = "Bit 4 - RW1, watch-dog timer overflow interrupt flag, cleared by RW1 or reload watch-dog count or __SEV(Send-Event)"]
#[inline (always)] pub fn wdog_int_flag (& mut self) -> WDOG_INT_FLAG_W < RST_WDOG_CTRL_SPEC > { WDOG_INT_FLAG_W :: new (self , 4) } }
#[doc = "RWA, reset and watch-dog control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`rst_wdog_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rst_wdog_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RST_WDOG_CTRL_SPEC ; impl crate :: RegisterSpec for RST_WDOG_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`rst_wdog_ctrl::R`](R) reader structure"] impl crate :: Readable for RST_WDOG_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`rst_wdog_ctrl::W`](W) writer structure"] impl crate :: Writable for RST_WDOG_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RST_WDOG_CTRL to value 0"] impl crate :: Resettable for RST_WDOG_CTRL_SPEC { } }
#[doc = "GLOB_RESET_KEEP (rw) register accessor: RW, value keeper during global reset\n\nYou can [`read`](crate::Reg::read) this register and get [`glob_reset_keep::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`glob_reset_keep::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@glob_reset_keep`] module"] pub type GLOB_RESET_KEEP = crate :: Reg < glob_reset_keep :: GLOB_RESET_KEEP_SPEC > ;
#[doc = "RW, value keeper during global reset"] pub mod glob_reset_keep {
#[doc = "Register `GLOB_RESET_KEEP` reader"] pub type R = crate :: R < GLOB_RESET_KEEP_SPEC > ;
#[doc = "Register `GLOB_RESET_KEEP` writer"] pub type W = crate :: W < GLOB_RESET_KEEP_SPEC > ;
#[doc = "Field `GLOB_RESET_KEEP` reader - RW, value keeper during global reset"] pub type GLOB_RESET_KEEP_R = crate :: FieldReader ;
#[doc = "Field `GLOB_RESET_KEEP` writer - RW, value keeper during global reset"] pub type GLOB_RESET_KEEP_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW, value keeper during global reset"]
#[inline (always)] pub fn glob_reset_keep (& self) -> GLOB_RESET_KEEP_R { GLOB_RESET_KEEP_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RW, value keeper during global reset"]
#[inline (always)] pub fn glob_reset_keep (& mut self) -> GLOB_RESET_KEEP_W < GLOB_RESET_KEEP_SPEC > { GLOB_RESET_KEEP_W :: new (self , 0) } }
#[doc = "RW, value keeper during global reset\n\nYou can [`read`](crate::Reg::read) this register and get [`glob_reset_keep::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`glob_reset_keep::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct GLOB_RESET_KEEP_SPEC ; impl crate :: RegisterSpec for GLOB_RESET_KEEP_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`glob_reset_keep::R`](R) reader structure"] impl crate :: Readable for GLOB_RESET_KEEP_SPEC { }
#[doc = "`write(|w| ..)` method takes [`glob_reset_keep::W`](W) writer structure"] impl crate :: Writable for GLOB_RESET_KEEP_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets GLOB_RESET_KEEP to value 0"] impl crate :: Resettable for GLOB_RESET_KEEP_SPEC { } }
#[doc = "PLL_CONFIG (rw) register accessor: RWA, PLL configuration control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`pll_config::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pll_config::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pll_config`] module"] pub type PLL_CONFIG = crate :: Reg < pll_config :: PLL_CONFIG_SPEC > ;
#[doc = "RWA, PLL configuration control, SAM"] pub mod pll_config {
#[doc = "Register `PLL_CONFIG` reader"] pub type R = crate :: R < PLL_CONFIG_SPEC > ;
#[doc = "Register `PLL_CONFIG` writer"] pub type W = crate :: W < PLL_CONFIG_SPEC > ;
#[doc = "Field `PLL_CFG_DAT` reader - RWA, PLL configure data"] pub type PLL_CFG_DAT_R = crate :: FieldReader ;
#[doc = "Field `PLL_CFG_DAT` writer - RWA, PLL configure data"] pub type PLL_CFG_DAT_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `FLASH_IO_MOD` reader - RWA, flash ROM interface mode"] pub type FLASH_IO_MOD_R = crate :: BitReader ;
#[doc = "Field `FLASH_IO_MOD` writer - RWA, flash ROM interface mode"] pub type FLASH_IO_MOD_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:6 - RWA, PLL configure data"]
#[inline (always)] pub fn pll_cfg_dat (& self) -> PLL_CFG_DAT_R { PLL_CFG_DAT_R :: new (self . bits & 0x7f) }
#[doc = "Bit 7 - RWA, flash ROM interface mode"]
#[inline (always)] pub fn flash_io_mod (& self) -> FLASH_IO_MOD_R { FLASH_IO_MOD_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:6 - RWA, PLL configure data"]
#[inline (always)] pub fn pll_cfg_dat (& mut self) -> PLL_CFG_DAT_W < PLL_CONFIG_SPEC > { PLL_CFG_DAT_W :: new (self , 0) }
#[doc = "Bit 7 - RWA, flash ROM interface mode"]
#[inline (always)] pub fn flash_io_mod (& mut self) -> FLASH_IO_MOD_W < PLL_CONFIG_SPEC > { FLASH_IO_MOD_W :: new (self , 7) } }
#[doc = "RWA, PLL configuration control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`pll_config::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pll_config::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PLL_CONFIG_SPEC ; impl crate :: RegisterSpec for PLL_CONFIG_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`pll_config::R`](R) reader structure"] impl crate :: Readable for PLL_CONFIG_SPEC { }
#[doc = "`write(|w| ..)` method takes [`pll_config::W`](W) writer structure"] impl crate :: Writable for PLL_CONFIG_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PLL_CONFIG to value 0x4a"] impl crate :: Resettable for PLL_CONFIG_SPEC { const RESET_VALUE : u8 = 0x4a ; } }
#[doc = "XT32M_TUNE (rw) register accessor: RWA, external 32MHz oscillator tune control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`xt32m_tune::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`xt32m_tune::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@xt32m_tune`] module"] pub type XT32M_TUNE = crate :: Reg < xt32m_tune :: XT32M_TUNE_SPEC > ;
#[doc = "RWA, external 32MHz oscillator tune control, SAM"] pub mod xt32m_tune {
#[doc = "Register `XT32M_TUNE` reader"] pub type R = crate :: R < XT32M_TUNE_SPEC > ;
#[doc = "Register `XT32M_TUNE` writer"] pub type W = crate :: W < XT32M_TUNE_SPEC > ;
#[doc = "Field `XT32M_I_BIAS` reader - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current"] pub type XT32M_I_BIAS_R = crate :: FieldReader ;
#[doc = "Field `XT32M_I_BIAS` writer - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current"] pub type XT32M_I_BIAS_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `XT32M_C_LOAD` reader - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF"] pub type XT32M_C_LOAD_R = crate :: FieldReader ;
#[doc = "Field `XT32M_C_LOAD` writer - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF"] pub type XT32M_C_LOAD_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:1 - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current"]
#[inline (always)] pub fn xt32m_i_bias (& self) -> XT32M_I_BIAS_R { XT32M_I_BIAS_R :: new (self . bits & 3) }
#[doc = "Bits 4:6 - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF"]
#[inline (always)] pub fn xt32m_c_load (& self) -> XT32M_C_LOAD_R { XT32M_C_LOAD_R :: new ((self . bits >> 4) & 7) } } impl W {
#[doc = "Bits 0:1 - RWA, external 32MHz oscillator bias current tune: 00=75% current, 01=standard current, 10=125% current, 11=150% current"]
#[inline (always)] pub fn xt32m_i_bias (& mut self) -> XT32M_I_BIAS_W < XT32M_TUNE_SPEC > { XT32M_I_BIAS_W :: new (self , 0) }
#[doc = "Bits 4:6 - RWA, external 32MHz oscillator load capacitor tune: Cap = RB_XT32M_C_LOAD * 2 + 10pF"]
#[inline (always)] pub fn xt32m_c_load (& mut self) -> XT32M_C_LOAD_W < XT32M_TUNE_SPEC > { XT32M_C_LOAD_W :: new (self , 4) } }
#[doc = "RWA, external 32MHz oscillator tune control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`xt32m_tune::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`xt32m_tune::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct XT32M_TUNE_SPEC ; impl crate :: RegisterSpec for XT32M_TUNE_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`xt32m_tune::R`](R) reader structure"] impl crate :: Readable for XT32M_TUNE_SPEC { }
#[doc = "`write(|w| ..)` method takes [`xt32m_tune::W`](W) writer structure"] impl crate :: Writable for XT32M_TUNE_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets XT32M_TUNE to value 0x32"] impl crate :: Resettable for XT32M_TUNE_SPEC { const RESET_VALUE : u8 = 0x32 ; } }
#[doc = "OSC_CAL_CNT (r) register accessor: RO, system clock count value for 32KHz multi-cycles\n\nYou can [`read`](crate::Reg::read) this register and get [`osc_cal_cnt::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@osc_cal_cnt`] module"] pub type OSC_CAL_CNT = crate :: Reg < osc_cal_cnt :: OSC_CAL_CNT_SPEC > ;
#[doc = "RO, system clock count value for 32KHz multi-cycles"] pub mod osc_cal_cnt {
#[doc = "Register `OSC_CAL_CNT` reader"] pub type R = crate :: R < OSC_CAL_CNT_SPEC > ;
#[doc = "Field `OSC_CAL_CNT` reader - RO, system clock count value for 32KHz multi-cycles"] pub type OSC_CAL_CNT_R = crate :: FieldReader < u16 > ;
#[doc = "Field `OSC_CAL_OV_CLR` reader - RW1, indicate R8_OSC_CAL_OV_CNT not zero, set 1 to clear R8_OSC_CAL_OV_CNT"] pub type OSC_CAL_OV_CLR_R = crate :: BitReader ;
#[doc = "Field `OSC_CAL_IF` reader - RW1, interrupt flag for oscillator capture end, set 1 to clear"] pub type OSC_CAL_IF_R = crate :: BitReader ; impl R {
#[doc = "Bits 0:13 - RO, system clock count value for 32KHz multi-cycles"]
#[inline (always)] pub fn osc_cal_cnt (& self) -> OSC_CAL_CNT_R { OSC_CAL_CNT_R :: new (self . bits & 0x3fff) }
#[doc = "Bit 14 - RW1, indicate R8_OSC_CAL_OV_CNT not zero, set 1 to clear R8_OSC_CAL_OV_CNT"]
#[inline (always)] pub fn osc_cal_ov_clr (& self) -> OSC_CAL_OV_CLR_R { OSC_CAL_OV_CLR_R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - RW1, interrupt flag for oscillator capture end, set 1 to clear"]
#[inline (always)] pub fn osc_cal_if (& self) -> OSC_CAL_IF_R { OSC_CAL_IF_R :: new (((self . bits >> 15) & 1) != 0) } }
#[doc = "RO, system clock count value for 32KHz multi-cycles\n\nYou can [`read`](crate::Reg::read) this register and get [`osc_cal_cnt::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OSC_CAL_CNT_SPEC ; impl crate :: RegisterSpec for OSC_CAL_CNT_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`osc_cal_cnt::R`](R) reader structure"] impl crate :: Readable for OSC_CAL_CNT_SPEC { }
#[doc = "`reset()` method sets OSC_CAL_CNT to value 0"] impl crate :: Resettable for OSC_CAL_CNT_SPEC { } }
#[doc = "OSC_CAL_CTRL (rw) register accessor: RWA, oscillator frequency calibration control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`osc_cal_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`osc_cal_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@osc_cal_ctrl`] module"] pub type OSC_CAL_CTRL = crate :: Reg < osc_cal_ctrl :: OSC_CAL_CTRL_SPEC > ;
#[doc = "RWA, oscillator frequency calibration control, SAM"] pub mod osc_cal_ctrl {
#[doc = "Register `OSC_CAL_CTRL` reader"] pub type R = crate :: R < OSC_CAL_CTRL_SPEC > ;
#[doc = "Register `OSC_CAL_CTRL` writer"] pub type W = crate :: W < OSC_CAL_CTRL_SPEC > ;
#[doc = "Field `OSC_CNT_TOTAL` reader - RWA, total cycles mode for oscillator capture"] pub type OSC_CNT_TOTAL_R = crate :: FieldReader ;
#[doc = "Field `OSC_CNT_TOTAL` writer - RWA, total cycles mode for oscillator capture"] pub type OSC_CNT_TOTAL_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ;
#[doc = "Field `OSC_CNT_HALT` reader - RO, calibration counter halt status: 0=counting, 1=halt for reading count value"] pub type OSC_CNT_HALT_R = crate :: BitReader ;
#[doc = "Field `OSC_CAL_IE` reader - RWA, interrupt enable for oscillator capture end"] pub type OSC_CAL_IE_R = crate :: BitReader ;
#[doc = "Field `OSC_CAL_IE` writer - RWA, interrupt enable for oscillator capture end"] pub type OSC_CAL_IE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OSC_CNT_EN` reader - RWA, calibration counter enable"] pub type OSC_CNT_EN_R = crate :: BitReader ;
#[doc = "Field `OSC_CNT_EN` writer - RWA, calibration counter enable"] pub type OSC_CNT_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OSC_CNT_END` reader - RWA, select oscillator capture end mode: 0=normal, 1=append 2 cycles"] pub type OSC_CNT_END_R = crate :: BitReader ;
#[doc = "Field `OSC_CNT_END` writer - RWA, select oscillator capture end mode: 0=normal, 1=append 2 cycles"] pub type OSC_CNT_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:2 - RWA, total cycles mode for oscillator capture"]
#[inline (always)] pub fn osc_cnt_total (& self) -> OSC_CNT_TOTAL_R { OSC_CNT_TOTAL_R :: new (self . bits & 7) }
#[doc = "Bit 3 - RO, calibration counter halt status: 0=counting, 1=halt for reading count value"]
#[inline (always)] pub fn osc_cnt_halt (& self) -> OSC_CNT_HALT_R { OSC_CNT_HALT_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RWA, interrupt enable for oscillator capture end"]
#[inline (always)] pub fn osc_cal_ie (& self) -> OSC_CAL_IE_R { OSC_CAL_IE_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RWA, calibration counter enable"]
#[inline (always)] pub fn osc_cnt_en (& self) -> OSC_CNT_EN_R { OSC_CNT_EN_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RWA, select oscillator capture end mode: 0=normal, 1=append 2 cycles"]
#[inline (always)] pub fn osc_cnt_end (& self) -> OSC_CNT_END_R { OSC_CNT_END_R :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bits 0:2 - RWA, total cycles mode for oscillator capture"]
#[inline (always)] pub fn osc_cnt_total (& mut self) -> OSC_CNT_TOTAL_W < OSC_CAL_CTRL_SPEC > { OSC_CNT_TOTAL_W :: new (self , 0) }
#[doc = "Bit 4 - RWA, interrupt enable for oscillator capture end"]
#[inline (always)] pub fn osc_cal_ie (& mut self) -> OSC_CAL_IE_W < OSC_CAL_CTRL_SPEC > { OSC_CAL_IE_W :: new (self , 4) }
#[doc = "Bit 5 - RWA, calibration counter enable"]
#[inline (always)] pub fn osc_cnt_en (& mut self) -> OSC_CNT_EN_W < OSC_CAL_CTRL_SPEC > { OSC_CNT_EN_W :: new (self , 5) }
#[doc = "Bit 6 - RWA, select oscillator capture end mode: 0=normal, 1=append 2 cycles"]
#[inline (always)] pub fn osc_cnt_end (& mut self) -> OSC_CNT_END_W < OSC_CAL_CTRL_SPEC > { OSC_CNT_END_W :: new (self , 6) } }
#[doc = "RWA, oscillator frequency calibration control, SAM\n\nYou can [`read`](crate::Reg::read) this register and get [`osc_cal_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`osc_cal_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OSC_CAL_CTRL_SPEC ; impl crate :: RegisterSpec for OSC_CAL_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`osc_cal_ctrl::R`](R) reader structure"] impl crate :: Readable for OSC_CAL_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`osc_cal_ctrl::W`](W) writer structure"] impl crate :: Writable for OSC_CAL_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OSC_CAL_CTRL to value 0x09"] impl crate :: Resettable for OSC_CAL_CTRL_SPEC { const RESET_VALUE : u8 = 0x09 ; } }
#[doc = "OSC_CAL_OV_CNT (r) register accessor: RO, oscillator frequency calibration overflow times\n\nYou can [`read`](crate::Reg::read) this register and get [`osc_cal_ov_cnt::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@osc_cal_ov_cnt`] module"] pub type OSC_CAL_OV_CNT = crate :: Reg < osc_cal_ov_cnt :: OSC_CAL_OV_CNT_SPEC > ;
#[doc = "RO, oscillator frequency calibration overflow times"] pub mod osc_cal_ov_cnt {
#[doc = "Register `OSC_CAL_OV_CNT` reader"] pub type R = crate :: R < OSC_CAL_OV_CNT_SPEC > ;
#[doc = "Field `OSC_CAL_OV_CNT` reader - RO, oscillator frequency calibration overflow times"] pub type OSC_CAL_OV_CNT_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RO, oscillator frequency calibration overflow times"]
#[inline (always)] pub fn osc_cal_ov_cnt (& self) -> OSC_CAL_OV_CNT_R { OSC_CAL_OV_CNT_R :: new (self . bits) } }
#[doc = "RO, oscillator frequency calibration overflow times\n\nYou can [`read`](crate::Reg::read) this register and get [`osc_cal_ov_cnt::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OSC_CAL_OV_CNT_SPEC ; impl crate :: RegisterSpec for OSC_CAL_OV_CNT_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`osc_cal_ov_cnt::R`](R) reader structure"] impl crate :: Readable for OSC_CAL_OV_CNT_SPEC { }
#[doc = "`reset()` method sets OSC_CAL_OV_CNT to value 0"] impl crate :: Resettable for OSC_CAL_OV_CNT_SPEC { } }
#[doc = "TKEY_COUNT (rw) register accessor: RW, Touchkey charge and discharge count\n\nYou can [`read`](crate::Reg::read) this register and get [`tkey_count::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tkey_count::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tkey_count`] module"] pub type TKEY_COUNT = crate :: Reg < tkey_count :: TKEY_COUNT_SPEC > ;
#[doc = "RW, Touchkey charge and discharge count"] pub mod tkey_count {
#[doc = "Register `TKEY_COUNT` reader"] pub type R = crate :: R < TKEY_COUNT_SPEC > ;
#[doc = "Register `TKEY_COUNT` writer"] pub type W = crate :: W < TKEY_COUNT_SPEC > ;
#[doc = "Field `TKEY_CHARG_CNT` reader - RW, Touchkey charge count"] pub type TKEY_CHARG_CNT_R = crate :: FieldReader ;
#[doc = "Field `TKEY_CHARG_CNT` writer - RW, Touchkey charge count"] pub type TKEY_CHARG_CNT_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 > ;
#[doc = "Field `TKEY_DISCH_CNT` reader - RW, Touchkey discharge count"] pub type TKEY_DISCH_CNT_R = crate :: FieldReader ;
#[doc = "Field `TKEY_DISCH_CNT` writer - RW, Touchkey discharge count"] pub type TKEY_DISCH_CNT_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R {
#[doc = "Bits 0:4 - RW, Touchkey charge count"]
#[inline (always)] pub fn tkey_charg_cnt (& self) -> TKEY_CHARG_CNT_R { TKEY_CHARG_CNT_R :: new (self . bits & 0x1f) }
#[doc = "Bits 5:7 - RW, Touchkey discharge count"]
#[inline (always)] pub fn tkey_disch_cnt (& self) -> TKEY_DISCH_CNT_R { TKEY_DISCH_CNT_R :: new ((self . bits >> 5) & 7) } } impl W {
#[doc = "Bits 0:4 - RW, Touchkey charge count"]
#[inline (always)] pub fn tkey_charg_cnt (& mut self) -> TKEY_CHARG_CNT_W < TKEY_COUNT_SPEC > { TKEY_CHARG_CNT_W :: new (self , 0) }
#[doc = "Bits 5:7 - RW, Touchkey discharge count"]
#[inline (always)] pub fn tkey_disch_cnt (& mut self) -> TKEY_DISCH_CNT_W < TKEY_COUNT_SPEC > { TKEY_DISCH_CNT_W :: new (self , 5) } }
#[doc = "RW, Touchkey charge and discharge count\n\nYou can [`read`](crate::Reg::read) this register and get [`tkey_count::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tkey_count::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TKEY_COUNT_SPEC ; impl crate :: RegisterSpec for TKEY_COUNT_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`tkey_count::R`](R) reader structure"] impl crate :: Readable for TKEY_COUNT_SPEC { }
#[doc = "`write(|w| ..)` method takes [`tkey_count::W`](W) writer structure"] impl crate :: Writable for TKEY_COUNT_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets TKEY_COUNT to value 0"] impl crate :: Resettable for TKEY_COUNT_SPEC { } }
#[doc = "TKEY_CONVERT (rw) register accessor: RW, Touchkey convert start control\n\nYou can [`read`](crate::Reg::read) this register and get [`tkey_convert::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tkey_convert::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tkey_convert`] module"] pub type TKEY_CONVERT = crate :: Reg < tkey_convert :: TKEY_CONVERT_SPEC > ;
#[doc = "RW, Touchkey convert start control"] pub mod tkey_convert {
#[doc = "Register `TKEY_CONVERT` reader"] pub type R = crate :: R < TKEY_CONVERT_SPEC > ;
#[doc = "Register `TKEY_CONVERT` writer"] pub type W = crate :: W < TKEY_CONVERT_SPEC > ;
#[doc = "Field `TKEY_START` reader - RW, Touchkey convert start control"] pub type TKEY_START_R = crate :: BitReader ;
#[doc = "Field `TKEY_START` writer - RW, Touchkey convert start control"] pub type TKEY_START_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, Touchkey convert start control"]
#[inline (always)] pub fn tkey_start (& self) -> TKEY_START_R { TKEY_START_R :: new ((self . bits & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, Touchkey convert start control"]
#[inline (always)] pub fn tkey_start (& mut self) -> TKEY_START_W < TKEY_CONVERT_SPEC > { TKEY_START_W :: new (self , 0) } }
#[doc = "RW, Touchkey convert start control\n\nYou can [`read`](crate::Reg::read) this register and get [`tkey_convert::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tkey_convert::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TKEY_CONVERT_SPEC ; impl crate :: RegisterSpec for TKEY_CONVERT_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`tkey_convert::R`](R) reader structure"] impl crate :: Readable for TKEY_CONVERT_SPEC { }
#[doc = "`write(|w| ..)` method takes [`tkey_convert::W`](W) writer structure"] impl crate :: Writable for TKEY_CONVERT_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets TKEY_CONVERT to value 0"] impl crate :: Resettable for TKEY_CONVERT_SPEC { } }
#[doc = "TKEY_CFG (rw) register accessor: RW, Touchkey configure\n\nYou can [`read`](crate::Reg::read) this register and get [`tkey_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tkey_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tkey_cfg`] module"] pub type TKEY_CFG = crate :: Reg < tkey_cfg :: TKEY_CFG_SPEC > ;
#[doc = "RW, Touchkey configure"] pub mod tkey_cfg {
#[doc = "Register `TKEY_CFG` reader"] pub type R = crate :: R < TKEY_CFG_SPEC > ;
#[doc = "Register `TKEY_CFG` writer"] pub type W = crate :: W < TKEY_CFG_SPEC > ;
#[doc = "Field `TKEY_PWR_ON` reader - RW, Touchkey power on"] pub type TKEY_PWR_ON_R = crate :: BitReader ;
#[doc = "Field `TKEY_PWR_ON` writer - RW, Touchkey power on"] pub type TKEY_PWR_ON_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TKEY_CURRENT` reader - RW, Touchkey charge current selection"] pub type TKEY_CURRENT_R = crate :: BitReader ;
#[doc = "Field `TKEY_CURRENT` writer - RW, Touchkey charge current selection"] pub type TKEY_CURRENT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TKEY_DRV_EN` reader - RW, Touchkey drive shield enable"] pub type TKEY_DRV_EN_R = crate :: BitReader ;
#[doc = "Field `TKEY_DRV_EN` writer - RW, Touchkey drive shield enable"] pub type TKEY_DRV_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `TKEY_PGA_ADJ` reader - RW, ADC input PGA speed selection"] pub type TKEY_PGA_ADJ_R = crate :: BitReader ;
#[doc = "Field `TKEY_PGA_ADJ` writer - RW, ADC input PGA speed selection"] pub type TKEY_PGA_ADJ_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, Touchkey power on"]
#[inline (always)] pub fn tkey_pwr_on (& self) -> TKEY_PWR_ON_R { TKEY_PWR_ON_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, Touchkey charge current selection"]
#[inline (always)] pub fn tkey_current (& self) -> TKEY_CURRENT_R { TKEY_CURRENT_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW, Touchkey drive shield enable"]
#[inline (always)] pub fn tkey_drv_en (& self) -> TKEY_DRV_EN_R { TKEY_DRV_EN_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, ADC input PGA speed selection"]
#[inline (always)] pub fn tkey_pga_adj (& self) -> TKEY_PGA_ADJ_R { TKEY_PGA_ADJ_R :: new (((self . bits >> 3) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, Touchkey power on"]
#[inline (always)] pub fn tkey_pwr_on (& mut self) -> TKEY_PWR_ON_W < TKEY_CFG_SPEC > { TKEY_PWR_ON_W :: new (self , 0) }
#[doc = "Bit 1 - RW, Touchkey charge current selection"]
#[inline (always)] pub fn tkey_current (& mut self) -> TKEY_CURRENT_W < TKEY_CFG_SPEC > { TKEY_CURRENT_W :: new (self , 1) }
#[doc = "Bit 2 - RW, Touchkey drive shield enable"]
#[inline (always)] pub fn tkey_drv_en (& mut self) -> TKEY_DRV_EN_W < TKEY_CFG_SPEC > { TKEY_DRV_EN_W :: new (self , 2) }
#[doc = "Bit 3 - RW, ADC input PGA speed selection"]
#[inline (always)] pub fn tkey_pga_adj (& mut self) -> TKEY_PGA_ADJ_W < TKEY_CFG_SPEC > { TKEY_PGA_ADJ_W :: new (self , 3) } }
#[doc = "RW, Touchkey configure\n\nYou can [`read`](crate::Reg::read) this register and get [`tkey_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tkey_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TKEY_CFG_SPEC ; impl crate :: RegisterSpec for TKEY_CFG_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`tkey_cfg::R`](R) reader structure"] impl crate :: Readable for TKEY_CFG_SPEC { }
#[doc = "`write(|w| ..)` method takes [`tkey_cfg::W`](W) writer structure"] impl crate :: Writable for TKEY_CFG_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets TKEY_CFG to value 0"] impl crate :: Resettable for TKEY_CFG_SPEC { } } }
#[doc = "System Control Register"] pub type ADC = crate :: Periph < adc :: RegisterBlock , 0x4000_1000 > ; impl core :: fmt :: Debug for ADC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("ADC") . finish () } }
#[doc = "System Control Register"] pub mod adc {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { _reserved0 : [u8 ; 0x58] , channel : CHANNEL , cfg : CFG , convert : CONVERT , tem_sensor : TEM_SENSOR , data : DATA , int_flag : INT_FLAG , _reserved6 : [u8 ; 0x01] , dma_ctrl : DMA_CTRL , ctrl_dma : CTRL_DMA , dma_if : DMA_IF , auto_cycle : AUTO_CYCLE , dma_now : DMA_NOW , _reserved11 : [u8 ; 0x03] , dma_beg : DMA_BEG , _reserved12 : [u8 ; 0x03] , dma_end : DMA_END , } impl RegisterBlock {
#[doc = "0x58 - RW, ADC input channel selection"]
#[inline (always)] pub const fn channel (& self) -> & CHANNEL { & self . channel }
#[doc = "0x59 - RW, ADC configure"]
#[inline (always)] pub const fn cfg (& self) -> & CFG { & self . cfg }
#[doc = "0x5a - RW, ADC convert control"]
#[inline (always)] pub const fn convert (& self) -> & CONVERT { & self . convert }
#[doc = "0x5b - RW, temperature sensor control"]
#[inline (always)] pub const fn tem_sensor (& self) -> & TEM_SENSOR { & self . tem_sensor }
#[doc = "0x5c - RO, ADC data"]
#[inline (always)] pub const fn data (& self) -> & DATA { & self . data }
#[doc = "0x5e - RO, ADC interrupt flag register"]
#[inline (always)] pub const fn int_flag (& self) -> & INT_FLAG { & self . int_flag }
#[doc = "0x60 - RO, ADC DMA control and status register"]
#[inline (always)] pub const fn dma_ctrl (& self) -> & DMA_CTRL { & self . dma_ctrl }
#[doc = "0x61 - RW, ADC DMA control"]
#[inline (always)] pub const fn ctrl_dma (& self) -> & CTRL_DMA { & self . ctrl_dma }
#[doc = "0x62 - RO, ADC interrupt flag"]
#[inline (always)] pub const fn dma_if (& self) -> & DMA_IF { & self . dma_if }
#[doc = "0x63 - RO, ADC interrupt flag"]
#[inline (always)] pub const fn auto_cycle (& self) -> & AUTO_CYCLE { & self . auto_cycle }
#[doc = "0x64 - RO, ADC DMA current address"]
#[inline (always)] pub const fn dma_now (& self) -> & DMA_NOW { & self . dma_now }
#[doc = "0x68 - RW, ADC DMA begin address"]
#[inline (always)] pub const fn dma_beg (& self) -> & DMA_BEG { & self . dma_beg }
#[doc = "0x6c - RW, ADC DMA end address"]
#[inline (always)] pub const fn dma_end (& self) -> & DMA_END { & self . dma_end } }
#[doc = "CHANNEL (rw) register accessor: RW, ADC input channel selection\n\nYou can [`read`](crate::Reg::read) this register and get [`channel::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`channel::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@channel`] module"] pub type CHANNEL = crate :: Reg < channel :: CHANNEL_SPEC > ;
#[doc = "RW, ADC input channel selection"] pub mod channel {
#[doc = "Register `CHANNEL` reader"] pub type R = crate :: R < CHANNEL_SPEC > ;
#[doc = "Register `CHANNEL` writer"] pub type W = crate :: W < CHANNEL_SPEC > ;
#[doc = "Field `CH_INX` reader - RW, ADC input channel index"] pub type CH_INX_R = crate :: FieldReader ;
#[doc = "Field `CH_INX` writer - RW, ADC input channel index"] pub type CH_INX_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - RW, ADC input channel index"]
#[inline (always)] pub fn ch_inx (& self) -> CH_INX_R { CH_INX_R :: new (self . bits & 0x0f) } } impl W {
#[doc = "Bits 0:3 - RW, ADC input channel index"]
#[inline (always)] pub fn ch_inx (& mut self) -> CH_INX_W < CHANNEL_SPEC > { CH_INX_W :: new (self , 0) } }
#[doc = "RW, ADC input channel selection\n\nYou can [`read`](crate::Reg::read) this register and get [`channel::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`channel::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CHANNEL_SPEC ; impl crate :: RegisterSpec for CHANNEL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`channel::R`](R) reader structure"] impl crate :: Readable for CHANNEL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`channel::W`](W) writer structure"] impl crate :: Writable for CHANNEL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CHANNEL to value 0x0f"] impl crate :: Resettable for CHANNEL_SPEC { const RESET_VALUE : u8 = 0x0f ; } }
#[doc = "CFG (rw) register accessor: RW, ADC configure\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfg`] module"] pub type CFG = crate :: Reg < cfg :: CFG_SPEC > ;
#[doc = "RW, ADC configure"] pub mod cfg {
#[doc = "Register `CFG` reader"] pub type R = crate :: R < CFG_SPEC > ;
#[doc = "Register `CFG` writer"] pub type W = crate :: W < CFG_SPEC > ;
#[doc = "Field `POWER_ON` reader - RW, ADC power control: 0=power down, 1=power on"] pub type POWER_ON_R = crate :: BitReader ;
#[doc = "Field `POWER_ON` writer - RW, ADC power control: 0=power down, 1=power on"] pub type POWER_ON_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `BUF_EN` reader - RW, ADC input buffer enable"] pub type BUF_EN_R = crate :: BitReader ;
#[doc = "Field `BUF_EN` writer - RW, ADC input buffer enable"] pub type BUF_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DIFF_EN` reader - RW, ADC input channel mode: 0=single-end, 1=differnetial"] pub type DIFF_EN_R = crate :: BitReader ;
#[doc = "Field `DIFF_EN` writer - RW, ADC input channel mode: 0=single-end, 1=differnetial"] pub type DIFF_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OFS_TEST` reader - RW, enable ADC offset test mode: 0=normal mode, 1=short to test offset"] pub type OFS_TEST_R = crate :: BitReader ;
#[doc = "Field `OFS_TEST` writer - RW, enable ADC offset test mode: 0=normal mode, 1=short to test offset"] pub type OFS_TEST_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PGA_GAIN` reader - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB"] pub type PGA_GAIN_R = crate :: FieldReader ;
#[doc = "Field `PGA_GAIN` writer - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB"] pub type PGA_GAIN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `CLK_DIV` reader - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz"] pub type CLK_DIV_R = crate :: FieldReader ;
#[doc = "Field `CLK_DIV` writer - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz"] pub type CLK_DIV_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bit 0 - RW, ADC power control: 0=power down, 1=power on"]
#[inline (always)] pub fn power_on (& self) -> POWER_ON_R { POWER_ON_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, ADC input buffer enable"]
#[inline (always)] pub fn buf_en (& self) -> BUF_EN_R { BUF_EN_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW, ADC input channel mode: 0=single-end, 1=differnetial"]
#[inline (always)] pub fn diff_en (& self) -> DIFF_EN_R { DIFF_EN_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, enable ADC offset test mode: 0=normal mode, 1=short to test offset"]
#[inline (always)] pub fn ofs_test (& self) -> OFS_TEST_R { OFS_TEST_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:5 - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB"]
#[inline (always)] pub fn pga_gain (& self) -> PGA_GAIN_R { PGA_GAIN_R :: new ((self . bits >> 4) & 3) }
#[doc = "Bits 6:7 - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz"]
#[inline (always)] pub fn clk_div (& self) -> CLK_DIV_R { CLK_DIV_R :: new ((self . bits >> 6) & 3) } } impl W {
#[doc = "Bit 0 - RW, ADC power control: 0=power down, 1=power on"]
#[inline (always)] pub fn power_on (& mut self) -> POWER_ON_W < CFG_SPEC > { POWER_ON_W :: new (self , 0) }
#[doc = "Bit 1 - RW, ADC input buffer enable"]
#[inline (always)] pub fn buf_en (& mut self) -> BUF_EN_W < CFG_SPEC > { BUF_EN_W :: new (self , 1) }
#[doc = "Bit 2 - RW, ADC input channel mode: 0=single-end, 1=differnetial"]
#[inline (always)] pub fn diff_en (& mut self) -> DIFF_EN_W < CFG_SPEC > { DIFF_EN_W :: new (self , 2) }
#[doc = "Bit 3 - RW, enable ADC offset test mode: 0=normal mode, 1=short to test offset"]
#[inline (always)] pub fn ofs_test (& mut self) -> OFS_TEST_W < CFG_SPEC > { OFS_TEST_W :: new (self , 3) }
#[doc = "Bits 4:5 - RW, set ADC input PGA gain: 00=-12dB, 01=-6dB, 10=0dB, 11=6dB"]
#[inline (always)] pub fn pga_gain (& mut self) -> PGA_GAIN_W < CFG_SPEC > { PGA_GAIN_W :: new (self , 4) }
#[doc = "Bits 6:7 - RW, select ADC clock frequency: 00=3.2MHz, 01=2.67MHz, 10=5.33MHz, 11=4MHz"]
#[inline (always)] pub fn clk_div (& mut self) -> CLK_DIV_W < CFG_SPEC > { CLK_DIV_W :: new (self , 6) } }
#[doc = "RW, ADC configure\n\nYou can [`read`](crate::Reg::read) this register and get [`cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CFG_SPEC ; impl crate :: RegisterSpec for CFG_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`cfg::R`](R) reader structure"] impl crate :: Readable for CFG_SPEC { }
#[doc = "`write(|w| ..)` method takes [`cfg::W`](W) writer structure"] impl crate :: Writable for CFG_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CFG to value 0xa0"] impl crate :: Resettable for CFG_SPEC { const RESET_VALUE : u8 = 0xa0 ; } }
#[doc = "CONVERT (rw) register accessor: RW, ADC convert control\n\nYou can [`read`](crate::Reg::read) this register and get [`convert::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`convert::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@convert`] module"] pub type CONVERT = crate :: Reg < convert :: CONVERT_SPEC > ;
#[doc = "RW, ADC convert control"] pub mod convert {
#[doc = "Register `CONVERT` reader"] pub type R = crate :: R < CONVERT_SPEC > ;
#[doc = "Register `CONVERT` writer"] pub type W = crate :: W < CONVERT_SPEC > ;
#[doc = "Field `START` reader - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear"] pub type START_R = crate :: BitReader ;
#[doc = "Field `START` writer - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear"] pub type START_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EOC_X` reader - RO, end of ADC conversion flag"] pub type EOC_X_R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear"]
#[inline (always)] pub fn start (& self) -> START_R { START_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 7 - RO, end of ADC conversion flag"]
#[inline (always)] pub fn eoc_x (& self) -> EOC_X_R { EOC_X_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, ADC convert start control: 0=stop ADC convert, 1=start an ADC convert, auto clear"]
#[inline (always)] pub fn start (& mut self) -> START_W < CONVERT_SPEC > { START_W :: new (self , 0) } }
#[doc = "RW, ADC convert control\n\nYou can [`read`](crate::Reg::read) this register and get [`convert::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`convert::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CONVERT_SPEC ; impl crate :: RegisterSpec for CONVERT_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`convert::R`](R) reader structure"] impl crate :: Readable for CONVERT_SPEC { }
#[doc = "`write(|w| ..)` method takes [`convert::W`](W) writer structure"] impl crate :: Writable for CONVERT_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CONVERT to value 0"] impl crate :: Resettable for CONVERT_SPEC { } }
#[doc = "TEM_SENSOR (rw) register accessor: RW, temperature sensor control\n\nYou can [`read`](crate::Reg::read) this register and get [`tem_sensor::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tem_sensor::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tem_sensor`] module"] pub type TEM_SENSOR = crate :: Reg < tem_sensor :: TEM_SENSOR_SPEC > ;
#[doc = "RW, temperature sensor control"] pub mod tem_sensor {
#[doc = "Register `TEM_SENSOR` reader"] pub type R = crate :: R < TEM_SENSOR_SPEC > ;
#[doc = "Register `TEM_SENSOR` writer"] pub type W = crate :: W < TEM_SENSOR_SPEC > ;
#[doc = "Field `TEM_SEN_PWR_ON` reader - RW, temperature sensor power control: 0=power down, 1=power on"] pub type TEM_SEN_PWR_ON_R = crate :: BitReader ;
#[doc = "Field `TEM_SEN_PWR_ON` writer - RW, temperature sensor power control: 0=power down, 1=power on"] pub type TEM_SEN_PWR_ON_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 7 - RW, temperature sensor power control: 0=power down, 1=power on"]
#[inline (always)] pub fn tem_sen_pwr_on (& self) -> TEM_SEN_PWR_ON_R { TEM_SEN_PWR_ON_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 7 - RW, temperature sensor power control: 0=power down, 1=power on"]
#[inline (always)] pub fn tem_sen_pwr_on (& mut self) -> TEM_SEN_PWR_ON_W < TEM_SENSOR_SPEC > { TEM_SEN_PWR_ON_W :: new (self , 7) } }
#[doc = "RW, temperature sensor control\n\nYou can [`read`](crate::Reg::read) this register and get [`tem_sensor::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tem_sensor::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TEM_SENSOR_SPEC ; impl crate :: RegisterSpec for TEM_SENSOR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`tem_sensor::R`](R) reader structure"] impl crate :: Readable for TEM_SENSOR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`tem_sensor::W`](W) writer structure"] impl crate :: Writable for TEM_SENSOR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets TEM_SENSOR to value 0"] impl crate :: Resettable for TEM_SENSOR_SPEC { } }
#[doc = "DATA (r) register accessor: RO, ADC data\n\nYou can [`read`](crate::Reg::read) this register and get [`data::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@data`] module"] pub type DATA = crate :: Reg < data :: DATA_SPEC > ;
#[doc = "RO, ADC data"] pub mod data {
#[doc = "Register `DATA` reader"] pub type R = crate :: R < DATA_SPEC > ;
#[doc = "Field `DATA` reader - RO, ADC conversion data"] pub type DATA_R = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:11 - RO, ADC conversion data"]
#[inline (always)] pub fn data (& self) -> DATA_R { DATA_R :: new (self . bits & 0x0fff) } }
#[doc = "RO, ADC data\n\nYou can [`read`](crate::Reg::read) this register and get [`data::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DATA_SPEC ; impl crate :: RegisterSpec for DATA_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`data::R`](R) reader structure"] impl crate :: Readable for DATA_SPEC { }
#[doc = "`reset()` method sets DATA to value 0"] impl crate :: Resettable for DATA_SPEC { } }
#[doc = "INT_FLAG (r) register accessor: RO, ADC interrupt flag register\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_flag`] module"] pub type INT_FLAG = crate :: Reg < int_flag :: INT_FLAG_SPEC > ;
#[doc = "RO, ADC interrupt flag register"] pub mod int_flag {
#[doc = "Register `INT_FLAG` reader"] pub type R = crate :: R < INT_FLAG_SPEC > ;
#[doc = "Field `IF_EOC` reader - RO, ADC conversion interrupt flag: 0=free or converting, 1=end of conversion, interrupt action, write R8_ADC_CONVERT to clear flag"] pub type IF_EOC_R = crate :: BitReader ; impl R {
#[doc = "Bit 7 - RO, ADC conversion interrupt flag: 0=free or converting, 1=end of conversion, interrupt action, write R8_ADC_CONVERT to clear flag"]
#[inline (always)] pub fn if_eoc (& self) -> IF_EOC_R { IF_EOC_R :: new (((self . bits >> 7) & 1) != 0) } }
#[doc = "RO, ADC interrupt flag register\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_FLAG_SPEC ; impl crate :: RegisterSpec for INT_FLAG_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`int_flag::R`](R) reader structure"] impl crate :: Readable for INT_FLAG_SPEC { }
#[doc = "`reset()` method sets INT_FLAG to value 0"] impl crate :: Resettable for INT_FLAG_SPEC { } }
#[doc = "DMA_CTRL (rw) register accessor: RO, ADC DMA control and status register\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_ctrl`] module"] pub type DMA_CTRL = crate :: Reg < dma_ctrl :: DMA_CTRL_SPEC > ;
#[doc = "RO, ADC DMA control and status register"] pub mod dma_ctrl {
#[doc = "Register `DMA_CTRL` reader"] pub type R = crate :: R < DMA_CTRL_SPEC > ;
#[doc = "Register `DMA_CTRL` writer"] pub type W = crate :: W < DMA_CTRL_SPEC > ;
#[doc = "Field `DMA_CTRL` reader - RW, ADC DMA enable"] pub type DMA_CTRL_R = crate :: FieldReader ;
#[doc = "Field `DMA_CTRL` writer - RW, ADC DMA enable"] pub type DMA_CTRL_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW, ADC DMA enable"]
#[inline (always)] pub fn dma_ctrl (& self) -> DMA_CTRL_R { DMA_CTRL_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RW, ADC DMA enable"]
#[inline (always)] pub fn dma_ctrl (& mut self) -> DMA_CTRL_W < DMA_CTRL_SPEC > { DMA_CTRL_W :: new (self , 0) } }
#[doc = "RO, ADC DMA control and status register\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DMA_CTRL_SPEC ; impl crate :: RegisterSpec for DMA_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`dma_ctrl::R`](R) reader structure"] impl crate :: Readable for DMA_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`dma_ctrl::W`](W) writer structure"] impl crate :: Writable for DMA_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMA_CTRL to value 0"] impl crate :: Resettable for DMA_CTRL_SPEC { } }
#[doc = "CTRL_DMA (rw) register accessor: RW, ADC DMA control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl_dma`] module"] pub type CTRL_DMA = crate :: Reg < ctrl_dma :: CTRL_DMA_SPEC > ;
#[doc = "RW, ADC DMA control"] pub mod ctrl_dma {
#[doc = "Register `CTRL_DMA` reader"] pub type R = crate :: R < CTRL_DMA_SPEC > ;
#[doc = "Register `CTRL_DMA` writer"] pub type W = crate :: W < CTRL_DMA_SPEC > ;
#[doc = "Field `DMA_ENABLE` reader - RW, ADC DMA enable"] pub type DMA_ENABLE_R = crate :: BitReader ;
#[doc = "Field `DMA_ENABLE` writer - RW, ADC DMA enable"] pub type DMA_ENABLE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `DMA_LOOP` reader - RW, ADC DMA address loop enable"] pub type DMA_LOOP_R = crate :: BitReader ;
#[doc = "Field `DMA_LOOP` writer - RW, ADC DMA address loop enable"] pub type DMA_LOOP_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IE_DMA_END` reader - RW, enable interrupt for ADC DMA completion"] pub type IE_DMA_END_R = crate :: BitReader ;
#[doc = "Field `IE_DMA_END` writer - RW, enable interrupt for ADC DMA completion"] pub type IE_DMA_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IE_EOC` reader - RW, enable interrupt for end of ADC conversion"] pub type IE_EOC_R = crate :: BitReader ;
#[doc = "Field `IE_EOC` writer - RW, enable interrupt for end of ADC conversion"] pub type IE_EOC_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CONT_EN` reader - RW, enable contineous conversion ADC"] pub type CONT_EN_R = crate :: BitReader ;
#[doc = "Field `CONT_EN` writer - RW, enable contineous conversion ADC"] pub type CONT_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AUTO_EN` reader - RW, enable auto continuing ADC for DMA"] pub type AUTO_EN_R = crate :: BitReader ;
#[doc = "Field `AUTO_EN` writer - RW, enable auto continuing ADC for DMA"] pub type AUTO_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, ADC DMA enable"]
#[inline (always)] pub fn dma_enable (& self) -> DMA_ENABLE_R { DMA_ENABLE_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 2 - RW, ADC DMA address loop enable"]
#[inline (always)] pub fn dma_loop (& self) -> DMA_LOOP_R { DMA_LOOP_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, enable interrupt for ADC DMA completion"]
#[inline (always)] pub fn ie_dma_end (& self) -> IE_DMA_END_R { IE_DMA_END_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW, enable interrupt for end of ADC conversion"]
#[inline (always)] pub fn ie_eoc (& self) -> IE_EOC_R { IE_EOC_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - RW, enable contineous conversion ADC"]
#[inline (always)] pub fn cont_en (& self) -> CONT_EN_R { CONT_EN_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RW, enable auto continuing ADC for DMA"]
#[inline (always)] pub fn auto_en (& self) -> AUTO_EN_R { AUTO_EN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, ADC DMA enable"]
#[inline (always)] pub fn dma_enable (& mut self) -> DMA_ENABLE_W < CTRL_DMA_SPEC > { DMA_ENABLE_W :: new (self , 0) }
#[doc = "Bit 2 - RW, ADC DMA address loop enable"]
#[inline (always)] pub fn dma_loop (& mut self) -> DMA_LOOP_W < CTRL_DMA_SPEC > { DMA_LOOP_W :: new (self , 2) }
#[doc = "Bit 3 - RW, enable interrupt for ADC DMA completion"]
#[inline (always)] pub fn ie_dma_end (& mut self) -> IE_DMA_END_W < CTRL_DMA_SPEC > { IE_DMA_END_W :: new (self , 3) }
#[doc = "Bit 4 - RW, enable interrupt for end of ADC conversion"]
#[inline (always)] pub fn ie_eoc (& mut self) -> IE_EOC_W < CTRL_DMA_SPEC > { IE_EOC_W :: new (self , 4) }
#[doc = "Bit 6 - RW, enable contineous conversion ADC"]
#[inline (always)] pub fn cont_en (& mut self) -> CONT_EN_W < CTRL_DMA_SPEC > { CONT_EN_W :: new (self , 6) }
#[doc = "Bit 7 - RW, enable auto continuing ADC for DMA"]
#[inline (always)] pub fn auto_en (& mut self) -> AUTO_EN_W < CTRL_DMA_SPEC > { AUTO_EN_W :: new (self , 7) } }
#[doc = "RW, ADC DMA control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CTRL_DMA_SPEC ; impl crate :: RegisterSpec for CTRL_DMA_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`ctrl_dma::R`](R) reader structure"] impl crate :: Readable for CTRL_DMA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`ctrl_dma::W`](W) writer structure"] impl crate :: Writable for CTRL_DMA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL_DMA to value 0"] impl crate :: Resettable for CTRL_DMA_SPEC { } }
#[doc = "DMA_IF (rw) register accessor: RO, ADC interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_if::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_if::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_if`] module"] pub type DMA_IF = crate :: Reg < dma_if :: DMA_IF_SPEC > ;
#[doc = "RO, ADC interrupt flag"] pub mod dma_if {
#[doc = "Register `DMA_IF` reader"] pub type R = crate :: R < DMA_IF_SPEC > ;
#[doc = "Register `DMA_IF` writer"] pub type W = crate :: W < DMA_IF_SPEC > ;
#[doc = "Field `IF_DMA_END` reader - interrupt flag for ADC DMA completion"] pub type IF_DMA_END_R = crate :: BitReader ;
#[doc = "Field `IF_DMA_END` writer - interrupt flag for ADC DMA completion"] pub type IF_DMA_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IF_END_ADC` reader - interrupt flag for end of ADC conversion"] pub type IF_END_ADC_R = crate :: BitReader ;
#[doc = "Field `IF_END_ADC` writer - interrupt flag for end of ADC conversion"] pub type IF_END_ADC_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 3 - interrupt flag for ADC DMA completion"]
#[inline (always)] pub fn if_dma_end (& self) -> IF_DMA_END_R { IF_DMA_END_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - interrupt flag for end of ADC conversion"]
#[inline (always)] pub fn if_end_adc (& self) -> IF_END_ADC_R { IF_END_ADC_R :: new (((self . bits >> 4) & 1) != 0) } } impl W {
#[doc = "Bit 3 - interrupt flag for ADC DMA completion"]
#[inline (always)] pub fn if_dma_end (& mut self) -> IF_DMA_END_W < DMA_IF_SPEC > { IF_DMA_END_W :: new (self , 3) }
#[doc = "Bit 4 - interrupt flag for end of ADC conversion"]
#[inline (always)] pub fn if_end_adc (& mut self) -> IF_END_ADC_W < DMA_IF_SPEC > { IF_END_ADC_W :: new (self , 4) } }
#[doc = "RO, ADC interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_if::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_if::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DMA_IF_SPEC ; impl crate :: RegisterSpec for DMA_IF_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`dma_if::R`](R) reader structure"] impl crate :: Readable for DMA_IF_SPEC { }
#[doc = "`write(|w| ..)` method takes [`dma_if::W`](W) writer structure"] impl crate :: Writable for DMA_IF_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMA_IF to value 0"] impl crate :: Resettable for DMA_IF_SPEC { } }
#[doc = "AUTO_CYCLE (rw) register accessor: RO, ADC interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`auto_cycle::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`auto_cycle::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@auto_cycle`] module"] pub type AUTO_CYCLE = crate :: Reg < auto_cycle :: AUTO_CYCLE_SPEC > ;
#[doc = "RO, ADC interrupt flag"] pub mod auto_cycle {
#[doc = "Register `AUTO_CYCLE` reader"] pub type R = crate :: R < AUTO_CYCLE_SPEC > ;
#[doc = "Register `AUTO_CYCLE` writer"] pub type W = crate :: W < AUTO_CYCLE_SPEC > ;
#[doc = "Field `AUTO_CYCLE` reader - auto ADC cycle value, unit is 16 Fsys"] pub type AUTO_CYCLE_R = crate :: FieldReader ;
#[doc = "Field `AUTO_CYCLE` writer - auto ADC cycle value, unit is 16 Fsys"] pub type AUTO_CYCLE_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - auto ADC cycle value, unit is 16 Fsys"]
#[inline (always)] pub fn auto_cycle (& self) -> AUTO_CYCLE_R { AUTO_CYCLE_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - auto ADC cycle value, unit is 16 Fsys"]
#[inline (always)] pub fn auto_cycle (& mut self) -> AUTO_CYCLE_W < AUTO_CYCLE_SPEC > { AUTO_CYCLE_W :: new (self , 0) } }
#[doc = "RO, ADC interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`auto_cycle::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`auto_cycle::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AUTO_CYCLE_SPEC ; impl crate :: RegisterSpec for AUTO_CYCLE_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`auto_cycle::R`](R) reader structure"] impl crate :: Readable for AUTO_CYCLE_SPEC { }
#[doc = "`write(|w| ..)` method takes [`auto_cycle::W`](W) writer structure"] impl crate :: Writable for AUTO_CYCLE_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets AUTO_CYCLE to value 0"] impl crate :: Resettable for AUTO_CYCLE_SPEC { } }
#[doc = "DMA_NOW (r) register accessor: RO, ADC DMA current address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_now::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_now`] module"] pub type DMA_NOW = crate :: Reg < dma_now :: DMA_NOW_SPEC > ;
#[doc = "RO, ADC DMA current address"] pub mod dma_now {
#[doc = "Register `DMA_NOW` reader"] pub type R = crate :: R < DMA_NOW_SPEC > ;
#[doc = "Field `DMA_NOW` reader - ADC DMA current address"] pub type DMA_NOW_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - ADC DMA current address"]
#[inline (always)] pub fn dma_now (& self) -> DMA_NOW_R { DMA_NOW_R :: new (self . bits) } }
#[doc = "RO, ADC DMA current address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_now::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DMA_NOW_SPEC ; impl crate :: RegisterSpec for DMA_NOW_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`dma_now::R`](R) reader structure"] impl crate :: Readable for DMA_NOW_SPEC { }
#[doc = "`reset()` method sets DMA_NOW to value 0"] impl crate :: Resettable for DMA_NOW_SPEC { } }
#[doc = "DMA_BEG (rw) register accessor: RW, ADC DMA begin address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_beg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_beg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_beg`] module"] pub type DMA_BEG = crate :: Reg < dma_beg :: DMA_BEG_SPEC > ;
#[doc = "RW, ADC DMA begin address"] pub mod dma_beg {
#[doc = "Register `DMA_BEG` reader"] pub type R = crate :: R < DMA_BEG_SPEC > ;
#[doc = "Register `DMA_BEG` writer"] pub type W = crate :: W < DMA_BEG_SPEC > ;
#[doc = "Field `DMA_BEG` reader - ADC DMA begin address"] pub type DMA_BEG_R = crate :: FieldReader ;
#[doc = "Field `DMA_BEG` writer - ADC DMA begin address"] pub type DMA_BEG_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - ADC DMA begin address"]
#[inline (always)] pub fn dma_beg (& self) -> DMA_BEG_R { DMA_BEG_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - ADC DMA begin address"]
#[inline (always)] pub fn dma_beg (& mut self) -> DMA_BEG_W < DMA_BEG_SPEC > { DMA_BEG_W :: new (self , 0) } }
#[doc = "RW, ADC DMA begin address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_beg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_beg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DMA_BEG_SPEC ; impl crate :: RegisterSpec for DMA_BEG_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`dma_beg::R`](R) reader structure"] impl crate :: Readable for DMA_BEG_SPEC { }
#[doc = "`write(|w| ..)` method takes [`dma_beg::W`](W) writer structure"] impl crate :: Writable for DMA_BEG_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMA_BEG to value 0"] impl crate :: Resettable for DMA_BEG_SPEC { } }
#[doc = "DMA_END (rw) register accessor: RW, ADC DMA end address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_end::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_end::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_end`] module"] pub type DMA_END = crate :: Reg < dma_end :: DMA_END_SPEC > ;
#[doc = "RW, ADC DMA end address"] pub mod dma_end {
#[doc = "Register `DMA_END` reader"] pub type R = crate :: R < DMA_END_SPEC > ;
#[doc = "Register `DMA_END` writer"] pub type W = crate :: W < DMA_END_SPEC > ;
#[doc = "Field `DMA_END` reader - ADC DMA end address"] pub type DMA_END_R = crate :: FieldReader ;
#[doc = "Field `DMA_END` writer - ADC DMA end address"] pub type DMA_END_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - ADC DMA end address"]
#[inline (always)] pub fn dma_end (& self) -> DMA_END_R { DMA_END_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - ADC DMA end address"]
#[inline (always)] pub fn dma_end (& mut self) -> DMA_END_W < DMA_END_SPEC > { DMA_END_W :: new (self , 0) } }
#[doc = "RW, ADC DMA end address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_end::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_end::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DMA_END_SPEC ; impl crate :: RegisterSpec for DMA_END_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`dma_end::R`](R) reader structure"] impl crate :: Readable for DMA_END_SPEC { }
#[doc = "`write(|w| ..)` method takes [`dma_end::W`](W) writer structure"] impl crate :: Writable for DMA_END_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMA_END to value 0"] impl crate :: Resettable for DMA_END_SPEC { } } }
#[doc = "System Control Register"] pub type GPIOA = crate :: Periph < gpioa :: RegisterBlock , 0x4000_1000 > ; impl core :: fmt :: Debug for GPIOA { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("GPIOA") . finish () } }
#[doc = "System Control Register"] pub mod gpioa {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { _reserved0 : [u8 ; 0x90] , int_en : INT_EN , _reserved1 : [u8 ; 0x02] , int_mode : INT_MODE , _reserved2 : [u8 ; 0x06] , int_if : INT_IF , _reserved3 : [u8 ; 0x02] , dir : DIR , pin : PIN , out : OUT , clr : CLR , pu : PU , pd_drv : PD_DRV , } impl RegisterBlock {
#[doc = "0x90 - RW, GPIO PA interrupt enable"]
#[inline (always)] pub const fn int_en (& self) -> & INT_EN { & self . int_en }
#[doc = "0x94 - RW, GPIO PA interrupt mode: 0=level action, 1=edge action"]
#[inline (always)] pub const fn int_mode (& self) -> & INT_MODE { & self . int_mode }
#[doc = "0x9c - RW1, GPIO PA interrupt flag"]
#[inline (always)] pub const fn int_if (& self) -> & INT_IF { & self . int_if }
#[doc = "0xa0 - RW, GPIO PA I/O direction: 0=in, 1=out"]
#[inline (always)] pub const fn dir (& self) -> & DIR { & self . dir }
#[doc = "0xa4 - RO, GPIO PA input"]
#[inline (always)] pub const fn pin (& self) -> & PIN { & self . pin }
#[doc = "0xa8 - RW, GPIO PA output"]
#[inline (always)] pub const fn out (& self) -> & OUT { & self . out }
#[doc = "0xac - WZ, GPIO PA clear output: 0=keep, 1=clear"]
#[inline (always)] pub const fn clr (& self) -> & CLR { & self . clr }
#[doc = "0xb0 - RW, GPIO PA pullup resistance enable"]
#[inline (always)] pub const fn pu (& self) -> & PU { & self . pu }
#[doc = "0xb4 - RW, PA pulldown for input or PA driving capability for output"]
#[inline (always)] pub const fn pd_drv (& self) -> & PD_DRV { & self . pd_drv } }
#[doc = "INT_EN (rw) register accessor: RW, GPIO PA interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`int_en::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_en::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_en`] module"] pub type INT_EN = crate :: Reg < int_en :: INT_EN_SPEC > ;
#[doc = "RW, GPIO PA interrupt enable"] pub mod int_en {
#[doc = "Register `INT_EN` reader"] pub type R = crate :: R < INT_EN_SPEC > ;
#[doc = "Register `INT_EN` writer"] pub type W = crate :: W < INT_EN_SPEC > ;
#[doc = "Field `INT_EN` reader - GPIO PA interrupt enable"] pub type INT_EN_R = crate :: FieldReader < u16 > ;
#[doc = "Field `INT_EN` writer - GPIO PA interrupt enable"] pub type INT_EN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - GPIO PA interrupt enable"]
#[inline (always)] pub fn int_en (& self) -> INT_EN_R { INT_EN_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - GPIO PA interrupt enable"]
#[inline (always)] pub fn int_en (& mut self) -> INT_EN_W < INT_EN_SPEC > { INT_EN_W :: new (self , 0) } }
#[doc = "RW, GPIO PA interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`int_en::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_en::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_EN_SPEC ; impl crate :: RegisterSpec for INT_EN_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`int_en::R`](R) reader structure"] impl crate :: Readable for INT_EN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`int_en::W`](W) writer structure"] impl crate :: Writable for INT_EN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INT_EN to value 0"] impl crate :: Resettable for INT_EN_SPEC { } }
#[doc = "INT_MODE (rw) register accessor: RW, GPIO PA interrupt mode: 0=level action, 1=edge action\n\nYou can [`read`](crate::Reg::read) this register and get [`int_mode::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_mode::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_mode`] module"] pub type INT_MODE = crate :: Reg < int_mode :: INT_MODE_SPEC > ;
#[doc = "RW, GPIO PA interrupt mode: 0=level action, 1=edge action"] pub mod int_mode {
#[doc = "Register `INT_MODE` reader"] pub type R = crate :: R < INT_MODE_SPEC > ;
#[doc = "Register `INT_MODE` writer"] pub type W = crate :: W < INT_MODE_SPEC > ;
#[doc = "Field `INT_MODE` reader - GPIO PA interrupt mode"] pub type INT_MODE_R = crate :: FieldReader < u16 > ;
#[doc = "Field `INT_MODE` writer - GPIO PA interrupt mode"] pub type INT_MODE_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - GPIO PA interrupt mode"]
#[inline (always)] pub fn int_mode (& self) -> INT_MODE_R { INT_MODE_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - GPIO PA interrupt mode"]
#[inline (always)] pub fn int_mode (& mut self) -> INT_MODE_W < INT_MODE_SPEC > { INT_MODE_W :: new (self , 0) } }
#[doc = "RW, GPIO PA interrupt mode: 0=level action, 1=edge action\n\nYou can [`read`](crate::Reg::read) this register and get [`int_mode::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_mode::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_MODE_SPEC ; impl crate :: RegisterSpec for INT_MODE_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`int_mode::R`](R) reader structure"] impl crate :: Readable for INT_MODE_SPEC { }
#[doc = "`write(|w| ..)` method takes [`int_mode::W`](W) writer structure"] impl crate :: Writable for INT_MODE_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INT_MODE to value 0"] impl crate :: Resettable for INT_MODE_SPEC { } }
#[doc = "INT_IF (rw) register accessor: RW1, GPIO PA interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_if::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_if::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_if`] module"] pub type INT_IF = crate :: Reg < int_if :: INT_IF_SPEC > ;
#[doc = "RW1, GPIO PA interrupt flag"] pub mod int_if {
#[doc = "Register `INT_IF` reader"] pub type R = crate :: R < INT_IF_SPEC > ;
#[doc = "Register `INT_IF` writer"] pub type W = crate :: W < INT_IF_SPEC > ;
#[doc = "Field `INT_IF` reader - GPIO PA interrupt flag"] pub type INT_IF_R = crate :: FieldReader < u16 > ;
#[doc = "Field `INT_IF` writer - GPIO PA interrupt flag"] pub type INT_IF_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - GPIO PA interrupt flag"]
#[inline (always)] pub fn int_if (& self) -> INT_IF_R { INT_IF_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - GPIO PA interrupt flag"]
#[inline (always)] pub fn int_if (& mut self) -> INT_IF_W < INT_IF_SPEC > { INT_IF_W :: new (self , 0) } }
#[doc = "RW1, GPIO PA interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_if::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_if::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_IF_SPEC ; impl crate :: RegisterSpec for INT_IF_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`int_if::R`](R) reader structure"] impl crate :: Readable for INT_IF_SPEC { }
#[doc = "`write(|w| ..)` method takes [`int_if::W`](W) writer structure"] impl crate :: Writable for INT_IF_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INT_IF to value 0"] impl crate :: Resettable for INT_IF_SPEC { } }
#[doc = "DIR (rw) register accessor: RW, GPIO PA I/O direction: 0=in, 1=out\n\nYou can [`read`](crate::Reg::read) this register and get [`dir::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dir::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dir`] module"] pub type DIR = crate :: Reg < dir :: DIR_SPEC > ;
#[doc = "RW, GPIO PA I/O direction: 0=in, 1=out"] pub mod dir {
#[doc = "Register `DIR` reader"] pub type R = crate :: R < DIR_SPEC > ;
#[doc = "Register `DIR` writer"] pub type W = crate :: W < DIR_SPEC > ;
#[doc = "Field `DIR_0` reader - GPIO PA I/O direction byte 0"] pub type DIR_0_R = crate :: FieldReader ;
#[doc = "Field `DIR_0` writer - GPIO PA I/O direction byte 0"] pub type DIR_0_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `DIR_1` reader - GPIO PA I/O direction byte 1"] pub type DIR_1_R = crate :: FieldReader ;
#[doc = "Field `DIR_1` writer - GPIO PA I/O direction byte 1"] pub type DIR_1_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - GPIO PA I/O direction byte 0"]
#[inline (always)] pub fn dir_0 (& self) -> DIR_0_R { DIR_0_R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - GPIO PA I/O direction byte 1"]
#[inline (always)] pub fn dir_1 (& self) -> DIR_1_R { DIR_1_R :: new (((self . bits >> 8) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - GPIO PA I/O direction byte 0"]
#[inline (always)] pub fn dir_0 (& mut self) -> DIR_0_W < DIR_SPEC > { DIR_0_W :: new (self , 0) }
#[doc = "Bits 8:15 - GPIO PA I/O direction byte 1"]
#[inline (always)] pub fn dir_1 (& mut self) -> DIR_1_W < DIR_SPEC > { DIR_1_W :: new (self , 8) } }
#[doc = "RW, GPIO PA I/O direction: 0=in, 1=out\n\nYou can [`read`](crate::Reg::read) this register and get [`dir::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dir::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`dir::R`](R) reader structure"] impl crate :: Readable for DIR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`dir::W`](W) writer structure"] impl crate :: Writable for DIR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIR to value 0"] impl crate :: Resettable for DIR_SPEC { } }
#[doc = "PIN (r) register accessor: RO, GPIO PA input\n\nYou can [`read`](crate::Reg::read) this register and get [`pin::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pin`] module"] pub type PIN = crate :: Reg < pin :: PIN_SPEC > ;
#[doc = "RO, GPIO PA input"] pub mod pin {
#[doc = "Register `PIN` reader"] pub type R = crate :: R < PIN_SPEC > ;
#[doc = "Field `PIN_0` reader - GPIO PA input byte 0"] pub type PIN_0_R = crate :: FieldReader ;
#[doc = "Field `PIN_1` reader - GPIO PA input byte 1"] pub type PIN_1_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - GPIO PA input byte 0"]
#[inline (always)] pub fn pin_0 (& self) -> PIN_0_R { PIN_0_R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - GPIO PA input byte 1"]
#[inline (always)] pub fn pin_1 (& self) -> PIN_1_R { PIN_1_R :: new (((self . bits >> 8) & 0xff) as u8) } }
#[doc = "RO, GPIO PA input\n\nYou can [`read`](crate::Reg::read) this register and get [`pin::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PIN_SPEC ; impl crate :: RegisterSpec for PIN_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`pin::R`](R) reader structure"] impl crate :: Readable for PIN_SPEC { }
#[doc = "`reset()` method sets PIN to value 0"] impl crate :: Resettable for PIN_SPEC { } }
#[doc = "OUT (rw) register accessor: RW, GPIO PA output\n\nYou can [`read`](crate::Reg::read) this register and get [`out::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`out::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@out`] module"] pub type OUT = crate :: Reg < out :: OUT_SPEC > ;
#[doc = "RW, GPIO PA output"] pub mod out {
#[doc = "Register `OUT` reader"] pub type R = crate :: R < OUT_SPEC > ;
#[doc = "Register `OUT` writer"] pub type W = crate :: W < OUT_SPEC > ;
#[doc = "Field `OUT_0` reader - GPIO PA output byte 0"] pub type OUT_0_R = crate :: FieldReader ;
#[doc = "Field `OUT_0` writer - GPIO PA output byte 0"] pub type OUT_0_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `OUT_1` reader - GPIO PA output byte 1"] pub type OUT_1_R = crate :: FieldReader ;
#[doc = "Field `OUT_1` writer - GPIO PA output byte 1"] pub type OUT_1_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - GPIO PA output byte 0"]
#[inline (always)] pub fn out_0 (& self) -> OUT_0_R { OUT_0_R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - GPIO PA output byte 1"]
#[inline (always)] pub fn out_1 (& self) -> OUT_1_R { OUT_1_R :: new (((self . bits >> 8) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - GPIO PA output byte 0"]
#[inline (always)] pub fn out_0 (& mut self) -> OUT_0_W < OUT_SPEC > { OUT_0_W :: new (self , 0) }
#[doc = "Bits 8:15 - GPIO PA output byte 1"]
#[inline (always)] pub fn out_1 (& mut self) -> OUT_1_W < OUT_SPEC > { OUT_1_W :: new (self , 8) } }
#[doc = "RW, GPIO PA output\n\nYou can [`read`](crate::Reg::read) this register and get [`out::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`out::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`out::R`](R) reader structure"] impl crate :: Readable for OUT_SPEC { }
#[doc = "`write(|w| ..)` method takes [`out::W`](W) writer structure"] impl crate :: Writable for OUT_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OUT to value 0"] impl crate :: Resettable for OUT_SPEC { } }
#[doc = "CLR (rw) register accessor: WZ, GPIO PA clear output: 0=keep, 1=clear\n\nYou can [`read`](crate::Reg::read) this register and get [`clr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clr`] module"] pub type CLR = crate :: Reg < clr :: CLR_SPEC > ;
#[doc = "WZ, GPIO PA clear output: 0=keep, 1=clear"] pub mod clr {
#[doc = "Register `CLR` reader"] pub type R = crate :: R < CLR_SPEC > ;
#[doc = "Register `CLR` writer"] pub type W = crate :: W < CLR_SPEC > ;
#[doc = "Field `CLR_0` reader - GPIO PA clear output byte 0"] pub type CLR_0_R = crate :: FieldReader ;
#[doc = "Field `CLR_0` writer - GPIO PA clear output byte 0"] pub type CLR_0_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `CLR_1` reader - GPIO PA clear output byte 1"] pub type CLR_1_R = crate :: FieldReader ;
#[doc = "Field `CLR_1` writer - GPIO PA clear output byte 1"] pub type CLR_1_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - GPIO PA clear output byte 0"]
#[inline (always)] pub fn clr_0 (& self) -> CLR_0_R { CLR_0_R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - GPIO PA clear output byte 1"]
#[inline (always)] pub fn clr_1 (& self) -> CLR_1_R { CLR_1_R :: new (((self . bits >> 8) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - GPIO PA clear output byte 0"]
#[inline (always)] pub fn clr_0 (& mut self) -> CLR_0_W < CLR_SPEC > { CLR_0_W :: new (self , 0) }
#[doc = "Bits 8:15 - GPIO PA clear output byte 1"]
#[inline (always)] pub fn clr_1 (& mut self) -> CLR_1_W < CLR_SPEC > { CLR_1_W :: new (self , 8) } }
#[doc = "WZ, GPIO PA clear output: 0=keep, 1=clear\n\nYou can [`read`](crate::Reg::read) this register and get [`clr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CLR_SPEC ; impl crate :: RegisterSpec for CLR_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`clr::R`](R) reader structure"] impl crate :: Readable for CLR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`clr::W`](W) writer structure"] impl crate :: Writable for CLR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CLR to value 0"] impl crate :: Resettable for CLR_SPEC { } }
#[doc = "PU (rw) register accessor: RW, GPIO PA pullup resistance enable\n\nYou can [`read`](crate::Reg::read) this register and get [`pu::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pu::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pu`] module"] pub type PU = crate :: Reg < pu :: PU_SPEC > ;
#[doc = "RW, GPIO PA pullup resistance enable"] pub mod pu {
#[doc = "Register `PU` reader"] pub type R = crate :: R < PU_SPEC > ;
#[doc = "Register `PU` writer"] pub type W = crate :: W < PU_SPEC > ;
#[doc = "Field `PU_0` reader - GPIO PA pullup resistance enable byte 0"] pub type PU_0_R = crate :: FieldReader ;
#[doc = "Field `PU_0` writer - GPIO PA pullup resistance enable byte 0"] pub type PU_0_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `PU_1` reader - GPIO PA pullup resistance enable byte 0"] pub type PU_1_R = crate :: FieldReader ;
#[doc = "Field `PU_1` writer - GPIO PA pullup resistance enable byte 0"] pub type PU_1_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - GPIO PA pullup resistance enable byte 0"]
#[inline (always)] pub fn pu_0 (& self) -> PU_0_R { PU_0_R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - GPIO PA pullup resistance enable byte 0"]
#[inline (always)] pub fn pu_1 (& self) -> PU_1_R { PU_1_R :: new (((self . bits >> 8) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - GPIO PA pullup resistance enable byte 0"]
#[inline (always)] pub fn pu_0 (& mut self) -> PU_0_W < PU_SPEC > { PU_0_W :: new (self , 0) }
#[doc = "Bits 8:15 - GPIO PA pullup resistance enable byte 0"]
#[inline (always)] pub fn pu_1 (& mut self) -> PU_1_W < PU_SPEC > { PU_1_W :: new (self , 8) } }
#[doc = "RW, GPIO PA pullup resistance enable\n\nYou can [`read`](crate::Reg::read) this register and get [`pu::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pu::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PU_SPEC ; impl crate :: RegisterSpec for PU_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`pu::R`](R) reader structure"] impl crate :: Readable for PU_SPEC { }
#[doc = "`write(|w| ..)` method takes [`pu::W`](W) writer structure"] impl crate :: Writable for PU_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PU to value 0"] impl crate :: Resettable for PU_SPEC { } }
#[doc = "PD_DRV (rw) register accessor: RW, PA pulldown for input or PA driving capability for output\n\nYou can [`read`](crate::Reg::read) this register and get [`pd_drv::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pd_drv::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pd_drv`] module"] pub type PD_DRV = crate :: Reg < pd_drv :: PD_DRV_SPEC > ;
#[doc = "RW, PA pulldown for input or PA driving capability for output"] pub mod pd_drv {
#[doc = "Register `PD_DRV` reader"] pub type R = crate :: R < PD_DRV_SPEC > ;
#[doc = "Register `PD_DRV` writer"] pub type W = crate :: W < PD_DRV_SPEC > ;
#[doc = "Field `PD_DRV_0` reader - PA pulldown for input or PA driving capability for output byte 0"] pub type PD_DRV_0_R = crate :: FieldReader ;
#[doc = "Field `PD_DRV_0` writer - PA pulldown for input or PA driving capability for output byte 0"] pub type PD_DRV_0_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `PD_DRV_1` reader - PA pulldown for input or PA driving capability for output byte 1"] pub type PD_DRV_1_R = crate :: FieldReader ;
#[doc = "Field `PD_DRV_1` writer - PA pulldown for input or PA driving capability for output byte 1"] pub type PD_DRV_1_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - PA pulldown for input or PA driving capability for output byte 0"]
#[inline (always)] pub fn pd_drv_0 (& self) -> PD_DRV_0_R { PD_DRV_0_R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - PA pulldown for input or PA driving capability for output byte 1"]
#[inline (always)] pub fn pd_drv_1 (& self) -> PD_DRV_1_R { PD_DRV_1_R :: new (((self . bits >> 8) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - PA pulldown for input or PA driving capability for output byte 0"]
#[inline (always)] pub fn pd_drv_0 (& mut self) -> PD_DRV_0_W < PD_DRV_SPEC > { PD_DRV_0_W :: new (self , 0) }
#[doc = "Bits 8:15 - PA pulldown for input or PA driving capability for output byte 1"]
#[inline (always)] pub fn pd_drv_1 (& mut self) -> PD_DRV_1_W < PD_DRV_SPEC > { PD_DRV_1_W :: new (self , 8) } }
#[doc = "RW, PA pulldown for input or PA driving capability for output\n\nYou can [`read`](crate::Reg::read) this register and get [`pd_drv::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pd_drv::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PD_DRV_SPEC ; impl crate :: RegisterSpec for PD_DRV_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`pd_drv::R`](R) reader structure"] impl crate :: Readable for PD_DRV_SPEC { }
#[doc = "`write(|w| ..)` method takes [`pd_drv::W`](W) writer structure"] impl crate :: Writable for PD_DRV_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PD_DRV to value 0"] impl crate :: Resettable for PD_DRV_SPEC { } } }
#[doc = "System Control Register"] pub type GPIOB = crate :: Periph < gpiob :: RegisterBlock , 0x4000_1000 > ; impl core :: fmt :: Debug for GPIOB { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("GPIOB") . finish () } }
#[doc = "System Control Register"] pub mod gpiob {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { _reserved0 : [u8 ; 0x92] , int_en : INT_EN , _reserved1 : [u8 ; 0x02] , int_mode : INT_MODE , _reserved2 : [u8 ; 0x06] , int_if : INT_IF , _reserved3 : [u8 ; 0x20] , dir : DIR , pin : PIN , out : OUT , clr : CLR , pu : PU , pd_drv : PD_DRV , } impl RegisterBlock {
#[doc = "0x92 - RW, GPIO PB interrupt enable"]
#[inline (always)] pub const fn int_en (& self) -> & INT_EN { & self . int_en }
#[doc = "0x96 - RW, GPIO PB interrupt mode: 0=level action, 1=edge action"]
#[inline (always)] pub const fn int_mode (& self) -> & INT_MODE { & self . int_mode }
#[doc = "0x9e - RW1, GPIO PB interrupt flag"]
#[inline (always)] pub const fn int_if (& self) -> & INT_IF { & self . int_if }
#[doc = "0xc0 - RW, GPIO PB I/O direction: 0=in, 1=out"]
#[inline (always)] pub const fn dir (& self) -> & DIR { & self . dir }
#[doc = "0xc4 - RO, GPIO PB input"]
#[inline (always)] pub const fn pin (& self) -> & PIN { & self . pin }
#[doc = "0xc8 - RW, GPIO PB output"]
#[inline (always)] pub const fn out (& self) -> & OUT { & self . out }
#[doc = "0xcc - WZ, GPIO PB clear output: 0=keep, 1=clear"]
#[inline (always)] pub const fn clr (& self) -> & CLR { & self . clr }
#[doc = "0xd0 - RW, GPIO PB pullup resistance enable"]
#[inline (always)] pub const fn pu (& self) -> & PU { & self . pu }
#[doc = "0xd4 - RW, PB pulldown for input or PB driving capability for output"]
#[inline (always)] pub const fn pd_drv (& self) -> & PD_DRV { & self . pd_drv } }
#[doc = "INT_EN (rw) register accessor: RW, GPIO PB interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`int_en::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_en::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_en`] module"] pub type INT_EN = crate :: Reg < int_en :: INT_EN_SPEC > ;
#[doc = "RW, GPIO PB interrupt enable"] pub mod int_en {
#[doc = "Register `INT_EN` reader"] pub type R = crate :: R < INT_EN_SPEC > ;
#[doc = "Register `INT_EN` writer"] pub type W = crate :: W < INT_EN_SPEC > ;
#[doc = "Field `INT_EN` reader - GPIO PB interrupt enable"] pub type INT_EN_R = crate :: FieldReader < u16 > ;
#[doc = "Field `INT_EN` writer - GPIO PB interrupt enable"] pub type INT_EN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - GPIO PB interrupt enable"]
#[inline (always)] pub fn int_en (& self) -> INT_EN_R { INT_EN_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - GPIO PB interrupt enable"]
#[inline (always)] pub fn int_en (& mut self) -> INT_EN_W < INT_EN_SPEC > { INT_EN_W :: new (self , 0) } }
#[doc = "RW, GPIO PB interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`int_en::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_en::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_EN_SPEC ; impl crate :: RegisterSpec for INT_EN_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`int_en::R`](R) reader structure"] impl crate :: Readable for INT_EN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`int_en::W`](W) writer structure"] impl crate :: Writable for INT_EN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INT_EN to value 0"] impl crate :: Resettable for INT_EN_SPEC { } }
#[doc = "INT_MODE (rw) register accessor: RW, GPIO PB interrupt mode: 0=level action, 1=edge action\n\nYou can [`read`](crate::Reg::read) this register and get [`int_mode::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_mode::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_mode`] module"] pub type INT_MODE = crate :: Reg < int_mode :: INT_MODE_SPEC > ;
#[doc = "RW, GPIO PB interrupt mode: 0=level action, 1=edge action"] pub mod int_mode {
#[doc = "Register `INT_MODE` reader"] pub type R = crate :: R < INT_MODE_SPEC > ;
#[doc = "Register `INT_MODE` writer"] pub type W = crate :: W < INT_MODE_SPEC > ;
#[doc = "Field `INT_MODE` reader - GPIO PB interrupt mode"] pub type INT_MODE_R = crate :: FieldReader < u16 > ;
#[doc = "Field `INT_MODE` writer - GPIO PB interrupt mode"] pub type INT_MODE_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - GPIO PB interrupt mode"]
#[inline (always)] pub fn int_mode (& self) -> INT_MODE_R { INT_MODE_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - GPIO PB interrupt mode"]
#[inline (always)] pub fn int_mode (& mut self) -> INT_MODE_W < INT_MODE_SPEC > { INT_MODE_W :: new (self , 0) } }
#[doc = "RW, GPIO PB interrupt mode: 0=level action, 1=edge action\n\nYou can [`read`](crate::Reg::read) this register and get [`int_mode::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_mode::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_MODE_SPEC ; impl crate :: RegisterSpec for INT_MODE_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`int_mode::R`](R) reader structure"] impl crate :: Readable for INT_MODE_SPEC { }
#[doc = "`write(|w| ..)` method takes [`int_mode::W`](W) writer structure"] impl crate :: Writable for INT_MODE_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INT_MODE to value 0"] impl crate :: Resettable for INT_MODE_SPEC { } }
#[doc = "INT_IF (rw) register accessor: RW1, GPIO PB interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_if::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_if::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_if`] module"] pub type INT_IF = crate :: Reg < int_if :: INT_IF_SPEC > ;
#[doc = "RW1, GPIO PB interrupt flag"] pub mod int_if {
#[doc = "Register `INT_IF` reader"] pub type R = crate :: R < INT_IF_SPEC > ;
#[doc = "Register `INT_IF` writer"] pub type W = crate :: W < INT_IF_SPEC > ;
#[doc = "Field `INT_IF` reader - GPIO PB interrupt flag"] pub type INT_IF_R = crate :: FieldReader < u16 > ;
#[doc = "Field `INT_IF` writer - GPIO PB interrupt flag"] pub type INT_IF_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - GPIO PB interrupt flag"]
#[inline (always)] pub fn int_if (& self) -> INT_IF_R { INT_IF_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - GPIO PB interrupt flag"]
#[inline (always)] pub fn int_if (& mut self) -> INT_IF_W < INT_IF_SPEC > { INT_IF_W :: new (self , 0) } }
#[doc = "RW1, GPIO PB interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_if::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_if::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_IF_SPEC ; impl crate :: RegisterSpec for INT_IF_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`int_if::R`](R) reader structure"] impl crate :: Readable for INT_IF_SPEC { }
#[doc = "`write(|w| ..)` method takes [`int_if::W`](W) writer structure"] impl crate :: Writable for INT_IF_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INT_IF to value 0"] impl crate :: Resettable for INT_IF_SPEC { } }
#[doc = "DIR (rw) register accessor: RW, GPIO PB I/O direction: 0=in, 1=out\n\nYou can [`read`](crate::Reg::read) this register and get [`dir::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dir::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dir`] module"] pub type DIR = crate :: Reg < dir :: DIR_SPEC > ;
#[doc = "RW, GPIO PB I/O direction: 0=in, 1=out"] pub mod dir {
#[doc = "Register `DIR` reader"] pub type R = crate :: R < DIR_SPEC > ;
#[doc = "Register `DIR` writer"] pub type W = crate :: W < DIR_SPEC > ;
#[doc = "Field `DIR_0` reader - GPIO PB I/O direction byte 0"] pub type DIR_0_R = crate :: FieldReader ;
#[doc = "Field `DIR_0` writer - GPIO PB I/O direction byte 0"] pub type DIR_0_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `DIR_1` reader - GPIO PB I/O direction byte 1"] pub type DIR_1_R = crate :: FieldReader ;
#[doc = "Field `DIR_1` writer - GPIO PB I/O direction byte 1"] pub type DIR_1_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `DIR_2` reader - GPIO PB I/O direction byte 2"] pub type DIR_2_R = crate :: FieldReader ;
#[doc = "Field `DIR_2` writer - GPIO PB I/O direction byte 2"] pub type DIR_2_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - GPIO PB I/O direction byte 0"]
#[inline (always)] pub fn dir_0 (& self) -> DIR_0_R { DIR_0_R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - GPIO PB I/O direction byte 1"]
#[inline (always)] pub fn dir_1 (& self) -> DIR_1_R { DIR_1_R :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - GPIO PB I/O direction byte 2"]
#[inline (always)] pub fn dir_2 (& self) -> DIR_2_R { DIR_2_R :: new (((self . bits >> 16) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - GPIO PB I/O direction byte 0"]
#[inline (always)] pub fn dir_0 (& mut self) -> DIR_0_W < DIR_SPEC > { DIR_0_W :: new (self , 0) }
#[doc = "Bits 8:15 - GPIO PB I/O direction byte 1"]
#[inline (always)] pub fn dir_1 (& mut self) -> DIR_1_W < DIR_SPEC > { DIR_1_W :: new (self , 8) }
#[doc = "Bits 16:23 - GPIO PB I/O direction byte 2"]
#[inline (always)] pub fn dir_2 (& mut self) -> DIR_2_W < DIR_SPEC > { DIR_2_W :: new (self , 16) } }
#[doc = "RW, GPIO PB I/O direction: 0=in, 1=out\n\nYou can [`read`](crate::Reg::read) this register and get [`dir::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dir::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DIR_SPEC ; impl crate :: RegisterSpec for DIR_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`dir::R`](R) reader structure"] impl crate :: Readable for DIR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`dir::W`](W) writer structure"] impl crate :: Writable for DIR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIR to value 0"] impl crate :: Resettable for DIR_SPEC { } }
#[doc = "PIN (r) register accessor: RO, GPIO PB input\n\nYou can [`read`](crate::Reg::read) this register and get [`pin::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pin`] module"] pub type PIN = crate :: Reg < pin :: PIN_SPEC > ;
#[doc = "RO, GPIO PB input"] pub mod pin {
#[doc = "Register `PIN` reader"] pub type R = crate :: R < PIN_SPEC > ;
#[doc = "Field `PIN_0` reader - GPIO PB input byte 0"] pub type PIN_0_R = crate :: FieldReader ;
#[doc = "Field `PIN_1` reader - GPIO PB input byte 1"] pub type PIN_1_R = crate :: FieldReader ;
#[doc = "Field `PIN_2` reader - GPIO PB input byte 2"] pub type PIN_2_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - GPIO PB input byte 0"]
#[inline (always)] pub fn pin_0 (& self) -> PIN_0_R { PIN_0_R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - GPIO PB input byte 1"]
#[inline (always)] pub fn pin_1 (& self) -> PIN_1_R { PIN_1_R :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - GPIO PB input byte 2"]
#[inline (always)] pub fn pin_2 (& self) -> PIN_2_R { PIN_2_R :: new (((self . bits >> 16) & 0xff) as u8) } }
#[doc = "RO, GPIO PB input\n\nYou can [`read`](crate::Reg::read) this register and get [`pin::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PIN_SPEC ; impl crate :: RegisterSpec for PIN_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`pin::R`](R) reader structure"] impl crate :: Readable for PIN_SPEC { }
#[doc = "`reset()` method sets PIN to value 0"] impl crate :: Resettable for PIN_SPEC { } }
#[doc = "OUT (rw) register accessor: RW, GPIO PB output\n\nYou can [`read`](crate::Reg::read) this register and get [`out::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`out::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@out`] module"] pub type OUT = crate :: Reg < out :: OUT_SPEC > ;
#[doc = "RW, GPIO PB output"] pub mod out {
#[doc = "Register `OUT` reader"] pub type R = crate :: R < OUT_SPEC > ;
#[doc = "Register `OUT` writer"] pub type W = crate :: W < OUT_SPEC > ;
#[doc = "Field `OUT_0` reader - GPIO PB output byte 0"] pub type OUT_0_R = crate :: FieldReader ;
#[doc = "Field `OUT_0` writer - GPIO PB output byte 0"] pub type OUT_0_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `OUT_1` reader - GPIO PB output byte 1"] pub type OUT_1_R = crate :: FieldReader ;
#[doc = "Field `OUT_1` writer - GPIO PB output byte 1"] pub type OUT_1_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `OUT_2` reader - GPIO PB output byte 2"] pub type OUT_2_R = crate :: FieldReader ;
#[doc = "Field `OUT_2` writer - GPIO PB output byte 2"] pub type OUT_2_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - GPIO PB output byte 0"]
#[inline (always)] pub fn out_0 (& self) -> OUT_0_R { OUT_0_R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - GPIO PB output byte 1"]
#[inline (always)] pub fn out_1 (& self) -> OUT_1_R { OUT_1_R :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - GPIO PB output byte 2"]
#[inline (always)] pub fn out_2 (& self) -> OUT_2_R { OUT_2_R :: new (((self . bits >> 16) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - GPIO PB output byte 0"]
#[inline (always)] pub fn out_0 (& mut self) -> OUT_0_W < OUT_SPEC > { OUT_0_W :: new (self , 0) }
#[doc = "Bits 8:15 - GPIO PB output byte 1"]
#[inline (always)] pub fn out_1 (& mut self) -> OUT_1_W < OUT_SPEC > { OUT_1_W :: new (self , 8) }
#[doc = "Bits 16:23 - GPIO PB output byte 2"]
#[inline (always)] pub fn out_2 (& mut self) -> OUT_2_W < OUT_SPEC > { OUT_2_W :: new (self , 16) } }
#[doc = "RW, GPIO PB output\n\nYou can [`read`](crate::Reg::read) this register and get [`out::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`out::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OUT_SPEC ; impl crate :: RegisterSpec for OUT_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`out::R`](R) reader structure"] impl crate :: Readable for OUT_SPEC { }
#[doc = "`write(|w| ..)` method takes [`out::W`](W) writer structure"] impl crate :: Writable for OUT_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OUT to value 0"] impl crate :: Resettable for OUT_SPEC { } }
#[doc = "CLR (rw) register accessor: WZ, GPIO PB clear output: 0=keep, 1=clear\n\nYou can [`read`](crate::Reg::read) this register and get [`clr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clr`] module"] pub type CLR = crate :: Reg < clr :: CLR_SPEC > ;
#[doc = "WZ, GPIO PB clear output: 0=keep, 1=clear"] pub mod clr {
#[doc = "Register `CLR` reader"] pub type R = crate :: R < CLR_SPEC > ;
#[doc = "Register `CLR` writer"] pub type W = crate :: W < CLR_SPEC > ;
#[doc = "Field `CLR_0` reader - GPIO PB clear output byte 0"] pub type CLR_0_R = crate :: FieldReader ;
#[doc = "Field `CLR_0` writer - GPIO PB clear output byte 0"] pub type CLR_0_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `CLR_1` reader - GPIO PB clear output byte 1"] pub type CLR_1_R = crate :: FieldReader ;
#[doc = "Field `CLR_1` writer - GPIO PB clear output byte 1"] pub type CLR_1_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `CLR_2` reader - GPIO PB clear output byte 2"] pub type CLR_2_R = crate :: FieldReader ;
#[doc = "Field `CLR_2` writer - GPIO PB clear output byte 2"] pub type CLR_2_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - GPIO PB clear output byte 0"]
#[inline (always)] pub fn clr_0 (& self) -> CLR_0_R { CLR_0_R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - GPIO PB clear output byte 1"]
#[inline (always)] pub fn clr_1 (& self) -> CLR_1_R { CLR_1_R :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - GPIO PB clear output byte 2"]
#[inline (always)] pub fn clr_2 (& self) -> CLR_2_R { CLR_2_R :: new (((self . bits >> 16) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - GPIO PB clear output byte 0"]
#[inline (always)] pub fn clr_0 (& mut self) -> CLR_0_W < CLR_SPEC > { CLR_0_W :: new (self , 0) }
#[doc = "Bits 8:15 - GPIO PB clear output byte 1"]
#[inline (always)] pub fn clr_1 (& mut self) -> CLR_1_W < CLR_SPEC > { CLR_1_W :: new (self , 8) }
#[doc = "Bits 16:23 - GPIO PB clear output byte 2"]
#[inline (always)] pub fn clr_2 (& mut self) -> CLR_2_W < CLR_SPEC > { CLR_2_W :: new (self , 16) } }
#[doc = "WZ, GPIO PB clear output: 0=keep, 1=clear\n\nYou can [`read`](crate::Reg::read) this register and get [`clr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CLR_SPEC ; impl crate :: RegisterSpec for CLR_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`clr::R`](R) reader structure"] impl crate :: Readable for CLR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`clr::W`](W) writer structure"] impl crate :: Writable for CLR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CLR to value 0"] impl crate :: Resettable for CLR_SPEC { } }
#[doc = "PU (rw) register accessor: RW, GPIO PB pullup resistance enable\n\nYou can [`read`](crate::Reg::read) this register and get [`pu::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pu::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pu`] module"] pub type PU = crate :: Reg < pu :: PU_SPEC > ;
#[doc = "RW, GPIO PB pullup resistance enable"] pub mod pu {
#[doc = "Register `PU` reader"] pub type R = crate :: R < PU_SPEC > ;
#[doc = "Register `PU` writer"] pub type W = crate :: W < PU_SPEC > ;
#[doc = "Field `PU_0` reader - GPIO PB pullup resistance enable byte 0"] pub type PU_0_R = crate :: FieldReader ;
#[doc = "Field `PU_0` writer - GPIO PB pullup resistance enable byte 0"] pub type PU_0_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `PU_1` reader - GPIO PB pullup resistance enable byte 1"] pub type PU_1_R = crate :: FieldReader ;
#[doc = "Field `PU_1` writer - GPIO PB pullup resistance enable byte 1"] pub type PU_1_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `PU_2` reader - GPIO PB pullup resistance enable byte 2"] pub type PU_2_R = crate :: FieldReader ;
#[doc = "Field `PU_2` writer - GPIO PB pullup resistance enable byte 2"] pub type PU_2_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - GPIO PB pullup resistance enable byte 0"]
#[inline (always)] pub fn pu_0 (& self) -> PU_0_R { PU_0_R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - GPIO PB pullup resistance enable byte 1"]
#[inline (always)] pub fn pu_1 (& self) -> PU_1_R { PU_1_R :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - GPIO PB pullup resistance enable byte 2"]
#[inline (always)] pub fn pu_2 (& self) -> PU_2_R { PU_2_R :: new (((self . bits >> 16) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - GPIO PB pullup resistance enable byte 0"]
#[inline (always)] pub fn pu_0 (& mut self) -> PU_0_W < PU_SPEC > { PU_0_W :: new (self , 0) }
#[doc = "Bits 8:15 - GPIO PB pullup resistance enable byte 1"]
#[inline (always)] pub fn pu_1 (& mut self) -> PU_1_W < PU_SPEC > { PU_1_W :: new (self , 8) }
#[doc = "Bits 16:23 - GPIO PB pullup resistance enable byte 2"]
#[inline (always)] pub fn pu_2 (& mut self) -> PU_2_W < PU_SPEC > { PU_2_W :: new (self , 16) } }
#[doc = "RW, GPIO PB pullup resistance enable\n\nYou can [`read`](crate::Reg::read) this register and get [`pu::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pu::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PU_SPEC ; impl crate :: RegisterSpec for PU_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`pu::R`](R) reader structure"] impl crate :: Readable for PU_SPEC { }
#[doc = "`write(|w| ..)` method takes [`pu::W`](W) writer structure"] impl crate :: Writable for PU_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PU to value 0"] impl crate :: Resettable for PU_SPEC { } }
#[doc = "PD_DRV (rw) register accessor: RW, PB pulldown for input or PB driving capability for output\n\nYou can [`read`](crate::Reg::read) this register and get [`pd_drv::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pd_drv::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pd_drv`] module"] pub type PD_DRV = crate :: Reg < pd_drv :: PD_DRV_SPEC > ;
#[doc = "RW, PB pulldown for input or PB driving capability for output"] pub mod pd_drv {
#[doc = "Register `PD_DRV` reader"] pub type R = crate :: R < PD_DRV_SPEC > ;
#[doc = "Register `PD_DRV` writer"] pub type W = crate :: W < PD_DRV_SPEC > ;
#[doc = "Field `PD_DRV_0` reader - PB pulldown for input or PB driving capability for output byte 0"] pub type PD_DRV_0_R = crate :: FieldReader ;
#[doc = "Field `PD_DRV_0` writer - PB pulldown for input or PB driving capability for output byte 0"] pub type PD_DRV_0_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `PD_DRV_1` reader - PB pulldown for input or PB driving capability for output byte 0"] pub type PD_DRV_1_R = crate :: FieldReader ;
#[doc = "Field `PD_DRV_1` writer - PB pulldown for input or PB driving capability for output byte 0"] pub type PD_DRV_1_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `PD_DRV_2` reader - PB pulldown for input or PB driving capability for output byte 0"] pub type PD_DRV_2_R = crate :: FieldReader ;
#[doc = "Field `PD_DRV_2` writer - PB pulldown for input or PB driving capability for output byte 0"] pub type PD_DRV_2_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - PB pulldown for input or PB driving capability for output byte 0"]
#[inline (always)] pub fn pd_drv_0 (& self) -> PD_DRV_0_R { PD_DRV_0_R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - PB pulldown for input or PB driving capability for output byte 0"]
#[inline (always)] pub fn pd_drv_1 (& self) -> PD_DRV_1_R { PD_DRV_1_R :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - PB pulldown for input or PB driving capability for output byte 0"]
#[inline (always)] pub fn pd_drv_2 (& self) -> PD_DRV_2_R { PD_DRV_2_R :: new (((self . bits >> 16) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - PB pulldown for input or PB driving capability for output byte 0"]
#[inline (always)] pub fn pd_drv_0 (& mut self) -> PD_DRV_0_W < PD_DRV_SPEC > { PD_DRV_0_W :: new (self , 0) }
#[doc = "Bits 8:15 - PB pulldown for input or PB driving capability for output byte 0"]
#[inline (always)] pub fn pd_drv_1 (& mut self) -> PD_DRV_1_W < PD_DRV_SPEC > { PD_DRV_1_W :: new (self , 8) }
#[doc = "Bits 16:23 - PB pulldown for input or PB driving capability for output byte 0"]
#[inline (always)] pub fn pd_drv_2 (& mut self) -> PD_DRV_2_W < PD_DRV_SPEC > { PD_DRV_2_W :: new (self , 16) } }
#[doc = "RW, PB pulldown for input or PB driving capability for output\n\nYou can [`read`](crate::Reg::read) this register and get [`pd_drv::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pd_drv::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PD_DRV_SPEC ; impl crate :: RegisterSpec for PD_DRV_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`pd_drv::R`](R) reader structure"] impl crate :: Readable for PD_DRV_SPEC { }
#[doc = "`write(|w| ..)` method takes [`pd_drv::W`](W) writer structure"] impl crate :: Writable for PD_DRV_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PD_DRV to value 0"] impl crate :: Resettable for PD_DRV_SPEC { } } }
#[doc = "Timer0 register"] pub type TMR0 = crate :: Periph < tmr0 :: RegisterBlock , 0x4000_2000 > ; impl core :: fmt :: Debug for TMR0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TMR0") . finish () } }
#[doc = "Timer0 register"] pub mod tmr0 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ctrl_mod : CTRL_MOD , _reserved1 : [u8 ; 0x01] , inter_en : INTER_EN , _reserved2 : [u8 ; 0x03] , int_flag : INT_FLAG , fifo_count : FIFO_COUNT , count : COUNT , cnt_end : CNT_END , fifo : FIFO , } impl RegisterBlock {
#[doc = "0x00 - RW, TMR0 mode control"]
#[inline (always)] pub const fn ctrl_mod (& self) -> & CTRL_MOD { & self . ctrl_mod }
#[doc = "0x02 - RW, TMR0 interrupt enable"]
#[inline (always)] pub const fn inter_en (& self) -> & INTER_EN { & self . inter_en }
#[doc = "0x06 - RW1, TMR0 interrupt flag"]
#[inline (always)] pub const fn int_flag (& self) -> & INT_FLAG { & self . int_flag }
#[doc = "0x07 - RO, TMR0 FIFO count status"]
#[inline (always)] pub const fn fifo_count (& self) -> & FIFO_COUNT { & self . fifo_count }
#[doc = "0x08 - RO, TMR0 current count"]
#[inline (always)] pub const fn count (& self) -> & COUNT { & self . count }
#[doc = "0x0c - RW, TMR0 end count value, only low 26 bit"]
#[inline (always)] pub const fn cnt_end (& self) -> & CNT_END { & self . cnt_end }
#[doc = "0x10 - RO/WO, TMR0 FIFO register, only low 26 bit"]
#[inline (always)] pub const fn fifo (& self) -> & FIFO { & self . fifo } }
#[doc = "CTRL_MOD (rw) register accessor: RW, TMR0 mode control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl_mod`] module"] pub type CTRL_MOD = crate :: Reg < ctrl_mod :: CTRL_MOD_SPEC > ;
#[doc = "RW, TMR0 mode control"] pub mod ctrl_mod {
#[doc = "Register `CTRL_MOD` reader"] pub type R = crate :: R < CTRL_MOD_SPEC > ;
#[doc = "Register `CTRL_MOD` writer"] pub type W = crate :: W < CTRL_MOD_SPEC > ;
#[doc = "Field `ODE_IN` reader - RW, timer in mode: 0=timer/PWM, 1=capture/count"] pub type ODE_IN_R = crate :: BitReader ;
#[doc = "Field `ODE_IN` writer - RW, timer in mode: 0=timer/PWM, 1=capture/count"] pub type ODE_IN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LL_CLEAR` reader - RW, force clear timer FIFO and count"] pub type LL_CLEAR_R = crate :: BitReader ;
#[doc = "Field `LL_CLEAR` writer - RW, force clear timer FIFO and count"] pub type LL_CLEAR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OUNT_EN` reader - RW, timer count enable"] pub type OUNT_EN_R = crate :: BitReader ;
#[doc = "Field `OUNT_EN` writer - RW, timer count enable"] pub type OUNT_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UT_EN` reader - RW, timer output enable"] pub type UT_EN_R = crate :: BitReader ;
#[doc = "Field `UT_EN` writer - RW, timer output enable"] pub type UT_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UT_POLAR` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"] pub type UT_POLAR_R = crate :: BitReader ;
#[doc = "Field `UT_POLAR` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"] pub type UT_POLAR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AP_COUNT` reader - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"] pub type AP_COUNT_R = crate :: BitReader ;
#[doc = "Field `AP_COUNT` writer - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"] pub type AP_COUNT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WM_REPEAT` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"] pub type WM_REPEAT_R = crate :: FieldReader ;
#[doc = "Field `WM_REPEAT` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"] pub type WM_REPEAT_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `AP_EDGE` reader - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"] pub type AP_EDGE_R = crate :: FieldReader ;
#[doc = "Field `AP_EDGE` writer - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"] pub type AP_EDGE_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count"]
#[inline (always)] pub fn ode_in (& self) -> ODE_IN_R { ODE_IN_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, force clear timer FIFO and count"]
#[inline (always)] pub fn ll_clear (& self) -> LL_CLEAR_R { LL_CLEAR_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW, timer count enable"]
#[inline (always)] pub fn ount_en (& self) -> OUNT_EN_R { OUNT_EN_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, timer output enable"]
#[inline (always)] pub fn ut_en (& self) -> UT_EN_R { UT_EN_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"]
#[inline (always)] pub fn ut_polar (& self) -> UT_POLAR_R { UT_POLAR_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 4 - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"]
#[inline (always)] pub fn ap_count (& self) -> AP_COUNT_R { AP_COUNT_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"]
#[inline (always)] pub fn wm_repeat (& self) -> WM_REPEAT_R { WM_REPEAT_R :: new ((self . bits >> 6) & 3) }
#[doc = "Bits 6:7 - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"]
#[inline (always)] pub fn ap_edge (& self) -> AP_EDGE_R { AP_EDGE_R :: new ((self . bits >> 6) & 3) } } impl W {
#[doc = "Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count"]
#[inline (always)] pub fn ode_in (& mut self) -> ODE_IN_W < CTRL_MOD_SPEC > { ODE_IN_W :: new (self , 0) }
#[doc = "Bit 1 - RW, force clear timer FIFO and count"]
#[inline (always)] pub fn ll_clear (& mut self) -> LL_CLEAR_W < CTRL_MOD_SPEC > { LL_CLEAR_W :: new (self , 1) }
#[doc = "Bit 2 - RW, timer count enable"]
#[inline (always)] pub fn ount_en (& mut self) -> OUNT_EN_W < CTRL_MOD_SPEC > { OUNT_EN_W :: new (self , 2) }
#[doc = "Bit 3 - RW, timer output enable"]
#[inline (always)] pub fn ut_en (& mut self) -> UT_EN_W < CTRL_MOD_SPEC > { UT_EN_W :: new (self , 3) }
#[doc = "Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"]
#[inline (always)] pub fn ut_polar (& mut self) -> UT_POLAR_W < CTRL_MOD_SPEC > { UT_POLAR_W :: new (self , 4) }
#[doc = "Bit 4 - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"]
#[inline (always)] pub fn ap_count (& mut self) -> AP_COUNT_W < CTRL_MOD_SPEC > { AP_COUNT_W :: new (self , 4) }
#[doc = "Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"]
#[inline (always)] pub fn wm_repeat (& mut self) -> WM_REPEAT_W < CTRL_MOD_SPEC > { WM_REPEAT_W :: new (self , 6) }
#[doc = "Bits 6:7 - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"]
#[inline (always)] pub fn ap_edge (& mut self) -> AP_EDGE_W < CTRL_MOD_SPEC > { AP_EDGE_W :: new (self , 6) } }
#[doc = "RW, TMR0 mode control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CTRL_MOD_SPEC ; impl crate :: RegisterSpec for CTRL_MOD_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`ctrl_mod::R`](R) reader structure"] impl crate :: Readable for CTRL_MOD_SPEC { }
#[doc = "`write(|w| ..)` method takes [`ctrl_mod::W`](W) writer structure"] impl crate :: Writable for CTRL_MOD_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL_MOD to value 0x02"] impl crate :: Resettable for CTRL_MOD_SPEC { const RESET_VALUE : u8 = 0x02 ; } }
#[doc = "INTER_EN (rw) register accessor: RW, TMR0 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`inter_en::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inter_en::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@inter_en`] module"] pub type INTER_EN = crate :: Reg < inter_en :: INTER_EN_SPEC > ;
#[doc = "RW, TMR0 interrupt enable"] pub mod inter_en {
#[doc = "Register `INTER_EN` reader"] pub type R = crate :: R < INTER_EN_SPEC > ;
#[doc = "Register `INTER_EN` writer"] pub type W = crate :: W < INTER_EN_SPEC > ;
#[doc = "Field `E_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end"] pub type E_CYC_END_R = crate :: BitReader ;
#[doc = "Field `E_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end"] pub type E_CYC_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger"] pub type E_DATA_ACT_R = crate :: BitReader ;
#[doc = "Field `E_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger"] pub type E_DATA_ACT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"] pub type E_FIFO_HF_R = crate :: BitReader ;
#[doc = "Field `E_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"] pub type E_FIFO_HF_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion"] pub type E_DMA_END_R = crate :: BitReader ;
#[doc = "Field `E_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion"] pub type E_DMA_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow"] pub type E_FIFO_OV_R = crate :: BitReader ;
#[doc = "Field `E_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow"] pub type E_FIFO_OV_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end"]
#[inline (always)] pub fn e_cyc_end (& self) -> E_CYC_END_R { E_CYC_END_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger"]
#[inline (always)] pub fn e_data_act (& self) -> E_DATA_ACT_R { E_DATA_ACT_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"]
#[inline (always)] pub fn e_fifo_hf (& self) -> E_FIFO_HF_R { E_FIFO_HF_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, enable interrupt for timer1/2 DMA completion"]
#[inline (always)] pub fn e_dma_end (& self) -> E_DMA_END_R { E_DMA_END_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW, enable interrupt for timer FIFO overflow"]
#[inline (always)] pub fn e_fifo_ov (& self) -> E_FIFO_OV_R { E_FIFO_OV_R :: new (((self . bits >> 4) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end"]
#[inline (always)] pub fn e_cyc_end (& mut self) -> E_CYC_END_W < INTER_EN_SPEC > { E_CYC_END_W :: new (self , 0) }
#[doc = "Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger"]
#[inline (always)] pub fn e_data_act (& mut self) -> E_DATA_ACT_W < INTER_EN_SPEC > { E_DATA_ACT_W :: new (self , 1) }
#[doc = "Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"]
#[inline (always)] pub fn e_fifo_hf (& mut self) -> E_FIFO_HF_W < INTER_EN_SPEC > { E_FIFO_HF_W :: new (self , 2) }
#[doc = "Bit 3 - RW, enable interrupt for timer1/2 DMA completion"]
#[inline (always)] pub fn e_dma_end (& mut self) -> E_DMA_END_W < INTER_EN_SPEC > { E_DMA_END_W :: new (self , 3) }
#[doc = "Bit 4 - RW, enable interrupt for timer FIFO overflow"]
#[inline (always)] pub fn e_fifo_ov (& mut self) -> E_FIFO_OV_W < INTER_EN_SPEC > { E_FIFO_OV_W :: new (self , 4) } }
#[doc = "RW, TMR0 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`inter_en::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inter_en::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INTER_EN_SPEC ; impl crate :: RegisterSpec for INTER_EN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`inter_en::R`](R) reader structure"] impl crate :: Readable for INTER_EN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`inter_en::W`](W) writer structure"] impl crate :: Writable for INTER_EN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INTER_EN to value 0"] impl crate :: Resettable for INTER_EN_SPEC { } }
#[doc = "INT_FLAG (rw) register accessor: RW1, TMR0 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_flag`] module"] pub type INT_FLAG = crate :: Reg < int_flag :: INT_FLAG_SPEC > ;
#[doc = "RW1, TMR0 interrupt flag"] pub mod int_flag {
#[doc = "Register `INT_FLAG` reader"] pub type R = crate :: R < INT_FLAG_SPEC > ;
#[doc = "Register `INT_FLAG` writer"] pub type W = crate :: W < INT_FLAG_SPEC > ;
#[doc = "Field `F_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end"] pub type F_CYC_END_R = crate :: BitReader ;
#[doc = "Field `F_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end"] pub type F_CYC_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger"] pub type F_DATA_ACT_R = crate :: BitReader ;
#[doc = "Field `F_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger"] pub type F_DATA_ACT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"] pub type F_FIFO_HF_R = crate :: BitReader ;
#[doc = "Field `F_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"] pub type F_FIFO_HF_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion"] pub type F_DMA_END_R = crate :: BitReader ;
#[doc = "Field `F_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion"] pub type F_DMA_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow"] pub type F_FIFO_OV_R = crate :: BitReader ;
#[doc = "Field `F_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow"] pub type F_FIFO_OV_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end"]
#[inline (always)] pub fn f_cyc_end (& self) -> F_CYC_END_R { F_CYC_END_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger"]
#[inline (always)] pub fn f_data_act (& self) -> F_DATA_ACT_R { F_DATA_ACT_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"]
#[inline (always)] pub fn f_fifo_hf (& self) -> F_FIFO_HF_R { F_FIFO_HF_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW1, interrupt flag for timer1/2 DMA completion"]
#[inline (always)] pub fn f_dma_end (& self) -> F_DMA_END_R { F_DMA_END_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW1, interrupt flag for timer FIFO overflow"]
#[inline (always)] pub fn f_fifo_ov (& self) -> F_FIFO_OV_R { F_FIFO_OV_R :: new (((self . bits >> 4) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end"]
#[inline (always)] pub fn f_cyc_end (& mut self) -> F_CYC_END_W < INT_FLAG_SPEC > { F_CYC_END_W :: new (self , 0) }
#[doc = "Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger"]
#[inline (always)] pub fn f_data_act (& mut self) -> F_DATA_ACT_W < INT_FLAG_SPEC > { F_DATA_ACT_W :: new (self , 1) }
#[doc = "Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"]
#[inline (always)] pub fn f_fifo_hf (& mut self) -> F_FIFO_HF_W < INT_FLAG_SPEC > { F_FIFO_HF_W :: new (self , 2) }
#[doc = "Bit 3 - RW1, interrupt flag for timer1/2 DMA completion"]
#[inline (always)] pub fn f_dma_end (& mut self) -> F_DMA_END_W < INT_FLAG_SPEC > { F_DMA_END_W :: new (self , 3) }
#[doc = "Bit 4 - RW1, interrupt flag for timer FIFO overflow"]
#[inline (always)] pub fn f_fifo_ov (& mut self) -> F_FIFO_OV_W < INT_FLAG_SPEC > { F_FIFO_OV_W :: new (self , 4) } }
#[doc = "RW1, TMR0 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_FLAG_SPEC ; impl crate :: RegisterSpec for INT_FLAG_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`int_flag::R`](R) reader structure"] impl crate :: Readable for INT_FLAG_SPEC { }
#[doc = "`write(|w| ..)` method takes [`int_flag::W`](W) writer structure"] impl crate :: Writable for INT_FLAG_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INT_FLAG to value 0"] impl crate :: Resettable for INT_FLAG_SPEC { } }
#[doc = "FIFO_COUNT (r) register accessor: RO, TMR0 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo_count`] module"] pub type FIFO_COUNT = crate :: Reg < fifo_count :: FIFO_COUNT_SPEC > ;
#[doc = "RO, TMR0 FIFO count status"] pub mod fifo_count {
#[doc = "Register `FIFO_COUNT` reader"] pub type R = crate :: R < FIFO_COUNT_SPEC > ;
#[doc = "Field `FIFO_COUNT` reader - RW1,TMR0 FIFO count status"] pub type FIFO_COUNT_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RW1,TMR0 FIFO count status"]
#[inline (always)] pub fn fifo_count (& self) -> FIFO_COUNT_R { FIFO_COUNT_R :: new (self . bits) } }
#[doc = "RO, TMR0 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FIFO_COUNT_SPEC ; impl crate :: RegisterSpec for FIFO_COUNT_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`fifo_count::R`](R) reader structure"] impl crate :: Readable for FIFO_COUNT_SPEC { }
#[doc = "`reset()` method sets FIFO_COUNT to value 0"] impl crate :: Resettable for FIFO_COUNT_SPEC { } }
#[doc = "COUNT (r) register accessor: RO, TMR0 current count\n\nYou can [`read`](crate::Reg::read) this register and get [`count::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count`] module"] pub type COUNT = crate :: Reg < count :: COUNT_SPEC > ;
#[doc = "RO, TMR0 current count"] pub mod count {
#[doc = "Register `COUNT` reader"] pub type R = crate :: R < COUNT_SPEC > ;
#[doc = "Field `COUNT` reader - RW1,TMR0 current count"] pub type COUNT_R = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - RW1,TMR0 current count"]
#[inline (always)] pub fn count (& self) -> COUNT_R { COUNT_R :: new (self . bits) } }
#[doc = "RO, TMR0 current count\n\nYou can [`read`](crate::Reg::read) this register and get [`count::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct COUNT_SPEC ; impl crate :: RegisterSpec for COUNT_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`count::R`](R) reader structure"] impl crate :: Readable for COUNT_SPEC { }
#[doc = "`reset()` method sets COUNT to value 0"] impl crate :: Resettable for COUNT_SPEC { } }
#[doc = "CNT_END (rw) register accessor: RW, TMR0 end count value, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt_end::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt_end::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt_end`] module"] pub type CNT_END = crate :: Reg < cnt_end :: CNT_END_SPEC > ;
#[doc = "RW, TMR0 end count value, only low 26 bit"] pub mod cnt_end {
#[doc = "Register `CNT_END` reader"] pub type R = crate :: R < CNT_END_SPEC > ;
#[doc = "Register `CNT_END` writer"] pub type W = crate :: W < CNT_END_SPEC > ;
#[doc = "Field `CNT_END` reader - RW1,TMR0 end count value"] pub type CNT_END_R = crate :: FieldReader < u32 > ;
#[doc = "Field `CNT_END` writer - RW1,TMR0 end count value"] pub type CNT_END_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW1,TMR0 end count value"]
#[inline (always)] pub fn cnt_end (& self) -> CNT_END_R { CNT_END_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW1,TMR0 end count value"]
#[inline (always)] pub fn cnt_end (& mut self) -> CNT_END_W < CNT_END_SPEC > { CNT_END_W :: new (self , 0) } }
#[doc = "RW, TMR0 end count value, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt_end::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt_end::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CNT_END_SPEC ; impl crate :: RegisterSpec for CNT_END_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`cnt_end::R`](R) reader structure"] impl crate :: Readable for CNT_END_SPEC { }
#[doc = "`write(|w| ..)` method takes [`cnt_end::W`](W) writer structure"] impl crate :: Writable for CNT_END_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNT_END to value 0"] impl crate :: Resettable for CNT_END_SPEC { } }
#[doc = "FIFO (r) register accessor: RO/WO, TMR0 FIFO register, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo`] module"] pub type FIFO = crate :: Reg < fifo :: FIFO_SPEC > ;
#[doc = "RO/WO, TMR0 FIFO register, only low 26 bit"] pub mod fifo {
#[doc = "Register `FIFO` reader"] pub type R = crate :: R < FIFO_SPEC > ;
#[doc = "Field `FIFO` reader - RW1,TMR0 FIFO register"] pub type FIFO_R = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - RW1,TMR0 FIFO register"]
#[inline (always)] pub fn fifo (& self) -> FIFO_R { FIFO_R :: new (self . bits) } }
#[doc = "RO/WO, TMR0 FIFO register, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FIFO_SPEC ; impl crate :: RegisterSpec for FIFO_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`fifo::R`](R) reader structure"] impl crate :: Readable for FIFO_SPEC { }
#[doc = "`reset()` method sets FIFO to value 0"] impl crate :: Resettable for FIFO_SPEC { } } }
#[doc = "Timer1 register"] pub type TMR1 = crate :: Periph < tmr1 :: RegisterBlock , 0x4000_2400 > ; impl core :: fmt :: Debug for TMR1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TMR1") . finish () } }
#[doc = "Timer1 register"] pub mod tmr1 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ctrl_mod : CTRL_MOD , ctrl_dma : CTRL_DMA , inter_en : INTER_EN , _reserved3 : [u8 ; 0x03] , int_flag : INT_FLAG , fifo_count : FIFO_COUNT , count : COUNT , cnt_end : CNT_END , fifo : FIFO , dma_now : DMA_NOW , _reserved9 : [u8 ; 0x02] , dma_beg : DMA_BEG , _reserved10 : [u8 ; 0x02] , dma_end : DMA_END , } impl RegisterBlock {
#[doc = "0x00 - RW, TMR1 mode control"]
#[inline (always)] pub const fn ctrl_mod (& self) -> & CTRL_MOD { & self . ctrl_mod }
#[doc = "0x01 - RW, TMR1 DMA control"]
#[inline (always)] pub const fn ctrl_dma (& self) -> & CTRL_DMA { & self . ctrl_dma }
#[doc = "0x02 - RW, TMR1 interrupt enable"]
#[inline (always)] pub const fn inter_en (& self) -> & INTER_EN { & self . inter_en }
#[doc = "0x06 - RW1, TMR1 interrupt flag"]
#[inline (always)] pub const fn int_flag (& self) -> & INT_FLAG { & self . int_flag }
#[doc = "0x07 - RO, TMR1 FIFO count status"]
#[inline (always)] pub const fn fifo_count (& self) -> & FIFO_COUNT { & self . fifo_count }
#[doc = "0x08 - RO, TMR1 current count"]
#[inline (always)] pub const fn count (& self) -> & COUNT { & self . count }
#[doc = "0x0c - RW, TMR1 end count value, only low 26 bit"]
#[inline (always)] pub const fn cnt_end (& self) -> & CNT_END { & self . cnt_end }
#[doc = "0x10 - RO, TMR1 FIFO register, only low 26 bit"]
#[inline (always)] pub const fn fifo (& self) -> & FIFO { & self . fifo }
#[doc = "0x14 - RO, TMR1 DMA current address"]
#[inline (always)] pub const fn dma_now (& self) -> & DMA_NOW { & self . dma_now }
#[doc = "0x18 - RW, TMR1 DMA begin address"]
#[inline (always)] pub const fn dma_beg (& self) -> & DMA_BEG { & self . dma_beg }
#[doc = "0x1c - RW, TMR1 DMA end address"]
#[inline (always)] pub const fn dma_end (& self) -> & DMA_END { & self . dma_end } }
#[doc = "CTRL_MOD (rw) register accessor: RW, TMR1 mode control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl_mod`] module"] pub type CTRL_MOD = crate :: Reg < ctrl_mod :: CTRL_MOD_SPEC > ;
#[doc = "RW, TMR1 mode control"] pub mod ctrl_mod {
#[doc = "Register `CTRL_MOD` reader"] pub type R = crate :: R < CTRL_MOD_SPEC > ;
#[doc = "Register `CTRL_MOD` writer"] pub type W = crate :: W < CTRL_MOD_SPEC > ;
#[doc = "Field `ODE_IN` reader - RW, timer in mode: 0=timer/PWM, 1=capture/count"] pub type ODE_IN_R = crate :: BitReader ;
#[doc = "Field `ODE_IN` writer - RW, timer in mode: 0=timer/PWM, 1=capture/count"] pub type ODE_IN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LL_CLEAR` reader - RW, force clear timer FIFO and count"] pub type LL_CLEAR_R = crate :: BitReader ;
#[doc = "Field `LL_CLEAR` writer - RW, force clear timer FIFO and count"] pub type LL_CLEAR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OUNT_EN` reader - RW, timer count enable"] pub type OUNT_EN_R = crate :: BitReader ;
#[doc = "Field `OUNT_EN` writer - RW, timer count enable"] pub type OUNT_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UT_EN` reader - RW, timer output enable"] pub type UT_EN_R = crate :: BitReader ;
#[doc = "Field `UT_EN` writer - RW, timer output enable"] pub type UT_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UT_POLAR` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"] pub type UT_POLAR_R = crate :: BitReader ;
#[doc = "Field `UT_POLAR` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"] pub type UT_POLAR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AP_COUNT` reader - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"] pub type AP_COUNT_R = crate :: BitReader ;
#[doc = "Field `AP_COUNT` writer - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"] pub type AP_COUNT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WM_REPEAT` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"] pub type WM_REPEAT_R = crate :: FieldReader ;
#[doc = "Field `WM_REPEAT` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"] pub type WM_REPEAT_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `AP_EDGE` reader - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"] pub type AP_EDGE_R = crate :: FieldReader ;
#[doc = "Field `AP_EDGE` writer - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"] pub type AP_EDGE_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count"]
#[inline (always)] pub fn ode_in (& self) -> ODE_IN_R { ODE_IN_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, force clear timer FIFO and count"]
#[inline (always)] pub fn ll_clear (& self) -> LL_CLEAR_R { LL_CLEAR_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW, timer count enable"]
#[inline (always)] pub fn ount_en (& self) -> OUNT_EN_R { OUNT_EN_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, timer output enable"]
#[inline (always)] pub fn ut_en (& self) -> UT_EN_R { UT_EN_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"]
#[inline (always)] pub fn ut_polar (& self) -> UT_POLAR_R { UT_POLAR_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 4 - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"]
#[inline (always)] pub fn ap_count (& self) -> AP_COUNT_R { AP_COUNT_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"]
#[inline (always)] pub fn wm_repeat (& self) -> WM_REPEAT_R { WM_REPEAT_R :: new ((self . bits >> 6) & 3) }
#[doc = "Bits 6:7 - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"]
#[inline (always)] pub fn ap_edge (& self) -> AP_EDGE_R { AP_EDGE_R :: new ((self . bits >> 6) & 3) } } impl W {
#[doc = "Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count"]
#[inline (always)] pub fn ode_in (& mut self) -> ODE_IN_W < CTRL_MOD_SPEC > { ODE_IN_W :: new (self , 0) }
#[doc = "Bit 1 - RW, force clear timer FIFO and count"]
#[inline (always)] pub fn ll_clear (& mut self) -> LL_CLEAR_W < CTRL_MOD_SPEC > { LL_CLEAR_W :: new (self , 1) }
#[doc = "Bit 2 - RW, timer count enable"]
#[inline (always)] pub fn ount_en (& mut self) -> OUNT_EN_W < CTRL_MOD_SPEC > { OUNT_EN_W :: new (self , 2) }
#[doc = "Bit 3 - RW, timer output enable"]
#[inline (always)] pub fn ut_en (& mut self) -> UT_EN_W < CTRL_MOD_SPEC > { UT_EN_W :: new (self , 3) }
#[doc = "Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"]
#[inline (always)] pub fn ut_polar (& mut self) -> UT_POLAR_W < CTRL_MOD_SPEC > { UT_POLAR_W :: new (self , 4) }
#[doc = "Bit 4 - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"]
#[inline (always)] pub fn ap_count (& mut self) -> AP_COUNT_W < CTRL_MOD_SPEC > { AP_COUNT_W :: new (self , 4) }
#[doc = "Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"]
#[inline (always)] pub fn wm_repeat (& mut self) -> WM_REPEAT_W < CTRL_MOD_SPEC > { WM_REPEAT_W :: new (self , 6) }
#[doc = "Bits 6:7 - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"]
#[inline (always)] pub fn ap_edge (& mut self) -> AP_EDGE_W < CTRL_MOD_SPEC > { AP_EDGE_W :: new (self , 6) } }
#[doc = "RW, TMR1 mode control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CTRL_MOD_SPEC ; impl crate :: RegisterSpec for CTRL_MOD_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`ctrl_mod::R`](R) reader structure"] impl crate :: Readable for CTRL_MOD_SPEC { }
#[doc = "`write(|w| ..)` method takes [`ctrl_mod::W`](W) writer structure"] impl crate :: Writable for CTRL_MOD_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL_MOD to value 0x02"] impl crate :: Resettable for CTRL_MOD_SPEC { const RESET_VALUE : u8 = 0x02 ; } }
#[doc = "CTRL_DMA (rw) register accessor: RW, TMR1 DMA control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl_dma`] module"] pub type CTRL_DMA = crate :: Reg < ctrl_dma :: CTRL_DMA_SPEC > ;
#[doc = "RW, TMR1 DMA control"] pub mod ctrl_dma {
#[doc = "Register `CTRL_DMA` reader"] pub type R = crate :: R < CTRL_DMA_SPEC > ;
#[doc = "Register `CTRL_DMA` writer"] pub type W = crate :: W < CTRL_DMA_SPEC > ;
#[doc = "Field `MA_ENABLE` reader - RW, timer1/2 DMA enable"] pub type MA_ENABLE_R = crate :: BitReader ;
#[doc = "Field `MA_ENABLE` writer - RW, timer1/2 DMA enable"] pub type MA_ENABLE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MA_LOOP` reader - RW, timer1/2 DMA address loop enable"] pub type MA_LOOP_R = crate :: BitReader ;
#[doc = "Field `MA_LOOP` writer - RW, timer1/2 DMA address loop enable"] pub type MA_LOOP_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, timer1/2 DMA enable"]
#[inline (always)] pub fn ma_enable (& self) -> MA_ENABLE_R { MA_ENABLE_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 2 - RW, timer1/2 DMA address loop enable"]
#[inline (always)] pub fn ma_loop (& self) -> MA_LOOP_R { MA_LOOP_R :: new (((self . bits >> 2) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, timer1/2 DMA enable"]
#[inline (always)] pub fn ma_enable (& mut self) -> MA_ENABLE_W < CTRL_DMA_SPEC > { MA_ENABLE_W :: new (self , 0) }
#[doc = "Bit 2 - RW, timer1/2 DMA address loop enable"]
#[inline (always)] pub fn ma_loop (& mut self) -> MA_LOOP_W < CTRL_DMA_SPEC > { MA_LOOP_W :: new (self , 2) } }
#[doc = "RW, TMR1 DMA control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CTRL_DMA_SPEC ; impl crate :: RegisterSpec for CTRL_DMA_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`ctrl_dma::R`](R) reader structure"] impl crate :: Readable for CTRL_DMA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`ctrl_dma::W`](W) writer structure"] impl crate :: Writable for CTRL_DMA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL_DMA to value 0"] impl crate :: Resettable for CTRL_DMA_SPEC { } }
#[doc = "INTER_EN (rw) register accessor: RW, TMR1 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`inter_en::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inter_en::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@inter_en`] module"] pub type INTER_EN = crate :: Reg < inter_en :: INTER_EN_SPEC > ;
#[doc = "RW, TMR1 interrupt enable"] pub mod inter_en {
#[doc = "Register `INTER_EN` reader"] pub type R = crate :: R < INTER_EN_SPEC > ;
#[doc = "Register `INTER_EN` writer"] pub type W = crate :: W < INTER_EN_SPEC > ;
#[doc = "Field `E_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end"] pub type E_CYC_END_R = crate :: BitReader ;
#[doc = "Field `E_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end"] pub type E_CYC_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger"] pub type E_DATA_ACT_R = crate :: BitReader ;
#[doc = "Field `E_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger"] pub type E_DATA_ACT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"] pub type E_FIFO_HF_R = crate :: BitReader ;
#[doc = "Field `E_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"] pub type E_FIFO_HF_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion"] pub type E_DMA_END_R = crate :: BitReader ;
#[doc = "Field `E_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion"] pub type E_DMA_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow"] pub type E_FIFO_OV_R = crate :: BitReader ;
#[doc = "Field `E_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow"] pub type E_FIFO_OV_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end"]
#[inline (always)] pub fn e_cyc_end (& self) -> E_CYC_END_R { E_CYC_END_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger"]
#[inline (always)] pub fn e_data_act (& self) -> E_DATA_ACT_R { E_DATA_ACT_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"]
#[inline (always)] pub fn e_fifo_hf (& self) -> E_FIFO_HF_R { E_FIFO_HF_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, enable interrupt for timer1/2 DMA completion"]
#[inline (always)] pub fn e_dma_end (& self) -> E_DMA_END_R { E_DMA_END_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW, enable interrupt for timer FIFO overflow"]
#[inline (always)] pub fn e_fifo_ov (& self) -> E_FIFO_OV_R { E_FIFO_OV_R :: new (((self . bits >> 4) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end"]
#[inline (always)] pub fn e_cyc_end (& mut self) -> E_CYC_END_W < INTER_EN_SPEC > { E_CYC_END_W :: new (self , 0) }
#[doc = "Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger"]
#[inline (always)] pub fn e_data_act (& mut self) -> E_DATA_ACT_W < INTER_EN_SPEC > { E_DATA_ACT_W :: new (self , 1) }
#[doc = "Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"]
#[inline (always)] pub fn e_fifo_hf (& mut self) -> E_FIFO_HF_W < INTER_EN_SPEC > { E_FIFO_HF_W :: new (self , 2) }
#[doc = "Bit 3 - RW, enable interrupt for timer1/2 DMA completion"]
#[inline (always)] pub fn e_dma_end (& mut self) -> E_DMA_END_W < INTER_EN_SPEC > { E_DMA_END_W :: new (self , 3) }
#[doc = "Bit 4 - RW, enable interrupt for timer FIFO overflow"]
#[inline (always)] pub fn e_fifo_ov (& mut self) -> E_FIFO_OV_W < INTER_EN_SPEC > { E_FIFO_OV_W :: new (self , 4) } }
#[doc = "RW, TMR1 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`inter_en::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inter_en::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INTER_EN_SPEC ; impl crate :: RegisterSpec for INTER_EN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`inter_en::R`](R) reader structure"] impl crate :: Readable for INTER_EN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`inter_en::W`](W) writer structure"] impl crate :: Writable for INTER_EN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INTER_EN to value 0"] impl crate :: Resettable for INTER_EN_SPEC { } }
#[doc = "INT_FLAG (rw) register accessor: RW1, TMR1 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_flag`] module"] pub type INT_FLAG = crate :: Reg < int_flag :: INT_FLAG_SPEC > ;
#[doc = "RW1, TMR1 interrupt flag"] pub mod int_flag {
#[doc = "Register `INT_FLAG` reader"] pub type R = crate :: R < INT_FLAG_SPEC > ;
#[doc = "Register `INT_FLAG` writer"] pub type W = crate :: W < INT_FLAG_SPEC > ;
#[doc = "Field `F_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end"] pub type F_CYC_END_R = crate :: BitReader ;
#[doc = "Field `F_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end"] pub type F_CYC_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger"] pub type F_DATA_ACT_R = crate :: BitReader ;
#[doc = "Field `F_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger"] pub type F_DATA_ACT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"] pub type F_FIFO_HF_R = crate :: BitReader ;
#[doc = "Field `F_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"] pub type F_FIFO_HF_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion"] pub type F_DMA_END_R = crate :: BitReader ;
#[doc = "Field `F_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion"] pub type F_DMA_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow"] pub type F_FIFO_OV_R = crate :: BitReader ;
#[doc = "Field `F_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow"] pub type F_FIFO_OV_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end"]
#[inline (always)] pub fn f_cyc_end (& self) -> F_CYC_END_R { F_CYC_END_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger"]
#[inline (always)] pub fn f_data_act (& self) -> F_DATA_ACT_R { F_DATA_ACT_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"]
#[inline (always)] pub fn f_fifo_hf (& self) -> F_FIFO_HF_R { F_FIFO_HF_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW1, interrupt flag for timer1/2 DMA completion"]
#[inline (always)] pub fn f_dma_end (& self) -> F_DMA_END_R { F_DMA_END_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW1, interrupt flag for timer FIFO overflow"]
#[inline (always)] pub fn f_fifo_ov (& self) -> F_FIFO_OV_R { F_FIFO_OV_R :: new (((self . bits >> 4) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end"]
#[inline (always)] pub fn f_cyc_end (& mut self) -> F_CYC_END_W < INT_FLAG_SPEC > { F_CYC_END_W :: new (self , 0) }
#[doc = "Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger"]
#[inline (always)] pub fn f_data_act (& mut self) -> F_DATA_ACT_W < INT_FLAG_SPEC > { F_DATA_ACT_W :: new (self , 1) }
#[doc = "Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"]
#[inline (always)] pub fn f_fifo_hf (& mut self) -> F_FIFO_HF_W < INT_FLAG_SPEC > { F_FIFO_HF_W :: new (self , 2) }
#[doc = "Bit 3 - RW1, interrupt flag for timer1/2 DMA completion"]
#[inline (always)] pub fn f_dma_end (& mut self) -> F_DMA_END_W < INT_FLAG_SPEC > { F_DMA_END_W :: new (self , 3) }
#[doc = "Bit 4 - RW1, interrupt flag for timer FIFO overflow"]
#[inline (always)] pub fn f_fifo_ov (& mut self) -> F_FIFO_OV_W < INT_FLAG_SPEC > { F_FIFO_OV_W :: new (self , 4) } }
#[doc = "RW1, TMR1 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_FLAG_SPEC ; impl crate :: RegisterSpec for INT_FLAG_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`int_flag::R`](R) reader structure"] impl crate :: Readable for INT_FLAG_SPEC { }
#[doc = "`write(|w| ..)` method takes [`int_flag::W`](W) writer structure"] impl crate :: Writable for INT_FLAG_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INT_FLAG to value 0"] impl crate :: Resettable for INT_FLAG_SPEC { } }
#[doc = "FIFO_COUNT (r) register accessor: RO, TMR1 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo_count`] module"] pub type FIFO_COUNT = crate :: Reg < fifo_count :: FIFO_COUNT_SPEC > ;
#[doc = "RO, TMR1 FIFO count status"] pub mod fifo_count {
#[doc = "Register `FIFO_COUNT` reader"] pub type R = crate :: R < FIFO_COUNT_SPEC > ;
#[doc = "Field `FIFO_COUNT` reader - RW1, TMR1 FIFO count status"] pub type FIFO_COUNT_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RW1, TMR1 FIFO count status"]
#[inline (always)] pub fn fifo_count (& self) -> FIFO_COUNT_R { FIFO_COUNT_R :: new (self . bits) } }
#[doc = "RO, TMR1 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FIFO_COUNT_SPEC ; impl crate :: RegisterSpec for FIFO_COUNT_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`fifo_count::R`](R) reader structure"] impl crate :: Readable for FIFO_COUNT_SPEC { }
#[doc = "`reset()` method sets FIFO_COUNT to value 0"] impl crate :: Resettable for FIFO_COUNT_SPEC { } }
#[doc = "COUNT (r) register accessor: RO, TMR1 current count\n\nYou can [`read`](crate::Reg::read) this register and get [`count::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count`] module"] pub type COUNT = crate :: Reg < count :: COUNT_SPEC > ;
#[doc = "RO, TMR1 current count"] pub mod count {
#[doc = "Register `COUNT` reader"] pub type R = crate :: R < COUNT_SPEC > ;
#[doc = "Field `COUNT` reader - RW1,TMR1 current count"] pub type COUNT_R = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - RW1,TMR1 current count"]
#[inline (always)] pub fn count (& self) -> COUNT_R { COUNT_R :: new (self . bits) } }
#[doc = "RO, TMR1 current count\n\nYou can [`read`](crate::Reg::read) this register and get [`count::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct COUNT_SPEC ; impl crate :: RegisterSpec for COUNT_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`count::R`](R) reader structure"] impl crate :: Readable for COUNT_SPEC { }
#[doc = "`reset()` method sets COUNT to value 0"] impl crate :: Resettable for COUNT_SPEC { } }
#[doc = "CNT_END (rw) register accessor: RW, TMR1 end count value, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt_end::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt_end::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt_end`] module"] pub type CNT_END = crate :: Reg < cnt_end :: CNT_END_SPEC > ;
#[doc = "RW, TMR1 end count value, only low 26 bit"] pub mod cnt_end {
#[doc = "Register `CNT_END` reader"] pub type R = crate :: R < CNT_END_SPEC > ;
#[doc = "Register `CNT_END` writer"] pub type W = crate :: W < CNT_END_SPEC > ;
#[doc = "Field `CNT_END` reader - RW1,TMR1 end count value,"] pub type CNT_END_R = crate :: FieldReader < u32 > ;
#[doc = "Field `CNT_END` writer - RW1,TMR1 end count value,"] pub type CNT_END_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW1,TMR1 end count value,"]
#[inline (always)] pub fn cnt_end (& self) -> CNT_END_R { CNT_END_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW1,TMR1 end count value,"]
#[inline (always)] pub fn cnt_end (& mut self) -> CNT_END_W < CNT_END_SPEC > { CNT_END_W :: new (self , 0) } }
#[doc = "RW, TMR1 end count value, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt_end::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt_end::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CNT_END_SPEC ; impl crate :: RegisterSpec for CNT_END_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`cnt_end::R`](R) reader structure"] impl crate :: Readable for CNT_END_SPEC { }
#[doc = "`write(|w| ..)` method takes [`cnt_end::W`](W) writer structure"] impl crate :: Writable for CNT_END_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNT_END to value 0"] impl crate :: Resettable for CNT_END_SPEC { } }
#[doc = "FIFO (r) register accessor: RO, TMR1 FIFO register, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo`] module"] pub type FIFO = crate :: Reg < fifo :: FIFO_SPEC > ;
#[doc = "RO, TMR1 FIFO register, only low 26 bit"] pub mod fifo {
#[doc = "Register `FIFO` reader"] pub type R = crate :: R < FIFO_SPEC > ;
#[doc = "Field `FIFO` reader - RW1,TMR1 FIFO register"] pub type FIFO_R = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - RW1,TMR1 FIFO register"]
#[inline (always)] pub fn fifo (& self) -> FIFO_R { FIFO_R :: new (self . bits) } }
#[doc = "RO, TMR1 FIFO register, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FIFO_SPEC ; impl crate :: RegisterSpec for FIFO_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`fifo::R`](R) reader structure"] impl crate :: Readable for FIFO_SPEC { }
#[doc = "`reset()` method sets FIFO to value 0"] impl crate :: Resettable for FIFO_SPEC { } }
#[doc = "DMA_NOW (r) register accessor: RO, TMR1 DMA current address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_now::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_now`] module"] pub type DMA_NOW = crate :: Reg < dma_now :: DMA_NOW_SPEC > ;
#[doc = "RO, TMR1 DMA current address"] pub mod dma_now {
#[doc = "Register `DMA_NOW` reader"] pub type R = crate :: R < DMA_NOW_SPEC > ;
#[doc = "Field `DMA_NOW` reader - RW1,TMR1 FIFO register"] pub type DMA_NOW_R = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - RW1,TMR1 FIFO register"]
#[inline (always)] pub fn dma_now (& self) -> DMA_NOW_R { DMA_NOW_R :: new (self . bits) } }
#[doc = "RO, TMR1 DMA current address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_now::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DMA_NOW_SPEC ; impl crate :: RegisterSpec for DMA_NOW_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`dma_now::R`](R) reader structure"] impl crate :: Readable for DMA_NOW_SPEC { }
#[doc = "`reset()` method sets DMA_NOW to value 0"] impl crate :: Resettable for DMA_NOW_SPEC { } }
#[doc = "DMA_BEG (rw) register accessor: RW, TMR1 DMA begin address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_beg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_beg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_beg`] module"] pub type DMA_BEG = crate :: Reg < dma_beg :: DMA_BEG_SPEC > ;
#[doc = "RW, TMR1 DMA begin address"] pub mod dma_beg {
#[doc = "Register `DMA_BEG` reader"] pub type R = crate :: R < DMA_BEG_SPEC > ;
#[doc = "Register `DMA_BEG` writer"] pub type W = crate :: W < DMA_BEG_SPEC > ;
#[doc = "Field `DMA_BEG` reader - RW1,TMR1 FIFO register"] pub type DMA_BEG_R = crate :: FieldReader < u16 > ;
#[doc = "Field `DMA_BEG` writer - RW1,TMR1 FIFO register"] pub type DMA_BEG_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW1,TMR1 FIFO register"]
#[inline (always)] pub fn dma_beg (& self) -> DMA_BEG_R { DMA_BEG_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW1,TMR1 FIFO register"]
#[inline (always)] pub fn dma_beg (& mut self) -> DMA_BEG_W < DMA_BEG_SPEC > { DMA_BEG_W :: new (self , 0) } }
#[doc = "RW, TMR1 DMA begin address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_beg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_beg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DMA_BEG_SPEC ; impl crate :: RegisterSpec for DMA_BEG_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`dma_beg::R`](R) reader structure"] impl crate :: Readable for DMA_BEG_SPEC { }
#[doc = "`write(|w| ..)` method takes [`dma_beg::W`](W) writer structure"] impl crate :: Writable for DMA_BEG_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMA_BEG to value 0"] impl crate :: Resettable for DMA_BEG_SPEC { } }
#[doc = "DMA_END (rw) register accessor: RW, TMR1 DMA end address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_end::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_end::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_end`] module"] pub type DMA_END = crate :: Reg < dma_end :: DMA_END_SPEC > ;
#[doc = "RW, TMR1 DMA end address"] pub mod dma_end {
#[doc = "Register `DMA_END` reader"] pub type R = crate :: R < DMA_END_SPEC > ;
#[doc = "Register `DMA_END` writer"] pub type W = crate :: W < DMA_END_SPEC > ;
#[doc = "Field `DMA_END` reader - RW1,TMR1 FIFO register"] pub type DMA_END_R = crate :: FieldReader < u16 > ;
#[doc = "Field `DMA_END` writer - RW1,TMR1 FIFO register"] pub type DMA_END_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW1,TMR1 FIFO register"]
#[inline (always)] pub fn dma_end (& self) -> DMA_END_R { DMA_END_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW1,TMR1 FIFO register"]
#[inline (always)] pub fn dma_end (& mut self) -> DMA_END_W < DMA_END_SPEC > { DMA_END_W :: new (self , 0) } }
#[doc = "RW, TMR1 DMA end address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_end::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_end::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DMA_END_SPEC ; impl crate :: RegisterSpec for DMA_END_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`dma_end::R`](R) reader structure"] impl crate :: Readable for DMA_END_SPEC { }
#[doc = "`write(|w| ..)` method takes [`dma_end::W`](W) writer structure"] impl crate :: Writable for DMA_END_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMA_END to value 0"] impl crate :: Resettable for DMA_END_SPEC { } } }
#[doc = "Timer2 register"] pub type TMR2 = crate :: Periph < tmr2 :: RegisterBlock , 0x4000_2800 > ; impl core :: fmt :: Debug for TMR2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TMR2") . finish () } }
#[doc = "Timer2 register"] pub mod tmr2 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ctrl_mod : CTRL_MOD , ctrl_dma : CTRL_DMA , inter_en : INTER_EN , _reserved3 : [u8 ; 0x03] , int_flag : INT_FLAG , fifo_count : FIFO_COUNT , count : COUNT , cnt_end : CNT_END , fifo : FIFO , dma_now : DMA_NOW , _reserved9 : [u8 ; 0x02] , dma_beg : DMA_BEG , _reserved10 : [u8 ; 0x02] , dma_end : DMA_END , } impl RegisterBlock {
#[doc = "0x00 - RW, TMR2 mode control"]
#[inline (always)] pub const fn ctrl_mod (& self) -> & CTRL_MOD { & self . ctrl_mod }
#[doc = "0x01 - RW, TMR2 DMA control"]
#[inline (always)] pub const fn ctrl_dma (& self) -> & CTRL_DMA { & self . ctrl_dma }
#[doc = "0x02 - RW, TMR2 interrupt enable"]
#[inline (always)] pub const fn inter_en (& self) -> & INTER_EN { & self . inter_en }
#[doc = "0x06 - RW1, TMR2 interrupt flag"]
#[inline (always)] pub const fn int_flag (& self) -> & INT_FLAG { & self . int_flag }
#[doc = "0x07 - RO, TMR2 FIFO count status"]
#[inline (always)] pub const fn fifo_count (& self) -> & FIFO_COUNT { & self . fifo_count }
#[doc = "0x08 - RO, TMR2 current count"]
#[inline (always)] pub const fn count (& self) -> & COUNT { & self . count }
#[doc = "0x0c - RW, TMR2 end count value, only low 26 bit"]
#[inline (always)] pub const fn cnt_end (& self) -> & CNT_END { & self . cnt_end }
#[doc = "0x10 - RO, TMR2 FIFO register, only low 26 bit"]
#[inline (always)] pub const fn fifo (& self) -> & FIFO { & self . fifo }
#[doc = "0x14 - RO, TMR2 DMA current address"]
#[inline (always)] pub const fn dma_now (& self) -> & DMA_NOW { & self . dma_now }
#[doc = "0x18 - RW, TMR2 DMA begin address"]
#[inline (always)] pub const fn dma_beg (& self) -> & DMA_BEG { & self . dma_beg }
#[doc = "0x1c - RW, TMR2 DMA end address"]
#[inline (always)] pub const fn dma_end (& self) -> & DMA_END { & self . dma_end } }
#[doc = "CTRL_MOD (rw) register accessor: RW, TMR2 mode control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl_mod`] module"] pub type CTRL_MOD = crate :: Reg < ctrl_mod :: CTRL_MOD_SPEC > ;
#[doc = "RW, TMR2 mode control"] pub mod ctrl_mod {
#[doc = "Register `CTRL_MOD` reader"] pub type R = crate :: R < CTRL_MOD_SPEC > ;
#[doc = "Register `CTRL_MOD` writer"] pub type W = crate :: W < CTRL_MOD_SPEC > ;
#[doc = "Field `ODE_IN` reader - RW, timer in mode: 0=timer_PWM, 1=capture_count"] pub type ODE_IN_R = crate :: BitReader ;
#[doc = "Field `ODE_IN` writer - RW, timer in mode: 0=timer_PWM, 1=capture_count"] pub type ODE_IN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LL_CLEAR` reader - RW, force clear timer FIFO and count"] pub type LL_CLEAR_R = crate :: BitReader ;
#[doc = "Field `LL_CLEAR` writer - RW, force clear timer FIFO and count"] pub type LL_CLEAR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OUNT_EN` reader - RW, timer count enable"] pub type OUNT_EN_R = crate :: BitReader ;
#[doc = "Field `OUNT_EN` writer - RW, timer count enable"] pub type OUNT_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UT_EN` reader - RW, timer output enable"] pub type UT_EN_R = crate :: BitReader ;
#[doc = "Field `UT_EN` writer - RW, timer output enable"] pub type UT_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UT_POLAR` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"] pub type UT_POLAR_R = crate :: BitReader ;
#[doc = "Field `UT_POLAR` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"] pub type UT_POLAR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AP_COUNT` reader - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"] pub type AP_COUNT_R = crate :: BitReader ;
#[doc = "Field `AP_COUNT` writer - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"] pub type AP_COUNT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WM_REPEAT` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"] pub type WM_REPEAT_R = crate :: FieldReader ;
#[doc = "Field `WM_REPEAT` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"] pub type WM_REPEAT_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `AP_EDGE` reader - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"] pub type AP_EDGE_R = crate :: FieldReader ;
#[doc = "Field `AP_EDGE` writer - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"] pub type AP_EDGE_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bit 0 - RW, timer in mode: 0=timer_PWM, 1=capture_count"]
#[inline (always)] pub fn ode_in (& self) -> ODE_IN_R { ODE_IN_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, force clear timer FIFO and count"]
#[inline (always)] pub fn ll_clear (& self) -> LL_CLEAR_R { LL_CLEAR_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW, timer count enable"]
#[inline (always)] pub fn ount_en (& self) -> OUNT_EN_R { OUNT_EN_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, timer output enable"]
#[inline (always)] pub fn ut_en (& self) -> UT_EN_R { UT_EN_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"]
#[inline (always)] pub fn ut_polar (& self) -> UT_POLAR_R { UT_POLAR_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 4 - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"]
#[inline (always)] pub fn ap_count (& self) -> AP_COUNT_R { AP_COUNT_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"]
#[inline (always)] pub fn wm_repeat (& self) -> WM_REPEAT_R { WM_REPEAT_R :: new ((self . bits >> 6) & 3) }
#[doc = "Bits 6:7 - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"]
#[inline (always)] pub fn ap_edge (& self) -> AP_EDGE_R { AP_EDGE_R :: new ((self . bits >> 6) & 3) } } impl W {
#[doc = "Bit 0 - RW, timer in mode: 0=timer_PWM, 1=capture_count"]
#[inline (always)] pub fn ode_in (& mut self) -> ODE_IN_W < CTRL_MOD_SPEC > { ODE_IN_W :: new (self , 0) }
#[doc = "Bit 1 - RW, force clear timer FIFO and count"]
#[inline (always)] pub fn ll_clear (& mut self) -> LL_CLEAR_W < CTRL_MOD_SPEC > { LL_CLEAR_W :: new (self , 1) }
#[doc = "Bit 2 - RW, timer count enable"]
#[inline (always)] pub fn ount_en (& mut self) -> OUNT_EN_W < CTRL_MOD_SPEC > { OUNT_EN_W :: new (self , 2) }
#[doc = "Bit 3 - RW, timer output enable"]
#[inline (always)] pub fn ut_en (& mut self) -> UT_EN_W < CTRL_MOD_SPEC > { UT_EN_W :: new (self , 3) }
#[doc = "Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"]
#[inline (always)] pub fn ut_polar (& mut self) -> UT_POLAR_W < CTRL_MOD_SPEC > { UT_POLAR_W :: new (self , 4) }
#[doc = "Bit 4 - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"]
#[inline (always)] pub fn ap_count (& mut self) -> AP_COUNT_W < CTRL_MOD_SPEC > { AP_COUNT_W :: new (self , 4) }
#[doc = "Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"]
#[inline (always)] pub fn wm_repeat (& mut self) -> WM_REPEAT_W < CTRL_MOD_SPEC > { WM_REPEAT_W :: new (self , 6) }
#[doc = "Bits 6:7 - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"]
#[inline (always)] pub fn ap_edge (& mut self) -> AP_EDGE_W < CTRL_MOD_SPEC > { AP_EDGE_W :: new (self , 6) } }
#[doc = "RW, TMR2 mode control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CTRL_MOD_SPEC ; impl crate :: RegisterSpec for CTRL_MOD_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`ctrl_mod::R`](R) reader structure"] impl crate :: Readable for CTRL_MOD_SPEC { }
#[doc = "`write(|w| ..)` method takes [`ctrl_mod::W`](W) writer structure"] impl crate :: Writable for CTRL_MOD_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL_MOD to value 0x02"] impl crate :: Resettable for CTRL_MOD_SPEC { const RESET_VALUE : u8 = 0x02 ; } }
#[doc = "CTRL_DMA (rw) register accessor: RW, TMR2 DMA control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl_dma`] module"] pub type CTRL_DMA = crate :: Reg < ctrl_dma :: CTRL_DMA_SPEC > ;
#[doc = "RW, TMR2 DMA control"] pub mod ctrl_dma {
#[doc = "Register `CTRL_DMA` reader"] pub type R = crate :: R < CTRL_DMA_SPEC > ;
#[doc = "Register `CTRL_DMA` writer"] pub type W = crate :: W < CTRL_DMA_SPEC > ;
#[doc = "Field `MA_ENABLE` reader - RW, timer1_2 DMA enable"] pub type MA_ENABLE_R = crate :: BitReader ;
#[doc = "Field `MA_ENABLE` writer - RW, timer1_2 DMA enable"] pub type MA_ENABLE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MA_LOOP` reader - RW, timer1_2 DMA address loop enable"] pub type MA_LOOP_R = crate :: BitReader ;
#[doc = "Field `MA_LOOP` writer - RW, timer1_2 DMA address loop enable"] pub type MA_LOOP_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, timer1_2 DMA enable"]
#[inline (always)] pub fn ma_enable (& self) -> MA_ENABLE_R { MA_ENABLE_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 2 - RW, timer1_2 DMA address loop enable"]
#[inline (always)] pub fn ma_loop (& self) -> MA_LOOP_R { MA_LOOP_R :: new (((self . bits >> 2) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, timer1_2 DMA enable"]
#[inline (always)] pub fn ma_enable (& mut self) -> MA_ENABLE_W < CTRL_DMA_SPEC > { MA_ENABLE_W :: new (self , 0) }
#[doc = "Bit 2 - RW, timer1_2 DMA address loop enable"]
#[inline (always)] pub fn ma_loop (& mut self) -> MA_LOOP_W < CTRL_DMA_SPEC > { MA_LOOP_W :: new (self , 2) } }
#[doc = "RW, TMR2 DMA control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CTRL_DMA_SPEC ; impl crate :: RegisterSpec for CTRL_DMA_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`ctrl_dma::R`](R) reader structure"] impl crate :: Readable for CTRL_DMA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`ctrl_dma::W`](W) writer structure"] impl crate :: Writable for CTRL_DMA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL_DMA to value 0"] impl crate :: Resettable for CTRL_DMA_SPEC { } }
#[doc = "INTER_EN (rw) register accessor: RW, TMR2 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`inter_en::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inter_en::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@inter_en`] module"] pub type INTER_EN = crate :: Reg < inter_en :: INTER_EN_SPEC > ;
#[doc = "RW, TMR2 interrupt enable"] pub mod inter_en {
#[doc = "Register `INTER_EN` reader"] pub type R = crate :: R < INTER_EN_SPEC > ;
#[doc = "Register `INTER_EN` writer"] pub type W = crate :: W < INTER_EN_SPEC > ;
#[doc = "Field `E_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end"] pub type E_CYC_END_R = crate :: BitReader ;
#[doc = "Field `E_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end"] pub type E_CYC_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger"] pub type E_DATA_ACT_R = crate :: BitReader ;
#[doc = "Field `E_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger"] pub type E_DATA_ACT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"] pub type E_FIFO_HF_R = crate :: BitReader ;
#[doc = "Field `E_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"] pub type E_FIFO_HF_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion"] pub type E_DMA_END_R = crate :: BitReader ;
#[doc = "Field `E_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion"] pub type E_DMA_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow"] pub type E_FIFO_OV_R = crate :: BitReader ;
#[doc = "Field `E_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow"] pub type E_FIFO_OV_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end"]
#[inline (always)] pub fn e_cyc_end (& self) -> E_CYC_END_R { E_CYC_END_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger"]
#[inline (always)] pub fn e_data_act (& self) -> E_DATA_ACT_R { E_DATA_ACT_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"]
#[inline (always)] pub fn e_fifo_hf (& self) -> E_FIFO_HF_R { E_FIFO_HF_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, enable interrupt for timer1/2 DMA completion"]
#[inline (always)] pub fn e_dma_end (& self) -> E_DMA_END_R { E_DMA_END_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW, enable interrupt for timer FIFO overflow"]
#[inline (always)] pub fn e_fifo_ov (& self) -> E_FIFO_OV_R { E_FIFO_OV_R :: new (((self . bits >> 4) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end"]
#[inline (always)] pub fn e_cyc_end (& mut self) -> E_CYC_END_W < INTER_EN_SPEC > { E_CYC_END_W :: new (self , 0) }
#[doc = "Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger"]
#[inline (always)] pub fn e_data_act (& mut self) -> E_DATA_ACT_W < INTER_EN_SPEC > { E_DATA_ACT_W :: new (self , 1) }
#[doc = "Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"]
#[inline (always)] pub fn e_fifo_hf (& mut self) -> E_FIFO_HF_W < INTER_EN_SPEC > { E_FIFO_HF_W :: new (self , 2) }
#[doc = "Bit 3 - RW, enable interrupt for timer1/2 DMA completion"]
#[inline (always)] pub fn e_dma_end (& mut self) -> E_DMA_END_W < INTER_EN_SPEC > { E_DMA_END_W :: new (self , 3) }
#[doc = "Bit 4 - RW, enable interrupt for timer FIFO overflow"]
#[inline (always)] pub fn e_fifo_ov (& mut self) -> E_FIFO_OV_W < INTER_EN_SPEC > { E_FIFO_OV_W :: new (self , 4) } }
#[doc = "RW, TMR2 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`inter_en::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inter_en::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INTER_EN_SPEC ; impl crate :: RegisterSpec for INTER_EN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`inter_en::R`](R) reader structure"] impl crate :: Readable for INTER_EN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`inter_en::W`](W) writer structure"] impl crate :: Writable for INTER_EN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INTER_EN to value 0"] impl crate :: Resettable for INTER_EN_SPEC { } }
#[doc = "INT_FLAG (rw) register accessor: RW1, TMR2 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_flag`] module"] pub type INT_FLAG = crate :: Reg < int_flag :: INT_FLAG_SPEC > ;
#[doc = "RW1, TMR2 interrupt flag"] pub mod int_flag {
#[doc = "Register `INT_FLAG` reader"] pub type R = crate :: R < INT_FLAG_SPEC > ;
#[doc = "Register `INT_FLAG` writer"] pub type W = crate :: W < INT_FLAG_SPEC > ;
#[doc = "Field `F_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end"] pub type F_CYC_END_R = crate :: BitReader ;
#[doc = "Field `F_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end"] pub type F_CYC_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger"] pub type F_DATA_ACT_R = crate :: BitReader ;
#[doc = "Field `F_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger"] pub type F_DATA_ACT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"] pub type F_FIFO_HF_R = crate :: BitReader ;
#[doc = "Field `F_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"] pub type F_FIFO_HF_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion"] pub type F_DMA_END_R = crate :: BitReader ;
#[doc = "Field `F_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion"] pub type F_DMA_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow"] pub type F_FIFO_OV_R = crate :: BitReader ;
#[doc = "Field `F_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow"] pub type F_FIFO_OV_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end"]
#[inline (always)] pub fn f_cyc_end (& self) -> F_CYC_END_R { F_CYC_END_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger"]
#[inline (always)] pub fn f_data_act (& self) -> F_DATA_ACT_R { F_DATA_ACT_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"]
#[inline (always)] pub fn f_fifo_hf (& self) -> F_FIFO_HF_R { F_FIFO_HF_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW1, interrupt flag for timer1/2 DMA completion"]
#[inline (always)] pub fn f_dma_end (& self) -> F_DMA_END_R { F_DMA_END_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW1, interrupt flag for timer FIFO overflow"]
#[inline (always)] pub fn f_fifo_ov (& self) -> F_FIFO_OV_R { F_FIFO_OV_R :: new (((self . bits >> 4) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end"]
#[inline (always)] pub fn f_cyc_end (& mut self) -> F_CYC_END_W < INT_FLAG_SPEC > { F_CYC_END_W :: new (self , 0) }
#[doc = "Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger"]
#[inline (always)] pub fn f_data_act (& mut self) -> F_DATA_ACT_W < INT_FLAG_SPEC > { F_DATA_ACT_W :: new (self , 1) }
#[doc = "Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"]
#[inline (always)] pub fn f_fifo_hf (& mut self) -> F_FIFO_HF_W < INT_FLAG_SPEC > { F_FIFO_HF_W :: new (self , 2) }
#[doc = "Bit 3 - RW1, interrupt flag for timer1/2 DMA completion"]
#[inline (always)] pub fn f_dma_end (& mut self) -> F_DMA_END_W < INT_FLAG_SPEC > { F_DMA_END_W :: new (self , 3) }
#[doc = "Bit 4 - RW1, interrupt flag for timer FIFO overflow"]
#[inline (always)] pub fn f_fifo_ov (& mut self) -> F_FIFO_OV_W < INT_FLAG_SPEC > { F_FIFO_OV_W :: new (self , 4) } }
#[doc = "RW1, TMR2 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_FLAG_SPEC ; impl crate :: RegisterSpec for INT_FLAG_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`int_flag::R`](R) reader structure"] impl crate :: Readable for INT_FLAG_SPEC { }
#[doc = "`write(|w| ..)` method takes [`int_flag::W`](W) writer structure"] impl crate :: Writable for INT_FLAG_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INT_FLAG to value 0"] impl crate :: Resettable for INT_FLAG_SPEC { } }
#[doc = "FIFO_COUNT (r) register accessor: RO, TMR2 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo_count`] module"] pub type FIFO_COUNT = crate :: Reg < fifo_count :: FIFO_COUNT_SPEC > ;
#[doc = "RO, TMR2 FIFO count status"] pub mod fifo_count {
#[doc = "Register `FIFO_COUNT` reader"] pub type R = crate :: R < FIFO_COUNT_SPEC > ;
#[doc = "Field `FIFO_COUNT` reader - RW, TMR2 FIFO count status"] pub type FIFO_COUNT_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RW, TMR2 FIFO count status"]
#[inline (always)] pub fn fifo_count (& self) -> FIFO_COUNT_R { FIFO_COUNT_R :: new (self . bits) } }
#[doc = "RO, TMR2 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FIFO_COUNT_SPEC ; impl crate :: RegisterSpec for FIFO_COUNT_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`fifo_count::R`](R) reader structure"] impl crate :: Readable for FIFO_COUNT_SPEC { }
#[doc = "`reset()` method sets FIFO_COUNT to value 0"] impl crate :: Resettable for FIFO_COUNT_SPEC { } }
#[doc = "COUNT (r) register accessor: RO, TMR2 current count\n\nYou can [`read`](crate::Reg::read) this register and get [`count::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count`] module"] pub type COUNT = crate :: Reg < count :: COUNT_SPEC > ;
#[doc = "RO, TMR2 current count"] pub mod count {
#[doc = "Register `COUNT` reader"] pub type R = crate :: R < COUNT_SPEC > ;
#[doc = "Field `COUNT` reader - RW, TMR2 current count"] pub type COUNT_R = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - RW, TMR2 current count"]
#[inline (always)] pub fn count (& self) -> COUNT_R { COUNT_R :: new (self . bits) } }
#[doc = "RO, TMR2 current count\n\nYou can [`read`](crate::Reg::read) this register and get [`count::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct COUNT_SPEC ; impl crate :: RegisterSpec for COUNT_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`count::R`](R) reader structure"] impl crate :: Readable for COUNT_SPEC { }
#[doc = "`reset()` method sets COUNT to value 0"] impl crate :: Resettable for COUNT_SPEC { } }
#[doc = "CNT_END (rw) register accessor: RW, TMR2 end count value, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt_end::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt_end::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt_end`] module"] pub type CNT_END = crate :: Reg < cnt_end :: CNT_END_SPEC > ;
#[doc = "RW, TMR2 end count value, only low 26 bit"] pub mod cnt_end {
#[doc = "Register `CNT_END` reader"] pub type R = crate :: R < CNT_END_SPEC > ;
#[doc = "Register `CNT_END` writer"] pub type W = crate :: W < CNT_END_SPEC > ;
#[doc = "Field `CNT_END` reader - RW, TMR2 current count"] pub type CNT_END_R = crate :: FieldReader < u32 > ;
#[doc = "Field `CNT_END` writer - RW, TMR2 current count"] pub type CNT_END_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW, TMR2 current count"]
#[inline (always)] pub fn cnt_end (& self) -> CNT_END_R { CNT_END_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW, TMR2 current count"]
#[inline (always)] pub fn cnt_end (& mut self) -> CNT_END_W < CNT_END_SPEC > { CNT_END_W :: new (self , 0) } }
#[doc = "RW, TMR2 end count value, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt_end::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt_end::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CNT_END_SPEC ; impl crate :: RegisterSpec for CNT_END_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`cnt_end::R`](R) reader structure"] impl crate :: Readable for CNT_END_SPEC { }
#[doc = "`write(|w| ..)` method takes [`cnt_end::W`](W) writer structure"] impl crate :: Writable for CNT_END_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNT_END to value 0"] impl crate :: Resettable for CNT_END_SPEC { } }
#[doc = "FIFO (rw) register accessor: RO, TMR2 FIFO register, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fifo::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo`] module"] pub type FIFO = crate :: Reg < fifo :: FIFO_SPEC > ;
#[doc = "RO, TMR2 FIFO register, only low 26 bit"] pub mod fifo {
#[doc = "Register `FIFO` reader"] pub type R = crate :: R < FIFO_SPEC > ;
#[doc = "Register `FIFO` writer"] pub type W = crate :: W < FIFO_SPEC > ;
#[doc = "Field `FIFO` reader - RW, TMR2 current count"] pub type FIFO_R = crate :: FieldReader < u32 > ;
#[doc = "Field `FIFO` writer - RW, TMR2 current count"] pub type FIFO_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW, TMR2 current count"]
#[inline (always)] pub fn fifo (& self) -> FIFO_R { FIFO_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW, TMR2 current count"]
#[inline (always)] pub fn fifo (& mut self) -> FIFO_W < FIFO_SPEC > { FIFO_W :: new (self , 0) } }
#[doc = "RO, TMR2 FIFO register, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fifo::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FIFO_SPEC ; impl crate :: RegisterSpec for FIFO_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`fifo::R`](R) reader structure"] impl crate :: Readable for FIFO_SPEC { }
#[doc = "`write(|w| ..)` method takes [`fifo::W`](W) writer structure"] impl crate :: Writable for FIFO_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FIFO to value 0"] impl crate :: Resettable for FIFO_SPEC { } }
#[doc = "DMA_NOW (r) register accessor: RO, TMR2 DMA current address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_now::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_now`] module"] pub type DMA_NOW = crate :: Reg < dma_now :: DMA_NOW_SPEC > ;
#[doc = "RO, TMR2 DMA current address"] pub mod dma_now {
#[doc = "Register `DMA_NOW` reader"] pub type R = crate :: R < DMA_NOW_SPEC > ;
#[doc = "Field `DMA_NOW` reader - RW, TMR2 current count"] pub type DMA_NOW_R = crate :: FieldReader < u16 > ; impl R {
#[doc = "Bits 0:15 - RW, TMR2 current count"]
#[inline (always)] pub fn dma_now (& self) -> DMA_NOW_R { DMA_NOW_R :: new (self . bits) } }
#[doc = "RO, TMR2 DMA current address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_now::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DMA_NOW_SPEC ; impl crate :: RegisterSpec for DMA_NOW_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`dma_now::R`](R) reader structure"] impl crate :: Readable for DMA_NOW_SPEC { }
#[doc = "`reset()` method sets DMA_NOW to value 0"] impl crate :: Resettable for DMA_NOW_SPEC { } }
#[doc = "DMA_BEG (rw) register accessor: RW, TMR2 DMA begin address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_beg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_beg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_beg`] module"] pub type DMA_BEG = crate :: Reg < dma_beg :: DMA_BEG_SPEC > ;
#[doc = "RW, TMR2 DMA begin address"] pub mod dma_beg {
#[doc = "Register `DMA_BEG` reader"] pub type R = crate :: R < DMA_BEG_SPEC > ;
#[doc = "Register `DMA_BEG` writer"] pub type W = crate :: W < DMA_BEG_SPEC > ;
#[doc = "Field `DMA_BEG` reader - RW, TMR2 DMA begin address"] pub type DMA_BEG_R = crate :: FieldReader < u16 > ;
#[doc = "Field `DMA_BEG` writer - RW, TMR2 DMA begin address"] pub type DMA_BEG_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW, TMR2 DMA begin address"]
#[inline (always)] pub fn dma_beg (& self) -> DMA_BEG_R { DMA_BEG_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW, TMR2 DMA begin address"]
#[inline (always)] pub fn dma_beg (& mut self) -> DMA_BEG_W < DMA_BEG_SPEC > { DMA_BEG_W :: new (self , 0) } }
#[doc = "RW, TMR2 DMA begin address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_beg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_beg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DMA_BEG_SPEC ; impl crate :: RegisterSpec for DMA_BEG_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`dma_beg::R`](R) reader structure"] impl crate :: Readable for DMA_BEG_SPEC { }
#[doc = "`write(|w| ..)` method takes [`dma_beg::W`](W) writer structure"] impl crate :: Writable for DMA_BEG_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMA_BEG to value 0"] impl crate :: Resettable for DMA_BEG_SPEC { } }
#[doc = "DMA_END (rw) register accessor: RW, TMR2 DMA end address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_end::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_end::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_end`] module"] pub type DMA_END = crate :: Reg < dma_end :: DMA_END_SPEC > ;
#[doc = "RW, TMR2 DMA end address"] pub mod dma_end {
#[doc = "Register `DMA_END` reader"] pub type R = crate :: R < DMA_END_SPEC > ;
#[doc = "Register `DMA_END` writer"] pub type W = crate :: W < DMA_END_SPEC > ;
#[doc = "Field `DMA_END` reader - RW, TMR2 DMA end address"] pub type DMA_END_R = crate :: FieldReader < u16 > ;
#[doc = "Field `DMA_END` writer - RW, TMR2 DMA end address"] pub type DMA_END_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW, TMR2 DMA end address"]
#[inline (always)] pub fn dma_end (& self) -> DMA_END_R { DMA_END_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW, TMR2 DMA end address"]
#[inline (always)] pub fn dma_end (& mut self) -> DMA_END_W < DMA_END_SPEC > { DMA_END_W :: new (self , 0) } }
#[doc = "RW, TMR2 DMA end address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_end::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_end::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DMA_END_SPEC ; impl crate :: RegisterSpec for DMA_END_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`dma_end::R`](R) reader structure"] impl crate :: Readable for DMA_END_SPEC { }
#[doc = "`write(|w| ..)` method takes [`dma_end::W`](W) writer structure"] impl crate :: Writable for DMA_END_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMA_END to value 0"] impl crate :: Resettable for DMA_END_SPEC { } } }
#[doc = "Timer3 register"] pub type TMR3 = crate :: Periph < tmr3 :: RegisterBlock , 0x4000_2c00 > ; impl core :: fmt :: Debug for TMR3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("TMR3") . finish () } }
#[doc = "Timer3 register"] pub mod tmr3 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ctrl_mod : CTRL_MOD , _reserved1 : [u8 ; 0x01] , inter_en : INTER_EN , _reserved2 : [u8 ; 0x03] , int_flag : INT_FLAG , fifo_count : FIFO_COUNT , count : COUNT , cnt_end : CNT_END , fifo : FIFO , } impl RegisterBlock {
#[doc = "0x00 - RW, TMR3 mode control"]
#[inline (always)] pub const fn ctrl_mod (& self) -> & CTRL_MOD { & self . ctrl_mod }
#[doc = "0x02 - RW, TMR3 interrupt enable"]
#[inline (always)] pub const fn inter_en (& self) -> & INTER_EN { & self . inter_en }
#[doc = "0x06 - RW1, TMR3 interrupt flag"]
#[inline (always)] pub const fn int_flag (& self) -> & INT_FLAG { & self . int_flag }
#[doc = "0x07 - RO, TMR3 FIFO count status"]
#[inline (always)] pub const fn fifo_count (& self) -> & FIFO_COUNT { & self . fifo_count }
#[doc = "0x08 - RO, TMR3 current count"]
#[inline (always)] pub const fn count (& self) -> & COUNT { & self . count }
#[doc = "0x0c - RW, TMR3 end count value, only low 26 bit"]
#[inline (always)] pub const fn cnt_end (& self) -> & CNT_END { & self . cnt_end }
#[doc = "0x10 - RO/WO, TMR3 FIFO register, only low 26 bit"]
#[inline (always)] pub const fn fifo (& self) -> & FIFO { & self . fifo } }
#[doc = "CTRL_MOD (rw) register accessor: RW, TMR3 mode control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl_mod`] module"] pub type CTRL_MOD = crate :: Reg < ctrl_mod :: CTRL_MOD_SPEC > ;
#[doc = "RW, TMR3 mode control"] pub mod ctrl_mod {
#[doc = "Register `CTRL_MOD` reader"] pub type R = crate :: R < CTRL_MOD_SPEC > ;
#[doc = "Register `CTRL_MOD` writer"] pub type W = crate :: W < CTRL_MOD_SPEC > ;
#[doc = "Field `ODE_IN` reader - RW, timer in mode: 0=timer/PWM, 1=capture/count"] pub type ODE_IN_R = crate :: BitReader ;
#[doc = "Field `ODE_IN` writer - RW, timer in mode: 0=timer/PWM, 1=capture/count"] pub type ODE_IN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LL_CLEAR` reader - RW, force clear timer FIFO and count"] pub type LL_CLEAR_R = crate :: BitReader ;
#[doc = "Field `LL_CLEAR` writer - RW, force clear timer FIFO and count"] pub type LL_CLEAR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OUNT_EN` reader - RW, timer count enable"] pub type OUNT_EN_R = crate :: BitReader ;
#[doc = "Field `OUNT_EN` writer - RW, timer count enable"] pub type OUNT_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UT_EN` reader - RW, timer output enable"] pub type UT_EN_R = crate :: BitReader ;
#[doc = "Field `UT_EN` writer - RW, timer output enable"] pub type UT_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UT_POLAR` reader - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"] pub type UT_POLAR_R = crate :: BitReader ;
#[doc = "Field `UT_POLAR` writer - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"] pub type UT_POLAR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `AP_COUNT` reader - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"] pub type AP_COUNT_R = crate :: BitReader ;
#[doc = "Field `AP_COUNT` writer - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"] pub type AP_COUNT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WM_REPEAT` reader - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"] pub type WM_REPEAT_R = crate :: FieldReader ;
#[doc = "Field `WM_REPEAT` writer - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"] pub type WM_REPEAT_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `AP_EDGE` reader - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"] pub type AP_EDGE_R = crate :: FieldReader ;
#[doc = "Field `AP_EDGE` writer - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"] pub type AP_EDGE_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count"]
#[inline (always)] pub fn ode_in (& self) -> ODE_IN_R { ODE_IN_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, force clear timer FIFO and count"]
#[inline (always)] pub fn ll_clear (& self) -> LL_CLEAR_R { LL_CLEAR_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW, timer count enable"]
#[inline (always)] pub fn ount_en (& self) -> OUNT_EN_R { OUNT_EN_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, timer output enable"]
#[inline (always)] pub fn ut_en (& self) -> UT_EN_R { UT_EN_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"]
#[inline (always)] pub fn ut_polar (& self) -> UT_POLAR_R { UT_POLAR_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 4 - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"]
#[inline (always)] pub fn ap_count (& self) -> AP_COUNT_R { AP_COUNT_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"]
#[inline (always)] pub fn wm_repeat (& self) -> WM_REPEAT_R { WM_REPEAT_R :: new ((self . bits >> 6) & 3) }
#[doc = "Bits 6:7 - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"]
#[inline (always)] pub fn ap_edge (& self) -> AP_EDGE_R { AP_EDGE_R :: new ((self . bits >> 6) & 3) } } impl W {
#[doc = "Bit 0 - RW, timer in mode: 0=timer/PWM, 1=capture/count"]
#[inline (always)] pub fn ode_in (& mut self) -> ODE_IN_W < CTRL_MOD_SPEC > { ODE_IN_W :: new (self , 0) }
#[doc = "Bit 1 - RW, force clear timer FIFO and count"]
#[inline (always)] pub fn ll_clear (& mut self) -> LL_CLEAR_W < CTRL_MOD_SPEC > { LL_CLEAR_W :: new (self , 1) }
#[doc = "Bit 2 - RW, timer count enable"]
#[inline (always)] pub fn ount_en (& mut self) -> OUNT_EN_W < CTRL_MOD_SPEC > { OUNT_EN_W :: new (self , 2) }
#[doc = "Bit 3 - RW, timer output enable"]
#[inline (always)] pub fn ut_en (& mut self) -> UT_EN_W < CTRL_MOD_SPEC > { UT_EN_W :: new (self , 3) }
#[doc = "Bit 4 - RW, timer PWM output polarity: 0=default low and high action, 1=default high and low action"]
#[inline (always)] pub fn ut_polar (& mut self) -> UT_POLAR_W < CTRL_MOD_SPEC > { UT_POLAR_W :: new (self , 4) }
#[doc = "Bit 4 - RW, count sub-mode if RB_TMR_MODE_IN=1: 0=capture, 1=count"]
#[inline (always)] pub fn ap_count (& mut self) -> AP_COUNT_W < CTRL_MOD_SPEC > { AP_COUNT_W :: new (self , 4) }
#[doc = "Bits 6:7 - RW, timer PWM repeat mode: 00=1, 01=4, 10=8, 11-16"]
#[inline (always)] pub fn wm_repeat (& mut self) -> WM_REPEAT_W < CTRL_MOD_SPEC > { WM_REPEAT_W :: new (self , 6) }
#[doc = "Bits 6:7 - RW, timer capture edge mode: 00=disable, 01=edge change, 10=fall to fall, 11-rise to rise"]
#[inline (always)] pub fn ap_edge (& mut self) -> AP_EDGE_W < CTRL_MOD_SPEC > { AP_EDGE_W :: new (self , 6) } }
#[doc = "RW, TMR3 mode control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CTRL_MOD_SPEC ; impl crate :: RegisterSpec for CTRL_MOD_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`ctrl_mod::R`](R) reader structure"] impl crate :: Readable for CTRL_MOD_SPEC { }
#[doc = "`write(|w| ..)` method takes [`ctrl_mod::W`](W) writer structure"] impl crate :: Writable for CTRL_MOD_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL_MOD to value 0x02"] impl crate :: Resettable for CTRL_MOD_SPEC { const RESET_VALUE : u8 = 0x02 ; } }
#[doc = "INTER_EN (rw) register accessor: RW, TMR3 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`inter_en::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inter_en::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@inter_en`] module"] pub type INTER_EN = crate :: Reg < inter_en :: INTER_EN_SPEC > ;
#[doc = "RW, TMR3 interrupt enable"] pub mod inter_en {
#[doc = "Register `INTER_EN` reader"] pub type R = crate :: R < INTER_EN_SPEC > ;
#[doc = "Register `INTER_EN` writer"] pub type W = crate :: W < INTER_EN_SPEC > ;
#[doc = "Field `E_CYC_END` reader - RW, enable interrupt for timer capture count timeout or PWM cycle end"] pub type E_CYC_END_R = crate :: BitReader ;
#[doc = "Field `E_CYC_END` writer - RW, enable interrupt for timer capture count timeout or PWM cycle end"] pub type E_CYC_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_DATA_ACT` reader - RW, enable interrupt for timer capture input action or PWM trigger"] pub type E_DATA_ACT_R = crate :: BitReader ;
#[doc = "Field `E_DATA_ACT` writer - RW, enable interrupt for timer capture input action or PWM trigger"] pub type E_DATA_ACT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_FIFO_HF` reader - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"] pub type E_FIFO_HF_R = crate :: BitReader ;
#[doc = "Field `E_FIFO_HF` writer - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"] pub type E_FIFO_HF_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_DMA_END` reader - RW, enable interrupt for timer1/2 DMA completion"] pub type E_DMA_END_R = crate :: BitReader ;
#[doc = "Field `E_DMA_END` writer - RW, enable interrupt for timer1/2 DMA completion"] pub type E_DMA_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_FIFO_OV` reader - RW, enable interrupt for timer FIFO overflow"] pub type E_FIFO_OV_R = crate :: BitReader ;
#[doc = "Field `E_FIFO_OV` writer - RW, enable interrupt for timer FIFO overflow"] pub type E_FIFO_OV_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end"]
#[inline (always)] pub fn e_cyc_end (& self) -> E_CYC_END_R { E_CYC_END_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger"]
#[inline (always)] pub fn e_data_act (& self) -> E_DATA_ACT_R { E_DATA_ACT_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"]
#[inline (always)] pub fn e_fifo_hf (& self) -> E_FIFO_HF_R { E_FIFO_HF_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, enable interrupt for timer1/2 DMA completion"]
#[inline (always)] pub fn e_dma_end (& self) -> E_DMA_END_R { E_DMA_END_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW, enable interrupt for timer FIFO overflow"]
#[inline (always)] pub fn e_fifo_ov (& self) -> E_FIFO_OV_R { E_FIFO_OV_R :: new (((self . bits >> 4) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, enable interrupt for timer capture count timeout or PWM cycle end"]
#[inline (always)] pub fn e_cyc_end (& mut self) -> E_CYC_END_W < INTER_EN_SPEC > { E_CYC_END_W :: new (self , 0) }
#[doc = "Bit 1 - RW, enable interrupt for timer capture input action or PWM trigger"]
#[inline (always)] pub fn e_data_act (& mut self) -> E_DATA_ACT_W < INTER_EN_SPEC > { E_DATA_ACT_W :: new (self , 1) }
#[doc = "Bit 2 - RW, enable interrupt for timer FIFO half (capture fifo >=4 or PWM fifo less than 3)"]
#[inline (always)] pub fn e_fifo_hf (& mut self) -> E_FIFO_HF_W < INTER_EN_SPEC > { E_FIFO_HF_W :: new (self , 2) }
#[doc = "Bit 3 - RW, enable interrupt for timer1/2 DMA completion"]
#[inline (always)] pub fn e_dma_end (& mut self) -> E_DMA_END_W < INTER_EN_SPEC > { E_DMA_END_W :: new (self , 3) }
#[doc = "Bit 4 - RW, enable interrupt for timer FIFO overflow"]
#[inline (always)] pub fn e_fifo_ov (& mut self) -> E_FIFO_OV_W < INTER_EN_SPEC > { E_FIFO_OV_W :: new (self , 4) } }
#[doc = "RW, TMR3 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`inter_en::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inter_en::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INTER_EN_SPEC ; impl crate :: RegisterSpec for INTER_EN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`inter_en::R`](R) reader structure"] impl crate :: Readable for INTER_EN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`inter_en::W`](W) writer structure"] impl crate :: Writable for INTER_EN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INTER_EN to value 0"] impl crate :: Resettable for INTER_EN_SPEC { } }
#[doc = "INT_FLAG (rw) register accessor: RW1, TMR3 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_flag`] module"] pub type INT_FLAG = crate :: Reg < int_flag :: INT_FLAG_SPEC > ;
#[doc = "RW1, TMR3 interrupt flag"] pub mod int_flag {
#[doc = "Register `INT_FLAG` reader"] pub type R = crate :: R < INT_FLAG_SPEC > ;
#[doc = "Register `INT_FLAG` writer"] pub type W = crate :: W < INT_FLAG_SPEC > ;
#[doc = "Field `F_CYC_END` reader - RW1, interrupt flag for timer capture count timeout or PWM cycle end"] pub type F_CYC_END_R = crate :: BitReader ;
#[doc = "Field `F_CYC_END` writer - RW1, interrupt flag for timer capture count timeout or PWM cycle end"] pub type F_CYC_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_DATA_ACT` reader - RW1, interrupt flag for timer capture input action or PWM trigger"] pub type F_DATA_ACT_R = crate :: BitReader ;
#[doc = "Field `F_DATA_ACT` writer - RW1, interrupt flag for timer capture input action or PWM trigger"] pub type F_DATA_ACT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_FIFO_HF` reader - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"] pub type F_FIFO_HF_R = crate :: BitReader ;
#[doc = "Field `F_FIFO_HF` writer - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"] pub type F_FIFO_HF_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_DMA_END` reader - RW1, interrupt flag for timer1/2 DMA completion"] pub type F_DMA_END_R = crate :: BitReader ;
#[doc = "Field `F_DMA_END` writer - RW1, interrupt flag for timer1/2 DMA completion"] pub type F_DMA_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_FIFO_OV` reader - RW1, interrupt flag for timer FIFO overflow"] pub type F_FIFO_OV_R = crate :: BitReader ;
#[doc = "Field `F_FIFO_OV` writer - RW1, interrupt flag for timer FIFO overflow"] pub type F_FIFO_OV_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end"]
#[inline (always)] pub fn f_cyc_end (& self) -> F_CYC_END_R { F_CYC_END_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger"]
#[inline (always)] pub fn f_data_act (& self) -> F_DATA_ACT_R { F_DATA_ACT_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"]
#[inline (always)] pub fn f_fifo_hf (& self) -> F_FIFO_HF_R { F_FIFO_HF_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW1, interrupt flag for timer1/2 DMA completion"]
#[inline (always)] pub fn f_dma_end (& self) -> F_DMA_END_R { F_DMA_END_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW1, interrupt flag for timer FIFO overflow"]
#[inline (always)] pub fn f_fifo_ov (& self) -> F_FIFO_OV_R { F_FIFO_OV_R :: new (((self . bits >> 4) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW1, interrupt flag for timer capture count timeout or PWM cycle end"]
#[inline (always)] pub fn f_cyc_end (& mut self) -> F_CYC_END_W < INT_FLAG_SPEC > { F_CYC_END_W :: new (self , 0) }
#[doc = "Bit 1 - RW1, interrupt flag for timer capture input action or PWM trigger"]
#[inline (always)] pub fn f_data_act (& mut self) -> F_DATA_ACT_W < INT_FLAG_SPEC > { F_DATA_ACT_W :: new (self , 1) }
#[doc = "Bit 2 - RW1, interrupt flag for timer FIFO half (capture fifo >=4 or PWM fifo less than 3"]
#[inline (always)] pub fn f_fifo_hf (& mut self) -> F_FIFO_HF_W < INT_FLAG_SPEC > { F_FIFO_HF_W :: new (self , 2) }
#[doc = "Bit 3 - RW1, interrupt flag for timer1/2 DMA completion"]
#[inline (always)] pub fn f_dma_end (& mut self) -> F_DMA_END_W < INT_FLAG_SPEC > { F_DMA_END_W :: new (self , 3) }
#[doc = "Bit 4 - RW1, interrupt flag for timer FIFO overflow"]
#[inline (always)] pub fn f_fifo_ov (& mut self) -> F_FIFO_OV_W < INT_FLAG_SPEC > { F_FIFO_OV_W :: new (self , 4) } }
#[doc = "RW1, TMR3 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_FLAG_SPEC ; impl crate :: RegisterSpec for INT_FLAG_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`int_flag::R`](R) reader structure"] impl crate :: Readable for INT_FLAG_SPEC { }
#[doc = "`write(|w| ..)` method takes [`int_flag::W`](W) writer structure"] impl crate :: Writable for INT_FLAG_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INT_FLAG to value 0"] impl crate :: Resettable for INT_FLAG_SPEC { } }
#[doc = "FIFO_COUNT (r) register accessor: RO, TMR3 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo_count`] module"] pub type FIFO_COUNT = crate :: Reg < fifo_count :: FIFO_COUNT_SPEC > ;
#[doc = "RO, TMR3 FIFO count status"] pub mod fifo_count {
#[doc = "Register `FIFO_COUNT` reader"] pub type R = crate :: R < FIFO_COUNT_SPEC > ;
#[doc = "Field `FIFO_COUNT` reader - R0, TMR3 FIFO count status"] pub type FIFO_COUNT_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - R0, TMR3 FIFO count status"]
#[inline (always)] pub fn fifo_count (& self) -> FIFO_COUNT_R { FIFO_COUNT_R :: new (self . bits) } }
#[doc = "RO, TMR3 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FIFO_COUNT_SPEC ; impl crate :: RegisterSpec for FIFO_COUNT_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`fifo_count::R`](R) reader structure"] impl crate :: Readable for FIFO_COUNT_SPEC { }
#[doc = "`reset()` method sets FIFO_COUNT to value 0"] impl crate :: Resettable for FIFO_COUNT_SPEC { } }
#[doc = "COUNT (r) register accessor: RO, TMR3 current count\n\nYou can [`read`](crate::Reg::read) this register and get [`count::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@count`] module"] pub type COUNT = crate :: Reg < count :: COUNT_SPEC > ;
#[doc = "RO, TMR3 current count"] pub mod count {
#[doc = "Register `COUNT` reader"] pub type R = crate :: R < COUNT_SPEC > ;
#[doc = "Field `COUNT` reader - R0, TMR3 current count"] pub type COUNT_R = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 0:31 - R0, TMR3 current count"]
#[inline (always)] pub fn count (& self) -> COUNT_R { COUNT_R :: new (self . bits) } }
#[doc = "RO, TMR3 current count\n\nYou can [`read`](crate::Reg::read) this register and get [`count::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct COUNT_SPEC ; impl crate :: RegisterSpec for COUNT_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`count::R`](R) reader structure"] impl crate :: Readable for COUNT_SPEC { }
#[doc = "`reset()` method sets COUNT to value 0"] impl crate :: Resettable for COUNT_SPEC { } }
#[doc = "CNT_END (rw) register accessor: RW, TMR3 end count value, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt_end::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt_end::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt_end`] module"] pub type CNT_END = crate :: Reg < cnt_end :: CNT_END_SPEC > ;
#[doc = "RW, TMR3 end count value, only low 26 bit"] pub mod cnt_end {
#[doc = "Register `CNT_END` reader"] pub type R = crate :: R < CNT_END_SPEC > ;
#[doc = "Register `CNT_END` writer"] pub type W = crate :: W < CNT_END_SPEC > ;
#[doc = "Field `CNT_END` reader - RW, TMR3 end count value, only low 26 bit"] pub type CNT_END_R = crate :: FieldReader < u32 > ;
#[doc = "Field `CNT_END` writer - RW, TMR3 end count value, only low 26 bit"] pub type CNT_END_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW, TMR3 end count value, only low 26 bit"]
#[inline (always)] pub fn cnt_end (& self) -> CNT_END_R { CNT_END_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW, TMR3 end count value, only low 26 bit"]
#[inline (always)] pub fn cnt_end (& mut self) -> CNT_END_W < CNT_END_SPEC > { CNT_END_W :: new (self , 0) } }
#[doc = "RW, TMR3 end count value, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt_end::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt_end::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CNT_END_SPEC ; impl crate :: RegisterSpec for CNT_END_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`cnt_end::R`](R) reader structure"] impl crate :: Readable for CNT_END_SPEC { }
#[doc = "`write(|w| ..)` method takes [`cnt_end::W`](W) writer structure"] impl crate :: Writable for CNT_END_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNT_END to value 0"] impl crate :: Resettable for CNT_END_SPEC { } }
#[doc = "FIFO (rw) register accessor: RO/WO, TMR3 FIFO register, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fifo::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo`] module"] pub type FIFO = crate :: Reg < fifo :: FIFO_SPEC > ;
#[doc = "RO/WO, TMR3 FIFO register, only low 26 bit"] pub mod fifo {
#[doc = "Register `FIFO` reader"] pub type R = crate :: R < FIFO_SPEC > ;
#[doc = "Register `FIFO` writer"] pub type W = crate :: W < FIFO_SPEC > ;
#[doc = "Field `FIFO` reader - RO/WO, TMR3 FIFO register, only low 26 bit"] pub type FIFO_R = crate :: FieldReader < u32 > ;
#[doc = "Field `FIFO` writer - RO/WO, TMR3 FIFO register, only low 26 bit"] pub type FIFO_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RO/WO, TMR3 FIFO register, only low 26 bit"]
#[inline (always)] pub fn fifo (& self) -> FIFO_R { FIFO_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RO/WO, TMR3 FIFO register, only low 26 bit"]
#[inline (always)] pub fn fifo (& mut self) -> FIFO_W < FIFO_SPEC > { FIFO_W :: new (self , 0) } }
#[doc = "RO/WO, TMR3 FIFO register, only low 26 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fifo::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FIFO_SPEC ; impl crate :: RegisterSpec for FIFO_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`fifo::R`](R) reader structure"] impl crate :: Readable for FIFO_SPEC { }
#[doc = "`write(|w| ..)` method takes [`fifo::W`](W) writer structure"] impl crate :: Writable for FIFO_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FIFO to value 0"] impl crate :: Resettable for FIFO_SPEC { } } }
#[doc = "UART0 register"] pub type UART0 = crate :: Periph < uart0 :: RegisterBlock , 0x4000_3000 > ; impl core :: fmt :: Debug for UART0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("UART0") . finish () } }
#[doc = "UART0 register"] pub mod uart0 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { mcr : MCR , ier : IER , fcr : FCR , lcr : LCR , iir : IIR , lsr : LSR , msr : MSR , _reserved7 : [u8 ; 0x01] , _reserved_7_rbr : [u8 ; 0x01] , _reserved8 : [u8 ; 0x01] , rfc : RFC , tfc : TFC , dl : DL , div : DIV , adr : ADR , } impl RegisterBlock {
#[doc = "0x00 - RW, UART0 modem control"]
#[inline (always)] pub const fn mcr (& self) -> & MCR { & self . mcr }
#[doc = "0x01 - RW, UART0 interrupt enable"]
#[inline (always)] pub const fn ier (& self) -> & IER { & self . ier }
#[doc = "0x02 - RW, UART0 FIFO control"]
#[inline (always)] pub const fn fcr (& self) -> & FCR { & self . fcr }
#[doc = "0x03 - RW, UART0 line control"]
#[inline (always)] pub const fn lcr (& self) -> & LCR { & self . lcr }
#[doc = "0x04 - RO, UART0 interrupt identification"]
#[inline (always)] pub const fn iir (& self) -> & IIR { & self . iir }
#[doc = "0x05 - RO, UART0 line status"]
#[inline (always)] pub const fn lsr (& self) -> & LSR { & self . lsr }
#[doc = "0x06 - RO, UART0 modem status"]
#[inline (always)] pub const fn msr (& self) -> & MSR { & self . msr }
#[doc = "0x08 - WO, UART0 transmitter holding, transmittal byte"]
#[inline (always)] pub const fn thr (& self) -> & THR { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (8) . cast () } }
#[doc = "0x08 - RO, UART0 receiver buffer, receiving byte"]
#[inline (always)] pub const fn rbr (& self) -> & RBR { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (8) . cast () } }
#[doc = "0x0a - RO, UART0 receiver FIFO count"]
#[inline (always)] pub const fn rfc (& self) -> & RFC { & self . rfc }
#[doc = "0x0b - RO, UART0 transmitter FIFO count"]
#[inline (always)] pub const fn tfc (& self) -> & TFC { & self . tfc }
#[doc = "0x0c - RW, UART0 divisor latch"]
#[inline (always)] pub const fn dl (& self) -> & DL { & self . dl }
#[doc = "0x0e - RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128"]
#[inline (always)] pub const fn div (& self) -> & DIV { & self . div }
#[doc = "0x0f - RW, UART0 slave address: 0xFF=disable, other=enable"]
#[inline (always)] pub const fn adr (& self) -> & ADR { & self . adr } }
#[doc = "MCR (rw) register accessor: RW, UART0 modem control\n\nYou can [`read`](crate::Reg::read) this register and get [`mcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mcr`] module"] pub type MCR = crate :: Reg < mcr :: MCR_SPEC > ;
#[doc = "RW, UART0 modem control"] pub mod mcr {
#[doc = "Register `MCR` reader"] pub type R = crate :: R < MCR_SPEC > ;
#[doc = "Register `MCR` writer"] pub type W = crate :: W < MCR_SPEC > ;
#[doc = "Field `MCR_DTR` reader - RW, UART0 control DTR"] pub type MCR_DTR_R = crate :: BitReader ;
#[doc = "Field `MCR_DTR` writer - RW, UART0 control DTR"] pub type MCR_DTR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MCR_RTS` reader - RW, UART0 control RTS"] pub type MCR_RTS_R = crate :: BitReader ;
#[doc = "Field `MCR_RTS` writer - RW, UART0 control RTS"] pub type MCR_RTS_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MCR_OUT1` reader - RW, UART0 control OUT1"] pub type MCR_OUT1_R = crate :: BitReader ;
#[doc = "Field `MCR_OUT1` writer - RW, UART0 control OUT1"] pub type MCR_OUT1_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MCR_OUT2` reader - RW, UART control OUT2"] pub type MCR_OUT2_R = crate :: BitReader ;
#[doc = "Field `MCR_OUT2` writer - RW, UART control OUT2"] pub type MCR_OUT2_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MCR_INT_OE` reader - RW, UART interrupt output enable"] pub type MCR_INT_OE_R = crate :: BitReader ;
#[doc = "Field `MCR_INT_OE` writer - RW, UART interrupt output enable"] pub type MCR_INT_OE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MCR_LOOP` reader - RW, UART0 enable local loop back"] pub type MCR_LOOP_R = crate :: BitReader ;
#[doc = "Field `MCR_LOOP` writer - RW, UART0 enable local loop back"] pub type MCR_LOOP_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MCR_AU_FLOW_EN` reader - RW, UART0 enable autoflow control"] pub type MCR_AU_FLOW_EN_R = crate :: BitReader ;
#[doc = "Field `MCR_AU_FLOW_EN` writer - RW, UART0 enable autoflow control"] pub type MCR_AU_FLOW_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MCR_TNOW` reader - RW, UART0 enable TNOW output on DTR pin"] pub type MCR_TNOW_R = crate :: BitReader ;
#[doc = "Field `MCR_TNOW` writer - RW, UART0 enable TNOW output on DTR pin"] pub type MCR_TNOW_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MCR_HALF` reader - RW, UART0 enable half-duplex"] pub type MCR_HALF_R = crate :: BitReader ;
#[doc = "Field `MCR_HALF` writer - RW, UART0 enable half-duplex"] pub type MCR_HALF_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, UART0 control DTR"]
#[inline (always)] pub fn mcr_dtr (& self) -> MCR_DTR_R { MCR_DTR_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, UART0 control RTS"]
#[inline (always)] pub fn mcr_rts (& self) -> MCR_RTS_R { MCR_RTS_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW, UART0 control OUT1"]
#[inline (always)] pub fn mcr_out1 (& self) -> MCR_OUT1_R { MCR_OUT1_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, UART control OUT2"]
#[inline (always)] pub fn mcr_out2 (& self) -> MCR_OUT2_R { MCR_OUT2_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 3 - RW, UART interrupt output enable"]
#[inline (always)] pub fn mcr_int_oe (& self) -> MCR_INT_OE_R { MCR_INT_OE_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW, UART0 enable local loop back"]
#[inline (always)] pub fn mcr_loop (& self) -> MCR_LOOP_R { MCR_LOOP_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RW, UART0 enable autoflow control"]
#[inline (always)] pub fn mcr_au_flow_en (& self) -> MCR_AU_FLOW_EN_R { MCR_AU_FLOW_EN_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RW, UART0 enable TNOW output on DTR pin"]
#[inline (always)] pub fn mcr_tnow (& self) -> MCR_TNOW_R { MCR_TNOW_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RW, UART0 enable half-duplex"]
#[inline (always)] pub fn mcr_half (& self) -> MCR_HALF_R { MCR_HALF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, UART0 control DTR"]
#[inline (always)] pub fn mcr_dtr (& mut self) -> MCR_DTR_W < MCR_SPEC > { MCR_DTR_W :: new (self , 0) }
#[doc = "Bit 1 - RW, UART0 control RTS"]
#[inline (always)] pub fn mcr_rts (& mut self) -> MCR_RTS_W < MCR_SPEC > { MCR_RTS_W :: new (self , 1) }
#[doc = "Bit 2 - RW, UART0 control OUT1"]
#[inline (always)] pub fn mcr_out1 (& mut self) -> MCR_OUT1_W < MCR_SPEC > { MCR_OUT1_W :: new (self , 2) }
#[doc = "Bit 3 - RW, UART control OUT2"]
#[inline (always)] pub fn mcr_out2 (& mut self) -> MCR_OUT2_W < MCR_SPEC > { MCR_OUT2_W :: new (self , 3) }
#[doc = "Bit 3 - RW, UART interrupt output enable"]
#[inline (always)] pub fn mcr_int_oe (& mut self) -> MCR_INT_OE_W < MCR_SPEC > { MCR_INT_OE_W :: new (self , 3) }
#[doc = "Bit 4 - RW, UART0 enable local loop back"]
#[inline (always)] pub fn mcr_loop (& mut self) -> MCR_LOOP_W < MCR_SPEC > { MCR_LOOP_W :: new (self , 4) }
#[doc = "Bit 5 - RW, UART0 enable autoflow control"]
#[inline (always)] pub fn mcr_au_flow_en (& mut self) -> MCR_AU_FLOW_EN_W < MCR_SPEC > { MCR_AU_FLOW_EN_W :: new (self , 5) }
#[doc = "Bit 6 - RW, UART0 enable TNOW output on DTR pin"]
#[inline (always)] pub fn mcr_tnow (& mut self) -> MCR_TNOW_W < MCR_SPEC > { MCR_TNOW_W :: new (self , 6) }
#[doc = "Bit 7 - RW, UART0 enable half-duplex"]
#[inline (always)] pub fn mcr_half (& mut self) -> MCR_HALF_W < MCR_SPEC > { MCR_HALF_W :: new (self , 7) } }
#[doc = "RW, UART0 modem control\n\nYou can [`read`](crate::Reg::read) this register and get [`mcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MCR_SPEC ; impl crate :: RegisterSpec for MCR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`mcr::R`](R) reader structure"] impl crate :: Readable for MCR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`mcr::W`](W) writer structure"] impl crate :: Writable for MCR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MCR to value 0"] impl crate :: Resettable for MCR_SPEC { } }
#[doc = "IER (rw) register accessor: RW, UART0 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ier`] module"] pub type IER = crate :: Reg < ier :: IER_SPEC > ;
#[doc = "RW, UART0 interrupt enable"] pub mod ier {
#[doc = "Register `IER` reader"] pub type R = crate :: R < IER_SPEC > ;
#[doc = "Register `IER` writer"] pub type W = crate :: W < IER_SPEC > ;
#[doc = "Field `IER_RECV_RDY` reader - RW, UART interrupt enable for receiver data ready"] pub type IER_RECV_RDY_R = crate :: BitReader ;
#[doc = "Field `IER_RECV_RDY` writer - RW, UART interrupt enable for receiver data ready"] pub type IER_RECV_RDY_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IER_THR_EMPTY` reader - RW, UART interrupt enable for THR empty"] pub type IER_THR_EMPTY_R = crate :: BitReader ;
#[doc = "Field `IER_THR_EMPTY` writer - RW, UART interrupt enable for THR empty"] pub type IER_THR_EMPTY_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IER_LINE_STAT` reader - RW, UART interrupt enable for receiver line status"] pub type IER_LINE_STAT_R = crate :: BitReader ;
#[doc = "Field `IER_LINE_STAT` writer - RW, UART interrupt enable for receiver line status"] pub type IER_LINE_STAT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IER_MODEM_CHG` reader - RW, UART0 interrupt enable for modem status change"] pub type IER_MODEM_CHG_R = crate :: BitReader ;
#[doc = "Field `IER_MODEM_CHG` writer - RW, UART0 interrupt enable for modem status change"] pub type IER_MODEM_CHG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IER_DTR_EN` reader - RW, UART0 DTR/TNOW output pin enable"] pub type IER_DTR_EN_R = crate :: BitReader ;
#[doc = "Field `IER_DTR_EN` writer - RW, UART0 DTR/TNOW output pin enable"] pub type IER_DTR_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IER_RTS_EN` reader - RW, UART0 RTS output pin enable"] pub type IER_RTS_EN_R = crate :: BitReader ;
#[doc = "Field `IER_RTS_EN` writer - RW, UART0 RTS output pin enable"] pub type IER_RTS_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IER_TXD_EN` reader - RW, UART TXD pin enable"] pub type IER_TXD_EN_R = crate :: BitReader ;
#[doc = "Field `IER_TXD_EN` writer - RW, UART TXD pin enable"] pub type IER_TXD_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IER_RESET` reader - WZ, UART software reset control, high action, auto clear"] pub type IER_RESET_R = crate :: BitReader ;
#[doc = "Field `IER_RESET` writer - WZ, UART software reset control, high action, auto clear"] pub type IER_RESET_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, UART interrupt enable for receiver data ready"]
#[inline (always)] pub fn ier_recv_rdy (& self) -> IER_RECV_RDY_R { IER_RECV_RDY_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, UART interrupt enable for THR empty"]
#[inline (always)] pub fn ier_thr_empty (& self) -> IER_THR_EMPTY_R { IER_THR_EMPTY_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW, UART interrupt enable for receiver line status"]
#[inline (always)] pub fn ier_line_stat (& self) -> IER_LINE_STAT_R { IER_LINE_STAT_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, UART0 interrupt enable for modem status change"]
#[inline (always)] pub fn ier_modem_chg (& self) -> IER_MODEM_CHG_R { IER_MODEM_CHG_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW, UART0 DTR/TNOW output pin enable"]
#[inline (always)] pub fn ier_dtr_en (& self) -> IER_DTR_EN_R { IER_DTR_EN_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RW, UART0 RTS output pin enable"]
#[inline (always)] pub fn ier_rts_en (& self) -> IER_RTS_EN_R { IER_RTS_EN_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RW, UART TXD pin enable"]
#[inline (always)] pub fn ier_txd_en (& self) -> IER_TXD_EN_R { IER_TXD_EN_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - WZ, UART software reset control, high action, auto clear"]
#[inline (always)] pub fn ier_reset (& self) -> IER_RESET_R { IER_RESET_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, UART interrupt enable for receiver data ready"]
#[inline (always)] pub fn ier_recv_rdy (& mut self) -> IER_RECV_RDY_W < IER_SPEC > { IER_RECV_RDY_W :: new (self , 0) }
#[doc = "Bit 1 - RW, UART interrupt enable for THR empty"]
#[inline (always)] pub fn ier_thr_empty (& mut self) -> IER_THR_EMPTY_W < IER_SPEC > { IER_THR_EMPTY_W :: new (self , 1) }
#[doc = "Bit 2 - RW, UART interrupt enable for receiver line status"]
#[inline (always)] pub fn ier_line_stat (& mut self) -> IER_LINE_STAT_W < IER_SPEC > { IER_LINE_STAT_W :: new (self , 2) }
#[doc = "Bit 3 - RW, UART0 interrupt enable for modem status change"]
#[inline (always)] pub fn ier_modem_chg (& mut self) -> IER_MODEM_CHG_W < IER_SPEC > { IER_MODEM_CHG_W :: new (self , 3) }
#[doc = "Bit 4 - RW, UART0 DTR/TNOW output pin enable"]
#[inline (always)] pub fn ier_dtr_en (& mut self) -> IER_DTR_EN_W < IER_SPEC > { IER_DTR_EN_W :: new (self , 4) }
#[doc = "Bit 5 - RW, UART0 RTS output pin enable"]
#[inline (always)] pub fn ier_rts_en (& mut self) -> IER_RTS_EN_W < IER_SPEC > { IER_RTS_EN_W :: new (self , 5) }
#[doc = "Bit 6 - RW, UART TXD pin enable"]
#[inline (always)] pub fn ier_txd_en (& mut self) -> IER_TXD_EN_W < IER_SPEC > { IER_TXD_EN_W :: new (self , 6) }
#[doc = "Bit 7 - WZ, UART software reset control, high action, auto clear"]
#[inline (always)] pub fn ier_reset (& mut self) -> IER_RESET_W < IER_SPEC > { IER_RESET_W :: new (self , 7) } }
#[doc = "RW, UART0 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IER_SPEC ; impl crate :: RegisterSpec for IER_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`ier::R`](R) reader structure"] impl crate :: Readable for IER_SPEC { }
#[doc = "`write(|w| ..)` method takes [`ier::W`](W) writer structure"] impl crate :: Writable for IER_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IER to value 0"] impl crate :: Resettable for IER_SPEC { } }
#[doc = "FCR (rw) register accessor: RW, UART0 FIFO control\n\nYou can [`read`](crate::Reg::read) this register and get [`fcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fcr`] module"] pub type FCR = crate :: Reg < fcr :: FCR_SPEC > ;
#[doc = "RW, UART0 FIFO control"] pub mod fcr {
#[doc = "Register `FCR` reader"] pub type R = crate :: R < FCR_SPEC > ;
#[doc = "Register `FCR` writer"] pub type W = crate :: W < FCR_SPEC > ;
#[doc = "Field `FCR_FIFO_EN` reader - RW, UART FIFO enable"] pub type FCR_FIFO_EN_R = crate :: BitReader ;
#[doc = "Field `FCR_FIFO_EN` writer - RW, UART FIFO enable"] pub type FCR_FIFO_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FCR_RX_FIFO_CLR` reader - WZ, clear UART receiver FIFO, high action, auto clear"] pub type FCR_RX_FIFO_CLR_R = crate :: BitReader ;
#[doc = "Field `FCR_RX_FIFO_CLR` writer - WZ, clear UART receiver FIFO, high action, auto clear"] pub type FCR_RX_FIFO_CLR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FCR_TX_FIFO_CLR` reader - WZ, clear UART transmitter FIFO, high action, auto clear"] pub type FCR_TX_FIFO_CLR_R = crate :: BitReader ;
#[doc = "Field `FCR_TX_FIFO_CLR` writer - WZ, clear UART transmitter FIFO, high action, auto clear"] pub type FCR_TX_FIFO_CLR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FCR_FIFO_TRIG` reader - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"] pub type FCR_FIFO_TRIG_R = crate :: FieldReader ;
#[doc = "Field `FCR_FIFO_TRIG` writer - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"] pub type FCR_FIFO_TRIG_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bit 0 - RW, UART FIFO enable"]
#[inline (always)] pub fn fcr_fifo_en (& self) -> FCR_FIFO_EN_R { FCR_FIFO_EN_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear"]
#[inline (always)] pub fn fcr_rx_fifo_clr (& self) -> FCR_RX_FIFO_CLR_R { FCR_RX_FIFO_CLR_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear"]
#[inline (always)] pub fn fcr_tx_fifo_clr (& self) -> FCR_TX_FIFO_CLR_R { FCR_TX_FIFO_CLR_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"]
#[inline (always)] pub fn fcr_fifo_trig (& self) -> FCR_FIFO_TRIG_R { FCR_FIFO_TRIG_R :: new ((self . bits >> 6) & 3) } } impl W {
#[doc = "Bit 0 - RW, UART FIFO enable"]
#[inline (always)] pub fn fcr_fifo_en (& mut self) -> FCR_FIFO_EN_W < FCR_SPEC > { FCR_FIFO_EN_W :: new (self , 0) }
#[doc = "Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear"]
#[inline (always)] pub fn fcr_rx_fifo_clr (& mut self) -> FCR_RX_FIFO_CLR_W < FCR_SPEC > { FCR_RX_FIFO_CLR_W :: new (self , 1) }
#[doc = "Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear"]
#[inline (always)] pub fn fcr_tx_fifo_clr (& mut self) -> FCR_TX_FIFO_CLR_W < FCR_SPEC > { FCR_TX_FIFO_CLR_W :: new (self , 2) }
#[doc = "Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"]
#[inline (always)] pub fn fcr_fifo_trig (& mut self) -> FCR_FIFO_TRIG_W < FCR_SPEC > { FCR_FIFO_TRIG_W :: new (self , 6) } }
#[doc = "RW, UART0 FIFO control\n\nYou can [`read`](crate::Reg::read) this register and get [`fcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FCR_SPEC ; impl crate :: RegisterSpec for FCR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`fcr::R`](R) reader structure"] impl crate :: Readable for FCR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`fcr::W`](W) writer structure"] impl crate :: Writable for FCR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FCR to value 0"] impl crate :: Resettable for FCR_SPEC { } }
#[doc = "LCR (rw) register accessor: RW, UART0 line control\n\nYou can [`read`](crate::Reg::read) this register and get [`lcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lcr`] module"] pub type LCR = crate :: Reg < lcr :: LCR_SPEC > ;
#[doc = "RW, UART0 line control"] pub mod lcr {
#[doc = "Register `LCR` reader"] pub type R = crate :: R < LCR_SPEC > ;
#[doc = "Register `LCR` writer"] pub type W = crate :: W < LCR_SPEC > ;
#[doc = "Field `LCR_WORD_SZ` reader - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"] pub type LCR_WORD_SZ_R = crate :: FieldReader ;
#[doc = "Field `LCR_WORD_SZ` writer - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"] pub type LCR_WORD_SZ_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `LCR_STOP_BIT` reader - RW, UART stop bit length: 0-1bit, 1-2bit"] pub type LCR_STOP_BIT_R = crate :: BitReader ;
#[doc = "Field `LCR_STOP_BIT` writer - RW, UART stop bit length: 0-1bit, 1-2bit"] pub type LCR_STOP_BIT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCR_PAR_EN` reader - RW, UART parity enable"] pub type LCR_PAR_EN_R = crate :: BitReader ;
#[doc = "Field `LCR_PAR_EN` writer - RW, UART parity enable"] pub type LCR_PAR_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCR_PAR_MOD` reader - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"] pub type LCR_PAR_MOD_R = crate :: FieldReader ;
#[doc = "Field `LCR_PAR_MOD` writer - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"] pub type LCR_PAR_MOD_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `LCR_BREAK_EN` reader - RW, UART break control enable"] pub type LCR_BREAK_EN_R = crate :: BitReader ;
#[doc = "Field `LCR_BREAK_EN` writer - RW, UART break control enable"] pub type LCR_BREAK_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCR_GP_BIT` reader - RW, UART general purpose bit"] pub type LCR_GP_BIT_R = crate :: BitReader ;
#[doc = "Field `LCR_GP_BIT` writer - RW, UART general purpose bit"] pub type LCR_GP_BIT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCR_DLAB` reader - RW, UART reserved bit"] pub type LCR_DLAB_R = crate :: BitReader ;
#[doc = "Field `LCR_DLAB` writer - RW, UART reserved bit"] pub type LCR_DLAB_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"]
#[inline (always)] pub fn lcr_word_sz (& self) -> LCR_WORD_SZ_R { LCR_WORD_SZ_R :: new (self . bits & 3) }
#[doc = "Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit"]
#[inline (always)] pub fn lcr_stop_bit (& self) -> LCR_STOP_BIT_R { LCR_STOP_BIT_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, UART parity enable"]
#[inline (always)] pub fn lcr_par_en (& self) -> LCR_PAR_EN_R { LCR_PAR_EN_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"]
#[inline (always)] pub fn lcr_par_mod (& self) -> LCR_PAR_MOD_R { LCR_PAR_MOD_R :: new ((self . bits >> 4) & 3) }
#[doc = "Bit 6 - RW, UART break control enable"]
#[inline (always)] pub fn lcr_break_en (& self) -> LCR_BREAK_EN_R { LCR_BREAK_EN_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RW, UART general purpose bit"]
#[inline (always)] pub fn lcr_gp_bit (& self) -> LCR_GP_BIT_R { LCR_GP_BIT_R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 7 - RW, UART reserved bit"]
#[inline (always)] pub fn lcr_dlab (& self) -> LCR_DLAB_R { LCR_DLAB_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"]
#[inline (always)] pub fn lcr_word_sz (& mut self) -> LCR_WORD_SZ_W < LCR_SPEC > { LCR_WORD_SZ_W :: new (self , 0) }
#[doc = "Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit"]
#[inline (always)] pub fn lcr_stop_bit (& mut self) -> LCR_STOP_BIT_W < LCR_SPEC > { LCR_STOP_BIT_W :: new (self , 2) }
#[doc = "Bit 3 - RW, UART parity enable"]
#[inline (always)] pub fn lcr_par_en (& mut self) -> LCR_PAR_EN_W < LCR_SPEC > { LCR_PAR_EN_W :: new (self , 3) }
#[doc = "Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"]
#[inline (always)] pub fn lcr_par_mod (& mut self) -> LCR_PAR_MOD_W < LCR_SPEC > { LCR_PAR_MOD_W :: new (self , 4) }
#[doc = "Bit 6 - RW, UART break control enable"]
#[inline (always)] pub fn lcr_break_en (& mut self) -> LCR_BREAK_EN_W < LCR_SPEC > { LCR_BREAK_EN_W :: new (self , 6) }
#[doc = "Bit 7 - RW, UART general purpose bit"]
#[inline (always)] pub fn lcr_gp_bit (& mut self) -> LCR_GP_BIT_W < LCR_SPEC > { LCR_GP_BIT_W :: new (self , 7) }
#[doc = "Bit 7 - RW, UART reserved bit"]
#[inline (always)] pub fn lcr_dlab (& mut self) -> LCR_DLAB_W < LCR_SPEC > { LCR_DLAB_W :: new (self , 7) } }
#[doc = "RW, UART0 line control\n\nYou can [`read`](crate::Reg::read) this register and get [`lcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct LCR_SPEC ; impl crate :: RegisterSpec for LCR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`lcr::R`](R) reader structure"] impl crate :: Readable for LCR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`lcr::W`](W) writer structure"] impl crate :: Writable for LCR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets LCR to value 0"] impl crate :: Resettable for LCR_SPEC { } }
#[doc = "IIR (r) register accessor: RO, UART0 interrupt identification\n\nYou can [`read`](crate::Reg::read) this register and get [`iir::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iir`] module"] pub type IIR = crate :: Reg < iir :: IIR_SPEC > ;
#[doc = "RO, UART0 interrupt identification"] pub mod iir {
#[doc = "Register `IIR` reader"] pub type R = crate :: R < IIR_SPEC > ;
#[doc = "Field `IIR_NO_INT` reader - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt"] pub type IIR_NO_INT_R = crate :: BitReader ;
#[doc = "Field `IIR_INT_MASK` reader - RO, UART interrupt flag bit mask"] pub type IIR_INT_MASK_R = crate :: FieldReader ;
#[doc = "Field `IIR_FIFO_ID` reader - RO, UART FIFO enabled flag"] pub type IIR_FIFO_ID_R = crate :: FieldReader ; impl R {
#[doc = "Bit 0 - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt"]
#[inline (always)] pub fn iir_no_int (& self) -> IIR_NO_INT_R { IIR_NO_INT_R :: new ((self . bits & 1) != 0) }
#[doc = "Bits 0:3 - RO, UART interrupt flag bit mask"]
#[inline (always)] pub fn iir_int_mask (& self) -> IIR_INT_MASK_R { IIR_INT_MASK_R :: new (self . bits & 0x0f) }
#[doc = "Bits 6:7 - RO, UART FIFO enabled flag"]
#[inline (always)] pub fn iir_fifo_id (& self) -> IIR_FIFO_ID_R { IIR_FIFO_ID_R :: new ((self . bits >> 6) & 3) } }
#[doc = "RO, UART0 interrupt identification\n\nYou can [`read`](crate::Reg::read) this register and get [`iir::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IIR_SPEC ; impl crate :: RegisterSpec for IIR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`iir::R`](R) reader structure"] impl crate :: Readable for IIR_SPEC { }
#[doc = "`reset()` method sets IIR to value 0x01"] impl crate :: Resettable for IIR_SPEC { const RESET_VALUE : u8 = 0x01 ; } }
#[doc = "LSR (r) register accessor: RO, UART0 line status\n\nYou can [`read`](crate::Reg::read) this register and get [`lsr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lsr`] module"] pub type LSR = crate :: Reg < lsr :: LSR_SPEC > ;
#[doc = "RO, UART0 line status"] pub mod lsr {
#[doc = "Register `LSR` reader"] pub type R = crate :: R < LSR_SPEC > ;
#[doc = "Field `LSR_DATA_RDY` reader - RO, UART receiver fifo data ready status"] pub type LSR_DATA_RDY_R = crate :: BitReader ;
#[doc = "Field `LSR_OVER_ERR` reader - RZ, UART receiver overrun error"] pub type LSR_OVER_ERR_R = crate :: BitReader ;
#[doc = "Field `LSR_PAR_ERR` reader - RZ, UART receiver parity error"] pub type LSR_PAR_ERR_R = crate :: BitReader ;
#[doc = "Field `LSR_FRAME_ERR` reader - RZ, UART receiver frame error"] pub type LSR_FRAME_ERR_R = crate :: BitReader ;
#[doc = "Field `LSR_BREAK_ERR` reader - RZ, UART receiver break error"] pub type LSR_BREAK_ERR_R = crate :: BitReader ;
#[doc = "Field `LSR_TX_FIFO_EMP` reader - RO, UART transmitter fifo empty status"] pub type LSR_TX_FIFO_EMP_R = crate :: BitReader ;
#[doc = "Field `LSR_TX_ALL_EMP` reader - RO, UART transmitter all empty status"] pub type LSR_TX_ALL_EMP_R = crate :: BitReader ;
#[doc = "Field `LSR_ERR_RX_FIFO` reader - RO, indicate error in UART receiver fifo"] pub type LSR_ERR_RX_FIFO_R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - RO, UART receiver fifo data ready status"]
#[inline (always)] pub fn lsr_data_rdy (& self) -> LSR_DATA_RDY_R { LSR_DATA_RDY_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RZ, UART receiver overrun error"]
#[inline (always)] pub fn lsr_over_err (& self) -> LSR_OVER_ERR_R { LSR_OVER_ERR_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RZ, UART receiver parity error"]
#[inline (always)] pub fn lsr_par_err (& self) -> LSR_PAR_ERR_R { LSR_PAR_ERR_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RZ, UART receiver frame error"]
#[inline (always)] pub fn lsr_frame_err (& self) -> LSR_FRAME_ERR_R { LSR_FRAME_ERR_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RZ, UART receiver break error"]
#[inline (always)] pub fn lsr_break_err (& self) -> LSR_BREAK_ERR_R { LSR_BREAK_ERR_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RO, UART transmitter fifo empty status"]
#[inline (always)] pub fn lsr_tx_fifo_emp (& self) -> LSR_TX_FIFO_EMP_R { LSR_TX_FIFO_EMP_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RO, UART transmitter all empty status"]
#[inline (always)] pub fn lsr_tx_all_emp (& self) -> LSR_TX_ALL_EMP_R { LSR_TX_ALL_EMP_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RO, indicate error in UART receiver fifo"]
#[inline (always)] pub fn lsr_err_rx_fifo (& self) -> LSR_ERR_RX_FIFO_R { LSR_ERR_RX_FIFO_R :: new (((self . bits >> 7) & 1) != 0) } }
#[doc = "RO, UART0 line status\n\nYou can [`read`](crate::Reg::read) this register and get [`lsr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct LSR_SPEC ; impl crate :: RegisterSpec for LSR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`lsr::R`](R) reader structure"] impl crate :: Readable for LSR_SPEC { }
#[doc = "`reset()` method sets LSR to value 0x60"] impl crate :: Resettable for LSR_SPEC { const RESET_VALUE : u8 = 0x60 ; } }
#[doc = "MSR (r) register accessor: RO, UART0 modem status\n\nYou can [`read`](crate::Reg::read) this register and get [`msr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@msr`] module"] pub type MSR = crate :: Reg < msr :: MSR_SPEC > ;
#[doc = "RO, UART0 modem status"] pub mod msr {
#[doc = "Register `MSR` reader"] pub type R = crate :: R < MSR_SPEC > ;
#[doc = "Field `MSR_CTS_CHG` reader - RZ, UART0 CTS changed status, high action"] pub type MSR_CTS_CHG_R = crate :: BitReader ;
#[doc = "Field `MSR_DSR_CHG` reader - RZ, UART0 DSR changed status, high action"] pub type MSR_DSR_CHG_R = crate :: BitReader ;
#[doc = "Field `MSR_RI_CHG` reader - RZ, UART0 RI changed status, high action"] pub type MSR_RI_CHG_R = crate :: BitReader ;
#[doc = "Field `MSR_DCD_CHG` reader - RZ, UART0 DCD changed status, high action"] pub type MSR_DCD_CHG_R = crate :: BitReader ;
#[doc = "Field `MSR_CTS` reader - RO, UART0 CTS action status"] pub type MSR_CTS_R = crate :: BitReader ;
#[doc = "Field `MSR_DSR` reader - RO, UART0 DSR action statusv"] pub type MSR_DSR_R = crate :: BitReader ;
#[doc = "Field `MSR_RI` reader - RO, UART0 RI action status"] pub type MSR_RI_R = crate :: BitReader ;
#[doc = "Field `MSR_DCD` reader - RO, UART0 DCD action status"] pub type MSR_DCD_R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - RZ, UART0 CTS changed status, high action"]
#[inline (always)] pub fn msr_cts_chg (& self) -> MSR_CTS_CHG_R { MSR_CTS_CHG_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RZ, UART0 DSR changed status, high action"]
#[inline (always)] pub fn msr_dsr_chg (& self) -> MSR_DSR_CHG_R { MSR_DSR_CHG_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RZ, UART0 RI changed status, high action"]
#[inline (always)] pub fn msr_ri_chg (& self) -> MSR_RI_CHG_R { MSR_RI_CHG_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RZ, UART0 DCD changed status, high action"]
#[inline (always)] pub fn msr_dcd_chg (& self) -> MSR_DCD_CHG_R { MSR_DCD_CHG_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RO, UART0 CTS action status"]
#[inline (always)] pub fn msr_cts (& self) -> MSR_CTS_R { MSR_CTS_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RO, UART0 DSR action statusv"]
#[inline (always)] pub fn msr_dsr (& self) -> MSR_DSR_R { MSR_DSR_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RO, UART0 RI action status"]
#[inline (always)] pub fn msr_ri (& self) -> MSR_RI_R { MSR_RI_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RO, UART0 DCD action status"]
#[inline (always)] pub fn msr_dcd (& self) -> MSR_DCD_R { MSR_DCD_R :: new (((self . bits >> 7) & 1) != 0) } }
#[doc = "RO, UART0 modem status\n\nYou can [`read`](crate::Reg::read) this register and get [`msr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MSR_SPEC ; impl crate :: RegisterSpec for MSR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`msr::R`](R) reader structure"] impl crate :: Readable for MSR_SPEC { }
#[doc = "`reset()` method sets MSR to value 0"] impl crate :: Resettable for MSR_SPEC { } }
#[doc = "RBR (r) register accessor: RO, UART0 receiver buffer, receiving byte\n\nYou can [`read`](crate::Reg::read) this register and get [`rbr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rbr`] module"] pub type RBR = crate :: Reg < rbr :: RBR_SPEC > ;
#[doc = "RO, UART0 receiver buffer, receiving byte"] pub mod rbr {
#[doc = "Register `RBR` reader"] pub type R = crate :: R < RBR_SPEC > ;
#[doc = "Field `RBR` reader - RO, UART0 receiver buffer, receiving byte"] pub type RBR_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RO, UART0 receiver buffer, receiving byte"]
#[inline (always)] pub fn rbr (& self) -> RBR_R { RBR_R :: new (self . bits) } }
#[doc = "RO, UART0 receiver buffer, receiving byte\n\nYou can [`read`](crate::Reg::read) this register and get [`rbr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RBR_SPEC ; impl crate :: RegisterSpec for RBR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`rbr::R`](R) reader structure"] impl crate :: Readable for RBR_SPEC { }
#[doc = "`reset()` method sets RBR to value 0"] impl crate :: Resettable for RBR_SPEC { } }
#[doc = "THR (w) register accessor: WO, UART0 transmitter holding, transmittal byte\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`thr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@thr`] module"] pub type THR = crate :: Reg < thr :: THR_SPEC > ;
#[doc = "WO, UART0 transmitter holding, transmittal byte"] pub mod thr {
#[doc = "Register `THR` writer"] pub type W = crate :: W < THR_SPEC > ;
#[doc = "Field `THR` writer - RO, UART0 transmitter holding, transmittal byte"] pub type THR_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl W {
#[doc = "Bits 0:7 - RO, UART0 transmitter holding, transmittal byte"]
#[inline (always)] pub fn thr (& mut self) -> THR_W < THR_SPEC > { THR_W :: new (self , 0) } }
#[doc = "WO, UART0 transmitter holding, transmittal byte\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`thr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct THR_SPEC ; impl crate :: RegisterSpec for THR_SPEC { type Ux = u8 ; }
#[doc = "`write(|w| ..)` method takes [`thr::W`](W) writer structure"] impl crate :: Writable for THR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets THR to value 0"] impl crate :: Resettable for THR_SPEC { } }
#[doc = "RFC (r) register accessor: RO, UART0 receiver FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`rfc::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rfc`] module"] pub type RFC = crate :: Reg < rfc :: RFC_SPEC > ;
#[doc = "RO, UART0 receiver FIFO count"] pub mod rfc {
#[doc = "Register `RFC` reader"] pub type R = crate :: R < RFC_SPEC > ;
#[doc = "Field `RFC` reader - RO, UART0 receiver FIFO count"] pub type RFC_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RO, UART0 receiver FIFO count"]
#[inline (always)] pub fn rfc (& self) -> RFC_R { RFC_R :: new (self . bits) } }
#[doc = "RO, UART0 receiver FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`rfc::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RFC_SPEC ; impl crate :: RegisterSpec for RFC_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`rfc::R`](R) reader structure"] impl crate :: Readable for RFC_SPEC { }
#[doc = "`reset()` method sets RFC to value 0"] impl crate :: Resettable for RFC_SPEC { } }
#[doc = "TFC (r) register accessor: RO, UART0 transmitter FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`tfc::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tfc`] module"] pub type TFC = crate :: Reg < tfc :: TFC_SPEC > ;
#[doc = "RO, UART0 transmitter FIFO count"] pub mod tfc {
#[doc = "Register `TFC` reader"] pub type R = crate :: R < TFC_SPEC > ;
#[doc = "Field `TFC` reader - RO, UART0 transmitter FIFO count"] pub type TFC_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RO, UART0 transmitter FIFO count"]
#[inline (always)] pub fn tfc (& self) -> TFC_R { TFC_R :: new (self . bits) } }
#[doc = "RO, UART0 transmitter FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`tfc::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TFC_SPEC ; impl crate :: RegisterSpec for TFC_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`tfc::R`](R) reader structure"] impl crate :: Readable for TFC_SPEC { }
#[doc = "`reset()` method sets TFC to value 0"] impl crate :: Resettable for TFC_SPEC { } }
#[doc = "DL (rw) register accessor: RW, UART0 divisor latch\n\nYou can [`read`](crate::Reg::read) this register and get [`dl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dl`] module"] pub type DL = crate :: Reg < dl :: DL_SPEC > ;
#[doc = "RW, UART0 divisor latch"] pub mod dl {
#[doc = "Register `DL` reader"] pub type R = crate :: R < DL_SPEC > ;
#[doc = "Register `DL` writer"] pub type W = crate :: W < DL_SPEC > ;
#[doc = "Field `DL` reader - RW, UART0 divisor latch"] pub type DL_R = crate :: FieldReader < u16 > ;
#[doc = "Field `DL` writer - RW, UART0 divisor latch"] pub type DL_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW, UART0 divisor latch"]
#[inline (always)] pub fn dl (& self) -> DL_R { DL_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW, UART0 divisor latch"]
#[inline (always)] pub fn dl (& mut self) -> DL_W < DL_SPEC > { DL_W :: new (self , 0) } }
#[doc = "RW, UART0 divisor latch\n\nYou can [`read`](crate::Reg::read) this register and get [`dl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DL_SPEC ; impl crate :: RegisterSpec for DL_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`dl::R`](R) reader structure"] impl crate :: Readable for DL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`dl::W`](W) writer structure"] impl crate :: Writable for DL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DL to value 0"] impl crate :: Resettable for DL_SPEC { } }
#[doc = "DIV (rw) register accessor: RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128\n\nYou can [`read`](crate::Reg::read) this register and get [`div::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@div`] module"] pub type DIV = crate :: Reg < div :: DIV_SPEC > ;
#[doc = "RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128"] pub mod div {
#[doc = "Register `DIV` reader"] pub type R = crate :: R < DIV_SPEC > ;
#[doc = "Register `DIV` writer"] pub type W = crate :: W < DIV_SPEC > ;
#[doc = "Field `DIV` reader - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128"] pub type DIV_R = crate :: FieldReader ;
#[doc = "Field `DIV` writer - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128"] pub type DIV_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128"]
#[inline (always)] pub fn div (& self) -> DIV_R { DIV_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RW,UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128"]
#[inline (always)] pub fn div (& mut self) -> DIV_W < DIV_SPEC > { DIV_W :: new (self , 0) } }
#[doc = "RW, UART0 pre-divisor latch byte, only low 7 bit, from 1 to 0/128\n\nYou can [`read`](crate::Reg::read) this register and get [`div::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DIV_SPEC ; impl crate :: RegisterSpec for DIV_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`div::R`](R) reader structure"] impl crate :: Readable for DIV_SPEC { }
#[doc = "`write(|w| ..)` method takes [`div::W`](W) writer structure"] impl crate :: Writable for DIV_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIV to value 0"] impl crate :: Resettable for DIV_SPEC { } }
#[doc = "ADR (rw) register accessor: RW, UART0 slave address: 0xFF=disable, other=enable\n\nYou can [`read`](crate::Reg::read) this register and get [`adr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@adr`] module"] pub type ADR = crate :: Reg < adr :: ADR_SPEC > ;
#[doc = "RW, UART0 slave address: 0xFF=disable, other=enable"] pub mod adr {
#[doc = "Register `ADR` reader"] pub type R = crate :: R < ADR_SPEC > ;
#[doc = "Register `ADR` writer"] pub type W = crate :: W < ADR_SPEC > ;
#[doc = "Field `ADR` reader - RW,UART0 slave address: 0xFF=disable, other=enable"] pub type ADR_R = crate :: FieldReader ;
#[doc = "Field `ADR` writer - RW,UART0 slave address: 0xFF=disable, other=enable"] pub type ADR_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW,UART0 slave address: 0xFF=disable, other=enable"]
#[inline (always)] pub fn adr (& self) -> ADR_R { ADR_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RW,UART0 slave address: 0xFF=disable, other=enable"]
#[inline (always)] pub fn adr (& mut self) -> ADR_W < ADR_SPEC > { ADR_W :: new (self , 0) } }
#[doc = "RW, UART0 slave address: 0xFF=disable, other=enable\n\nYou can [`read`](crate::Reg::read) this register and get [`adr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ADR_SPEC ; impl crate :: RegisterSpec for ADR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`adr::R`](R) reader structure"] impl crate :: Readable for ADR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`adr::W`](W) writer structure"] impl crate :: Writable for ADR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ADR to value 0xff"] impl crate :: Resettable for ADR_SPEC { const RESET_VALUE : u8 = 0xff ; } } }
#[doc = "UART1 register"] pub type UART1 = crate :: Periph < uart1 :: RegisterBlock , 0x4000_3400 > ; impl core :: fmt :: Debug for UART1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("UART1") . finish () } }
#[doc = "UART1 register"] pub mod uart1 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { mcr : MCR , ier : IER , fcr : FCR , lcr : LCR , iir : IIR , lsr : LSR , _reserved6 : [u8 ; 0x02] , _reserved_6_rbr : [u8 ; 0x01] , _reserved7 : [u8 ; 0x01] , rfc : RFC , tfc : TFC , dl : DL , div : DIV , } impl RegisterBlock {
#[doc = "0x00 - RW, UART1 modem control"]
#[inline (always)] pub const fn mcr (& self) -> & MCR { & self . mcr }
#[doc = "0x01 - RW, UART1 interrupt enable"]
#[inline (always)] pub const fn ier (& self) -> & IER { & self . ier }
#[doc = "0x02 - RW, UART1 FIFO control"]
#[inline (always)] pub const fn fcr (& self) -> & FCR { & self . fcr }
#[doc = "0x03 - RW, UART1 line control"]
#[inline (always)] pub const fn lcr (& self) -> & LCR { & self . lcr }
#[doc = "0x04 - RO, UART1 interrupt identification"]
#[inline (always)] pub const fn iir (& self) -> & IIR { & self . iir }
#[doc = "0x05 - RO, UART1 line status"]
#[inline (always)] pub const fn lsr (& self) -> & LSR { & self . lsr }
#[doc = "0x08 - WO, UART1 transmitter holding, transmittal byte"]
#[inline (always)] pub const fn thr (& self) -> & THR { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (8) . cast () } }
#[doc = "0x08 - RO, UART1 receiver buffer, receiving byte"]
#[inline (always)] pub const fn rbr (& self) -> & RBR { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (8) . cast () } }
#[doc = "0x0a - RO, UART1 receiver FIFO count"]
#[inline (always)] pub const fn rfc (& self) -> & RFC { & self . rfc }
#[doc = "0x0b - RO, UART1 transmitter FIFO count"]
#[inline (always)] pub const fn tfc (& self) -> & TFC { & self . tfc }
#[doc = "0x0c - RW, UART1 divisor latch"]
#[inline (always)] pub const fn dl (& self) -> & DL { & self . dl }
#[doc = "0x0e - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
#[inline (always)] pub const fn div (& self) -> & DIV { & self . div } }
#[doc = "MCR (rw) register accessor: RW, UART1 modem control\n\nYou can [`read`](crate::Reg::read) this register and get [`mcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mcr`] module"] pub type MCR = crate :: Reg < mcr :: MCR_SPEC > ;
#[doc = "RW, UART1 modem control"] pub mod mcr {
#[doc = "Register `MCR` reader"] pub type R = crate :: R < MCR_SPEC > ;
#[doc = "Register `MCR` writer"] pub type W = crate :: W < MCR_SPEC > ;
#[doc = "Field `MCR_OUT2` reader - RW, UART control OUT2"] pub type MCR_OUT2_R = crate :: BitReader ;
#[doc = "Field `MCR_OUT2` writer - RW, UART control OUT2"] pub type MCR_OUT2_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MCR_INT_OE` reader - RW, UART interrupt output enable"] pub type MCR_INT_OE_R = crate :: BitReader ;
#[doc = "Field `MCR_INT_OE` writer - RW, UART interrupt output enable"] pub type MCR_INT_OE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 3 - RW, UART control OUT2"]
#[inline (always)] pub fn mcr_out2 (& self) -> MCR_OUT2_R { MCR_OUT2_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 3 - RW, UART interrupt output enable"]
#[inline (always)] pub fn mcr_int_oe (& self) -> MCR_INT_OE_R { MCR_INT_OE_R :: new (((self . bits >> 3) & 1) != 0) } } impl W {
#[doc = "Bit 3 - RW, UART control OUT2"]
#[inline (always)] pub fn mcr_out2 (& mut self) -> MCR_OUT2_W < MCR_SPEC > { MCR_OUT2_W :: new (self , 3) }
#[doc = "Bit 3 - RW, UART interrupt output enable"]
#[inline (always)] pub fn mcr_int_oe (& mut self) -> MCR_INT_OE_W < MCR_SPEC > { MCR_INT_OE_W :: new (self , 3) } }
#[doc = "RW, UART1 modem control\n\nYou can [`read`](crate::Reg::read) this register and get [`mcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MCR_SPEC ; impl crate :: RegisterSpec for MCR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`mcr::R`](R) reader structure"] impl crate :: Readable for MCR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`mcr::W`](W) writer structure"] impl crate :: Writable for MCR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MCR to value 0"] impl crate :: Resettable for MCR_SPEC { } }
#[doc = "IER (rw) register accessor: RW, UART1 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ier`] module"] pub type IER = crate :: Reg < ier :: IER_SPEC > ;
#[doc = "RW, UART1 interrupt enable"] pub mod ier {
#[doc = "Register `IER` reader"] pub type R = crate :: R < IER_SPEC > ;
#[doc = "Register `IER` writer"] pub type W = crate :: W < IER_SPEC > ;
#[doc = "Field `IER_RECV_RDY` reader - RW, UART interrupt enable for receiver data ready"] pub type IER_RECV_RDY_R = crate :: BitReader ;
#[doc = "Field `IER_RECV_RDY` writer - RW, UART interrupt enable for receiver data ready"] pub type IER_RECV_RDY_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IER_THR_EMPTY` reader - RW, UART interrupt enable for THR empty"] pub type IER_THR_EMPTY_R = crate :: BitReader ;
#[doc = "Field `IER_THR_EMPTY` writer - RW, UART interrupt enable for THR empty"] pub type IER_THR_EMPTY_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IER_LINE_STAT` reader - RW, UART interrupt enable for receiver line status"] pub type IER_LINE_STAT_R = crate :: BitReader ;
#[doc = "Field `IER_LINE_STAT` writer - RW, UART interrupt enable for receiver line status"] pub type IER_LINE_STAT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IER_TXD_EN` reader - RW, UART TXD pin enable"] pub type IER_TXD_EN_R = crate :: BitReader ;
#[doc = "Field `IER_TXD_EN` writer - RW, UART TXD pin enable"] pub type IER_TXD_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IER_RESET` reader - WZ, UART software reset control, high action, auto clear"] pub type IER_RESET_R = crate :: BitReader ;
#[doc = "Field `IER_RESET` writer - WZ, UART software reset control, high action, auto clear"] pub type IER_RESET_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, UART interrupt enable for receiver data ready"]
#[inline (always)] pub fn ier_recv_rdy (& self) -> IER_RECV_RDY_R { IER_RECV_RDY_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, UART interrupt enable for THR empty"]
#[inline (always)] pub fn ier_thr_empty (& self) -> IER_THR_EMPTY_R { IER_THR_EMPTY_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW, UART interrupt enable for receiver line status"]
#[inline (always)] pub fn ier_line_stat (& self) -> IER_LINE_STAT_R { IER_LINE_STAT_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 6 - RW, UART TXD pin enable"]
#[inline (always)] pub fn ier_txd_en (& self) -> IER_TXD_EN_R { IER_TXD_EN_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - WZ, UART software reset control, high action, auto clear"]
#[inline (always)] pub fn ier_reset (& self) -> IER_RESET_R { IER_RESET_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, UART interrupt enable for receiver data ready"]
#[inline (always)] pub fn ier_recv_rdy (& mut self) -> IER_RECV_RDY_W < IER_SPEC > { IER_RECV_RDY_W :: new (self , 0) }
#[doc = "Bit 1 - RW, UART interrupt enable for THR empty"]
#[inline (always)] pub fn ier_thr_empty (& mut self) -> IER_THR_EMPTY_W < IER_SPEC > { IER_THR_EMPTY_W :: new (self , 1) }
#[doc = "Bit 2 - RW, UART interrupt enable for receiver line status"]
#[inline (always)] pub fn ier_line_stat (& mut self) -> IER_LINE_STAT_W < IER_SPEC > { IER_LINE_STAT_W :: new (self , 2) }
#[doc = "Bit 6 - RW, UART TXD pin enable"]
#[inline (always)] pub fn ier_txd_en (& mut self) -> IER_TXD_EN_W < IER_SPEC > { IER_TXD_EN_W :: new (self , 6) }
#[doc = "Bit 7 - WZ, UART software reset control, high action, auto clear"]
#[inline (always)] pub fn ier_reset (& mut self) -> IER_RESET_W < IER_SPEC > { IER_RESET_W :: new (self , 7) } }
#[doc = "RW, UART1 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IER_SPEC ; impl crate :: RegisterSpec for IER_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`ier::R`](R) reader structure"] impl crate :: Readable for IER_SPEC { }
#[doc = "`write(|w| ..)` method takes [`ier::W`](W) writer structure"] impl crate :: Writable for IER_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IER to value 0"] impl crate :: Resettable for IER_SPEC { } }
#[doc = "FCR (rw) register accessor: RW, UART1 FIFO control\n\nYou can [`read`](crate::Reg::read) this register and get [`fcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fcr`] module"] pub type FCR = crate :: Reg < fcr :: FCR_SPEC > ;
#[doc = "RW, UART1 FIFO control"] pub mod fcr {
#[doc = "Register `FCR` reader"] pub type R = crate :: R < FCR_SPEC > ;
#[doc = "Register `FCR` writer"] pub type W = crate :: W < FCR_SPEC > ;
#[doc = "Field `FCR_FIFO_EN` reader - RW, UART FIFO enable"] pub type FCR_FIFO_EN_R = crate :: BitReader ;
#[doc = "Field `FCR_FIFO_EN` writer - RW, UART FIFO enable"] pub type FCR_FIFO_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FCR_RX_FIFO_CLR` reader - WZ, clear UART receiver FIFO, high action, auto clear"] pub type FCR_RX_FIFO_CLR_R = crate :: BitReader ;
#[doc = "Field `FCR_RX_FIFO_CLR` writer - WZ, clear UART receiver FIFO, high action, auto clear"] pub type FCR_RX_FIFO_CLR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FCR_TX_FIFO_CLR` reader - WZ, clear UART transmitter FIFO, high action, auto clear"] pub type FCR_TX_FIFO_CLR_R = crate :: BitReader ;
#[doc = "Field `FCR_TX_FIFO_CLR` writer - WZ, clear UART transmitter FIFO, high action, auto clear"] pub type FCR_TX_FIFO_CLR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FCR_FIFO_TRIG` reader - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"] pub type FCR_FIFO_TRIG_R = crate :: FieldReader ;
#[doc = "Field `FCR_FIFO_TRIG` writer - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"] pub type FCR_FIFO_TRIG_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bit 0 - RW, UART FIFO enable"]
#[inline (always)] pub fn fcr_fifo_en (& self) -> FCR_FIFO_EN_R { FCR_FIFO_EN_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear"]
#[inline (always)] pub fn fcr_rx_fifo_clr (& self) -> FCR_RX_FIFO_CLR_R { FCR_RX_FIFO_CLR_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear"]
#[inline (always)] pub fn fcr_tx_fifo_clr (& self) -> FCR_TX_FIFO_CLR_R { FCR_TX_FIFO_CLR_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"]
#[inline (always)] pub fn fcr_fifo_trig (& self) -> FCR_FIFO_TRIG_R { FCR_FIFO_TRIG_R :: new ((self . bits >> 6) & 3) } } impl W {
#[doc = "Bit 0 - RW, UART FIFO enable"]
#[inline (always)] pub fn fcr_fifo_en (& mut self) -> FCR_FIFO_EN_W < FCR_SPEC > { FCR_FIFO_EN_W :: new (self , 0) }
#[doc = "Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear"]
#[inline (always)] pub fn fcr_rx_fifo_clr (& mut self) -> FCR_RX_FIFO_CLR_W < FCR_SPEC > { FCR_RX_FIFO_CLR_W :: new (self , 1) }
#[doc = "Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear"]
#[inline (always)] pub fn fcr_tx_fifo_clr (& mut self) -> FCR_TX_FIFO_CLR_W < FCR_SPEC > { FCR_TX_FIFO_CLR_W :: new (self , 2) }
#[doc = "Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"]
#[inline (always)] pub fn fcr_fifo_trig (& mut self) -> FCR_FIFO_TRIG_W < FCR_SPEC > { FCR_FIFO_TRIG_W :: new (self , 6) } }
#[doc = "RW, UART1 FIFO control\n\nYou can [`read`](crate::Reg::read) this register and get [`fcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FCR_SPEC ; impl crate :: RegisterSpec for FCR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`fcr::R`](R) reader structure"] impl crate :: Readable for FCR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`fcr::W`](W) writer structure"] impl crate :: Writable for FCR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FCR to value 0"] impl crate :: Resettable for FCR_SPEC { } }
#[doc = "LCR (rw) register accessor: RW, UART1 line control\n\nYou can [`read`](crate::Reg::read) this register and get [`lcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lcr`] module"] pub type LCR = crate :: Reg < lcr :: LCR_SPEC > ;
#[doc = "RW, UART1 line control"] pub mod lcr {
#[doc = "Register `LCR` reader"] pub type R = crate :: R < LCR_SPEC > ;
#[doc = "Register `LCR` writer"] pub type W = crate :: W < LCR_SPEC > ;
#[doc = "Field `LCR_WORD_SZ` reader - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"] pub type LCR_WORD_SZ_R = crate :: FieldReader ;
#[doc = "Field `LCR_WORD_SZ` writer - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"] pub type LCR_WORD_SZ_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `LCR_STOP_BIT` reader - RW, UART stop bit length: 0-1bit, 1-2bit"] pub type LCR_STOP_BIT_R = crate :: BitReader ;
#[doc = "Field `LCR_STOP_BIT` writer - RW, UART stop bit length: 0-1bit, 1-2bit"] pub type LCR_STOP_BIT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCR_PAR_EN` reader - RW, UART parity enable"] pub type LCR_PAR_EN_R = crate :: BitReader ;
#[doc = "Field `LCR_PAR_EN` writer - RW, UART parity enable"] pub type LCR_PAR_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCR_PAR_MOD` reader - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"] pub type LCR_PAR_MOD_R = crate :: FieldReader ;
#[doc = "Field `LCR_PAR_MOD` writer - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"] pub type LCR_PAR_MOD_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `LCR_BREAK_EN` reader - RW, UART break control enable"] pub type LCR_BREAK_EN_R = crate :: BitReader ;
#[doc = "Field `LCR_BREAK_EN` writer - RW, UART break control enable"] pub type LCR_BREAK_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCR_GP_BIT` reader - RW, UART general purpose bit"] pub type LCR_GP_BIT_R = crate :: BitReader ;
#[doc = "Field `LCR_GP_BIT` writer - RW, UART general purpose bit"] pub type LCR_GP_BIT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCR_DLAB` reader - RW, UART reserved bit"] pub type LCR_DLAB_R = crate :: BitReader ;
#[doc = "Field `LCR_DLAB` writer - RW, UART reserved bit"] pub type LCR_DLAB_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"]
#[inline (always)] pub fn lcr_word_sz (& self) -> LCR_WORD_SZ_R { LCR_WORD_SZ_R :: new (self . bits & 3) }
#[doc = "Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit"]
#[inline (always)] pub fn lcr_stop_bit (& self) -> LCR_STOP_BIT_R { LCR_STOP_BIT_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, UART parity enable"]
#[inline (always)] pub fn lcr_par_en (& self) -> LCR_PAR_EN_R { LCR_PAR_EN_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"]
#[inline (always)] pub fn lcr_par_mod (& self) -> LCR_PAR_MOD_R { LCR_PAR_MOD_R :: new ((self . bits >> 4) & 3) }
#[doc = "Bit 6 - RW, UART break control enable"]
#[inline (always)] pub fn lcr_break_en (& self) -> LCR_BREAK_EN_R { LCR_BREAK_EN_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RW, UART general purpose bit"]
#[inline (always)] pub fn lcr_gp_bit (& self) -> LCR_GP_BIT_R { LCR_GP_BIT_R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 7 - RW, UART reserved bit"]
#[inline (always)] pub fn lcr_dlab (& self) -> LCR_DLAB_R { LCR_DLAB_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"]
#[inline (always)] pub fn lcr_word_sz (& mut self) -> LCR_WORD_SZ_W < LCR_SPEC > { LCR_WORD_SZ_W :: new (self , 0) }
#[doc = "Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit"]
#[inline (always)] pub fn lcr_stop_bit (& mut self) -> LCR_STOP_BIT_W < LCR_SPEC > { LCR_STOP_BIT_W :: new (self , 2) }
#[doc = "Bit 3 - RW, UART parity enable"]
#[inline (always)] pub fn lcr_par_en (& mut self) -> LCR_PAR_EN_W < LCR_SPEC > { LCR_PAR_EN_W :: new (self , 3) }
#[doc = "Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"]
#[inline (always)] pub fn lcr_par_mod (& mut self) -> LCR_PAR_MOD_W < LCR_SPEC > { LCR_PAR_MOD_W :: new (self , 4) }
#[doc = "Bit 6 - RW, UART break control enable"]
#[inline (always)] pub fn lcr_break_en (& mut self) -> LCR_BREAK_EN_W < LCR_SPEC > { LCR_BREAK_EN_W :: new (self , 6) }
#[doc = "Bit 7 - RW, UART general purpose bit"]
#[inline (always)] pub fn lcr_gp_bit (& mut self) -> LCR_GP_BIT_W < LCR_SPEC > { LCR_GP_BIT_W :: new (self , 7) }
#[doc = "Bit 7 - RW, UART reserved bit"]
#[inline (always)] pub fn lcr_dlab (& mut self) -> LCR_DLAB_W < LCR_SPEC > { LCR_DLAB_W :: new (self , 7) } }
#[doc = "RW, UART1 line control\n\nYou can [`read`](crate::Reg::read) this register and get [`lcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct LCR_SPEC ; impl crate :: RegisterSpec for LCR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`lcr::R`](R) reader structure"] impl crate :: Readable for LCR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`lcr::W`](W) writer structure"] impl crate :: Writable for LCR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets LCR to value 0"] impl crate :: Resettable for LCR_SPEC { } }
#[doc = "IIR (r) register accessor: RO, UART1 interrupt identification\n\nYou can [`read`](crate::Reg::read) this register and get [`iir::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iir`] module"] pub type IIR = crate :: Reg < iir :: IIR_SPEC > ;
#[doc = "RO, UART1 interrupt identification"] pub mod iir {
#[doc = "Register `IIR` reader"] pub type R = crate :: R < IIR_SPEC > ;
#[doc = "Field `IIR_NO_INT` reader - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt"] pub type IIR_NO_INT_R = crate :: BitReader ;
#[doc = "Field `IIR_INT_MASK` reader - RO, UART interrupt flag bit mask"] pub type IIR_INT_MASK_R = crate :: FieldReader ;
#[doc = "Field `IIR_FIFO_ID` reader - RO, UART FIFO enabled flag"] pub type IIR_FIFO_ID_R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt"]
#[inline (always)] pub fn iir_no_int (& self) -> IIR_NO_INT_R { IIR_NO_INT_R :: new ((self . bits & 1) != 0) }
#[doc = "Bits 0:3 - RO, UART interrupt flag bit mask"]
#[inline (always)] pub fn iir_int_mask (& self) -> IIR_INT_MASK_R { IIR_INT_MASK_R :: new (self . bits & 0x0f) }
#[doc = "Bit 7 - RO, UART FIFO enabled flag"]
#[inline (always)] pub fn iir_fifo_id (& self) -> IIR_FIFO_ID_R { IIR_FIFO_ID_R :: new (((self . bits >> 7) & 1) != 0) } }
#[doc = "RO, UART1 interrupt identification\n\nYou can [`read`](crate::Reg::read) this register and get [`iir::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IIR_SPEC ; impl crate :: RegisterSpec for IIR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`iir::R`](R) reader structure"] impl crate :: Readable for IIR_SPEC { }
#[doc = "`reset()` method sets IIR to value 0x01"] impl crate :: Resettable for IIR_SPEC { const RESET_VALUE : u8 = 0x01 ; } }
#[doc = "LSR (r) register accessor: RO, UART1 line status\n\nYou can [`read`](crate::Reg::read) this register and get [`lsr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lsr`] module"] pub type LSR = crate :: Reg < lsr :: LSR_SPEC > ;
#[doc = "RO, UART1 line status"] pub mod lsr {
#[doc = "Register `LSR` reader"] pub type R = crate :: R < LSR_SPEC > ;
#[doc = "Field `LSR_DATA_RDY` reader - RO, UART receiver fifo data ready status"] pub type LSR_DATA_RDY_R = crate :: BitReader ;
#[doc = "Field `LSR_OVER_ERR` reader - RZ, UART receiver overrun error"] pub type LSR_OVER_ERR_R = crate :: BitReader ;
#[doc = "Field `LSR_PAR_ERR` reader - RZ, UART receiver parity error"] pub type LSR_PAR_ERR_R = crate :: BitReader ;
#[doc = "Field `LSR_FRAME_ERR` reader - RZ, UART receiver frame error"] pub type LSR_FRAME_ERR_R = crate :: BitReader ;
#[doc = "Field `LSR_BREAK_ERR` reader - RZ, UART receiver break error"] pub type LSR_BREAK_ERR_R = crate :: BitReader ;
#[doc = "Field `LSR_TX_FIFO_EMP` reader - RO, UART transmitter fifo empty status"] pub type LSR_TX_FIFO_EMP_R = crate :: BitReader ;
#[doc = "Field `LSR_TX_ALL_EMP` reader - RO, UART transmitter all empty status"] pub type LSR_TX_ALL_EMP_R = crate :: BitReader ;
#[doc = "Field `LSR_ERR_RX_FIFO` reader - RO, indicate error in UART receiver fifo"] pub type LSR_ERR_RX_FIFO_R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - RO, UART receiver fifo data ready status"]
#[inline (always)] pub fn lsr_data_rdy (& self) -> LSR_DATA_RDY_R { LSR_DATA_RDY_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RZ, UART receiver overrun error"]
#[inline (always)] pub fn lsr_over_err (& self) -> LSR_OVER_ERR_R { LSR_OVER_ERR_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RZ, UART receiver parity error"]
#[inline (always)] pub fn lsr_par_err (& self) -> LSR_PAR_ERR_R { LSR_PAR_ERR_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RZ, UART receiver frame error"]
#[inline (always)] pub fn lsr_frame_err (& self) -> LSR_FRAME_ERR_R { LSR_FRAME_ERR_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RZ, UART receiver break error"]
#[inline (always)] pub fn lsr_break_err (& self) -> LSR_BREAK_ERR_R { LSR_BREAK_ERR_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RO, UART transmitter fifo empty status"]
#[inline (always)] pub fn lsr_tx_fifo_emp (& self) -> LSR_TX_FIFO_EMP_R { LSR_TX_FIFO_EMP_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RO, UART transmitter all empty status"]
#[inline (always)] pub fn lsr_tx_all_emp (& self) -> LSR_TX_ALL_EMP_R { LSR_TX_ALL_EMP_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RO, indicate error in UART receiver fifo"]
#[inline (always)] pub fn lsr_err_rx_fifo (& self) -> LSR_ERR_RX_FIFO_R { LSR_ERR_RX_FIFO_R :: new (((self . bits >> 7) & 1) != 0) } }
#[doc = "RO, UART1 line status\n\nYou can [`read`](crate::Reg::read) this register and get [`lsr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct LSR_SPEC ; impl crate :: RegisterSpec for LSR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`lsr::R`](R) reader structure"] impl crate :: Readable for LSR_SPEC { }
#[doc = "`reset()` method sets LSR to value 0x60"] impl crate :: Resettable for LSR_SPEC { const RESET_VALUE : u8 = 0x60 ; } }
#[doc = "RBR (r) register accessor: RO, UART1 receiver buffer, receiving byte\n\nYou can [`read`](crate::Reg::read) this register and get [`rbr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rbr`] module"] pub type RBR = crate :: Reg < rbr :: RBR_SPEC > ;
#[doc = "RO, UART1 receiver buffer, receiving byte"] pub mod rbr {
#[doc = "Register `RBR` reader"] pub type R = crate :: R < RBR_SPEC > ;
#[doc = "Field `RBR` reader - RO, UART1 receiver buffer, receiving byte"] pub type RBR_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RO, UART1 receiver buffer, receiving byte"]
#[inline (always)] pub fn rbr (& self) -> RBR_R { RBR_R :: new (self . bits) } }
#[doc = "RO, UART1 receiver buffer, receiving byte\n\nYou can [`read`](crate::Reg::read) this register and get [`rbr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RBR_SPEC ; impl crate :: RegisterSpec for RBR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`rbr::R`](R) reader structure"] impl crate :: Readable for RBR_SPEC { }
#[doc = "`reset()` method sets RBR to value 0"] impl crate :: Resettable for RBR_SPEC { } }
#[doc = "THR (w) register accessor: WO, UART1 transmitter holding, transmittal byte\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`thr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@thr`] module"] pub type THR = crate :: Reg < thr :: THR_SPEC > ;
#[doc = "WO, UART1 transmitter holding, transmittal byte"] pub mod thr {
#[doc = "Register `THR` writer"] pub type W = crate :: W < THR_SPEC > ;
#[doc = "Field `RBR` writer - WO, UART1 transmitter holding, transmittal byte"] pub type RBR_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl W {
#[doc = "Bits 0:7 - WO, UART1 transmitter holding, transmittal byte"]
#[inline (always)] pub fn rbr (& mut self) -> RBR_W < THR_SPEC > { RBR_W :: new (self , 0) } }
#[doc = "WO, UART1 transmitter holding, transmittal byte\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`thr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct THR_SPEC ; impl crate :: RegisterSpec for THR_SPEC { type Ux = u8 ; }
#[doc = "`write(|w| ..)` method takes [`thr::W`](W) writer structure"] impl crate :: Writable for THR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets THR to value 0"] impl crate :: Resettable for THR_SPEC { } }
#[doc = "RFC (r) register accessor: RO, UART1 receiver FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`rfc::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rfc`] module"] pub type RFC = crate :: Reg < rfc :: RFC_SPEC > ;
#[doc = "RO, UART1 receiver FIFO count"] pub mod rfc {
#[doc = "Register `RFC` reader"] pub type R = crate :: R < RFC_SPEC > ;
#[doc = "Field `RFC` reader - RO, UART1 receiver FIFO count"] pub type RFC_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RO, UART1 receiver FIFO count"]
#[inline (always)] pub fn rfc (& self) -> RFC_R { RFC_R :: new (self . bits) } }
#[doc = "RO, UART1 receiver FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`rfc::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RFC_SPEC ; impl crate :: RegisterSpec for RFC_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`rfc::R`](R) reader structure"] impl crate :: Readable for RFC_SPEC { }
#[doc = "`reset()` method sets RFC to value 0"] impl crate :: Resettable for RFC_SPEC { } }
#[doc = "TFC (r) register accessor: RO, UART1 transmitter FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`tfc::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tfc`] module"] pub type TFC = crate :: Reg < tfc :: TFC_SPEC > ;
#[doc = "RO, UART1 transmitter FIFO count"] pub mod tfc {
#[doc = "Register `TFC` reader"] pub type R = crate :: R < TFC_SPEC > ;
#[doc = "Field `TFC` reader - RO, UART1 receiver FIFO count"] pub type TFC_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RO, UART1 receiver FIFO count"]
#[inline (always)] pub fn tfc (& self) -> TFC_R { TFC_R :: new (self . bits) } }
#[doc = "RO, UART1 transmitter FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`tfc::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TFC_SPEC ; impl crate :: RegisterSpec for TFC_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`tfc::R`](R) reader structure"] impl crate :: Readable for TFC_SPEC { }
#[doc = "`reset()` method sets TFC to value 0"] impl crate :: Resettable for TFC_SPEC { } }
#[doc = "DL (rw) register accessor: RW, UART1 divisor latch\n\nYou can [`read`](crate::Reg::read) this register and get [`dl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dl`] module"] pub type DL = crate :: Reg < dl :: DL_SPEC > ;
#[doc = "RW, UART1 divisor latch"] pub mod dl {
#[doc = "Register `DL` reader"] pub type R = crate :: R < DL_SPEC > ;
#[doc = "Register `DL` writer"] pub type W = crate :: W < DL_SPEC > ;
#[doc = "Field `DL` reader - RW, UART1 divisor latch"] pub type DL_R = crate :: FieldReader < u16 > ;
#[doc = "Field `DL` writer - RW, UART1 divisor latch"] pub type DL_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW, UART1 divisor latch"]
#[inline (always)] pub fn dl (& self) -> DL_R { DL_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW, UART1 divisor latch"]
#[inline (always)] pub fn dl (& mut self) -> DL_W < DL_SPEC > { DL_W :: new (self , 0) } }
#[doc = "RW, UART1 divisor latch\n\nYou can [`read`](crate::Reg::read) this register and get [`dl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DL_SPEC ; impl crate :: RegisterSpec for DL_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`dl::R`](R) reader structure"] impl crate :: Readable for DL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`dl::W`](W) writer structure"] impl crate :: Writable for DL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DL to value 0"] impl crate :: Resettable for DL_SPEC { } }
#[doc = "DIV (rw) register accessor: RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128\n\nYou can [`read`](crate::Reg::read) this register and get [`div::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@div`] module"] pub type DIV = crate :: Reg < div :: DIV_SPEC > ;
#[doc = "RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128"] pub mod div {
#[doc = "Register `DIV` reader"] pub type R = crate :: R < DIV_SPEC > ;
#[doc = "Register `DIV` writer"] pub type W = crate :: W < DIV_SPEC > ;
#[doc = "Field `DIV` reader - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128"] pub type DIV_R = crate :: FieldReader ;
#[doc = "Field `DIV` writer - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128"] pub type DIV_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
#[inline (always)] pub fn div (& self) -> DIV_R { DIV_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
#[inline (always)] pub fn div (& mut self) -> DIV_W < DIV_SPEC > { DIV_W :: new (self , 0) } }
#[doc = "RW, UART1 pre-divisor latch byte, only low 7 bit, from 1 to 128\n\nYou can [`read`](crate::Reg::read) this register and get [`div::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DIV_SPEC ; impl crate :: RegisterSpec for DIV_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`div::R`](R) reader structure"] impl crate :: Readable for DIV_SPEC { }
#[doc = "`write(|w| ..)` method takes [`div::W`](W) writer structure"] impl crate :: Writable for DIV_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIV to value 0"] impl crate :: Resettable for DIV_SPEC { } } }
#[doc = "UART2 register"] pub type UART2 = crate :: Periph < uart2 :: RegisterBlock , 0x4000_3800 > ; impl core :: fmt :: Debug for UART2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("UART2") . finish () } }
#[doc = "UART2 register"] pub mod uart2 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { mcr : MCR , ier : IER , fcr : FCR , lcr : LCR , iir : IIR , lsr : LSR , _reserved6 : [u8 ; 0x02] , _reserved_6_rbr : [u8 ; 0x01] , _reserved7 : [u8 ; 0x01] , rfc : RFC , tfc : TFC , dl : DL , div : DIV , } impl RegisterBlock {
#[doc = "0x00 - RW, UART2 modem control"]
#[inline (always)] pub const fn mcr (& self) -> & MCR { & self . mcr }
#[doc = "0x01 - RW, UART2 interrupt enable"]
#[inline (always)] pub const fn ier (& self) -> & IER { & self . ier }
#[doc = "0x02 - RW, UART2 FIFO control"]
#[inline (always)] pub const fn fcr (& self) -> & FCR { & self . fcr }
#[doc = "0x03 - RW, UART2 line control"]
#[inline (always)] pub const fn lcr (& self) -> & LCR { & self . lcr }
#[doc = "0x04 - RO, UART2 interrupt identification"]
#[inline (always)] pub const fn iir (& self) -> & IIR { & self . iir }
#[doc = "0x05 - RO, UART2 line status"]
#[inline (always)] pub const fn lsr (& self) -> & LSR { & self . lsr }
#[doc = "0x08 - WO, UART2 transmitter holding, transmittal byte"]
#[inline (always)] pub const fn thr (& self) -> & THR { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (8) . cast () } }
#[doc = "0x08 - RO, UART2 receiver buffer, receiving byte"]
#[inline (always)] pub const fn rbr (& self) -> & RBR { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (8) . cast () } }
#[doc = "0x0a - RO, UART2 receiver FIFO count"]
#[inline (always)] pub const fn rfc (& self) -> & RFC { & self . rfc }
#[doc = "0x0b - RO, UART2 transmitter FIFO count"]
#[inline (always)] pub const fn tfc (& self) -> & TFC { & self . tfc }
#[doc = "0x0c - RW, UART2 divisor latch"]
#[inline (always)] pub const fn dl (& self) -> & DL { & self . dl }
#[doc = "0x0e - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
#[inline (always)] pub const fn div (& self) -> & DIV { & self . div } }
#[doc = "MCR (rw) register accessor: RW, UART2 modem control\n\nYou can [`read`](crate::Reg::read) this register and get [`mcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mcr`] module"] pub type MCR = crate :: Reg < mcr :: MCR_SPEC > ;
#[doc = "RW, UART2 modem control"] pub mod mcr {
#[doc = "Register `MCR` reader"] pub type R = crate :: R < MCR_SPEC > ;
#[doc = "Register `MCR` writer"] pub type W = crate :: W < MCR_SPEC > ;
#[doc = "Field `MCR_OUT2` reader - RW, UART control OUT2"] pub type MCR_OUT2_R = crate :: BitReader ;
#[doc = "Field `MCR_OUT2` writer - RW, UART control OUT2"] pub type MCR_OUT2_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MCR_INT_OE` reader - RW, UART interrupt output enable"] pub type MCR_INT_OE_R = crate :: BitReader ;
#[doc = "Field `MCR_INT_OE` writer - RW, UART interrupt output enable"] pub type MCR_INT_OE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 3 - RW, UART control OUT2"]
#[inline (always)] pub fn mcr_out2 (& self) -> MCR_OUT2_R { MCR_OUT2_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 3 - RW, UART interrupt output enable"]
#[inline (always)] pub fn mcr_int_oe (& self) -> MCR_INT_OE_R { MCR_INT_OE_R :: new (((self . bits >> 3) & 1) != 0) } } impl W {
#[doc = "Bit 3 - RW, UART control OUT2"]
#[inline (always)] pub fn mcr_out2 (& mut self) -> MCR_OUT2_W < MCR_SPEC > { MCR_OUT2_W :: new (self , 3) }
#[doc = "Bit 3 - RW, UART interrupt output enable"]
#[inline (always)] pub fn mcr_int_oe (& mut self) -> MCR_INT_OE_W < MCR_SPEC > { MCR_INT_OE_W :: new (self , 3) } }
#[doc = "RW, UART2 modem control\n\nYou can [`read`](crate::Reg::read) this register and get [`mcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MCR_SPEC ; impl crate :: RegisterSpec for MCR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`mcr::R`](R) reader structure"] impl crate :: Readable for MCR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`mcr::W`](W) writer structure"] impl crate :: Writable for MCR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MCR to value 0"] impl crate :: Resettable for MCR_SPEC { } }
#[doc = "IER (rw) register accessor: RW, UART2 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ier`] module"] pub type IER = crate :: Reg < ier :: IER_SPEC > ;
#[doc = "RW, UART2 interrupt enable"] pub mod ier {
#[doc = "Register `IER` reader"] pub type R = crate :: R < IER_SPEC > ;
#[doc = "Register `IER` writer"] pub type W = crate :: W < IER_SPEC > ;
#[doc = "Field `IER_RECV_RDY` reader - RW, UART interrupt enable for receiver data ready"] pub type IER_RECV_RDY_R = crate :: BitReader ;
#[doc = "Field `IER_RECV_RDY` writer - RW, UART interrupt enable for receiver data ready"] pub type IER_RECV_RDY_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IER_THR_EMPTY` reader - RW, UART interrupt enable for THR empty"] pub type IER_THR_EMPTY_R = crate :: BitReader ;
#[doc = "Field `IER_THR_EMPTY` writer - RW, UART interrupt enable for THR empty"] pub type IER_THR_EMPTY_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IER_LINE_STAT` reader - RW, UART interrupt enable for receiver line status"] pub type IER_LINE_STAT_R = crate :: BitReader ;
#[doc = "Field `IER_LINE_STAT` writer - RW, UART interrupt enable for receiver line status"] pub type IER_LINE_STAT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IER_TXD_EN` reader - RW, UART TXD pin enable"] pub type IER_TXD_EN_R = crate :: BitReader ;
#[doc = "Field `IER_TXD_EN` writer - RW, UART TXD pin enable"] pub type IER_TXD_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IER_RESET` reader - WZ, UART software reset control, high action, auto clear"] pub type IER_RESET_R = crate :: BitReader ;
#[doc = "Field `IER_RESET` writer - WZ, UART software reset control, high action, auto clear"] pub type IER_RESET_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, UART interrupt enable for receiver data ready"]
#[inline (always)] pub fn ier_recv_rdy (& self) -> IER_RECV_RDY_R { IER_RECV_RDY_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, UART interrupt enable for THR empty"]
#[inline (always)] pub fn ier_thr_empty (& self) -> IER_THR_EMPTY_R { IER_THR_EMPTY_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW, UART interrupt enable for receiver line status"]
#[inline (always)] pub fn ier_line_stat (& self) -> IER_LINE_STAT_R { IER_LINE_STAT_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 6 - RW, UART TXD pin enable"]
#[inline (always)] pub fn ier_txd_en (& self) -> IER_TXD_EN_R { IER_TXD_EN_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - WZ, UART software reset control, high action, auto clear"]
#[inline (always)] pub fn ier_reset (& self) -> IER_RESET_R { IER_RESET_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, UART interrupt enable for receiver data ready"]
#[inline (always)] pub fn ier_recv_rdy (& mut self) -> IER_RECV_RDY_W < IER_SPEC > { IER_RECV_RDY_W :: new (self , 0) }
#[doc = "Bit 1 - RW, UART interrupt enable for THR empty"]
#[inline (always)] pub fn ier_thr_empty (& mut self) -> IER_THR_EMPTY_W < IER_SPEC > { IER_THR_EMPTY_W :: new (self , 1) }
#[doc = "Bit 2 - RW, UART interrupt enable for receiver line status"]
#[inline (always)] pub fn ier_line_stat (& mut self) -> IER_LINE_STAT_W < IER_SPEC > { IER_LINE_STAT_W :: new (self , 2) }
#[doc = "Bit 6 - RW, UART TXD pin enable"]
#[inline (always)] pub fn ier_txd_en (& mut self) -> IER_TXD_EN_W < IER_SPEC > { IER_TXD_EN_W :: new (self , 6) }
#[doc = "Bit 7 - WZ, UART software reset control, high action, auto clear"]
#[inline (always)] pub fn ier_reset (& mut self) -> IER_RESET_W < IER_SPEC > { IER_RESET_W :: new (self , 7) } }
#[doc = "RW, UART2 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IER_SPEC ; impl crate :: RegisterSpec for IER_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`ier::R`](R) reader structure"] impl crate :: Readable for IER_SPEC { }
#[doc = "`write(|w| ..)` method takes [`ier::W`](W) writer structure"] impl crate :: Writable for IER_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IER to value 0"] impl crate :: Resettable for IER_SPEC { } }
#[doc = "FCR (rw) register accessor: RW, UART2 FIFO control\n\nYou can [`read`](crate::Reg::read) this register and get [`fcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fcr`] module"] pub type FCR = crate :: Reg < fcr :: FCR_SPEC > ;
#[doc = "RW, UART2 FIFO control"] pub mod fcr {
#[doc = "Register `FCR` reader"] pub type R = crate :: R < FCR_SPEC > ;
#[doc = "Register `FCR` writer"] pub type W = crate :: W < FCR_SPEC > ;
#[doc = "Field `FCR_FIFO_EN` reader - RW, UART FIFO enable"] pub type FCR_FIFO_EN_R = crate :: BitReader ;
#[doc = "Field `FCR_FIFO_EN` writer - RW, UART FIFO enable"] pub type FCR_FIFO_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FCR_RX_FIFO_CLR` reader - WZ, clear UART receiver FIFO, high action, auto clear"] pub type FCR_RX_FIFO_CLR_R = crate :: BitReader ;
#[doc = "Field `FCR_RX_FIFO_CLR` writer - WZ, clear UART receiver FIFO, high action, auto clear"] pub type FCR_RX_FIFO_CLR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FCR_TX_FIFO_CLR` reader - WZ, clear UART transmitter FIFO, high action, auto clear"] pub type FCR_TX_FIFO_CLR_R = crate :: BitReader ;
#[doc = "Field `FCR_TX_FIFO_CLR` writer - WZ, clear UART transmitter FIFO, high action, auto clear"] pub type FCR_TX_FIFO_CLR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FCR_FIFO_TRIG` reader - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"] pub type FCR_FIFO_TRIG_R = crate :: FieldReader ;
#[doc = "Field `FCR_FIFO_TRIG` writer - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"] pub type FCR_FIFO_TRIG_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bit 0 - RW, UART FIFO enable"]
#[inline (always)] pub fn fcr_fifo_en (& self) -> FCR_FIFO_EN_R { FCR_FIFO_EN_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear"]
#[inline (always)] pub fn fcr_rx_fifo_clr (& self) -> FCR_RX_FIFO_CLR_R { FCR_RX_FIFO_CLR_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear"]
#[inline (always)] pub fn fcr_tx_fifo_clr (& self) -> FCR_TX_FIFO_CLR_R { FCR_TX_FIFO_CLR_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"]
#[inline (always)] pub fn fcr_fifo_trig (& self) -> FCR_FIFO_TRIG_R { FCR_FIFO_TRIG_R :: new ((self . bits >> 6) & 3) } } impl W {
#[doc = "Bit 0 - RW, UART FIFO enable"]
#[inline (always)] pub fn fcr_fifo_en (& mut self) -> FCR_FIFO_EN_W < FCR_SPEC > { FCR_FIFO_EN_W :: new (self , 0) }
#[doc = "Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear"]
#[inline (always)] pub fn fcr_rx_fifo_clr (& mut self) -> FCR_RX_FIFO_CLR_W < FCR_SPEC > { FCR_RX_FIFO_CLR_W :: new (self , 1) }
#[doc = "Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear"]
#[inline (always)] pub fn fcr_tx_fifo_clr (& mut self) -> FCR_TX_FIFO_CLR_W < FCR_SPEC > { FCR_TX_FIFO_CLR_W :: new (self , 2) }
#[doc = "Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"]
#[inline (always)] pub fn fcr_fifo_trig (& mut self) -> FCR_FIFO_TRIG_W < FCR_SPEC > { FCR_FIFO_TRIG_W :: new (self , 6) } }
#[doc = "RW, UART2 FIFO control\n\nYou can [`read`](crate::Reg::read) this register and get [`fcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FCR_SPEC ; impl crate :: RegisterSpec for FCR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`fcr::R`](R) reader structure"] impl crate :: Readable for FCR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`fcr::W`](W) writer structure"] impl crate :: Writable for FCR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FCR to value 0"] impl crate :: Resettable for FCR_SPEC { } }
#[doc = "LCR (rw) register accessor: RW, UART2 line control\n\nYou can [`read`](crate::Reg::read) this register and get [`lcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lcr`] module"] pub type LCR = crate :: Reg < lcr :: LCR_SPEC > ;
#[doc = "RW, UART2 line control"] pub mod lcr {
#[doc = "Register `LCR` reader"] pub type R = crate :: R < LCR_SPEC > ;
#[doc = "Register `LCR` writer"] pub type W = crate :: W < LCR_SPEC > ;
#[doc = "Field `LCR_WORD_SZ` reader - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"] pub type LCR_WORD_SZ_R = crate :: FieldReader ;
#[doc = "Field `LCR_WORD_SZ` writer - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"] pub type LCR_WORD_SZ_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `LCR_STOP_BIT` reader - RW, UART stop bit length: 0-1bit, 1-2bit"] pub type LCR_STOP_BIT_R = crate :: BitReader ;
#[doc = "Field `LCR_STOP_BIT` writer - RW, UART stop bit length: 0-1bit, 1-2bit"] pub type LCR_STOP_BIT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCR_PAR_EN` reader - RW, UART parity enable"] pub type LCR_PAR_EN_R = crate :: BitReader ;
#[doc = "Field `LCR_PAR_EN` writer - RW, UART parity enable"] pub type LCR_PAR_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCR_PAR_MOD` reader - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"] pub type LCR_PAR_MOD_R = crate :: FieldReader ;
#[doc = "Field `LCR_PAR_MOD` writer - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"] pub type LCR_PAR_MOD_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `LCR_BREAK_EN` reader - RW, UART break control enable"] pub type LCR_BREAK_EN_R = crate :: BitReader ;
#[doc = "Field `LCR_BREAK_EN` writer - RW, UART break control enable"] pub type LCR_BREAK_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCR_GP_BIT` reader - RW, UART general purpose bit"] pub type LCR_GP_BIT_R = crate :: BitReader ;
#[doc = "Field `LCR_GP_BIT` writer - RW, UART general purpose bit"] pub type LCR_GP_BIT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCR_DLAB` reader - RW, UART reserved bit"] pub type LCR_DLAB_R = crate :: BitReader ;
#[doc = "Field `LCR_DLAB` writer - RW, UART reserved bit"] pub type LCR_DLAB_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"]
#[inline (always)] pub fn lcr_word_sz (& self) -> LCR_WORD_SZ_R { LCR_WORD_SZ_R :: new (self . bits & 3) }
#[doc = "Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit"]
#[inline (always)] pub fn lcr_stop_bit (& self) -> LCR_STOP_BIT_R { LCR_STOP_BIT_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, UART parity enable"]
#[inline (always)] pub fn lcr_par_en (& self) -> LCR_PAR_EN_R { LCR_PAR_EN_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"]
#[inline (always)] pub fn lcr_par_mod (& self) -> LCR_PAR_MOD_R { LCR_PAR_MOD_R :: new ((self . bits >> 4) & 3) }
#[doc = "Bit 6 - RW, UART break control enable"]
#[inline (always)] pub fn lcr_break_en (& self) -> LCR_BREAK_EN_R { LCR_BREAK_EN_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RW, UART general purpose bit"]
#[inline (always)] pub fn lcr_gp_bit (& self) -> LCR_GP_BIT_R { LCR_GP_BIT_R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 7 - RW, UART reserved bit"]
#[inline (always)] pub fn lcr_dlab (& self) -> LCR_DLAB_R { LCR_DLAB_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"]
#[inline (always)] pub fn lcr_word_sz (& mut self) -> LCR_WORD_SZ_W < LCR_SPEC > { LCR_WORD_SZ_W :: new (self , 0) }
#[doc = "Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit"]
#[inline (always)] pub fn lcr_stop_bit (& mut self) -> LCR_STOP_BIT_W < LCR_SPEC > { LCR_STOP_BIT_W :: new (self , 2) }
#[doc = "Bit 3 - RW, UART parity enable"]
#[inline (always)] pub fn lcr_par_en (& mut self) -> LCR_PAR_EN_W < LCR_SPEC > { LCR_PAR_EN_W :: new (self , 3) }
#[doc = "Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"]
#[inline (always)] pub fn lcr_par_mod (& mut self) -> LCR_PAR_MOD_W < LCR_SPEC > { LCR_PAR_MOD_W :: new (self , 4) }
#[doc = "Bit 6 - RW, UART break control enable"]
#[inline (always)] pub fn lcr_break_en (& mut self) -> LCR_BREAK_EN_W < LCR_SPEC > { LCR_BREAK_EN_W :: new (self , 6) }
#[doc = "Bit 7 - RW, UART general purpose bit"]
#[inline (always)] pub fn lcr_gp_bit (& mut self) -> LCR_GP_BIT_W < LCR_SPEC > { LCR_GP_BIT_W :: new (self , 7) }
#[doc = "Bit 7 - RW, UART reserved bit"]
#[inline (always)] pub fn lcr_dlab (& mut self) -> LCR_DLAB_W < LCR_SPEC > { LCR_DLAB_W :: new (self , 7) } }
#[doc = "RW, UART2 line control\n\nYou can [`read`](crate::Reg::read) this register and get [`lcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct LCR_SPEC ; impl crate :: RegisterSpec for LCR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`lcr::R`](R) reader structure"] impl crate :: Readable for LCR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`lcr::W`](W) writer structure"] impl crate :: Writable for LCR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets LCR to value 0"] impl crate :: Resettable for LCR_SPEC { } }
#[doc = "IIR (r) register accessor: RO, UART2 interrupt identification\n\nYou can [`read`](crate::Reg::read) this register and get [`iir::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iir`] module"] pub type IIR = crate :: Reg < iir :: IIR_SPEC > ;
#[doc = "RO, UART2 interrupt identification"] pub mod iir {
#[doc = "Register `IIR` reader"] pub type R = crate :: R < IIR_SPEC > ;
#[doc = "Field `IIR_NO_INT` reader - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt"] pub type IIR_NO_INT_R = crate :: BitReader ;
#[doc = "Field `IIR_INT_MASK` reader - RO, UART interrupt flag bit mask"] pub type IIR_INT_MASK_R = crate :: FieldReader ;
#[doc = "Field `IIR_FIFO_ID` reader - RO, UART FIFO enabled flag"] pub type IIR_FIFO_ID_R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt"]
#[inline (always)] pub fn iir_no_int (& self) -> IIR_NO_INT_R { IIR_NO_INT_R :: new ((self . bits & 1) != 0) }
#[doc = "Bits 0:3 - RO, UART interrupt flag bit mask"]
#[inline (always)] pub fn iir_int_mask (& self) -> IIR_INT_MASK_R { IIR_INT_MASK_R :: new (self . bits & 0x0f) }
#[doc = "Bit 7 - RO, UART FIFO enabled flag"]
#[inline (always)] pub fn iir_fifo_id (& self) -> IIR_FIFO_ID_R { IIR_FIFO_ID_R :: new (((self . bits >> 7) & 1) != 0) } }
#[doc = "RO, UART2 interrupt identification\n\nYou can [`read`](crate::Reg::read) this register and get [`iir::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IIR_SPEC ; impl crate :: RegisterSpec for IIR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`iir::R`](R) reader structure"] impl crate :: Readable for IIR_SPEC { }
#[doc = "`reset()` method sets IIR to value 0x01"] impl crate :: Resettable for IIR_SPEC { const RESET_VALUE : u8 = 0x01 ; } }
#[doc = "LSR (r) register accessor: RO, UART2 line status\n\nYou can [`read`](crate::Reg::read) this register and get [`lsr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lsr`] module"] pub type LSR = crate :: Reg < lsr :: LSR_SPEC > ;
#[doc = "RO, UART2 line status"] pub mod lsr {
#[doc = "Register `LSR` reader"] pub type R = crate :: R < LSR_SPEC > ;
#[doc = "Field `LSR_DATA_RDY` reader - RO, UART receiver fifo data ready status"] pub type LSR_DATA_RDY_R = crate :: BitReader ;
#[doc = "Field `LSR_OVER_ERR` reader - RZ, UART receiver overrun error"] pub type LSR_OVER_ERR_R = crate :: BitReader ;
#[doc = "Field `LSR_PAR_ERR` reader - RZ, UART receiver parity error"] pub type LSR_PAR_ERR_R = crate :: BitReader ;
#[doc = "Field `LSR_FRAME_ERR` reader - RZ, UART receiver frame error"] pub type LSR_FRAME_ERR_R = crate :: BitReader ;
#[doc = "Field `LSR_BREAK_ERR` reader - RZ, UART receiver break error"] pub type LSR_BREAK_ERR_R = crate :: BitReader ;
#[doc = "Field `LSR_TX_FIFO_EMP` reader - RO, UART transmitter fifo empty status"] pub type LSR_TX_FIFO_EMP_R = crate :: BitReader ;
#[doc = "Field `LSR_TX_ALL_EMP` reader - RO, UART transmitter all empty status"] pub type LSR_TX_ALL_EMP_R = crate :: BitReader ;
#[doc = "Field `LSR_ERR_RX_FIFO` reader - RO, indicate error in UART receiver fifo"] pub type LSR_ERR_RX_FIFO_R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - RO, UART receiver fifo data ready status"]
#[inline (always)] pub fn lsr_data_rdy (& self) -> LSR_DATA_RDY_R { LSR_DATA_RDY_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RZ, UART receiver overrun error"]
#[inline (always)] pub fn lsr_over_err (& self) -> LSR_OVER_ERR_R { LSR_OVER_ERR_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RZ, UART receiver parity error"]
#[inline (always)] pub fn lsr_par_err (& self) -> LSR_PAR_ERR_R { LSR_PAR_ERR_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RZ, UART receiver frame error"]
#[inline (always)] pub fn lsr_frame_err (& self) -> LSR_FRAME_ERR_R { LSR_FRAME_ERR_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RZ, UART receiver break error"]
#[inline (always)] pub fn lsr_break_err (& self) -> LSR_BREAK_ERR_R { LSR_BREAK_ERR_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RO, UART transmitter fifo empty status"]
#[inline (always)] pub fn lsr_tx_fifo_emp (& self) -> LSR_TX_FIFO_EMP_R { LSR_TX_FIFO_EMP_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RO, UART transmitter all empty status"]
#[inline (always)] pub fn lsr_tx_all_emp (& self) -> LSR_TX_ALL_EMP_R { LSR_TX_ALL_EMP_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RO, indicate error in UART receiver fifo"]
#[inline (always)] pub fn lsr_err_rx_fifo (& self) -> LSR_ERR_RX_FIFO_R { LSR_ERR_RX_FIFO_R :: new (((self . bits >> 7) & 1) != 0) } }
#[doc = "RO, UART2 line status\n\nYou can [`read`](crate::Reg::read) this register and get [`lsr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct LSR_SPEC ; impl crate :: RegisterSpec for LSR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`lsr::R`](R) reader structure"] impl crate :: Readable for LSR_SPEC { }
#[doc = "`reset()` method sets LSR to value 0x60"] impl crate :: Resettable for LSR_SPEC { const RESET_VALUE : u8 = 0x60 ; } }
#[doc = "RBR (r) register accessor: RO, UART2 receiver buffer, receiving byte\n\nYou can [`read`](crate::Reg::read) this register and get [`rbr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rbr`] module"] pub type RBR = crate :: Reg < rbr :: RBR_SPEC > ;
#[doc = "RO, UART2 receiver buffer, receiving byte"] pub mod rbr {
#[doc = "Register `RBR` reader"] pub type R = crate :: R < RBR_SPEC > ;
#[doc = "Field `RBR` reader - RO, UART2 receiver buffer, receiving byte"] pub type RBR_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RO, UART2 receiver buffer, receiving byte"]
#[inline (always)] pub fn rbr (& self) -> RBR_R { RBR_R :: new (self . bits) } }
#[doc = "RO, UART2 receiver buffer, receiving byte\n\nYou can [`read`](crate::Reg::read) this register and get [`rbr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RBR_SPEC ; impl crate :: RegisterSpec for RBR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`rbr::R`](R) reader structure"] impl crate :: Readable for RBR_SPEC { }
#[doc = "`reset()` method sets RBR to value 0"] impl crate :: Resettable for RBR_SPEC { } }
#[doc = "THR (w) register accessor: WO, UART2 transmitter holding, transmittal byte\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`thr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@thr`] module"] pub type THR = crate :: Reg < thr :: THR_SPEC > ;
#[doc = "WO, UART2 transmitter holding, transmittal byte"] pub mod thr {
#[doc = "Register `THR` writer"] pub type W = crate :: W < THR_SPEC > ;
#[doc = "Field `THR` writer - WO, UART2 transmitter holding, transmittal byte"] pub type THR_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl W {
#[doc = "Bits 0:7 - WO, UART2 transmitter holding, transmittal byte"]
#[inline (always)] pub fn thr (& mut self) -> THR_W < THR_SPEC > { THR_W :: new (self , 0) } }
#[doc = "WO, UART2 transmitter holding, transmittal byte\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`thr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct THR_SPEC ; impl crate :: RegisterSpec for THR_SPEC { type Ux = u8 ; }
#[doc = "`write(|w| ..)` method takes [`thr::W`](W) writer structure"] impl crate :: Writable for THR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets THR to value 0"] impl crate :: Resettable for THR_SPEC { } }
#[doc = "RFC (r) register accessor: RO, UART2 receiver FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`rfc::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rfc`] module"] pub type RFC = crate :: Reg < rfc :: RFC_SPEC > ;
#[doc = "RO, UART2 receiver FIFO count"] pub mod rfc {
#[doc = "Register `RFC` reader"] pub type R = crate :: R < RFC_SPEC > ;
#[doc = "Field `RFC` reader - RO, UART2 receiver FIFO count"] pub type RFC_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RO, UART2 receiver FIFO count"]
#[inline (always)] pub fn rfc (& self) -> RFC_R { RFC_R :: new (self . bits) } }
#[doc = "RO, UART2 receiver FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`rfc::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RFC_SPEC ; impl crate :: RegisterSpec for RFC_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`rfc::R`](R) reader structure"] impl crate :: Readable for RFC_SPEC { }
#[doc = "`reset()` method sets RFC to value 0"] impl crate :: Resettable for RFC_SPEC { } }
#[doc = "TFC (r) register accessor: RO, UART2 transmitter FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`tfc::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tfc`] module"] pub type TFC = crate :: Reg < tfc :: TFC_SPEC > ;
#[doc = "RO, UART2 transmitter FIFO count"] pub mod tfc {
#[doc = "Register `TFC` reader"] pub type R = crate :: R < TFC_SPEC > ;
#[doc = "Field `TFC` reader - RO, UART2 transmitter FIFO count"] pub type TFC_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RO, UART2 transmitter FIFO count"]
#[inline (always)] pub fn tfc (& self) -> TFC_R { TFC_R :: new (self . bits) } }
#[doc = "RO, UART2 transmitter FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`tfc::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TFC_SPEC ; impl crate :: RegisterSpec for TFC_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`tfc::R`](R) reader structure"] impl crate :: Readable for TFC_SPEC { }
#[doc = "`reset()` method sets TFC to value 0"] impl crate :: Resettable for TFC_SPEC { } }
#[doc = "DL (rw) register accessor: RW, UART2 divisor latch\n\nYou can [`read`](crate::Reg::read) this register and get [`dl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dl`] module"] pub type DL = crate :: Reg < dl :: DL_SPEC > ;
#[doc = "RW, UART2 divisor latch"] pub mod dl {
#[doc = "Register `DL` reader"] pub type R = crate :: R < DL_SPEC > ;
#[doc = "Register `DL` writer"] pub type W = crate :: W < DL_SPEC > ;
#[doc = "Field `DL` reader - RW, UART2 divisor latch"] pub type DL_R = crate :: FieldReader < u16 > ;
#[doc = "Field `DL` writer - RW, UART2 divisor latch"] pub type DL_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW, UART2 divisor latch"]
#[inline (always)] pub fn dl (& self) -> DL_R { DL_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW, UART2 divisor latch"]
#[inline (always)] pub fn dl (& mut self) -> DL_W < DL_SPEC > { DL_W :: new (self , 0) } }
#[doc = "RW, UART2 divisor latch\n\nYou can [`read`](crate::Reg::read) this register and get [`dl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DL_SPEC ; impl crate :: RegisterSpec for DL_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`dl::R`](R) reader structure"] impl crate :: Readable for DL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`dl::W`](W) writer structure"] impl crate :: Writable for DL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DL to value 0"] impl crate :: Resettable for DL_SPEC { } }
#[doc = "DIV (rw) register accessor: RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128\n\nYou can [`read`](crate::Reg::read) this register and get [`div::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@div`] module"] pub type DIV = crate :: Reg < div :: DIV_SPEC > ;
#[doc = "RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128"] pub mod div {
#[doc = "Register `DIV` reader"] pub type R = crate :: R < DIV_SPEC > ;
#[doc = "Register `DIV` writer"] pub type W = crate :: W < DIV_SPEC > ;
#[doc = "Field `DIV` reader - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128"] pub type DIV_R = crate :: FieldReader ;
#[doc = "Field `DIV` writer - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128"] pub type DIV_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
#[inline (always)] pub fn div (& self) -> DIV_R { DIV_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
#[inline (always)] pub fn div (& mut self) -> DIV_W < DIV_SPEC > { DIV_W :: new (self , 0) } }
#[doc = "RW, UART2 pre-divisor latch byte, only low 7 bit, from 1 to 128\n\nYou can [`read`](crate::Reg::read) this register and get [`div::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DIV_SPEC ; impl crate :: RegisterSpec for DIV_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`div::R`](R) reader structure"] impl crate :: Readable for DIV_SPEC { }
#[doc = "`write(|w| ..)` method takes [`div::W`](W) writer structure"] impl crate :: Writable for DIV_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIV to value 0"] impl crate :: Resettable for DIV_SPEC { } } }
#[doc = "UART3 register"] pub type UART3 = crate :: Periph < uart3 :: RegisterBlock , 0x4000_3c00 > ; impl core :: fmt :: Debug for UART3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("UART3") . finish () } }
#[doc = "UART3 register"] pub mod uart3 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { mcr : MCR , ier : IER , fcr : FCR , lcr : LCR , iir : IIR , lsr : LSR , _reserved6 : [u8 ; 0x02] , _reserved_6_rbr : [u8 ; 0x01] , _reserved7 : [u8 ; 0x01] , rfc : RFC , tfc : TFC , dl : DL , div : DIV , } impl RegisterBlock {
#[doc = "0x00 - RW, UART3 modem control"]
#[inline (always)] pub const fn mcr (& self) -> & MCR { & self . mcr }
#[doc = "0x01 - RW, UART3 interrupt enable"]
#[inline (always)] pub const fn ier (& self) -> & IER { & self . ier }
#[doc = "0x02 - RW, UART3 FIFO control"]
#[inline (always)] pub const fn fcr (& self) -> & FCR { & self . fcr }
#[doc = "0x03 - RW, UART3 line control"]
#[inline (always)] pub const fn lcr (& self) -> & LCR { & self . lcr }
#[doc = "0x04 - RO, UART3 interrupt identification"]
#[inline (always)] pub const fn iir (& self) -> & IIR { & self . iir }
#[doc = "0x05 - RO, UART3 line status"]
#[inline (always)] pub const fn lsr (& self) -> & LSR { & self . lsr }
#[doc = "0x08 - WO, UART3 transmitter holding, transmittal byte"]
#[inline (always)] pub const fn thr (& self) -> & THR { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (8) . cast () } }
#[doc = "0x08 - RO, UART3 receiver buffer, receiving byte"]
#[inline (always)] pub const fn rbr (& self) -> & RBR { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (8) . cast () } }
#[doc = "0x0a - RO, UART3 receiver FIFO count"]
#[inline (always)] pub const fn rfc (& self) -> & RFC { & self . rfc }
#[doc = "0x0b - RO, UART3 transmitter FIFO count"]
#[inline (always)] pub const fn tfc (& self) -> & TFC { & self . tfc }
#[doc = "0x0c - RW, UART3 divisor latch"]
#[inline (always)] pub const fn dl (& self) -> & DL { & self . dl }
#[doc = "0x0e - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
#[inline (always)] pub const fn div (& self) -> & DIV { & self . div } }
#[doc = "MCR (rw) register accessor: RW, UART3 modem control\n\nYou can [`read`](crate::Reg::read) this register and get [`mcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mcr`] module"] pub type MCR = crate :: Reg < mcr :: MCR_SPEC > ;
#[doc = "RW, UART3 modem control"] pub mod mcr {
#[doc = "Register `MCR` reader"] pub type R = crate :: R < MCR_SPEC > ;
#[doc = "Register `MCR` writer"] pub type W = crate :: W < MCR_SPEC > ;
#[doc = "Field `MCR_OUT2` reader - RW, UART control OUT2"] pub type MCR_OUT2_R = crate :: BitReader ;
#[doc = "Field `MCR_OUT2` writer - RW, UART control OUT2"] pub type MCR_OUT2_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MCR_INT_OE` reader - RW, UART interrupt output enable"] pub type MCR_INT_OE_R = crate :: BitReader ;
#[doc = "Field `MCR_INT_OE` writer - RW, UART interrupt output enable"] pub type MCR_INT_OE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 3 - RW, UART control OUT2"]
#[inline (always)] pub fn mcr_out2 (& self) -> MCR_OUT2_R { MCR_OUT2_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 3 - RW, UART interrupt output enable"]
#[inline (always)] pub fn mcr_int_oe (& self) -> MCR_INT_OE_R { MCR_INT_OE_R :: new (((self . bits >> 3) & 1) != 0) } } impl W {
#[doc = "Bit 3 - RW, UART control OUT2"]
#[inline (always)] pub fn mcr_out2 (& mut self) -> MCR_OUT2_W < MCR_SPEC > { MCR_OUT2_W :: new (self , 3) }
#[doc = "Bit 3 - RW, UART interrupt output enable"]
#[inline (always)] pub fn mcr_int_oe (& mut self) -> MCR_INT_OE_W < MCR_SPEC > { MCR_INT_OE_W :: new (self , 3) } }
#[doc = "RW, UART3 modem control\n\nYou can [`read`](crate::Reg::read) this register and get [`mcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MCR_SPEC ; impl crate :: RegisterSpec for MCR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`mcr::R`](R) reader structure"] impl crate :: Readable for MCR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`mcr::W`](W) writer structure"] impl crate :: Writable for MCR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets MCR to value 0"] impl crate :: Resettable for MCR_SPEC { } }
#[doc = "IER (rw) register accessor: RW, UART3 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ier`] module"] pub type IER = crate :: Reg < ier :: IER_SPEC > ;
#[doc = "RW, UART3 interrupt enable"] pub mod ier {
#[doc = "Register `IER` reader"] pub type R = crate :: R < IER_SPEC > ;
#[doc = "Register `IER` writer"] pub type W = crate :: W < IER_SPEC > ;
#[doc = "Field `IER_RECV_RDY` reader - RW, UART interrupt enable for receiver data ready"] pub type IER_RECV_RDY_R = crate :: BitReader ;
#[doc = "Field `IER_RECV_RDY` writer - RW, UART interrupt enable for receiver data ready"] pub type IER_RECV_RDY_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IER_THR_EMPTY` reader - RW, UART interrupt enable for THR empty"] pub type IER_THR_EMPTY_R = crate :: BitReader ;
#[doc = "Field `IER_THR_EMPTY` writer - RW, UART interrupt enable for THR empty"] pub type IER_THR_EMPTY_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IER_LINE_STAT` reader - RW, UART interrupt enable for receiver line status"] pub type IER_LINE_STAT_R = crate :: BitReader ;
#[doc = "Field `IER_LINE_STAT` writer - RW, UART interrupt enable for receiver line status"] pub type IER_LINE_STAT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IER_TXD_EN` reader - RW, UART TXD pin enable"] pub type IER_TXD_EN_R = crate :: BitReader ;
#[doc = "Field `IER_TXD_EN` writer - RW, UART TXD pin enable"] pub type IER_TXD_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IER_RESET` reader - WZ, UART software reset control, high action, auto clear"] pub type IER_RESET_R = crate :: BitReader ;
#[doc = "Field `IER_RESET` writer - WZ, UART software reset control, high action, auto clear"] pub type IER_RESET_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, UART interrupt enable for receiver data ready"]
#[inline (always)] pub fn ier_recv_rdy (& self) -> IER_RECV_RDY_R { IER_RECV_RDY_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, UART interrupt enable for THR empty"]
#[inline (always)] pub fn ier_thr_empty (& self) -> IER_THR_EMPTY_R { IER_THR_EMPTY_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW, UART interrupt enable for receiver line status"]
#[inline (always)] pub fn ier_line_stat (& self) -> IER_LINE_STAT_R { IER_LINE_STAT_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 6 - RW, UART TXD pin enable"]
#[inline (always)] pub fn ier_txd_en (& self) -> IER_TXD_EN_R { IER_TXD_EN_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - WZ, UART software reset control, high action, auto clear"]
#[inline (always)] pub fn ier_reset (& self) -> IER_RESET_R { IER_RESET_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, UART interrupt enable for receiver data ready"]
#[inline (always)] pub fn ier_recv_rdy (& mut self) -> IER_RECV_RDY_W < IER_SPEC > { IER_RECV_RDY_W :: new (self , 0) }
#[doc = "Bit 1 - RW, UART interrupt enable for THR empty"]
#[inline (always)] pub fn ier_thr_empty (& mut self) -> IER_THR_EMPTY_W < IER_SPEC > { IER_THR_EMPTY_W :: new (self , 1) }
#[doc = "Bit 2 - RW, UART interrupt enable for receiver line status"]
#[inline (always)] pub fn ier_line_stat (& mut self) -> IER_LINE_STAT_W < IER_SPEC > { IER_LINE_STAT_W :: new (self , 2) }
#[doc = "Bit 6 - RW, UART TXD pin enable"]
#[inline (always)] pub fn ier_txd_en (& mut self) -> IER_TXD_EN_W < IER_SPEC > { IER_TXD_EN_W :: new (self , 6) }
#[doc = "Bit 7 - WZ, UART software reset control, high action, auto clear"]
#[inline (always)] pub fn ier_reset (& mut self) -> IER_RESET_W < IER_SPEC > { IER_RESET_W :: new (self , 7) } }
#[doc = "RW, UART3 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IER_SPEC ; impl crate :: RegisterSpec for IER_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`ier::R`](R) reader structure"] impl crate :: Readable for IER_SPEC { }
#[doc = "`write(|w| ..)` method takes [`ier::W`](W) writer structure"] impl crate :: Writable for IER_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IER to value 0"] impl crate :: Resettable for IER_SPEC { } }
#[doc = "FCR (rw) register accessor: RW, UART3 FIFO control\n\nYou can [`read`](crate::Reg::read) this register and get [`fcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fcr`] module"] pub type FCR = crate :: Reg < fcr :: FCR_SPEC > ;
#[doc = "RW, UART3 FIFO control"] pub mod fcr {
#[doc = "Register `FCR` reader"] pub type R = crate :: R < FCR_SPEC > ;
#[doc = "Register `FCR` writer"] pub type W = crate :: W < FCR_SPEC > ;
#[doc = "Field `FCR_FIFO_EN` reader - RW, UART FIFO enable"] pub type FCR_FIFO_EN_R = crate :: BitReader ;
#[doc = "Field `FCR_FIFO_EN` writer - RW, UART FIFO enable"] pub type FCR_FIFO_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FCR_RX_FIFO_CLR` reader - WZ, clear UART receiver FIFO, high action, auto clear"] pub type FCR_RX_FIFO_CLR_R = crate :: BitReader ;
#[doc = "Field `FCR_RX_FIFO_CLR` writer - WZ, clear UART receiver FIFO, high action, auto clear"] pub type FCR_RX_FIFO_CLR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FCR_TX_FIFO_CLR` reader - WZ, clear UART transmitter FIFO, high action, auto clear"] pub type FCR_TX_FIFO_CLR_R = crate :: BitReader ;
#[doc = "Field `FCR_TX_FIFO_CLR` writer - WZ, clear UART transmitter FIFO, high action, auto clear"] pub type FCR_TX_FIFO_CLR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `FCR_FIFO_TRIG` reader - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"] pub type FCR_FIFO_TRIG_R = crate :: FieldReader ;
#[doc = "Field `FCR_FIFO_TRIG` writer - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"] pub type FCR_FIFO_TRIG_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; impl R {
#[doc = "Bit 0 - RW, UART FIFO enable"]
#[inline (always)] pub fn fcr_fifo_en (& self) -> FCR_FIFO_EN_R { FCR_FIFO_EN_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear"]
#[inline (always)] pub fn fcr_rx_fifo_clr (& self) -> FCR_RX_FIFO_CLR_R { FCR_RX_FIFO_CLR_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear"]
#[inline (always)] pub fn fcr_tx_fifo_clr (& self) -> FCR_TX_FIFO_CLR_R { FCR_TX_FIFO_CLR_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"]
#[inline (always)] pub fn fcr_fifo_trig (& self) -> FCR_FIFO_TRIG_R { FCR_FIFO_TRIG_R :: new ((self . bits >> 6) & 3) } } impl W {
#[doc = "Bit 0 - RW, UART FIFO enable"]
#[inline (always)] pub fn fcr_fifo_en (& mut self) -> FCR_FIFO_EN_W < FCR_SPEC > { FCR_FIFO_EN_W :: new (self , 0) }
#[doc = "Bit 1 - WZ, clear UART receiver FIFO, high action, auto clear"]
#[inline (always)] pub fn fcr_rx_fifo_clr (& mut self) -> FCR_RX_FIFO_CLR_W < FCR_SPEC > { FCR_RX_FIFO_CLR_W :: new (self , 1) }
#[doc = "Bit 2 - WZ, clear UART transmitter FIFO, high action, auto clear"]
#[inline (always)] pub fn fcr_tx_fifo_clr (& mut self) -> FCR_TX_FIFO_CLR_W < FCR_SPEC > { FCR_TX_FIFO_CLR_W :: new (self , 2) }
#[doc = "Bits 6:7 - RW, UART receiver FIFO trigger level: 00-1byte, 01-2bytes, 10-4bytes, 11-7bytes"]
#[inline (always)] pub fn fcr_fifo_trig (& mut self) -> FCR_FIFO_TRIG_W < FCR_SPEC > { FCR_FIFO_TRIG_W :: new (self , 6) } }
#[doc = "RW, UART3 FIFO control\n\nYou can [`read`](crate::Reg::read) this register and get [`fcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FCR_SPEC ; impl crate :: RegisterSpec for FCR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`fcr::R`](R) reader structure"] impl crate :: Readable for FCR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`fcr::W`](W) writer structure"] impl crate :: Writable for FCR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FCR to value 0"] impl crate :: Resettable for FCR_SPEC { } }
#[doc = "LCR (rw) register accessor: RW, UART3 line control\n\nYou can [`read`](crate::Reg::read) this register and get [`lcr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lcr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lcr`] module"] pub type LCR = crate :: Reg < lcr :: LCR_SPEC > ;
#[doc = "RW, UART3 line control"] pub mod lcr {
#[doc = "Register `LCR` reader"] pub type R = crate :: R < LCR_SPEC > ;
#[doc = "Register `LCR` writer"] pub type W = crate :: W < LCR_SPEC > ;
#[doc = "Field `LCR_WORD_SZ` reader - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"] pub type LCR_WORD_SZ_R = crate :: FieldReader ;
#[doc = "Field `LCR_WORD_SZ` writer - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"] pub type LCR_WORD_SZ_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `LCR_STOP_BIT` reader - RW, UART stop bit length: 0-1bit, 1-2bit"] pub type LCR_STOP_BIT_R = crate :: BitReader ;
#[doc = "Field `LCR_STOP_BIT` writer - RW, UART stop bit length: 0-1bit, 1-2bit"] pub type LCR_STOP_BIT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCR_PAR_EN` reader - RW, UART parity enable"] pub type LCR_PAR_EN_R = crate :: BitReader ;
#[doc = "Field `LCR_PAR_EN` writer - RW, UART parity enable"] pub type LCR_PAR_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCR_PAR_MOD` reader - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"] pub type LCR_PAR_MOD_R = crate :: FieldReader ;
#[doc = "Field `LCR_PAR_MOD` writer - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"] pub type LCR_PAR_MOD_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `LCR_BREAK_EN` reader - RW, UART break control enable"] pub type LCR_BREAK_EN_R = crate :: BitReader ;
#[doc = "Field `LCR_BREAK_EN` writer - RW, UART break control enable"] pub type LCR_BREAK_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCR_GP_BIT` reader - RW, UART general purpose bit"] pub type LCR_GP_BIT_R = crate :: BitReader ;
#[doc = "Field `LCR_GP_BIT` writer - RW, UART general purpose bit"] pub type LCR_GP_BIT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LCR_DLAB` reader - RW, UART reserved bit"] pub type LCR_DLAB_R = crate :: BitReader ;
#[doc = "Field `LCR_DLAB` writer - RW, UART reserved bit"] pub type LCR_DLAB_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"]
#[inline (always)] pub fn lcr_word_sz (& self) -> LCR_WORD_SZ_R { LCR_WORD_SZ_R :: new (self . bits & 3) }
#[doc = "Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit"]
#[inline (always)] pub fn lcr_stop_bit (& self) -> LCR_STOP_BIT_R { LCR_STOP_BIT_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, UART parity enable"]
#[inline (always)] pub fn lcr_par_en (& self) -> LCR_PAR_EN_R { LCR_PAR_EN_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"]
#[inline (always)] pub fn lcr_par_mod (& self) -> LCR_PAR_MOD_R { LCR_PAR_MOD_R :: new ((self . bits >> 4) & 3) }
#[doc = "Bit 6 - RW, UART break control enable"]
#[inline (always)] pub fn lcr_break_en (& self) -> LCR_BREAK_EN_R { LCR_BREAK_EN_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RW, UART general purpose bit"]
#[inline (always)] pub fn lcr_gp_bit (& self) -> LCR_GP_BIT_R { LCR_GP_BIT_R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 7 - RW, UART reserved bit"]
#[inline (always)] pub fn lcr_dlab (& self) -> LCR_DLAB_R { LCR_DLAB_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - RW, UART word bit length: 00-5bit, 01-6bit, 10-7bit, 11-8bit"]
#[inline (always)] pub fn lcr_word_sz (& mut self) -> LCR_WORD_SZ_W < LCR_SPEC > { LCR_WORD_SZ_W :: new (self , 0) }
#[doc = "Bit 2 - RW, UART stop bit length: 0-1bit, 1-2bit"]
#[inline (always)] pub fn lcr_stop_bit (& mut self) -> LCR_STOP_BIT_W < LCR_SPEC > { LCR_STOP_BIT_W :: new (self , 2) }
#[doc = "Bit 3 - RW, UART parity enable"]
#[inline (always)] pub fn lcr_par_en (& mut self) -> LCR_PAR_EN_W < LCR_SPEC > { LCR_PAR_EN_W :: new (self , 3) }
#[doc = "Bits 4:5 - RW, UART parity mode: 00-odd, 01-even, 10-mark, 11-space"]
#[inline (always)] pub fn lcr_par_mod (& mut self) -> LCR_PAR_MOD_W < LCR_SPEC > { LCR_PAR_MOD_W :: new (self , 4) }
#[doc = "Bit 6 - RW, UART break control enable"]
#[inline (always)] pub fn lcr_break_en (& mut self) -> LCR_BREAK_EN_W < LCR_SPEC > { LCR_BREAK_EN_W :: new (self , 6) }
#[doc = "Bit 7 - RW, UART general purpose bit"]
#[inline (always)] pub fn lcr_gp_bit (& mut self) -> LCR_GP_BIT_W < LCR_SPEC > { LCR_GP_BIT_W :: new (self , 7) }
#[doc = "Bit 7 - RW, UART reserved bit"]
#[inline (always)] pub fn lcr_dlab (& mut self) -> LCR_DLAB_W < LCR_SPEC > { LCR_DLAB_W :: new (self , 7) } }
#[doc = "RW, UART3 line control\n\nYou can [`read`](crate::Reg::read) this register and get [`lcr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`lcr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct LCR_SPEC ; impl crate :: RegisterSpec for LCR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`lcr::R`](R) reader structure"] impl crate :: Readable for LCR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`lcr::W`](W) writer structure"] impl crate :: Writable for LCR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets LCR to value 0"] impl crate :: Resettable for LCR_SPEC { } }
#[doc = "IIR (r) register accessor: RO, UART3 interrupt identification\n\nYou can [`read`](crate::Reg::read) this register and get [`iir::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iir`] module"] pub type IIR = crate :: Reg < iir :: IIR_SPEC > ;
#[doc = "RO, UART3 interrupt identification"] pub mod iir {
#[doc = "Register `IIR` reader"] pub type R = crate :: R < IIR_SPEC > ;
#[doc = "Field `IIR_NO_INT` reader - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt"] pub type IIR_NO_INT_R = crate :: BitReader ;
#[doc = "Field `IIR_INT_MASK` reader - RO, UART interrupt flag bit mask"] pub type IIR_INT_MASK_R = crate :: FieldReader ;
#[doc = "Field `IIR_FIFO_ID` reader - RO, UART FIFO enabled flag"] pub type IIR_FIFO_ID_R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - RO, UART no interrupt flag: 0=interrupt action, 1=no interrupt"]
#[inline (always)] pub fn iir_no_int (& self) -> IIR_NO_INT_R { IIR_NO_INT_R :: new ((self . bits & 1) != 0) }
#[doc = "Bits 1:3 - RO, UART interrupt flag bit mask"]
#[inline (always)] pub fn iir_int_mask (& self) -> IIR_INT_MASK_R { IIR_INT_MASK_R :: new ((self . bits >> 1) & 7) }
#[doc = "Bit 7 - RO, UART FIFO enabled flag"]
#[inline (always)] pub fn iir_fifo_id (& self) -> IIR_FIFO_ID_R { IIR_FIFO_ID_R :: new (((self . bits >> 7) & 1) != 0) } }
#[doc = "RO, UART3 interrupt identification\n\nYou can [`read`](crate::Reg::read) this register and get [`iir::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IIR_SPEC ; impl crate :: RegisterSpec for IIR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`iir::R`](R) reader structure"] impl crate :: Readable for IIR_SPEC { }
#[doc = "`reset()` method sets IIR to value 0x01"] impl crate :: Resettable for IIR_SPEC { const RESET_VALUE : u8 = 0x01 ; } }
#[doc = "LSR (r) register accessor: RO, UART3 line status\n\nYou can [`read`](crate::Reg::read) this register and get [`lsr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@lsr`] module"] pub type LSR = crate :: Reg < lsr :: LSR_SPEC > ;
#[doc = "RO, UART3 line status"] pub mod lsr {
#[doc = "Register `LSR` reader"] pub type R = crate :: R < LSR_SPEC > ;
#[doc = "Field `LSR_DATA_RDY` reader - RO, UART receiver fifo data ready status"] pub type LSR_DATA_RDY_R = crate :: BitReader ;
#[doc = "Field `LSR_OVER_ERR` reader - RZ, UART receiver overrun error"] pub type LSR_OVER_ERR_R = crate :: BitReader ;
#[doc = "Field `LSR_PAR_ERR` reader - RZ, UART receiver parity error"] pub type LSR_PAR_ERR_R = crate :: BitReader ;
#[doc = "Field `LSR_FRAME_ERR` reader - RZ, UART receiver frame error"] pub type LSR_FRAME_ERR_R = crate :: BitReader ;
#[doc = "Field `LSR_BREAK_ERR` reader - RZ, UART receiver break error"] pub type LSR_BREAK_ERR_R = crate :: BitReader ;
#[doc = "Field `LSR_TX_FIFO_EMP` reader - RO, UART transmitter fifo empty status"] pub type LSR_TX_FIFO_EMP_R = crate :: BitReader ;
#[doc = "Field `LSR_TX_ALL_EMP` reader - RO, UART transmitter all empty status"] pub type LSR_TX_ALL_EMP_R = crate :: BitReader ;
#[doc = "Field `LSR_ERR_RX_FIFO` reader - RO, indicate error in UART receiver fifo"] pub type LSR_ERR_RX_FIFO_R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - RO, UART receiver fifo data ready status"]
#[inline (always)] pub fn lsr_data_rdy (& self) -> LSR_DATA_RDY_R { LSR_DATA_RDY_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RZ, UART receiver overrun error"]
#[inline (always)] pub fn lsr_over_err (& self) -> LSR_OVER_ERR_R { LSR_OVER_ERR_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RZ, UART receiver parity error"]
#[inline (always)] pub fn lsr_par_err (& self) -> LSR_PAR_ERR_R { LSR_PAR_ERR_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RZ, UART receiver frame error"]
#[inline (always)] pub fn lsr_frame_err (& self) -> LSR_FRAME_ERR_R { LSR_FRAME_ERR_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RZ, UART receiver break error"]
#[inline (always)] pub fn lsr_break_err (& self) -> LSR_BREAK_ERR_R { LSR_BREAK_ERR_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RO, UART transmitter fifo empty status"]
#[inline (always)] pub fn lsr_tx_fifo_emp (& self) -> LSR_TX_FIFO_EMP_R { LSR_TX_FIFO_EMP_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RO, UART transmitter all empty status"]
#[inline (always)] pub fn lsr_tx_all_emp (& self) -> LSR_TX_ALL_EMP_R { LSR_TX_ALL_EMP_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RO, indicate error in UART receiver fifo"]
#[inline (always)] pub fn lsr_err_rx_fifo (& self) -> LSR_ERR_RX_FIFO_R { LSR_ERR_RX_FIFO_R :: new (((self . bits >> 7) & 1) != 0) } }
#[doc = "RO, UART3 line status\n\nYou can [`read`](crate::Reg::read) this register and get [`lsr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct LSR_SPEC ; impl crate :: RegisterSpec for LSR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`lsr::R`](R) reader structure"] impl crate :: Readable for LSR_SPEC { }
#[doc = "`reset()` method sets LSR to value 0x60"] impl crate :: Resettable for LSR_SPEC { const RESET_VALUE : u8 = 0x60 ; } }
#[doc = "RBR (r) register accessor: RO, UART3 receiver buffer, receiving byte\n\nYou can [`read`](crate::Reg::read) this register and get [`rbr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rbr`] module"] pub type RBR = crate :: Reg < rbr :: RBR_SPEC > ;
#[doc = "RO, UART3 receiver buffer, receiving byte"] pub mod rbr {
#[doc = "Register `RBR` reader"] pub type R = crate :: R < RBR_SPEC > ;
#[doc = "Field `RBR` reader - RO, UART3 receiver buffer, receiving byte"] pub type RBR_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RO, UART3 receiver buffer, receiving byte"]
#[inline (always)] pub fn rbr (& self) -> RBR_R { RBR_R :: new (self . bits) } }
#[doc = "RO, UART3 receiver buffer, receiving byte\n\nYou can [`read`](crate::Reg::read) this register and get [`rbr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RBR_SPEC ; impl crate :: RegisterSpec for RBR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`rbr::R`](R) reader structure"] impl crate :: Readable for RBR_SPEC { }
#[doc = "`reset()` method sets RBR to value 0"] impl crate :: Resettable for RBR_SPEC { } }
#[doc = "THR (w) register accessor: WO, UART3 transmitter holding, transmittal byte\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`thr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@thr`] module"] pub type THR = crate :: Reg < thr :: THR_SPEC > ;
#[doc = "WO, UART3 transmitter holding, transmittal byte"] pub mod thr {
#[doc = "Register `THR` writer"] pub type W = crate :: W < THR_SPEC > ;
#[doc = "Field `THR` writer - WO, UART3 transmitter holding, transmittal byte"] pub type THR_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl W {
#[doc = "Bits 0:7 - WO, UART3 transmitter holding, transmittal byte"]
#[inline (always)] pub fn thr (& mut self) -> THR_W < THR_SPEC > { THR_W :: new (self , 0) } }
#[doc = "WO, UART3 transmitter holding, transmittal byte\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`thr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct THR_SPEC ; impl crate :: RegisterSpec for THR_SPEC { type Ux = u8 ; }
#[doc = "`write(|w| ..)` method takes [`thr::W`](W) writer structure"] impl crate :: Writable for THR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets THR to value 0"] impl crate :: Resettable for THR_SPEC { } }
#[doc = "RFC (r) register accessor: RO, UART3 receiver FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`rfc::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rfc`] module"] pub type RFC = crate :: Reg < rfc :: RFC_SPEC > ;
#[doc = "RO, UART3 receiver FIFO count"] pub mod rfc {
#[doc = "Register `RFC` reader"] pub type R = crate :: R < RFC_SPEC > ;
#[doc = "Field `RFC` reader - RO, UART3 receiver FIFO count"] pub type RFC_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RO, UART3 receiver FIFO count"]
#[inline (always)] pub fn rfc (& self) -> RFC_R { RFC_R :: new (self . bits) } }
#[doc = "RO, UART3 receiver FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`rfc::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RFC_SPEC ; impl crate :: RegisterSpec for RFC_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`rfc::R`](R) reader structure"] impl crate :: Readable for RFC_SPEC { }
#[doc = "`reset()` method sets RFC to value 0"] impl crate :: Resettable for RFC_SPEC { } }
#[doc = "TFC (r) register accessor: RO, UART3 transmitter FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`tfc::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tfc`] module"] pub type TFC = crate :: Reg < tfc :: TFC_SPEC > ;
#[doc = "RO, UART3 transmitter FIFO count"] pub mod tfc {
#[doc = "Register `TFC` reader"] pub type R = crate :: R < TFC_SPEC > ;
#[doc = "Field `TFC` reader - RO, UART3 transmitter FIFO count"] pub type TFC_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RO, UART3 transmitter FIFO count"]
#[inline (always)] pub fn tfc (& self) -> TFC_R { TFC_R :: new (self . bits) } }
#[doc = "RO, UART3 transmitter FIFO count\n\nYou can [`read`](crate::Reg::read) this register and get [`tfc::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TFC_SPEC ; impl crate :: RegisterSpec for TFC_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`tfc::R`](R) reader structure"] impl crate :: Readable for TFC_SPEC { }
#[doc = "`reset()` method sets TFC to value 0"] impl crate :: Resettable for TFC_SPEC { } }
#[doc = "DL (rw) register accessor: RW, UART3 divisor latch\n\nYou can [`read`](crate::Reg::read) this register and get [`dl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dl`] module"] pub type DL = crate :: Reg < dl :: DL_SPEC > ;
#[doc = "RW, UART3 divisor latch"] pub mod dl {
#[doc = "Register `DL` reader"] pub type R = crate :: R < DL_SPEC > ;
#[doc = "Register `DL` writer"] pub type W = crate :: W < DL_SPEC > ;
#[doc = "Field `DL` reader - RW, UART3 divisor latch"] pub type DL_R = crate :: FieldReader < u16 > ;
#[doc = "Field `DL` writer - RW, UART3 divisor latch"] pub type DL_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW, UART3 divisor latch"]
#[inline (always)] pub fn dl (& self) -> DL_R { DL_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW, UART3 divisor latch"]
#[inline (always)] pub fn dl (& mut self) -> DL_W < DL_SPEC > { DL_W :: new (self , 0) } }
#[doc = "RW, UART3 divisor latch\n\nYou can [`read`](crate::Reg::read) this register and get [`dl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DL_SPEC ; impl crate :: RegisterSpec for DL_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`dl::R`](R) reader structure"] impl crate :: Readable for DL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`dl::W`](W) writer structure"] impl crate :: Writable for DL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DL to value 0"] impl crate :: Resettable for DL_SPEC { } }
#[doc = "DIV (rw) register accessor: RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128\n\nYou can [`read`](crate::Reg::read) this register and get [`div::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@div`] module"] pub type DIV = crate :: Reg < div :: DIV_SPEC > ;
#[doc = "RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128"] pub mod div {
#[doc = "Register `DIV` reader"] pub type R = crate :: R < DIV_SPEC > ;
#[doc = "Register `DIV` writer"] pub type W = crate :: W < DIV_SPEC > ;
#[doc = "Field `DIV` reader - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128"] pub type DIV_R = crate :: FieldReader ;
#[doc = "Field `DIV` writer - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128"] pub type DIV_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
#[inline (always)] pub fn div (& self) -> DIV_R { DIV_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128"]
#[inline (always)] pub fn div (& mut self) -> DIV_W < DIV_SPEC > { DIV_W :: new (self , 0) } }
#[doc = "RW, UART3 pre-divisor latch byte, only low 7 bit, from 1 to 128\n\nYou can [`read`](crate::Reg::read) this register and get [`div::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DIV_SPEC ; impl crate :: RegisterSpec for DIV_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`div::R`](R) reader structure"] impl crate :: Readable for DIV_SPEC { }
#[doc = "`write(|w| ..)` method takes [`div::W`](W) writer structure"] impl crate :: Writable for DIV_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DIV to value 0"] impl crate :: Resettable for DIV_SPEC { } } }
#[doc = "SPI0 register"] pub type SPI0 = crate :: Periph < spi0 :: RegisterBlock , 0x4000_4000 > ; impl core :: fmt :: Debug for SPI0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SPI0") . finish () } }
#[doc = "SPI0 register"] pub mod spi0 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ctrl_mod : CTRL_MOD , ctrl_cfg : CTRL_CFG , inter_en : INTER_EN , _reserved_3_clock_div : [u8 ; 0x01] , buffer : BUFFER , run_flag : RUN_FLAG , int_flag : INT_FLAG , fifo_count : FIFO_COUNT , _reserved8 : [u8 ; 0x04] , total_cnt : TOTAL_CNT , _reserved9 : [u8 ; 0x02] , fifo : FIFO , _reserved10 : [u8 ; 0x02] , fifo_count1 : FIFO_COUNT1 , dma_now : DMA_NOW , _reserved12 : [u8 ; 0x02] , dma_beg : DMA_BEG , _reserved13 : [u8 ; 0x02] , dma_end : DMA_END , } impl RegisterBlock {
#[doc = "0x00 - RW, SPI0 mode control"]
#[inline (always)] pub const fn ctrl_mod (& self) -> & CTRL_MOD { & self . ctrl_mod }
#[doc = "0x01 - RW, SPI0 configuration control"]
#[inline (always)] pub const fn ctrl_cfg (& self) -> & CTRL_CFG { & self . ctrl_cfg }
#[doc = "0x02 - RW, SPI0 interrupt enable"]
#[inline (always)] pub const fn inter_en (& self) -> & INTER_EN { & self . inter_en }
#[doc = "0x03 - RW, SPI0 slave preset value"]
#[inline (always)] pub const fn slave_pre (& self) -> & SLAVE_PRE { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (3) . cast () } }
#[doc = "0x03 - RW, SPI0 master clock divisor"]
#[inline (always)] pub const fn clock_div (& self) -> & CLOCK_DIV { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (3) . cast () } }
#[doc = "0x04 - RW, SPI0 data buffer"]
#[inline (always)] pub const fn buffer (& self) -> & BUFFER { & self . buffer }
#[doc = "0x05 - RO, SPI0 work flag"]
#[inline (always)] pub const fn run_flag (& self) -> & RUN_FLAG { & self . run_flag }
#[doc = "0x06 - RW1, SPI0 interrupt flag"]
#[inline (always)] pub const fn int_flag (& self) -> & INT_FLAG { & self . int_flag }
#[doc = "0x07 - RO, SPI0 FIFO count status"]
#[inline (always)] pub const fn fifo_count (& self) -> & FIFO_COUNT { & self . fifo_count }
#[doc = "0x0c - RW, SPI0 total byte count, only low 12 bit"]
#[inline (always)] pub const fn total_cnt (& self) -> & TOTAL_CNT { & self . total_cnt }
#[doc = "0x10 - RO/WO, SPI0 FIFO register"]
#[inline (always)] pub const fn fifo (& self) -> & FIFO { & self . fifo }
#[doc = "0x13 - RO, SPI0 FIFO count status"]
#[inline (always)] pub const fn fifo_count1 (& self) -> & FIFO_COUNT1 { & self . fifo_count1 }
#[doc = "0x14 - RW, SPI0 DMA current address"]
#[inline (always)] pub const fn dma_now (& self) -> & DMA_NOW { & self . dma_now }
#[doc = "0x18 - RW, SPI0 DMA begin address"]
#[inline (always)] pub const fn dma_beg (& self) -> & DMA_BEG { & self . dma_beg }
#[doc = "0x1c - RW, SPI0 DMA end address"]
#[inline (always)] pub const fn dma_end (& self) -> & DMA_END { & self . dma_end } }
#[doc = "CTRL_MOD (rw) register accessor: RW, SPI0 mode control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl_mod`] module"] pub type CTRL_MOD = crate :: Reg < ctrl_mod :: CTRL_MOD_SPEC > ;
#[doc = "RW, SPI0 mode control"] pub mod ctrl_mod {
#[doc = "Register `CTRL_MOD` reader"] pub type R = crate :: R < CTRL_MOD_SPEC > ;
#[doc = "Register `CTRL_MOD` writer"] pub type W = crate :: W < CTRL_MOD_SPEC > ;
#[doc = "Field `ODE_SLAVE` reader - RW, SPI0 slave mode: 0=master or host, 1=slave or device"] pub type ODE_SLAVE_R = crate :: BitReader ;
#[doc = "Field `ODE_SLAVE` writer - RW, SPI0 slave mode: 0=master or host, 1=slave or device"] pub type ODE_SLAVE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LL_CLEAR` reader - RW, force clear SPI FIFO and count"] pub type LL_CLEAR_R = crate :: BitReader ;
#[doc = "Field `LL_CLEAR` writer - RW, force clear SPI FIFO and count"] pub type LL_CLEAR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WIRE_MOD` reader - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)"] pub type WIRE_MOD_R = crate :: BitReader ;
#[doc = "Field `WIRE_MOD` writer - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)"] pub type WIRE_MOD_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ST_SCK_MOD` reader - RW, SPI master clock mode: 0=mode 0, 1=mode 3"] pub type ST_SCK_MOD_R = crate :: BitReader ;
#[doc = "Field `ST_SCK_MOD` writer - RW, SPI master clock mode: 0=mode 0, 1=mode 3"] pub type ST_SCK_MOD_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LV_CMD_MOD` reader - RW, SPI0 slave command mode: 0=byte stream, 1=first byte command"] pub type LV_CMD_MOD_R = crate :: BitReader ;
#[doc = "Field `LV_CMD_MOD` writer - RW, SPI0 slave command mode: 0=byte stream, 1=first byte command"] pub type LV_CMD_MOD_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IFO_DIR` reader - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)"] pub type IFO_DIR_R = crate :: BitReader ;
#[doc = "Field `IFO_DIR` writer - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)"] pub type IFO_DIR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CK_OE` reader - RW, SPI SCK output enable"] pub type CK_OE_R = crate :: BitReader ;
#[doc = "Field `CK_OE` writer - RW, SPI SCK output enable"] pub type CK_OE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OSI_OE` reader - RW, SPI MOSI output enable"] pub type OSI_OE_R = crate :: BitReader ;
#[doc = "Field `OSI_OE` writer - RW, SPI MOSI output enable"] pub type OSI_OE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ISO_OE` reader - RW, SPI MISO output enable"] pub type ISO_OE_R = crate :: BitReader ;
#[doc = "Field `ISO_OE` writer - RW, SPI MISO output enable"] pub type ISO_OE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, SPI0 slave mode: 0=master or host, 1=slave or device"]
#[inline (always)] pub fn ode_slave (& self) -> ODE_SLAVE_R { ODE_SLAVE_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, force clear SPI FIFO and count"]
#[inline (always)] pub fn ll_clear (& self) -> LL_CLEAR_R { LL_CLEAR_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)"]
#[inline (always)] pub fn wire_mod (& self) -> WIRE_MOD_R { WIRE_MOD_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, SPI master clock mode: 0=mode 0, 1=mode 3"]
#[inline (always)] pub fn st_sck_mod (& self) -> ST_SCK_MOD_R { ST_SCK_MOD_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 3 - RW, SPI0 slave command mode: 0=byte stream, 1=first byte command"]
#[inline (always)] pub fn lv_cmd_mod (& self) -> LV_CMD_MOD_R { LV_CMD_MOD_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)"]
#[inline (always)] pub fn ifo_dir (& self) -> IFO_DIR_R { IFO_DIR_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RW, SPI SCK output enable"]
#[inline (always)] pub fn ck_oe (& self) -> CK_OE_R { CK_OE_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RW, SPI MOSI output enable"]
#[inline (always)] pub fn osi_oe (& self) -> OSI_OE_R { OSI_OE_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RW, SPI MISO output enable"]
#[inline (always)] pub fn iso_oe (& self) -> ISO_OE_R { ISO_OE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, SPI0 slave mode: 0=master or host, 1=slave or device"]
#[inline (always)] pub fn ode_slave (& mut self) -> ODE_SLAVE_W < CTRL_MOD_SPEC > { ODE_SLAVE_W :: new (self , 0) }
#[doc = "Bit 1 - RW, force clear SPI FIFO and count"]
#[inline (always)] pub fn ll_clear (& mut self) -> LL_CLEAR_W < CTRL_MOD_SPEC > { LL_CLEAR_W :: new (self , 1) }
#[doc = "Bit 2 - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)"]
#[inline (always)] pub fn wire_mod (& mut self) -> WIRE_MOD_W < CTRL_MOD_SPEC > { WIRE_MOD_W :: new (self , 2) }
#[doc = "Bit 3 - RW, SPI master clock mode: 0=mode 0, 1=mode 3"]
#[inline (always)] pub fn st_sck_mod (& mut self) -> ST_SCK_MOD_W < CTRL_MOD_SPEC > { ST_SCK_MOD_W :: new (self , 3) }
#[doc = "Bit 3 - RW, SPI0 slave command mode: 0=byte stream, 1=first byte command"]
#[inline (always)] pub fn lv_cmd_mod (& mut self) -> LV_CMD_MOD_W < CTRL_MOD_SPEC > { LV_CMD_MOD_W :: new (self , 3) }
#[doc = "Bit 4 - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)"]
#[inline (always)] pub fn ifo_dir (& mut self) -> IFO_DIR_W < CTRL_MOD_SPEC > { IFO_DIR_W :: new (self , 4) }
#[doc = "Bit 5 - RW, SPI SCK output enable"]
#[inline (always)] pub fn ck_oe (& mut self) -> CK_OE_W < CTRL_MOD_SPEC > { CK_OE_W :: new (self , 5) }
#[doc = "Bit 6 - RW, SPI MOSI output enable"]
#[inline (always)] pub fn osi_oe (& mut self) -> OSI_OE_W < CTRL_MOD_SPEC > { OSI_OE_W :: new (self , 6) }
#[doc = "Bit 7 - RW, SPI MISO output enable"]
#[inline (always)] pub fn iso_oe (& mut self) -> ISO_OE_W < CTRL_MOD_SPEC > { ISO_OE_W :: new (self , 7) } }
#[doc = "RW, SPI0 mode control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CTRL_MOD_SPEC ; impl crate :: RegisterSpec for CTRL_MOD_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`ctrl_mod::R`](R) reader structure"] impl crate :: Readable for CTRL_MOD_SPEC { }
#[doc = "`write(|w| ..)` method takes [`ctrl_mod::W`](W) writer structure"] impl crate :: Writable for CTRL_MOD_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL_MOD to value 0x02"] impl crate :: Resettable for CTRL_MOD_SPEC { const RESET_VALUE : u8 = 0x02 ; } }
#[doc = "CTRL_CFG (rw) register accessor: RW, SPI0 configuration control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl_cfg`] module"] pub type CTRL_CFG = crate :: Reg < ctrl_cfg :: CTRL_CFG_SPEC > ;
#[doc = "RW, SPI0 configuration control"] pub mod ctrl_cfg {
#[doc = "Register `CTRL_CFG` reader"] pub type R = crate :: R < CTRL_CFG_SPEC > ;
#[doc = "Register `CTRL_CFG` writer"] pub type W = crate :: W < CTRL_CFG_SPEC > ;
#[doc = "Field `MA_ENABLE` reader - RW, SPI0 DMA enable"] pub type MA_ENABLE_R = crate :: BitReader ;
#[doc = "Field `MA_ENABLE` writer - RW, SPI0 DMA enable"] pub type MA_ENABLE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MA_LOOP` reader - RW, SPI0 DMA address loop enable"] pub type MA_LOOP_R = crate :: BitReader ;
#[doc = "Field `MA_LOOP` writer - RW, SPI0 DMA address loop enable"] pub type MA_LOOP_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UTO_IF` reader - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag"] pub type UTO_IF_R = crate :: BitReader ;
#[doc = "Field `UTO_IF` writer - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag"] pub type UTO_IF_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IT_ORDER` reader - RW, SPI bit data order: 0=MSB first, 1=LSB first"] pub type IT_ORDER_R = crate :: BitReader ;
#[doc = "Field `IT_ORDER` writer - RW, SPI bit data order: 0=MSB first, 1=LSB first"] pub type IT_ORDER_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ST_DLY_EN` reader - RW, SPI master input delay enable"] pub type ST_DLY_EN_R = crate :: BitReader ;
#[doc = "Field `ST_DLY_EN` writer - RW, SPI master input delay enable"] pub type ST_DLY_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, SPI0 DMA enable"]
#[inline (always)] pub fn ma_enable (& self) -> MA_ENABLE_R { MA_ENABLE_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 2 - RW, SPI0 DMA address loop enable"]
#[inline (always)] pub fn ma_loop (& self) -> MA_LOOP_R { MA_LOOP_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 4 - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag"]
#[inline (always)] pub fn uto_if (& self) -> UTO_IF_R { UTO_IF_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RW, SPI bit data order: 0=MSB first, 1=LSB first"]
#[inline (always)] pub fn it_order (& self) -> IT_ORDER_R { IT_ORDER_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RW, SPI master input delay enable"]
#[inline (always)] pub fn st_dly_en (& self) -> ST_DLY_EN_R { ST_DLY_EN_R :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, SPI0 DMA enable"]
#[inline (always)] pub fn ma_enable (& mut self) -> MA_ENABLE_W < CTRL_CFG_SPEC > { MA_ENABLE_W :: new (self , 0) }
#[doc = "Bit 2 - RW, SPI0 DMA address loop enable"]
#[inline (always)] pub fn ma_loop (& mut self) -> MA_LOOP_W < CTRL_CFG_SPEC > { MA_LOOP_W :: new (self , 2) }
#[doc = "Bit 4 - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag"]
#[inline (always)] pub fn uto_if (& mut self) -> UTO_IF_W < CTRL_CFG_SPEC > { UTO_IF_W :: new (self , 4) }
#[doc = "Bit 5 - RW, SPI bit data order: 0=MSB first, 1=LSB first"]
#[inline (always)] pub fn it_order (& mut self) -> IT_ORDER_W < CTRL_CFG_SPEC > { IT_ORDER_W :: new (self , 5) }
#[doc = "Bit 6 - RW, SPI master input delay enable"]
#[inline (always)] pub fn st_dly_en (& mut self) -> ST_DLY_EN_W < CTRL_CFG_SPEC > { ST_DLY_EN_W :: new (self , 6) } }
#[doc = "RW, SPI0 configuration control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CTRL_CFG_SPEC ; impl crate :: RegisterSpec for CTRL_CFG_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`ctrl_cfg::R`](R) reader structure"] impl crate :: Readable for CTRL_CFG_SPEC { }
#[doc = "`write(|w| ..)` method takes [`ctrl_cfg::W`](W) writer structure"] impl crate :: Writable for CTRL_CFG_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL_CFG to value 0"] impl crate :: Resettable for CTRL_CFG_SPEC { } }
#[doc = "INTER_EN (rw) register accessor: RW, SPI0 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`inter_en::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inter_en::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@inter_en`] module"] pub type INTER_EN = crate :: Reg < inter_en :: INTER_EN_SPEC > ;
#[doc = "RW, SPI0 interrupt enable"] pub mod inter_en {
#[doc = "Register `INTER_EN` reader"] pub type R = crate :: R < INTER_EN_SPEC > ;
#[doc = "Register `INTER_EN` writer"] pub type W = crate :: W < INTER_EN_SPEC > ;
#[doc = "Field `E_CNT_END` reader - RW, enable interrupt for SPI total byte count end"] pub type E_CNT_END_R = crate :: BitReader ;
#[doc = "Field `E_CNT_END` writer - RW, enable interrupt for SPI total byte count end"] pub type E_CNT_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_BYTE_END` reader - RW, enable interrupt for SPI byte exchanged"] pub type E_BYTE_END_R = crate :: BitReader ;
#[doc = "Field `E_BYTE_END` writer - RW, enable interrupt for SPI byte exchanged"] pub type E_BYTE_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_FIFO_HF` reader - RW, enable interrupt for SPI FIFO half"] pub type E_FIFO_HF_R = crate :: BitReader ;
#[doc = "Field `E_FIFO_HF` writer - RW, enable interrupt for SPI FIFO half"] pub type E_FIFO_HF_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_DMA_END` reader - RW, enable interrupt for SPI0 DMA completion"] pub type E_DMA_END_R = crate :: BitReader ;
#[doc = "Field `E_DMA_END` writer - RW, enable interrupt for SPI0 DMA completion"] pub type E_DMA_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_FIFO_OV` reader - RW, enable interrupt for SPI0 FIFO overflow"] pub type E_FIFO_OV_R = crate :: BitReader ;
#[doc = "Field `E_FIFO_OV` writer - RW, enable interrupt for SPI0 FIFO overflow"] pub type E_FIFO_OV_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_FST_BYTE` reader - RW, enable interrupt for SPI0 slave mode first byte received"] pub type E_FST_BYTE_R = crate :: BitReader ;
#[doc = "Field `E_FST_BYTE` writer - RW, enable interrupt for SPI0 slave mode first byte received"] pub type E_FST_BYTE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, enable interrupt for SPI total byte count end"]
#[inline (always)] pub fn e_cnt_end (& self) -> E_CNT_END_R { E_CNT_END_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, enable interrupt for SPI byte exchanged"]
#[inline (always)] pub fn e_byte_end (& self) -> E_BYTE_END_R { E_BYTE_END_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW, enable interrupt for SPI FIFO half"]
#[inline (always)] pub fn e_fifo_hf (& self) -> E_FIFO_HF_R { E_FIFO_HF_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, enable interrupt for SPI0 DMA completion"]
#[inline (always)] pub fn e_dma_end (& self) -> E_DMA_END_R { E_DMA_END_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW, enable interrupt for SPI0 FIFO overflow"]
#[inline (always)] pub fn e_fifo_ov (& self) -> E_FIFO_OV_R { E_FIFO_OV_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 7 - RW, enable interrupt for SPI0 slave mode first byte received"]
#[inline (always)] pub fn e_fst_byte (& self) -> E_FST_BYTE_R { E_FST_BYTE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, enable interrupt for SPI total byte count end"]
#[inline (always)] pub fn e_cnt_end (& mut self) -> E_CNT_END_W < INTER_EN_SPEC > { E_CNT_END_W :: new (self , 0) }
#[doc = "Bit 1 - RW, enable interrupt for SPI byte exchanged"]
#[inline (always)] pub fn e_byte_end (& mut self) -> E_BYTE_END_W < INTER_EN_SPEC > { E_BYTE_END_W :: new (self , 1) }
#[doc = "Bit 2 - RW, enable interrupt for SPI FIFO half"]
#[inline (always)] pub fn e_fifo_hf (& mut self) -> E_FIFO_HF_W < INTER_EN_SPEC > { E_FIFO_HF_W :: new (self , 2) }
#[doc = "Bit 3 - RW, enable interrupt for SPI0 DMA completion"]
#[inline (always)] pub fn e_dma_end (& mut self) -> E_DMA_END_W < INTER_EN_SPEC > { E_DMA_END_W :: new (self , 3) }
#[doc = "Bit 4 - RW, enable interrupt for SPI0 FIFO overflow"]
#[inline (always)] pub fn e_fifo_ov (& mut self) -> E_FIFO_OV_W < INTER_EN_SPEC > { E_FIFO_OV_W :: new (self , 4) }
#[doc = "Bit 7 - RW, enable interrupt for SPI0 slave mode first byte received"]
#[inline (always)] pub fn e_fst_byte (& mut self) -> E_FST_BYTE_W < INTER_EN_SPEC > { E_FST_BYTE_W :: new (self , 7) } }
#[doc = "RW, SPI0 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`inter_en::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inter_en::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INTER_EN_SPEC ; impl crate :: RegisterSpec for INTER_EN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`inter_en::R`](R) reader structure"] impl crate :: Readable for INTER_EN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`inter_en::W`](W) writer structure"] impl crate :: Writable for INTER_EN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INTER_EN to value 0"] impl crate :: Resettable for INTER_EN_SPEC { } }
#[doc = "CLOCK_DIV (rw) register accessor: RW, SPI0 master clock divisor\n\nYou can [`read`](crate::Reg::read) this register and get [`clock_div::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clock_div::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clock_div`] module"] pub type CLOCK_DIV = crate :: Reg < clock_div :: CLOCK_DIV_SPEC > ;
#[doc = "RW, SPI0 master clock divisor"] pub mod clock_div {
#[doc = "Register `CLOCK_DIV` reader"] pub type R = crate :: R < CLOCK_DIV_SPEC > ;
#[doc = "Register `CLOCK_DIV` writer"] pub type W = crate :: W < CLOCK_DIV_SPEC > ;
#[doc = "Field `CLOCK_DIV` reader - RW, SPI0 master clock divisor"] pub type CLOCK_DIV_R = crate :: FieldReader ;
#[doc = "Field `CLOCK_DIV` writer - RW, SPI0 master clock divisor"] pub type CLOCK_DIV_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW, SPI0 master clock divisor"]
#[inline (always)] pub fn clock_div (& self) -> CLOCK_DIV_R { CLOCK_DIV_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RW, SPI0 master clock divisor"]
#[inline (always)] pub fn clock_div (& mut self) -> CLOCK_DIV_W < CLOCK_DIV_SPEC > { CLOCK_DIV_W :: new (self , 0) } }
#[doc = "RW, SPI0 master clock divisor\n\nYou can [`read`](crate::Reg::read) this register and get [`clock_div::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clock_div::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CLOCK_DIV_SPEC ; impl crate :: RegisterSpec for CLOCK_DIV_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`clock_div::R`](R) reader structure"] impl crate :: Readable for CLOCK_DIV_SPEC { }
#[doc = "`write(|w| ..)` method takes [`clock_div::W`](W) writer structure"] impl crate :: Writable for CLOCK_DIV_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CLOCK_DIV to value 0x10"] impl crate :: Resettable for CLOCK_DIV_SPEC { const RESET_VALUE : u8 = 0x10 ; } }
#[doc = "SLAVE_PRE (rw) register accessor: RW, SPI0 slave preset value\n\nYou can [`read`](crate::Reg::read) this register and get [`slave_pre::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slave_pre::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@slave_pre`] module"] pub type SLAVE_PRE = crate :: Reg < slave_pre :: SLAVE_PRE_SPEC > ;
#[doc = "RW, SPI0 slave preset value"] pub mod slave_pre {
#[doc = "Register `SLAVE_PRE` reader"] pub type R = crate :: R < SLAVE_PRE_SPEC > ;
#[doc = "Register `SLAVE_PRE` writer"] pub type W = crate :: W < SLAVE_PRE_SPEC > ;
#[doc = "Field `SLAVE_PRE` reader - RW, SPI0 slave preset value"] pub type SLAVE_PRE_R = crate :: FieldReader ;
#[doc = "Field `SLAVE_PRE` writer - RW, SPI0 slave preset value"] pub type SLAVE_PRE_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW, SPI0 slave preset value"]
#[inline (always)] pub fn slave_pre (& self) -> SLAVE_PRE_R { SLAVE_PRE_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RW, SPI0 slave preset value"]
#[inline (always)] pub fn slave_pre (& mut self) -> SLAVE_PRE_W < SLAVE_PRE_SPEC > { SLAVE_PRE_W :: new (self , 0) } }
#[doc = "RW, SPI0 slave preset value\n\nYou can [`read`](crate::Reg::read) this register and get [`slave_pre::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slave_pre::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SLAVE_PRE_SPEC ; impl crate :: RegisterSpec for SLAVE_PRE_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`slave_pre::R`](R) reader structure"] impl crate :: Readable for SLAVE_PRE_SPEC { }
#[doc = "`write(|w| ..)` method takes [`slave_pre::W`](W) writer structure"] impl crate :: Writable for SLAVE_PRE_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SLAVE_PRE to value 0x10"] impl crate :: Resettable for SLAVE_PRE_SPEC { const RESET_VALUE : u8 = 0x10 ; } }
#[doc = "BUFFER (rw) register accessor: RW, SPI0 data buffer\n\nYou can [`read`](crate::Reg::read) this register and get [`buffer::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`buffer::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@buffer`] module"] pub type BUFFER = crate :: Reg < buffer :: BUFFER_SPEC > ;
#[doc = "RW, SPI0 data buffer"] pub mod buffer {
#[doc = "Register `BUFFER` reader"] pub type R = crate :: R < BUFFER_SPEC > ;
#[doc = "Register `BUFFER` writer"] pub type W = crate :: W < BUFFER_SPEC > ;
#[doc = "Field `BUFFER` reader - RW, SPI0 data buffer"] pub type BUFFER_R = crate :: FieldReader ;
#[doc = "Field `BUFFER` writer - RW, SPI0 data buffer"] pub type BUFFER_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW, SPI0 data buffer"]
#[inline (always)] pub fn buffer (& self) -> BUFFER_R { BUFFER_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RW, SPI0 data buffer"]
#[inline (always)] pub fn buffer (& mut self) -> BUFFER_W < BUFFER_SPEC > { BUFFER_W :: new (self , 0) } }
#[doc = "RW, SPI0 data buffer\n\nYou can [`read`](crate::Reg::read) this register and get [`buffer::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`buffer::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BUFFER_SPEC ; impl crate :: RegisterSpec for BUFFER_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`buffer::R`](R) reader structure"] impl crate :: Readable for BUFFER_SPEC { }
#[doc = "`write(|w| ..)` method takes [`buffer::W`](W) writer structure"] impl crate :: Writable for BUFFER_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BUFFER to value 0"] impl crate :: Resettable for BUFFER_SPEC { } }
#[doc = "RUN_FLAG (r) register accessor: RO, SPI0 work flag\n\nYou can [`read`](crate::Reg::read) this register and get [`run_flag::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@run_flag`] module"] pub type RUN_FLAG = crate :: Reg < run_flag :: RUN_FLAG_SPEC > ;
#[doc = "RO, SPI0 work flag"] pub mod run_flag {
#[doc = "Register `RUN_FLAG` reader"] pub type R = crate :: R < RUN_FLAG_SPEC > ;
#[doc = "Field `LV_CMD_ACT` reader - RO, SPI0 slave first byte or command flag"] pub type LV_CMD_ACT_R = crate :: BitReader ;
#[doc = "Field `IFO_READY` reader - RO, SPI FIFO ready status"] pub type IFO_READY_R = crate :: BitReader ;
#[doc = "Field `LV_CS_LOAD` reader - RO, SPI0 slave chip-select loading status"] pub type LV_CS_LOAD_R = crate :: BitReader ;
#[doc = "Field `LV_SELECT` reader - RO, SPI0 slave selection status"] pub type LV_SELECT_R = crate :: BitReader ; impl R {
#[doc = "Bit 4 - RO, SPI0 slave first byte or command flag"]
#[inline (always)] pub fn lv_cmd_act (& self) -> LV_CMD_ACT_R { LV_CMD_ACT_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RO, SPI FIFO ready status"]
#[inline (always)] pub fn ifo_ready (& self) -> IFO_READY_R { IFO_READY_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RO, SPI0 slave chip-select loading status"]
#[inline (always)] pub fn lv_cs_load (& self) -> LV_CS_LOAD_R { LV_CS_LOAD_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RO, SPI0 slave selection status"]
#[inline (always)] pub fn lv_select (& self) -> LV_SELECT_R { LV_SELECT_R :: new (((self . bits >> 7) & 1) != 0) } }
#[doc = "RO, SPI0 work flag\n\nYou can [`read`](crate::Reg::read) this register and get [`run_flag::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RUN_FLAG_SPEC ; impl crate :: RegisterSpec for RUN_FLAG_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`run_flag::R`](R) reader structure"] impl crate :: Readable for RUN_FLAG_SPEC { }
#[doc = "`reset()` method sets RUN_FLAG to value 0"] impl crate :: Resettable for RUN_FLAG_SPEC { } }
#[doc = "INT_FLAG (rw) register accessor: RW1, SPI0 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_flag`] module"] pub type INT_FLAG = crate :: Reg < int_flag :: INT_FLAG_SPEC > ;
#[doc = "RW1, SPI0 interrupt flag"] pub mod int_flag {
#[doc = "Register `INT_FLAG` reader"] pub type R = crate :: R < INT_FLAG_SPEC > ;
#[doc = "Register `INT_FLAG` writer"] pub type W = crate :: W < INT_FLAG_SPEC > ;
#[doc = "Field `F_CNT_END` reader - RW1, interrupt flag for SPI total byte count end"] pub type F_CNT_END_R = crate :: BitReader ;
#[doc = "Field `F_CNT_END` writer - RW1, interrupt flag for SPI total byte count end"] pub type F_CNT_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_BYTE_END` reader - RW1, interrupt flag for SPI byte exchanged"] pub type F_BYTE_END_R = crate :: BitReader ;
#[doc = "Field `F_BYTE_END` writer - RW1, interrupt flag for SPI byte exchanged"] pub type F_BYTE_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_FIFO_HF` reader - RW1, interrupt flag for SPI FIFO half"] pub type F_FIFO_HF_R = crate :: BitReader ;
#[doc = "Field `F_FIFO_HF` writer - RW1, interrupt flag for SPI FIFO half"] pub type F_FIFO_HF_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_DMA_END` reader - RW1, interrupt flag for SPI0 DMA completion"] pub type F_DMA_END_R = crate :: BitReader ;
#[doc = "Field `F_DMA_END` writer - RW1, interrupt flag for SPI0 DMA completion"] pub type F_DMA_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_FIFO_OV` reader - RW1, interrupt flag for SPI0 FIFO overflow"] pub type F_FIFO_OV_R = crate :: BitReader ;
#[doc = "Field `F_FIFO_OV` writer - RW1, interrupt flag for SPI0 FIFO overflow"] pub type F_FIFO_OV_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `REE` reader - RO, current SPI free status"] pub type REE_R = crate :: BitReader ;
#[doc = "Field `REE` writer - RO, current SPI free status"] pub type REE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_FST_BYTE` reader - RW1, interrupt flag for SPI0 slave mode first byte received"] pub type F_FST_BYTE_R = crate :: BitReader ;
#[doc = "Field `F_FST_BYTE` writer - RW1, interrupt flag for SPI0 slave mode first byte received"] pub type F_FST_BYTE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW1, interrupt flag for SPI total byte count end"]
#[inline (always)] pub fn f_cnt_end (& self) -> F_CNT_END_R { F_CNT_END_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW1, interrupt flag for SPI byte exchanged"]
#[inline (always)] pub fn f_byte_end (& self) -> F_BYTE_END_R { F_BYTE_END_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW1, interrupt flag for SPI FIFO half"]
#[inline (always)] pub fn f_fifo_hf (& self) -> F_FIFO_HF_R { F_FIFO_HF_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW1, interrupt flag for SPI0 DMA completion"]
#[inline (always)] pub fn f_dma_end (& self) -> F_DMA_END_R { F_DMA_END_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW1, interrupt flag for SPI0 FIFO overflow"]
#[inline (always)] pub fn f_fifo_ov (& self) -> F_FIFO_OV_R { F_FIFO_OV_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - RO, current SPI free status"]
#[inline (always)] pub fn ree (& self) -> REE_R { REE_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RW1, interrupt flag for SPI0 slave mode first byte received"]
#[inline (always)] pub fn f_fst_byte (& self) -> F_FST_BYTE_R { F_FST_BYTE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW1, interrupt flag for SPI total byte count end"]
#[inline (always)] pub fn f_cnt_end (& mut self) -> F_CNT_END_W < INT_FLAG_SPEC > { F_CNT_END_W :: new (self , 0) }
#[doc = "Bit 1 - RW1, interrupt flag for SPI byte exchanged"]
#[inline (always)] pub fn f_byte_end (& mut self) -> F_BYTE_END_W < INT_FLAG_SPEC > { F_BYTE_END_W :: new (self , 1) }
#[doc = "Bit 2 - RW1, interrupt flag for SPI FIFO half"]
#[inline (always)] pub fn f_fifo_hf (& mut self) -> F_FIFO_HF_W < INT_FLAG_SPEC > { F_FIFO_HF_W :: new (self , 2) }
#[doc = "Bit 3 - RW1, interrupt flag for SPI0 DMA completion"]
#[inline (always)] pub fn f_dma_end (& mut self) -> F_DMA_END_W < INT_FLAG_SPEC > { F_DMA_END_W :: new (self , 3) }
#[doc = "Bit 4 - RW1, interrupt flag for SPI0 FIFO overflow"]
#[inline (always)] pub fn f_fifo_ov (& mut self) -> F_FIFO_OV_W < INT_FLAG_SPEC > { F_FIFO_OV_W :: new (self , 4) }
#[doc = "Bit 6 - RO, current SPI free status"]
#[inline (always)] pub fn ree (& mut self) -> REE_W < INT_FLAG_SPEC > { REE_W :: new (self , 6) }
#[doc = "Bit 7 - RW1, interrupt flag for SPI0 slave mode first byte received"]
#[inline (always)] pub fn f_fst_byte (& mut self) -> F_FST_BYTE_W < INT_FLAG_SPEC > { F_FST_BYTE_W :: new (self , 7) } }
#[doc = "RW1, SPI0 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_FLAG_SPEC ; impl crate :: RegisterSpec for INT_FLAG_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`int_flag::R`](R) reader structure"] impl crate :: Readable for INT_FLAG_SPEC { }
#[doc = "`write(|w| ..)` method takes [`int_flag::W`](W) writer structure"] impl crate :: Writable for INT_FLAG_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INT_FLAG to value 0x40"] impl crate :: Resettable for INT_FLAG_SPEC { const RESET_VALUE : u8 = 0x40 ; } }
#[doc = "FIFO_COUNT (r) register accessor: RO, SPI0 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo_count`] module"] pub type FIFO_COUNT = crate :: Reg < fifo_count :: FIFO_COUNT_SPEC > ;
#[doc = "RO, SPI0 FIFO count status"] pub mod fifo_count {
#[doc = "Register `FIFO_COUNT` reader"] pub type R = crate :: R < FIFO_COUNT_SPEC > ;
#[doc = "Field `FIFO_COUNT` reader - RO, SPI0 FIFO count status"] pub type FIFO_COUNT_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RO, SPI0 FIFO count status"]
#[inline (always)] pub fn fifo_count (& self) -> FIFO_COUNT_R { FIFO_COUNT_R :: new (self . bits) } }
#[doc = "RO, SPI0 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FIFO_COUNT_SPEC ; impl crate :: RegisterSpec for FIFO_COUNT_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`fifo_count::R`](R) reader structure"] impl crate :: Readable for FIFO_COUNT_SPEC { }
#[doc = "`reset()` method sets FIFO_COUNT to value 0"] impl crate :: Resettable for FIFO_COUNT_SPEC { } }
#[doc = "TOTAL_CNT (rw) register accessor: RW, SPI0 total byte count, only low 12 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`total_cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`total_cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@total_cnt`] module"] pub type TOTAL_CNT = crate :: Reg < total_cnt :: TOTAL_CNT_SPEC > ;
#[doc = "RW, SPI0 total byte count, only low 12 bit"] pub mod total_cnt {
#[doc = "Register `TOTAL_CNT` reader"] pub type R = crate :: R < TOTAL_CNT_SPEC > ;
#[doc = "Register `TOTAL_CNT` writer"] pub type W = crate :: W < TOTAL_CNT_SPEC > ;
#[doc = "Field `TOTAL_CNT` reader - RW, SPI0 total byte count, only low 12 bit"] pub type TOTAL_CNT_R = crate :: FieldReader < u16 > ;
#[doc = "Field `TOTAL_CNT` writer - RW, SPI0 total byte count, only low 12 bit"] pub type TOTAL_CNT_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW, SPI0 total byte count, only low 12 bit"]
#[inline (always)] pub fn total_cnt (& self) -> TOTAL_CNT_R { TOTAL_CNT_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW, SPI0 total byte count, only low 12 bit"]
#[inline (always)] pub fn total_cnt (& mut self) -> TOTAL_CNT_W < TOTAL_CNT_SPEC > { TOTAL_CNT_W :: new (self , 0) } }
#[doc = "RW, SPI0 total byte count, only low 12 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`total_cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`total_cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TOTAL_CNT_SPEC ; impl crate :: RegisterSpec for TOTAL_CNT_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`total_cnt::R`](R) reader structure"] impl crate :: Readable for TOTAL_CNT_SPEC { }
#[doc = "`write(|w| ..)` method takes [`total_cnt::W`](W) writer structure"] impl crate :: Writable for TOTAL_CNT_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets TOTAL_CNT to value 0"] impl crate :: Resettable for TOTAL_CNT_SPEC { } }
#[doc = "FIFO (rw) register accessor: RO/WO, SPI0 FIFO register\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fifo::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo`] module"] pub type FIFO = crate :: Reg < fifo :: FIFO_SPEC > ;
#[doc = "RO/WO, SPI0 FIFO register"] pub mod fifo {
#[doc = "Register `FIFO` reader"] pub type R = crate :: R < FIFO_SPEC > ;
#[doc = "Register `FIFO` writer"] pub type W = crate :: W < FIFO_SPEC > ;
#[doc = "Field `FIFO` reader - RO/WO, SPI0 FIFO register"] pub type FIFO_R = crate :: FieldReader ;
#[doc = "Field `FIFO` writer - RO/WO, SPI0 FIFO register"] pub type FIFO_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RO/WO, SPI0 FIFO register"]
#[inline (always)] pub fn fifo (& self) -> FIFO_R { FIFO_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RO/WO, SPI0 FIFO register"]
#[inline (always)] pub fn fifo (& mut self) -> FIFO_W < FIFO_SPEC > { FIFO_W :: new (self , 0) } }
#[doc = "RO/WO, SPI0 FIFO register\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fifo::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FIFO_SPEC ; impl crate :: RegisterSpec for FIFO_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`fifo::R`](R) reader structure"] impl crate :: Readable for FIFO_SPEC { }
#[doc = "`write(|w| ..)` method takes [`fifo::W`](W) writer structure"] impl crate :: Writable for FIFO_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FIFO to value 0"] impl crate :: Resettable for FIFO_SPEC { } }
#[doc = "FIFO_COUNT1 (r) register accessor: RO, SPI0 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count1::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo_count1`] module"] pub type FIFO_COUNT1 = crate :: Reg < fifo_count1 :: FIFO_COUNT1_SPEC > ;
#[doc = "RO, SPI0 FIFO count status"] pub mod fifo_count1 {
#[doc = "Register `FIFO_COUNT1` reader"] pub type R = crate :: R < FIFO_COUNT1_SPEC > ;
#[doc = "Field `FIFO_COUNT1` reader - RO, SPI0 FIFO count status"] pub type FIFO_COUNT1_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RO, SPI0 FIFO count status"]
#[inline (always)] pub fn fifo_count1 (& self) -> FIFO_COUNT1_R { FIFO_COUNT1_R :: new (self . bits) } }
#[doc = "RO, SPI0 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count1::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FIFO_COUNT1_SPEC ; impl crate :: RegisterSpec for FIFO_COUNT1_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`fifo_count1::R`](R) reader structure"] impl crate :: Readable for FIFO_COUNT1_SPEC { }
#[doc = "`reset()` method sets FIFO_COUNT1 to value 0"] impl crate :: Resettable for FIFO_COUNT1_SPEC { } }
#[doc = "DMA_NOW (rw) register accessor: RW, SPI0 DMA current address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_now::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_now::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_now`] module"] pub type DMA_NOW = crate :: Reg < dma_now :: DMA_NOW_SPEC > ;
#[doc = "RW, SPI0 DMA current address"] pub mod dma_now {
#[doc = "Register `DMA_NOW` reader"] pub type R = crate :: R < DMA_NOW_SPEC > ;
#[doc = "Register `DMA_NOW` writer"] pub type W = crate :: W < DMA_NOW_SPEC > ;
#[doc = "Field `DMA_NOW` reader - RW, SPI0 DMA current address"] pub type DMA_NOW_R = crate :: FieldReader < u16 > ;
#[doc = "Field `DMA_NOW` writer - RW, SPI0 DMA current address"] pub type DMA_NOW_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW, SPI0 DMA current address"]
#[inline (always)] pub fn dma_now (& self) -> DMA_NOW_R { DMA_NOW_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW, SPI0 DMA current address"]
#[inline (always)] pub fn dma_now (& mut self) -> DMA_NOW_W < DMA_NOW_SPEC > { DMA_NOW_W :: new (self , 0) } }
#[doc = "RW, SPI0 DMA current address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_now::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_now::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DMA_NOW_SPEC ; impl crate :: RegisterSpec for DMA_NOW_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`dma_now::R`](R) reader structure"] impl crate :: Readable for DMA_NOW_SPEC { }
#[doc = "`write(|w| ..)` method takes [`dma_now::W`](W) writer structure"] impl crate :: Writable for DMA_NOW_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMA_NOW to value 0"] impl crate :: Resettable for DMA_NOW_SPEC { } }
#[doc = "DMA_BEG (rw) register accessor: RW, SPI0 DMA begin address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_beg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_beg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_beg`] module"] pub type DMA_BEG = crate :: Reg < dma_beg :: DMA_BEG_SPEC > ;
#[doc = "RW, SPI0 DMA begin address"] pub mod dma_beg {
#[doc = "Register `DMA_BEG` reader"] pub type R = crate :: R < DMA_BEG_SPEC > ;
#[doc = "Register `DMA_BEG` writer"] pub type W = crate :: W < DMA_BEG_SPEC > ;
#[doc = "Field `DMA_BEG` reader - RW, SPI0 DMA begin address"] pub type DMA_BEG_R = crate :: FieldReader < u16 > ;
#[doc = "Field `DMA_BEG` writer - RW, SPI0 DMA begin address"] pub type DMA_BEG_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW, SPI0 DMA begin address"]
#[inline (always)] pub fn dma_beg (& self) -> DMA_BEG_R { DMA_BEG_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW, SPI0 DMA begin address"]
#[inline (always)] pub fn dma_beg (& mut self) -> DMA_BEG_W < DMA_BEG_SPEC > { DMA_BEG_W :: new (self , 0) } }
#[doc = "RW, SPI0 DMA begin address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_beg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_beg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DMA_BEG_SPEC ; impl crate :: RegisterSpec for DMA_BEG_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`dma_beg::R`](R) reader structure"] impl crate :: Readable for DMA_BEG_SPEC { }
#[doc = "`write(|w| ..)` method takes [`dma_beg::W`](W) writer structure"] impl crate :: Writable for DMA_BEG_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMA_BEG to value 0"] impl crate :: Resettable for DMA_BEG_SPEC { } }
#[doc = "DMA_END (rw) register accessor: RW, SPI0 DMA end address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_end::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_end::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dma_end`] module"] pub type DMA_END = crate :: Reg < dma_end :: DMA_END_SPEC > ;
#[doc = "RW, SPI0 DMA end address"] pub mod dma_end {
#[doc = "Register `DMA_END` reader"] pub type R = crate :: R < DMA_END_SPEC > ;
#[doc = "Register `DMA_END` writer"] pub type W = crate :: W < DMA_END_SPEC > ;
#[doc = "Field `DMA_END` reader - RW, SPI0 DMA end address"] pub type DMA_END_R = crate :: FieldReader < u16 > ;
#[doc = "Field `DMA_END` writer - RW, SPI0 DMA end address"] pub type DMA_END_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW, SPI0 DMA end address"]
#[inline (always)] pub fn dma_end (& self) -> DMA_END_R { DMA_END_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW, SPI0 DMA end address"]
#[inline (always)] pub fn dma_end (& mut self) -> DMA_END_W < DMA_END_SPEC > { DMA_END_W :: new (self , 0) } }
#[doc = "RW, SPI0 DMA end address\n\nYou can [`read`](crate::Reg::read) this register and get [`dma_end::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dma_end::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DMA_END_SPEC ; impl crate :: RegisterSpec for DMA_END_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`dma_end::R`](R) reader structure"] impl crate :: Readable for DMA_END_SPEC { }
#[doc = "`write(|w| ..)` method takes [`dma_end::W`](W) writer structure"] impl crate :: Writable for DMA_END_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DMA_END to value 0"] impl crate :: Resettable for DMA_END_SPEC { } } }
#[doc = "SPI1 register"] pub type SPI1 = crate :: Periph < spi1 :: RegisterBlock , 0x4000_4400 > ; impl core :: fmt :: Debug for SPI1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SPI1") . finish () } }
#[doc = "SPI1 register"] pub mod spi1 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ctrl_mod : CTRL_MOD , ctrl_cfg : CTRL_CFG , inter_en : INTER_EN , _reserved_3_clock_div : [u8 ; 0x01] , buffer : BUFFER , run_flag : RUN_FLAG , int_flag : INT_FLAG , fifo_count : FIFO_COUNT , _reserved8 : [u8 ; 0x04] , total_cnt : TOTAL_CNT , _reserved9 : [u8 ; 0x02] , fifo : FIFO , _reserved10 : [u8 ; 0x02] , fifo_count1 : FIFO_COUNT1 , } impl RegisterBlock {
#[doc = "0x00 - RW, SPI1 mode control"]
#[inline (always)] pub const fn ctrl_mod (& self) -> & CTRL_MOD { & self . ctrl_mod }
#[doc = "0x01 - RW, SPI1 configuration control"]
#[inline (always)] pub const fn ctrl_cfg (& self) -> & CTRL_CFG { & self . ctrl_cfg }
#[doc = "0x02 - RW, SPI1 interrupt enable"]
#[inline (always)] pub const fn inter_en (& self) -> & INTER_EN { & self . inter_en }
#[doc = "0x03 - RW, SPI1 slave preset value"]
#[inline (always)] pub const fn slave_pre (& self) -> & SLAVE_PRE { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (3) . cast () } }
#[doc = "0x03 - RW, SPI1 master clock divisor"]
#[inline (always)] pub const fn clock_div (& self) -> & CLOCK_DIV { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (3) . cast () } }
#[doc = "0x04 - RW, SPI1 data buffer"]
#[inline (always)] pub const fn buffer (& self) -> & BUFFER { & self . buffer }
#[doc = "0x05 - RO, SPI1 work flag"]
#[inline (always)] pub const fn run_flag (& self) -> & RUN_FLAG { & self . run_flag }
#[doc = "0x06 - RW1, SPI1 interrupt flag"]
#[inline (always)] pub const fn int_flag (& self) -> & INT_FLAG { & self . int_flag }
#[doc = "0x07 - RO, SPI1 FIFO count status"]
#[inline (always)] pub const fn fifo_count (& self) -> & FIFO_COUNT { & self . fifo_count }
#[doc = "0x0c - RW, SPI1 total byte count, only low 12 bit"]
#[inline (always)] pub const fn total_cnt (& self) -> & TOTAL_CNT { & self . total_cnt }
#[doc = "0x10 - RO/WO, SPI1 FIFO register"]
#[inline (always)] pub const fn fifo (& self) -> & FIFO { & self . fifo }
#[doc = "0x13 - RO, SPI1 FIFO count status"]
#[inline (always)] pub const fn fifo_count1 (& self) -> & FIFO_COUNT1 { & self . fifo_count1 } }
#[doc = "CTRL_MOD (rw) register accessor: RW, SPI1 mode control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl_mod`] module"] pub type CTRL_MOD = crate :: Reg < ctrl_mod :: CTRL_MOD_SPEC > ;
#[doc = "RW, SPI1 mode control"] pub mod ctrl_mod {
#[doc = "Register `CTRL_MOD` reader"] pub type R = crate :: R < CTRL_MOD_SPEC > ;
#[doc = "Register `CTRL_MOD` writer"] pub type W = crate :: W < CTRL_MOD_SPEC > ;
#[doc = "Field `ODE_SLAVE` reader - RW, SPI0 slave mode: 0=master or host, 1=slave or device"] pub type ODE_SLAVE_R = crate :: BitReader ;
#[doc = "Field `ODE_SLAVE` writer - RW, SPI0 slave mode: 0=master or host, 1=slave or device"] pub type ODE_SLAVE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LL_CLEAR` reader - RW, force clear SPI FIFO and count"] pub type LL_CLEAR_R = crate :: BitReader ;
#[doc = "Field `LL_CLEAR` writer - RW, force clear SPI FIFO and count"] pub type LL_CLEAR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WIRE_MOD` reader - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)"] pub type WIRE_MOD_R = crate :: BitReader ;
#[doc = "Field `WIRE_MOD` writer - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)"] pub type WIRE_MOD_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ST_SCK_MOD` reader - RW, SPI master clock mode: 0=mode 0, 1=mode 3"] pub type ST_SCK_MOD_R = crate :: BitReader ;
#[doc = "Field `ST_SCK_MOD` writer - RW, SPI master clock mode: 0=mode 0, 1=mode 3"] pub type ST_SCK_MOD_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `LV_CMD_MOD` reader - RW, SPI0 slave command mode: 0=byte stream, 1=first byte command"] pub type LV_CMD_MOD_R = crate :: BitReader ;
#[doc = "Field `LV_CMD_MOD` writer - RW, SPI0 slave command mode: 0=byte stream, 1=first byte command"] pub type LV_CMD_MOD_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IFO_DIR` reader - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)"] pub type IFO_DIR_R = crate :: BitReader ;
#[doc = "Field `IFO_DIR` writer - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)"] pub type IFO_DIR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `CK_OE` reader - RW, SPI SCK output enable"] pub type CK_OE_R = crate :: BitReader ;
#[doc = "Field `CK_OE` writer - RW, SPI SCK output enable"] pub type CK_OE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `OSI_OE` reader - RW, SPI MOSI output enable"] pub type OSI_OE_R = crate :: BitReader ;
#[doc = "Field `OSI_OE` writer - RW, SPI MOSI output enable"] pub type OSI_OE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ISO_OE` reader - RW, SPI MISO output enable"] pub type ISO_OE_R = crate :: BitReader ;
#[doc = "Field `ISO_OE` writer - RW, SPI MISO output enable"] pub type ISO_OE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, SPI0 slave mode: 0=master or host, 1=slave or device"]
#[inline (always)] pub fn ode_slave (& self) -> ODE_SLAVE_R { ODE_SLAVE_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, force clear SPI FIFO and count"]
#[inline (always)] pub fn ll_clear (& self) -> LL_CLEAR_R { LL_CLEAR_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)"]
#[inline (always)] pub fn wire_mod (& self) -> WIRE_MOD_R { WIRE_MOD_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, SPI master clock mode: 0=mode 0, 1=mode 3"]
#[inline (always)] pub fn st_sck_mod (& self) -> ST_SCK_MOD_R { ST_SCK_MOD_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 3 - RW, SPI0 slave command mode: 0=byte stream, 1=first byte command"]
#[inline (always)] pub fn lv_cmd_mod (& self) -> LV_CMD_MOD_R { LV_CMD_MOD_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)"]
#[inline (always)] pub fn ifo_dir (& self) -> IFO_DIR_R { IFO_DIR_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RW, SPI SCK output enable"]
#[inline (always)] pub fn ck_oe (& self) -> CK_OE_R { CK_OE_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RW, SPI MOSI output enable"]
#[inline (always)] pub fn osi_oe (& self) -> OSI_OE_R { OSI_OE_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RW, SPI MISO output enable"]
#[inline (always)] pub fn iso_oe (& self) -> ISO_OE_R { ISO_OE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, SPI0 slave mode: 0=master or host, 1=slave or device"]
#[inline (always)] pub fn ode_slave (& mut self) -> ODE_SLAVE_W < CTRL_MOD_SPEC > { ODE_SLAVE_W :: new (self , 0) }
#[doc = "Bit 1 - RW, force clear SPI FIFO and count"]
#[inline (always)] pub fn ll_clear (& mut self) -> LL_CLEAR_W < CTRL_MOD_SPEC > { LL_CLEAR_W :: new (self , 1) }
#[doc = "Bit 2 - RW, SPI0 enable 2 wire mode for slave: 0=3wire(SCK0,MOSI,MISO), 1=2wire(SCK0,MISO=MXSX)"]
#[inline (always)] pub fn wire_mod (& mut self) -> WIRE_MOD_W < CTRL_MOD_SPEC > { WIRE_MOD_W :: new (self , 2) }
#[doc = "Bit 3 - RW, SPI master clock mode: 0=mode 0, 1=mode 3"]
#[inline (always)] pub fn st_sck_mod (& mut self) -> ST_SCK_MOD_W < CTRL_MOD_SPEC > { ST_SCK_MOD_W :: new (self , 3) }
#[doc = "Bit 3 - RW, SPI0 slave command mode: 0=byte stream, 1=first byte command"]
#[inline (always)] pub fn lv_cmd_mod (& mut self) -> LV_CMD_MOD_W < CTRL_MOD_SPEC > { LV_CMD_MOD_W :: new (self , 3) }
#[doc = "Bit 4 - RW, SPI FIFO direction: 0=out(write @master mode), 1=in(read @master mode)"]
#[inline (always)] pub fn ifo_dir (& mut self) -> IFO_DIR_W < CTRL_MOD_SPEC > { IFO_DIR_W :: new (self , 4) }
#[doc = "Bit 5 - RW, SPI SCK output enable"]
#[inline (always)] pub fn ck_oe (& mut self) -> CK_OE_W < CTRL_MOD_SPEC > { CK_OE_W :: new (self , 5) }
#[doc = "Bit 6 - RW, SPI MOSI output enable"]
#[inline (always)] pub fn osi_oe (& mut self) -> OSI_OE_W < CTRL_MOD_SPEC > { OSI_OE_W :: new (self , 6) }
#[doc = "Bit 7 - RW, SPI MISO output enable"]
#[inline (always)] pub fn iso_oe (& mut self) -> ISO_OE_W < CTRL_MOD_SPEC > { ISO_OE_W :: new (self , 7) } }
#[doc = "RW, SPI1 mode control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CTRL_MOD_SPEC ; impl crate :: RegisterSpec for CTRL_MOD_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`ctrl_mod::R`](R) reader structure"] impl crate :: Readable for CTRL_MOD_SPEC { }
#[doc = "`write(|w| ..)` method takes [`ctrl_mod::W`](W) writer structure"] impl crate :: Writable for CTRL_MOD_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL_MOD to value 0x02"] impl crate :: Resettable for CTRL_MOD_SPEC { const RESET_VALUE : u8 = 0x02 ; } }
#[doc = "CTRL_CFG (rw) register accessor: RW, SPI1 configuration control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl_cfg`] module"] pub type CTRL_CFG = crate :: Reg < ctrl_cfg :: CTRL_CFG_SPEC > ;
#[doc = "RW, SPI1 configuration control"] pub mod ctrl_cfg {
#[doc = "Register `CTRL_CFG` reader"] pub type R = crate :: R < CTRL_CFG_SPEC > ;
#[doc = "Register `CTRL_CFG` writer"] pub type W = crate :: W < CTRL_CFG_SPEC > ;
#[doc = "Field `MA_ENABLE` reader - RW, SPI0 DMA enable"] pub type MA_ENABLE_R = crate :: BitReader ;
#[doc = "Field `MA_ENABLE` writer - RW, SPI0 DMA enable"] pub type MA_ENABLE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MA_LOOP` reader - RW, SPI0 DMA address loop enable"] pub type MA_LOOP_R = crate :: BitReader ;
#[doc = "Field `MA_LOOP` writer - RW, SPI0 DMA address loop enable"] pub type MA_LOOP_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UTO_IF` reader - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag"] pub type UTO_IF_R = crate :: BitReader ;
#[doc = "Field `UTO_IF` writer - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag"] pub type UTO_IF_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `IT_ORDER` reader - RW, SPI bit data order: 0=MSB first, 1=LSB first"] pub type IT_ORDER_R = crate :: BitReader ;
#[doc = "Field `IT_ORDER` writer - RW, SPI bit data order: 0=MSB first, 1=LSB first"] pub type IT_ORDER_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ST_DLY_EN` reader - RW, SPI master input delay enable"] pub type ST_DLY_EN_R = crate :: BitReader ;
#[doc = "Field `ST_DLY_EN` writer - RW, SPI master input delay enable"] pub type ST_DLY_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, SPI0 DMA enable"]
#[inline (always)] pub fn ma_enable (& self) -> MA_ENABLE_R { MA_ENABLE_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 2 - RW, SPI0 DMA address loop enable"]
#[inline (always)] pub fn ma_loop (& self) -> MA_LOOP_R { MA_LOOP_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 4 - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag"]
#[inline (always)] pub fn uto_if (& self) -> UTO_IF_R { UTO_IF_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RW, SPI bit data order: 0=MSB first, 1=LSB first"]
#[inline (always)] pub fn it_order (& self) -> IT_ORDER_R { IT_ORDER_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RW, SPI master input delay enable"]
#[inline (always)] pub fn st_dly_en (& self) -> ST_DLY_EN_R { ST_DLY_EN_R :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, SPI0 DMA enable"]
#[inline (always)] pub fn ma_enable (& mut self) -> MA_ENABLE_W < CTRL_CFG_SPEC > { MA_ENABLE_W :: new (self , 0) }
#[doc = "Bit 2 - RW, SPI0 DMA address loop enable"]
#[inline (always)] pub fn ma_loop (& mut self) -> MA_LOOP_W < CTRL_CFG_SPEC > { MA_LOOP_W :: new (self , 2) }
#[doc = "Bit 4 - RW, enable buffer/FIFO accessing to auto clear RB_SPI_IF_BYTE_END interrupt flag"]
#[inline (always)] pub fn uto_if (& mut self) -> UTO_IF_W < CTRL_CFG_SPEC > { UTO_IF_W :: new (self , 4) }
#[doc = "Bit 5 - RW, SPI bit data order: 0=MSB first, 1=LSB first"]
#[inline (always)] pub fn it_order (& mut self) -> IT_ORDER_W < CTRL_CFG_SPEC > { IT_ORDER_W :: new (self , 5) }
#[doc = "Bit 6 - RW, SPI master input delay enable"]
#[inline (always)] pub fn st_dly_en (& mut self) -> ST_DLY_EN_W < CTRL_CFG_SPEC > { ST_DLY_EN_W :: new (self , 6) } }
#[doc = "RW, SPI1 configuration control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CTRL_CFG_SPEC ; impl crate :: RegisterSpec for CTRL_CFG_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`ctrl_cfg::R`](R) reader structure"] impl crate :: Readable for CTRL_CFG_SPEC { }
#[doc = "`write(|w| ..)` method takes [`ctrl_cfg::W`](W) writer structure"] impl crate :: Writable for CTRL_CFG_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL_CFG to value 0"] impl crate :: Resettable for CTRL_CFG_SPEC { } }
#[doc = "INTER_EN (rw) register accessor: RW, SPI1 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`inter_en::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inter_en::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@inter_en`] module"] pub type INTER_EN = crate :: Reg < inter_en :: INTER_EN_SPEC > ;
#[doc = "RW, SPI1 interrupt enable"] pub mod inter_en {
#[doc = "Register `INTER_EN` reader"] pub type R = crate :: R < INTER_EN_SPEC > ;
#[doc = "Register `INTER_EN` writer"] pub type W = crate :: W < INTER_EN_SPEC > ;
#[doc = "Field `E_CNT_END` reader - RW, enable interrupt for SPI total byte count end"] pub type E_CNT_END_R = crate :: BitReader ;
#[doc = "Field `E_CNT_END` writer - RW, enable interrupt for SPI total byte count end"] pub type E_CNT_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_BYTE_END` reader - RW, enable interrupt for SPI byte exchanged"] pub type E_BYTE_END_R = crate :: BitReader ;
#[doc = "Field `E_BYTE_END` writer - RW, enable interrupt for SPI byte exchanged"] pub type E_BYTE_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_FIFO_HF` reader - RW, enable interrupt for SPI FIFO half"] pub type E_FIFO_HF_R = crate :: BitReader ;
#[doc = "Field `E_FIFO_HF` writer - RW, enable interrupt for SPI FIFO half"] pub type E_FIFO_HF_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_DMA_END` reader - RW, enable interrupt for SPI0 DMA completion"] pub type E_DMA_END_R = crate :: BitReader ;
#[doc = "Field `E_DMA_END` writer - RW, enable interrupt for SPI0 DMA completion"] pub type E_DMA_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_FIFO_OV` reader - RW, enable interrupt for SPI0 FIFO overflow"] pub type E_FIFO_OV_R = crate :: BitReader ;
#[doc = "Field `E_FIFO_OV` writer - RW, enable interrupt for SPI0 FIFO overflow"] pub type E_FIFO_OV_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `E_FST_BYTE` reader - RW, enable interrupt for SPI0 slave mode first byte received"] pub type E_FST_BYTE_R = crate :: BitReader ;
#[doc = "Field `E_FST_BYTE` writer - RW, enable interrupt for SPI0 slave mode first byte received"] pub type E_FST_BYTE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, enable interrupt for SPI total byte count end"]
#[inline (always)] pub fn e_cnt_end (& self) -> E_CNT_END_R { E_CNT_END_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, enable interrupt for SPI byte exchanged"]
#[inline (always)] pub fn e_byte_end (& self) -> E_BYTE_END_R { E_BYTE_END_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW, enable interrupt for SPI FIFO half"]
#[inline (always)] pub fn e_fifo_hf (& self) -> E_FIFO_HF_R { E_FIFO_HF_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, enable interrupt for SPI0 DMA completion"]
#[inline (always)] pub fn e_dma_end (& self) -> E_DMA_END_R { E_DMA_END_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW, enable interrupt for SPI0 FIFO overflow"]
#[inline (always)] pub fn e_fifo_ov (& self) -> E_FIFO_OV_R { E_FIFO_OV_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 7 - RW, enable interrupt for SPI0 slave mode first byte received"]
#[inline (always)] pub fn e_fst_byte (& self) -> E_FST_BYTE_R { E_FST_BYTE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, enable interrupt for SPI total byte count end"]
#[inline (always)] pub fn e_cnt_end (& mut self) -> E_CNT_END_W < INTER_EN_SPEC > { E_CNT_END_W :: new (self , 0) }
#[doc = "Bit 1 - RW, enable interrupt for SPI byte exchanged"]
#[inline (always)] pub fn e_byte_end (& mut self) -> E_BYTE_END_W < INTER_EN_SPEC > { E_BYTE_END_W :: new (self , 1) }
#[doc = "Bit 2 - RW, enable interrupt for SPI FIFO half"]
#[inline (always)] pub fn e_fifo_hf (& mut self) -> E_FIFO_HF_W < INTER_EN_SPEC > { E_FIFO_HF_W :: new (self , 2) }
#[doc = "Bit 3 - RW, enable interrupt for SPI0 DMA completion"]
#[inline (always)] pub fn e_dma_end (& mut self) -> E_DMA_END_W < INTER_EN_SPEC > { E_DMA_END_W :: new (self , 3) }
#[doc = "Bit 4 - RW, enable interrupt for SPI0 FIFO overflow"]
#[inline (always)] pub fn e_fifo_ov (& mut self) -> E_FIFO_OV_W < INTER_EN_SPEC > { E_FIFO_OV_W :: new (self , 4) }
#[doc = "Bit 7 - RW, enable interrupt for SPI0 slave mode first byte received"]
#[inline (always)] pub fn e_fst_byte (& mut self) -> E_FST_BYTE_W < INTER_EN_SPEC > { E_FST_BYTE_W :: new (self , 7) } }
#[doc = "RW, SPI1 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`inter_en::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`inter_en::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INTER_EN_SPEC ; impl crate :: RegisterSpec for INTER_EN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`inter_en::R`](R) reader structure"] impl crate :: Readable for INTER_EN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`inter_en::W`](W) writer structure"] impl crate :: Writable for INTER_EN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INTER_EN to value 0"] impl crate :: Resettable for INTER_EN_SPEC { } }
#[doc = "CLOCK_DIV (rw) register accessor: RW, SPI1 master clock divisor\n\nYou can [`read`](crate::Reg::read) this register and get [`clock_div::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clock_div::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clock_div`] module"] pub type CLOCK_DIV = crate :: Reg < clock_div :: CLOCK_DIV_SPEC > ;
#[doc = "RW, SPI1 master clock divisor"] pub mod clock_div {
#[doc = "Register `CLOCK_DIV` reader"] pub type R = crate :: R < CLOCK_DIV_SPEC > ;
#[doc = "Register `CLOCK_DIV` writer"] pub type W = crate :: W < CLOCK_DIV_SPEC > ;
#[doc = "Field `CLOCK_DIV` reader - RW, SPI1 master clock divisor"] pub type CLOCK_DIV_R = crate :: FieldReader ;
#[doc = "Field `CLOCK_DIV` writer - RW, SPI1 master clock divisor"] pub type CLOCK_DIV_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW, SPI1 master clock divisor"]
#[inline (always)] pub fn clock_div (& self) -> CLOCK_DIV_R { CLOCK_DIV_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RW, SPI1 master clock divisor"]
#[inline (always)] pub fn clock_div (& mut self) -> CLOCK_DIV_W < CLOCK_DIV_SPEC > { CLOCK_DIV_W :: new (self , 0) } }
#[doc = "RW, SPI1 master clock divisor\n\nYou can [`read`](crate::Reg::read) this register and get [`clock_div::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clock_div::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CLOCK_DIV_SPEC ; impl crate :: RegisterSpec for CLOCK_DIV_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`clock_div::R`](R) reader structure"] impl crate :: Readable for CLOCK_DIV_SPEC { }
#[doc = "`write(|w| ..)` method takes [`clock_div::W`](W) writer structure"] impl crate :: Writable for CLOCK_DIV_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CLOCK_DIV to value 0x10"] impl crate :: Resettable for CLOCK_DIV_SPEC { const RESET_VALUE : u8 = 0x10 ; } }
#[doc = "SLAVE_PRE (rw) register accessor: RW, SPI1 slave preset value\n\nYou can [`read`](crate::Reg::read) this register and get [`slave_pre::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slave_pre::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@slave_pre`] module"] pub type SLAVE_PRE = crate :: Reg < slave_pre :: SLAVE_PRE_SPEC > ;
#[doc = "RW, SPI1 slave preset value"] pub mod slave_pre {
#[doc = "Register `SLAVE_PRE` reader"] pub type R = crate :: R < SLAVE_PRE_SPEC > ;
#[doc = "Register `SLAVE_PRE` writer"] pub type W = crate :: W < SLAVE_PRE_SPEC > ;
#[doc = "Field `SLAVE_PRE` reader - RW, SPI1 slave preset value"] pub type SLAVE_PRE_R = crate :: FieldReader ;
#[doc = "Field `SLAVE_PRE` writer - RW, SPI1 slave preset value"] pub type SLAVE_PRE_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW, SPI1 slave preset value"]
#[inline (always)] pub fn slave_pre (& self) -> SLAVE_PRE_R { SLAVE_PRE_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RW, SPI1 slave preset value"]
#[inline (always)] pub fn slave_pre (& mut self) -> SLAVE_PRE_W < SLAVE_PRE_SPEC > { SLAVE_PRE_W :: new (self , 0) } }
#[doc = "RW, SPI1 slave preset value\n\nYou can [`read`](crate::Reg::read) this register and get [`slave_pre::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`slave_pre::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SLAVE_PRE_SPEC ; impl crate :: RegisterSpec for SLAVE_PRE_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`slave_pre::R`](R) reader structure"] impl crate :: Readable for SLAVE_PRE_SPEC { }
#[doc = "`write(|w| ..)` method takes [`slave_pre::W`](W) writer structure"] impl crate :: Writable for SLAVE_PRE_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SLAVE_PRE to value 0x10"] impl crate :: Resettable for SLAVE_PRE_SPEC { const RESET_VALUE : u8 = 0x10 ; } }
#[doc = "BUFFER (rw) register accessor: RW, SPI1 data buffer\n\nYou can [`read`](crate::Reg::read) this register and get [`buffer::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`buffer::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@buffer`] module"] pub type BUFFER = crate :: Reg < buffer :: BUFFER_SPEC > ;
#[doc = "RW, SPI1 data buffer"] pub mod buffer {
#[doc = "Register `BUFFER` reader"] pub type R = crate :: R < BUFFER_SPEC > ;
#[doc = "Register `BUFFER` writer"] pub type W = crate :: W < BUFFER_SPEC > ;
#[doc = "Field `BUFFER` reader - RW, SPI1 data buffer"] pub type BUFFER_R = crate :: FieldReader ;
#[doc = "Field `BUFFER` writer - RW, SPI1 data buffer"] pub type BUFFER_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW, SPI1 data buffer"]
#[inline (always)] pub fn buffer (& self) -> BUFFER_R { BUFFER_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RW, SPI1 data buffer"]
#[inline (always)] pub fn buffer (& mut self) -> BUFFER_W < BUFFER_SPEC > { BUFFER_W :: new (self , 0) } }
#[doc = "RW, SPI1 data buffer\n\nYou can [`read`](crate::Reg::read) this register and get [`buffer::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`buffer::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct BUFFER_SPEC ; impl crate :: RegisterSpec for BUFFER_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`buffer::R`](R) reader structure"] impl crate :: Readable for BUFFER_SPEC { }
#[doc = "`write(|w| ..)` method takes [`buffer::W`](W) writer structure"] impl crate :: Writable for BUFFER_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets BUFFER to value 0"] impl crate :: Resettable for BUFFER_SPEC { } }
#[doc = "RUN_FLAG (r) register accessor: RO, SPI1 work flag\n\nYou can [`read`](crate::Reg::read) this register and get [`run_flag::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@run_flag`] module"] pub type RUN_FLAG = crate :: Reg < run_flag :: RUN_FLAG_SPEC > ;
#[doc = "RO, SPI1 work flag"] pub mod run_flag {
#[doc = "Register `RUN_FLAG` reader"] pub type R = crate :: R < RUN_FLAG_SPEC > ;
#[doc = "Field `LV_CMD_ACT` reader - RO, SPI0 slave first byte or command flag"] pub type LV_CMD_ACT_R = crate :: BitReader ;
#[doc = "Field `IFO_READY` reader - RO, SPI FIFO ready status"] pub type IFO_READY_R = crate :: BitReader ;
#[doc = "Field `LV_CS_LOAD` reader - RO, SPI0 slave chip-select loading status"] pub type LV_CS_LOAD_R = crate :: BitReader ;
#[doc = "Field `LV_SELECT` reader - RO, SPI0 slave selection status"] pub type LV_SELECT_R = crate :: BitReader ; impl R {
#[doc = "Bit 4 - RO, SPI0 slave first byte or command flag"]
#[inline (always)] pub fn lv_cmd_act (& self) -> LV_CMD_ACT_R { LV_CMD_ACT_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RO, SPI FIFO ready status"]
#[inline (always)] pub fn ifo_ready (& self) -> IFO_READY_R { IFO_READY_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RO, SPI0 slave chip-select loading status"]
#[inline (always)] pub fn lv_cs_load (& self) -> LV_CS_LOAD_R { LV_CS_LOAD_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RO, SPI0 slave selection status"]
#[inline (always)] pub fn lv_select (& self) -> LV_SELECT_R { LV_SELECT_R :: new (((self . bits >> 7) & 1) != 0) } }
#[doc = "RO, SPI1 work flag\n\nYou can [`read`](crate::Reg::read) this register and get [`run_flag::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RUN_FLAG_SPEC ; impl crate :: RegisterSpec for RUN_FLAG_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`run_flag::R`](R) reader structure"] impl crate :: Readable for RUN_FLAG_SPEC { }
#[doc = "`reset()` method sets RUN_FLAG to value 0"] impl crate :: Resettable for RUN_FLAG_SPEC { } }
#[doc = "INT_FLAG (rw) register accessor: RW1, SPI1 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_flag`] module"] pub type INT_FLAG = crate :: Reg < int_flag :: INT_FLAG_SPEC > ;
#[doc = "RW1, SPI1 interrupt flag"] pub mod int_flag {
#[doc = "Register `INT_FLAG` reader"] pub type R = crate :: R < INT_FLAG_SPEC > ;
#[doc = "Register `INT_FLAG` writer"] pub type W = crate :: W < INT_FLAG_SPEC > ;
#[doc = "Field `F_CNT_END` reader - RW1, interrupt flag for SPI total byte count end"] pub type F_CNT_END_R = crate :: BitReader ;
#[doc = "Field `F_CNT_END` writer - RW1, interrupt flag for SPI total byte count end"] pub type F_CNT_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_BYTE_END` reader - RW1, interrupt flag for SPI byte exchanged"] pub type F_BYTE_END_R = crate :: BitReader ;
#[doc = "Field `F_BYTE_END` writer - RW1, interrupt flag for SPI byte exchanged"] pub type F_BYTE_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_FIFO_HF` reader - RW1, interrupt flag for SPI FIFO half"] pub type F_FIFO_HF_R = crate :: BitReader ;
#[doc = "Field `F_FIFO_HF` writer - RW1, interrupt flag for SPI FIFO half"] pub type F_FIFO_HF_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_DMA_END` reader - RW1, interrupt flag for SPI0 DMA completion"] pub type F_DMA_END_R = crate :: BitReader ;
#[doc = "Field `F_DMA_END` writer - RW1, interrupt flag for SPI0 DMA completion"] pub type F_DMA_END_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_FIFO_OV` reader - RW1, interrupt flag for SPI0 FIFO overflow"] pub type F_FIFO_OV_R = crate :: BitReader ;
#[doc = "Field `F_FIFO_OV` writer - RW1, interrupt flag for SPI0 FIFO overflow"] pub type F_FIFO_OV_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `REE` reader - RO, current SPI free status"] pub type REE_R = crate :: BitReader ;
#[doc = "Field `REE` writer - RO, current SPI free status"] pub type REE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_FST_BYTE` reader - RW1, interrupt flag for SPI0 slave mode first byte received"] pub type F_FST_BYTE_R = crate :: BitReader ;
#[doc = "Field `F_FST_BYTE` writer - RW1, interrupt flag for SPI0 slave mode first byte received"] pub type F_FST_BYTE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW1, interrupt flag for SPI total byte count end"]
#[inline (always)] pub fn f_cnt_end (& self) -> F_CNT_END_R { F_CNT_END_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW1, interrupt flag for SPI byte exchanged"]
#[inline (always)] pub fn f_byte_end (& self) -> F_BYTE_END_R { F_BYTE_END_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW1, interrupt flag for SPI FIFO half"]
#[inline (always)] pub fn f_fifo_hf (& self) -> F_FIFO_HF_R { F_FIFO_HF_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW1, interrupt flag for SPI0 DMA completion"]
#[inline (always)] pub fn f_dma_end (& self) -> F_DMA_END_R { F_DMA_END_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW1, interrupt flag for SPI0 FIFO overflow"]
#[inline (always)] pub fn f_fifo_ov (& self) -> F_FIFO_OV_R { F_FIFO_OV_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - RO, current SPI free status"]
#[inline (always)] pub fn ree (& self) -> REE_R { REE_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RW1, interrupt flag for SPI0 slave mode first byte received"]
#[inline (always)] pub fn f_fst_byte (& self) -> F_FST_BYTE_R { F_FST_BYTE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW1, interrupt flag for SPI total byte count end"]
#[inline (always)] pub fn f_cnt_end (& mut self) -> F_CNT_END_W < INT_FLAG_SPEC > { F_CNT_END_W :: new (self , 0) }
#[doc = "Bit 1 - RW1, interrupt flag for SPI byte exchanged"]
#[inline (always)] pub fn f_byte_end (& mut self) -> F_BYTE_END_W < INT_FLAG_SPEC > { F_BYTE_END_W :: new (self , 1) }
#[doc = "Bit 2 - RW1, interrupt flag for SPI FIFO half"]
#[inline (always)] pub fn f_fifo_hf (& mut self) -> F_FIFO_HF_W < INT_FLAG_SPEC > { F_FIFO_HF_W :: new (self , 2) }
#[doc = "Bit 3 - RW1, interrupt flag for SPI0 DMA completion"]
#[inline (always)] pub fn f_dma_end (& mut self) -> F_DMA_END_W < INT_FLAG_SPEC > { F_DMA_END_W :: new (self , 3) }
#[doc = "Bit 4 - RW1, interrupt flag for SPI0 FIFO overflow"]
#[inline (always)] pub fn f_fifo_ov (& mut self) -> F_FIFO_OV_W < INT_FLAG_SPEC > { F_FIFO_OV_W :: new (self , 4) }
#[doc = "Bit 6 - RO, current SPI free status"]
#[inline (always)] pub fn ree (& mut self) -> REE_W < INT_FLAG_SPEC > { REE_W :: new (self , 6) }
#[doc = "Bit 7 - RW1, interrupt flag for SPI0 slave mode first byte received"]
#[inline (always)] pub fn f_fst_byte (& mut self) -> F_FST_BYTE_W < INT_FLAG_SPEC > { F_FST_BYTE_W :: new (self , 7) } }
#[doc = "RW1, SPI1 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_FLAG_SPEC ; impl crate :: RegisterSpec for INT_FLAG_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`int_flag::R`](R) reader structure"] impl crate :: Readable for INT_FLAG_SPEC { }
#[doc = "`write(|w| ..)` method takes [`int_flag::W`](W) writer structure"] impl crate :: Writable for INT_FLAG_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INT_FLAG to value 0x40"] impl crate :: Resettable for INT_FLAG_SPEC { const RESET_VALUE : u8 = 0x40 ; } }
#[doc = "FIFO_COUNT (r) register accessor: RO, SPI1 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo_count`] module"] pub type FIFO_COUNT = crate :: Reg < fifo_count :: FIFO_COUNT_SPEC > ;
#[doc = "RO, SPI1 FIFO count status"] pub mod fifo_count {
#[doc = "Register `FIFO_COUNT` reader"] pub type R = crate :: R < FIFO_COUNT_SPEC > ;
#[doc = "Field `FIFO_COUNT` reader - RO, SPI0 FIFO count status"] pub type FIFO_COUNT_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RO, SPI0 FIFO count status"]
#[inline (always)] pub fn fifo_count (& self) -> FIFO_COUNT_R { FIFO_COUNT_R :: new (self . bits) } }
#[doc = "RO, SPI1 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FIFO_COUNT_SPEC ; impl crate :: RegisterSpec for FIFO_COUNT_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`fifo_count::R`](R) reader structure"] impl crate :: Readable for FIFO_COUNT_SPEC { }
#[doc = "`reset()` method sets FIFO_COUNT to value 0"] impl crate :: Resettable for FIFO_COUNT_SPEC { } }
#[doc = "TOTAL_CNT (rw) register accessor: RW, SPI1 total byte count, only low 12 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`total_cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`total_cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@total_cnt`] module"] pub type TOTAL_CNT = crate :: Reg < total_cnt :: TOTAL_CNT_SPEC > ;
#[doc = "RW, SPI1 total byte count, only low 12 bit"] pub mod total_cnt {
#[doc = "Register `TOTAL_CNT` reader"] pub type R = crate :: R < TOTAL_CNT_SPEC > ;
#[doc = "Register `TOTAL_CNT` writer"] pub type W = crate :: W < TOTAL_CNT_SPEC > ;
#[doc = "Field `TOTAL_CNT` reader - RW, SPI1 total byte count, only low 12 bit"] pub type TOTAL_CNT_R = crate :: FieldReader < u16 > ;
#[doc = "Field `TOTAL_CNT` writer - RW, SPI1 total byte count, only low 12 bit"] pub type TOTAL_CNT_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW, SPI1 total byte count, only low 12 bit"]
#[inline (always)] pub fn total_cnt (& self) -> TOTAL_CNT_R { TOTAL_CNT_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW, SPI1 total byte count, only low 12 bit"]
#[inline (always)] pub fn total_cnt (& mut self) -> TOTAL_CNT_W < TOTAL_CNT_SPEC > { TOTAL_CNT_W :: new (self , 0) } }
#[doc = "RW, SPI1 total byte count, only low 12 bit\n\nYou can [`read`](crate::Reg::read) this register and get [`total_cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`total_cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct TOTAL_CNT_SPEC ; impl crate :: RegisterSpec for TOTAL_CNT_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`total_cnt::R`](R) reader structure"] impl crate :: Readable for TOTAL_CNT_SPEC { }
#[doc = "`write(|w| ..)` method takes [`total_cnt::W`](W) writer structure"] impl crate :: Writable for TOTAL_CNT_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets TOTAL_CNT to value 0"] impl crate :: Resettable for TOTAL_CNT_SPEC { } }
#[doc = "FIFO (rw) register accessor: RO/WO, SPI1 FIFO register\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fifo::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo`] module"] pub type FIFO = crate :: Reg < fifo :: FIFO_SPEC > ;
#[doc = "RO/WO, SPI1 FIFO register"] pub mod fifo {
#[doc = "Register `FIFO` reader"] pub type R = crate :: R < FIFO_SPEC > ;
#[doc = "Register `FIFO` writer"] pub type W = crate :: W < FIFO_SPEC > ;
#[doc = "Field `FIFO` reader - RO/WO, SPI1 FIFO register"] pub type FIFO_R = crate :: FieldReader ;
#[doc = "Field `FIFO` writer - RO/WO, SPI1 FIFO register"] pub type FIFO_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RO/WO, SPI1 FIFO register"]
#[inline (always)] pub fn fifo (& self) -> FIFO_R { FIFO_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RO/WO, SPI1 FIFO register"]
#[inline (always)] pub fn fifo (& mut self) -> FIFO_W < FIFO_SPEC > { FIFO_W :: new (self , 0) } }
#[doc = "RO/WO, SPI1 FIFO register\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fifo::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FIFO_SPEC ; impl crate :: RegisterSpec for FIFO_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`fifo::R`](R) reader structure"] impl crate :: Readable for FIFO_SPEC { }
#[doc = "`write(|w| ..)` method takes [`fifo::W`](W) writer structure"] impl crate :: Writable for FIFO_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FIFO to value 0"] impl crate :: Resettable for FIFO_SPEC { } }
#[doc = "FIFO_COUNT1 (r) register accessor: RO, SPI1 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count1::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fifo_count1`] module"] pub type FIFO_COUNT1 = crate :: Reg < fifo_count1 :: FIFO_COUNT1_SPEC > ;
#[doc = "RO, SPI1 FIFO count status"] pub mod fifo_count1 {
#[doc = "Register `FIFO_COUNT1` reader"] pub type R = crate :: R < FIFO_COUNT1_SPEC > ;
#[doc = "Field `FIFO_COUNT1` reader - RO, SPI1 FIFO count status"] pub type FIFO_COUNT1_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RO, SPI1 FIFO count status"]
#[inline (always)] pub fn fifo_count1 (& self) -> FIFO_COUNT1_R { FIFO_COUNT1_R :: new (self . bits) } }
#[doc = "RO, SPI1 FIFO count status\n\nYou can [`read`](crate::Reg::read) this register and get [`fifo_count1::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FIFO_COUNT1_SPEC ; impl crate :: RegisterSpec for FIFO_COUNT1_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`fifo_count1::R`](R) reader structure"] impl crate :: Readable for FIFO_COUNT1_SPEC { }
#[doc = "`reset()` method sets FIFO_COUNT1 to value 0"] impl crate :: Resettable for FIFO_COUNT1_SPEC { } } }
#[doc = "I2C register"] pub type I2C = crate :: Periph < i2c :: RegisterBlock , 0x4000_4800 > ; impl core :: fmt :: Debug for I2C { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2C") . finish () } }
#[doc = "I2C register"] pub mod i2c {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ctrl1 : CTRL1 , _reserved1 : [u8 ; 0x02] , ctrl2 : CTRL2 , _reserved2 : [u8 ; 0x02] , oaddr1 : OADDR1 , _reserved3 : [u8 ; 0x02] , oaddr2 : OADDR2 , _reserved4 : [u8 ; 0x02] , datar : DATAR , _reserved5 : [u8 ; 0x02] , star1 : STAR1 , _reserved6 : [u8 ; 0x02] , _reserved_6_pec : [u8 ; 0x02] , _reserved7 : [u8 ; 0x02] , ckcfgr : CKCFGR , _reserved8 : [u8 ; 0x02] , rtr : RTR , } impl RegisterBlock {
#[doc = "0x00 - RW, I2C control 1"]
#[inline (always)] pub const fn ctrl1 (& self) -> & CTRL1 { & self . ctrl1 }
#[doc = "0x04 - RW, I2C control 2"]
#[inline (always)] pub const fn ctrl2 (& self) -> & CTRL2 { & self . ctrl2 }
#[doc = "0x08 - RW, I2C own address register 1"]
#[inline (always)] pub const fn oaddr1 (& self) -> & OADDR1 { & self . oaddr1 }
#[doc = "0x0c - RW, I2C own address register 2"]
#[inline (always)] pub const fn oaddr2 (& self) -> & OADDR2 { & self . oaddr2 }
#[doc = "0x10 - RW, I2C data register"]
#[inline (always)] pub const fn datar (& self) -> & DATAR { & self . datar }
#[doc = "0x14 - R0, I2C stauts register 1"]
#[inline (always)] pub const fn star1 (& self) -> & STAR1 { & self . star1 }
#[doc = "0x18 - R0, I2C status register 2"]
#[inline (always)] pub const fn star2 (& self) -> & STAR2 { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x19 - R0, I2C Packet error checking register"]
#[inline (always)] pub const fn pec (& self) -> & PEC { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (25) . cast () } }
#[doc = "0x1c - RW, I2C clock control register"]
#[inline (always)] pub const fn ckcfgr (& self) -> & CKCFGR { & self . ckcfgr }
#[doc = "0x20 - RW, I2C trise register"]
#[inline (always)] pub const fn rtr (& self) -> & RTR { & self . rtr } }
#[doc = "CTRL1 (rw) register accessor: RW, I2C control 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl1`] module"] pub type CTRL1 = crate :: Reg < ctrl1 :: CTRL1_SPEC > ;
#[doc = "RW, I2C control 1"] pub mod ctrl1 {
#[doc = "Register `CTRL1` reader"] pub type R = crate :: R < CTRL1_SPEC > ;
#[doc = "Register `CTRL1` writer"] pub type W = crate :: W < CTRL1_SPEC > ;
#[doc = "Field `PE` reader - RW, Peripheral enable"] pub type PE_R = crate :: BitReader ;
#[doc = "Field `PE` writer - RW, Peripheral enable"] pub type PE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SMBUS` reader - RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode"] pub type SMBUS_R = crate :: BitReader ;
#[doc = "Field `SMBUS` writer - RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode"] pub type SMBUS_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SMBTYPE` reader - RW, SMBus type: 0=Device, 1=Host"] pub type SMBTYPE_R = crate :: BitReader ;
#[doc = "Field `SMBTYPE` writer - RW, SMBus type: 0=Device, 1=Host"] pub type SMBTYPE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `EBARP` reader - RW, ARP enable"] pub type EBARP_R = crate :: BitReader ;
#[doc = "Field `EBARP` writer - RW, ARP enable"] pub type EBARP_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ENPEC` reader - RW, PEC ebable"] pub type ENPEC_R = crate :: BitReader ;
#[doc = "Field `ENPEC` writer - RW, PEC ebable"] pub type ENPEC_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ENGC` reader - RW, General call enable"] pub type ENGC_R = crate :: BitReader ;
#[doc = "Field `ENGC` writer - RW, General call enable"] pub type ENGC_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `NOSTRETCH` reader - RW, Clock stretching disable (Slave mode)"] pub type NOSTRETCH_R = crate :: BitReader ;
#[doc = "Field `NOSTRETCH` writer - RW, Clock stretching disable (Slave mode)"] pub type NOSTRETCH_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `START` reader - RW, Start generation: master mode: 0=no start, 1=repeated start; slave mode: 0=no start, 1=start at bus free"] pub type START_R = crate :: BitReader ;
#[doc = "Field `START` writer - RW, Start generation: master mode: 0=no start, 1=repeated start; slave mode: 0=no start, 1=start at bus free"] pub type START_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STOP` reader - RW, Stop generation: master mode: 0=no stop, 1=stop after the current byte transfer or after the current Start condition is sent; slave mode: 0=no stop, 1=Release the SCL and SDA lines after the current byte transfer"] pub type STOP_R = crate :: BitReader ;
#[doc = "Field `STOP` writer - RW, Stop generation: master mode: 0=no stop, 1=stop after the current byte transfer or after the current Start condition is sent; slave mode: 0=no stop, 1=Release the SCL and SDA lines after the current byte transfer"] pub type STOP_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ACK` reader - RW, Acknowledge enable"] pub type ACK_R = crate :: BitReader ;
#[doc = "Field `ACK` writer - RW, Acknowledge enable"] pub type ACK_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `POS` reader - RW, Acknowledge/PEC Position (for data reception)"] pub type POS_R = crate :: BitReader ;
#[doc = "Field `POS` writer - RW, Acknowledge/PEC Position (for data reception)"] pub type POS_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PEC` reader - RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer (in Tx or Rx mode)"] pub type PEC_R = crate :: BitReader ;
#[doc = "Field `PEC` writer - RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer (in Tx or Rx mode)"] pub type PEC_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ALERT` reader - RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin low."] pub type ALERT_R = crate :: BitReader ;
#[doc = "Field `ALERT` writer - RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin low."] pub type ALERT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWRST` reader - RW, Software reset"] pub type SWRST_R = crate :: BitReader ;
#[doc = "Field `SWRST` writer - RW, Software reset"] pub type SWRST_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, Peripheral enable"]
#[inline (always)] pub fn pe (& self) -> PE_R { PE_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode"]
#[inline (always)] pub fn smbus (& self) -> SMBUS_R { SMBUS_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 3 - RW, SMBus type: 0=Device, 1=Host"]
#[inline (always)] pub fn smbtype (& self) -> SMBTYPE_R { SMBTYPE_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW, ARP enable"]
#[inline (always)] pub fn ebarp (& self) -> EBARP_R { EBARP_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RW, PEC ebable"]
#[inline (always)] pub fn enpec (& self) -> ENPEC_R { ENPEC_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RW, General call enable"]
#[inline (always)] pub fn engc (& self) -> ENGC_R { ENGC_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RW, Clock stretching disable (Slave mode)"]
#[inline (always)] pub fn nostretch (& self) -> NOSTRETCH_R { NOSTRETCH_R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - RW, Start generation: master mode: 0=no start, 1=repeated start; slave mode: 0=no start, 1=start at bus free"]
#[inline (always)] pub fn start (& self) -> START_R { START_R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - RW, Stop generation: master mode: 0=no stop, 1=stop after the current byte transfer or after the current Start condition is sent; slave mode: 0=no stop, 1=Release the SCL and SDA lines after the current byte transfer"]
#[inline (always)] pub fn stop (& self) -> STOP_R { STOP_R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - RW, Acknowledge enable"]
#[inline (always)] pub fn ack (& self) -> ACK_R { ACK_R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - RW, Acknowledge/PEC Position (for data reception)"]
#[inline (always)] pub fn pos (& self) -> POS_R { POS_R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer (in Tx or Rx mode)"]
#[inline (always)] pub fn pec (& self) -> PEC_R { PEC_R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin low."]
#[inline (always)] pub fn alert (& self) -> ALERT_R { ALERT_R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 15 - RW, Software reset"]
#[inline (always)] pub fn swrst (& self) -> SWRST_R { SWRST_R :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, Peripheral enable"]
#[inline (always)] pub fn pe (& mut self) -> PE_W < CTRL1_SPEC > { PE_W :: new (self , 0) }
#[doc = "Bit 1 - RW, SMBUS mode: 0=I2C mode, 1=SMBUS mode"]
#[inline (always)] pub fn smbus (& mut self) -> SMBUS_W < CTRL1_SPEC > { SMBUS_W :: new (self , 1) }
#[doc = "Bit 3 - RW, SMBus type: 0=Device, 1=Host"]
#[inline (always)] pub fn smbtype (& mut self) -> SMBTYPE_W < CTRL1_SPEC > { SMBTYPE_W :: new (self , 3) }
#[doc = "Bit 4 - RW, ARP enable"]
#[inline (always)] pub fn ebarp (& mut self) -> EBARP_W < CTRL1_SPEC > { EBARP_W :: new (self , 4) }
#[doc = "Bit 5 - RW, PEC ebable"]
#[inline (always)] pub fn enpec (& mut self) -> ENPEC_W < CTRL1_SPEC > { ENPEC_W :: new (self , 5) }
#[doc = "Bit 6 - RW, General call enable"]
#[inline (always)] pub fn engc (& mut self) -> ENGC_W < CTRL1_SPEC > { ENGC_W :: new (self , 6) }
#[doc = "Bit 7 - RW, Clock stretching disable (Slave mode)"]
#[inline (always)] pub fn nostretch (& mut self) -> NOSTRETCH_W < CTRL1_SPEC > { NOSTRETCH_W :: new (self , 7) }
#[doc = "Bit 8 - RW, Start generation: master mode: 0=no start, 1=repeated start; slave mode: 0=no start, 1=start at bus free"]
#[inline (always)] pub fn start (& mut self) -> START_W < CTRL1_SPEC > { START_W :: new (self , 8) }
#[doc = "Bit 9 - RW, Stop generation: master mode: 0=no stop, 1=stop after the current byte transfer or after the current Start condition is sent; slave mode: 0=no stop, 1=Release the SCL and SDA lines after the current byte transfer"]
#[inline (always)] pub fn stop (& mut self) -> STOP_W < CTRL1_SPEC > { STOP_W :: new (self , 9) }
#[doc = "Bit 10 - RW, Acknowledge enable"]
#[inline (always)] pub fn ack (& mut self) -> ACK_W < CTRL1_SPEC > { ACK_W :: new (self , 10) }
#[doc = "Bit 11 - RW, Acknowledge/PEC Position (for data reception)"]
#[inline (always)] pub fn pos (& mut self) -> POS_W < CTRL1_SPEC > { POS_W :: new (self , 11) }
#[doc = "Bit 12 - RW, Packet error checking: 0=No PEC transfer, 1=PEC transfer (in Tx or Rx mode)"]
#[inline (always)] pub fn pec (& mut self) -> PEC_W < CTRL1_SPEC > { PEC_W :: new (self , 12) }
#[doc = "Bit 13 - RW, SMBus alert: 0=Releases SMBA pin high, 1=Drives SMBA pin low."]
#[inline (always)] pub fn alert (& mut self) -> ALERT_W < CTRL1_SPEC > { ALERT_W :: new (self , 13) }
#[doc = "Bit 15 - RW, Software reset"]
#[inline (always)] pub fn swrst (& mut self) -> SWRST_W < CTRL1_SPEC > { SWRST_W :: new (self , 15) } }
#[doc = "RW, I2C control 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CTRL1_SPEC ; impl crate :: RegisterSpec for CTRL1_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`ctrl1::R`](R) reader structure"] impl crate :: Readable for CTRL1_SPEC { }
#[doc = "`write(|w| ..)` method takes [`ctrl1::W`](W) writer structure"] impl crate :: Writable for CTRL1_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL1 to value 0"] impl crate :: Resettable for CTRL1_SPEC { } }
#[doc = "CTRL2 (rw) register accessor: RW, I2C control 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl2`] module"] pub type CTRL2 = crate :: Reg < ctrl2 :: CTRL2_SPEC > ;
#[doc = "RW, I2C control 2"] pub mod ctrl2 {
#[doc = "Register `CTRL2` reader"] pub type R = crate :: R < CTRL2_SPEC > ;
#[doc = "Register `CTRL2` writer"] pub type W = crate :: W < CTRL2_SPEC > ;
#[doc = "Field `FREQ` reader - RW, Peripheral clock frequency, The minimum allowed frequency is 2 MHz,the maximum frequency is 36 MHz"] pub type FREQ_R = crate :: FieldReader ;
#[doc = "Field `FREQ` writer - RW, Peripheral clock frequency, The minimum allowed frequency is 2 MHz,the maximum frequency is 36 MHz"] pub type FREQ_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ;
#[doc = "Field `ITERREN` reader - RW, Error interrupt enable"] pub type ITERREN_R = crate :: BitReader ;
#[doc = "Field `ITERREN` writer - RW, Error interrupt enable"] pub type ITERREN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ITEVTEN` reader - RW, Event interrupt enable"] pub type ITEVTEN_R = crate :: BitReader ;
#[doc = "Field `ITEVTEN` writer - RW, Event interrupt enable"] pub type ITEVTEN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ITBUFEN` reader - RW, Buffer interrupt enable"] pub type ITBUFEN_R = crate :: BitReader ;
#[doc = "Field `ITBUFEN` writer - RW, Buffer interrupt enable"] pub type ITBUFEN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:5 - RW, Peripheral clock frequency, The minimum allowed frequency is 2 MHz,the maximum frequency is 36 MHz"]
#[inline (always)] pub fn freq (& self) -> FREQ_R { FREQ_R :: new ((self . bits & 0x3f) as u8) }
#[doc = "Bit 8 - RW, Error interrupt enable"]
#[inline (always)] pub fn iterren (& self) -> ITERREN_R { ITERREN_R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - RW, Event interrupt enable"]
#[inline (always)] pub fn itevten (& self) -> ITEVTEN_R { ITEVTEN_R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - RW, Buffer interrupt enable"]
#[inline (always)] pub fn itbufen (& self) -> ITBUFEN_R { ITBUFEN_R :: new (((self . bits >> 10) & 1) != 0) } } impl W {
#[doc = "Bits 0:5 - RW, Peripheral clock frequency, The minimum allowed frequency is 2 MHz,the maximum frequency is 36 MHz"]
#[inline (always)] pub fn freq (& mut self) -> FREQ_W < CTRL2_SPEC > { FREQ_W :: new (self , 0) }
#[doc = "Bit 8 - RW, Error interrupt enable"]
#[inline (always)] pub fn iterren (& mut self) -> ITERREN_W < CTRL2_SPEC > { ITERREN_W :: new (self , 8) }
#[doc = "Bit 9 - RW, Event interrupt enable"]
#[inline (always)] pub fn itevten (& mut self) -> ITEVTEN_W < CTRL2_SPEC > { ITEVTEN_W :: new (self , 9) }
#[doc = "Bit 10 - RW, Buffer interrupt enable"]
#[inline (always)] pub fn itbufen (& mut self) -> ITBUFEN_W < CTRL2_SPEC > { ITBUFEN_W :: new (self , 10) } }
#[doc = "RW, I2C control 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CTRL2_SPEC ; impl crate :: RegisterSpec for CTRL2_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`ctrl2::R`](R) reader structure"] impl crate :: Readable for CTRL2_SPEC { }
#[doc = "`write(|w| ..)` method takes [`ctrl2::W`](W) writer structure"] impl crate :: Writable for CTRL2_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL2 to value 0"] impl crate :: Resettable for CTRL2_SPEC { } }
#[doc = "OADDR1 (rw) register accessor: RW, I2C own address register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`oaddr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`oaddr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@oaddr1`] module"] pub type OADDR1 = crate :: Reg < oaddr1 :: OADDR1_SPEC > ;
#[doc = "RW, I2C own address register 1"] pub mod oaddr1 {
#[doc = "Register `OADDR1` reader"] pub type R = crate :: R < OADDR1_SPEC > ;
#[doc = "Register `OADDR1` writer"] pub type W = crate :: W < OADDR1_SPEC > ;
#[doc = "Field `ADD0` reader - RW, bit0 of address in 10-bit addressing mode"] pub type ADD0_R = crate :: BitReader ;
#[doc = "Field `ADD0` writer - RW, bit0 of address in 10-bit addressing mode"] pub type ADD0_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADD7_1` reader - RW, bit\\[7:1\\] of address"] pub type ADD7_1_R = crate :: FieldReader ;
#[doc = "Field `ADD7_1` writer - RW, bit\\[7:1\\] of address"] pub type ADD7_1_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `ADD9_8` reader - RW, bit\\[9:8\\] of address in 10-bit addressing mode"] pub type ADD9_8_R = crate :: FieldReader ;
#[doc = "Field `ADD9_8` writer - RW, bit\\[9:8\\] of address in 10-bit addressing mode"] pub type ADD9_8_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `MUST1` reader - RW, Should always be kept at 1"] pub type MUST1_R = crate :: BitReader ;
#[doc = "Field `MUST1` writer - RW, Should always be kept at 1"] pub type MUST1_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADDMODE` reader - RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit slave address"] pub type ADDMODE_R = crate :: BitReader ;
#[doc = "Field `ADDMODE` writer - RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit slave address"] pub type ADDMODE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, bit0 of address in 10-bit addressing mode"]
#[inline (always)] pub fn add0 (& self) -> ADD0_R { ADD0_R :: new ((self . bits & 1) != 0) }
#[doc = "Bits 1:7 - RW, bit\\[7:1\\] of address"]
#[inline (always)] pub fn add7_1 (& self) -> ADD7_1_R { ADD7_1_R :: new (((self . bits >> 1) & 0x7f) as u8) }
#[doc = "Bits 8:9 - RW, bit\\[9:8\\] of address in 10-bit addressing mode"]
#[inline (always)] pub fn add9_8 (& self) -> ADD9_8_R { ADD9_8_R :: new (((self . bits >> 8) & 3) as u8) }
#[doc = "Bit 14 - RW, Should always be kept at 1"]
#[inline (always)] pub fn must1 (& self) -> MUST1_R { MUST1_R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit slave address"]
#[inline (always)] pub fn addmode (& self) -> ADDMODE_R { ADDMODE_R :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, bit0 of address in 10-bit addressing mode"]
#[inline (always)] pub fn add0 (& mut self) -> ADD0_W < OADDR1_SPEC > { ADD0_W :: new (self , 0) }
#[doc = "Bits 1:7 - RW, bit\\[7:1\\] of address"]
#[inline (always)] pub fn add7_1 (& mut self) -> ADD7_1_W < OADDR1_SPEC > { ADD7_1_W :: new (self , 1) }
#[doc = "Bits 8:9 - RW, bit\\[9:8\\] of address in 10-bit addressing mode"]
#[inline (always)] pub fn add9_8 (& mut self) -> ADD9_8_W < OADDR1_SPEC > { ADD9_8_W :: new (self , 8) }
#[doc = "Bit 14 - RW, Should always be kept at 1"]
#[inline (always)] pub fn must1 (& mut self) -> MUST1_W < OADDR1_SPEC > { MUST1_W :: new (self , 14) }
#[doc = "Bit 15 - RW, Addressing mode (slave mode): 0=7-bit slave address, 1=10-bit slave address"]
#[inline (always)] pub fn addmode (& mut self) -> ADDMODE_W < OADDR1_SPEC > { ADDMODE_W :: new (self , 15) } }
#[doc = "RW, I2C own address register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`oaddr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`oaddr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OADDR1_SPEC ; impl crate :: RegisterSpec for OADDR1_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`oaddr1::R`](R) reader structure"] impl crate :: Readable for OADDR1_SPEC { }
#[doc = "`write(|w| ..)` method takes [`oaddr1::W`](W) writer structure"] impl crate :: Writable for OADDR1_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OADDR1 to value 0"] impl crate :: Resettable for OADDR1_SPEC { } }
#[doc = "OADDR2 (rw) register accessor: RW, I2C own address register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`oaddr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`oaddr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@oaddr2`] module"] pub type OADDR2 = crate :: Reg < oaddr2 :: OADDR2_SPEC > ;
#[doc = "RW, I2C own address register 2"] pub mod oaddr2 {
#[doc = "Register `OADDR2` reader"] pub type R = crate :: R < OADDR2_SPEC > ;
#[doc = "Register `OADDR2` writer"] pub type W = crate :: W < OADDR2_SPEC > ;
#[doc = "Field `ENDUAL` reader - RW, Dual addressing mode enable"] pub type ENDUAL_R = crate :: BitReader ;
#[doc = "Field `ENDUAL` writer - RW, Dual addressing mode enable"] pub type ENDUAL_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADD2` reader - RW, bit\\[7:1\\] of address2"] pub type ADD2_R = crate :: FieldReader ;
#[doc = "Field `ADD2` writer - RW, bit\\[7:1\\] of address2"] pub type ADD2_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ; impl R {
#[doc = "Bit 0 - RW, Dual addressing mode enable"]
#[inline (always)] pub fn endual (& self) -> ENDUAL_R { ENDUAL_R :: new ((self . bits & 1) != 0) }
#[doc = "Bits 1:7 - RW, bit\\[7:1\\] of address2"]
#[inline (always)] pub fn add2 (& self) -> ADD2_R { ADD2_R :: new (((self . bits >> 1) & 0x7f) as u8) } } impl W {
#[doc = "Bit 0 - RW, Dual addressing mode enable"]
#[inline (always)] pub fn endual (& mut self) -> ENDUAL_W < OADDR2_SPEC > { ENDUAL_W :: new (self , 0) }
#[doc = "Bits 1:7 - RW, bit\\[7:1\\] of address2"]
#[inline (always)] pub fn add2 (& mut self) -> ADD2_W < OADDR2_SPEC > { ADD2_W :: new (self , 1) } }
#[doc = "RW, I2C own address register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`oaddr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`oaddr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct OADDR2_SPEC ; impl crate :: RegisterSpec for OADDR2_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`oaddr2::R`](R) reader structure"] impl crate :: Readable for OADDR2_SPEC { }
#[doc = "`write(|w| ..)` method takes [`oaddr2::W`](W) writer structure"] impl crate :: Writable for OADDR2_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets OADDR2 to value 0"] impl crate :: Resettable for OADDR2_SPEC { } }
#[doc = "DATAR (rw) register accessor: RW, I2C data register\n\nYou can [`read`](crate::Reg::read) this register and get [`datar::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`datar::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@datar`] module"] pub type DATAR = crate :: Reg < datar :: DATAR_SPEC > ;
#[doc = "RW, I2C data register"] pub mod datar {
#[doc = "Register `DATAR` reader"] pub type R = crate :: R < DATAR_SPEC > ;
#[doc = "Register `DATAR` writer"] pub type W = crate :: W < DATAR_SPEC > ;
#[doc = "Field `DATAR` reader - RW, I2C data register"] pub type DATAR_R = crate :: FieldReader ;
#[doc = "Field `DATAR` writer - RW, I2C data register"] pub type DATAR_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW, I2C data register"]
#[inline (always)] pub fn datar (& self) -> DATAR_R { DATAR_R :: new ((self . bits & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - RW, I2C data register"]
#[inline (always)] pub fn datar (& mut self) -> DATAR_W < DATAR_SPEC > { DATAR_W :: new (self , 0) } }
#[doc = "RW, I2C data register\n\nYou can [`read`](crate::Reg::read) this register and get [`datar::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`datar::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DATAR_SPEC ; impl crate :: RegisterSpec for DATAR_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`datar::R`](R) reader structure"] impl crate :: Readable for DATAR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`datar::W`](W) writer structure"] impl crate :: Writable for DATAR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DATAR to value 0"] impl crate :: Resettable for DATAR_SPEC { } }
#[doc = "STAR1 (r) register accessor: R0, I2C stauts register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`star1::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@star1`] module"] pub type STAR1 = crate :: Reg < star1 :: STAR1_SPEC > ;
#[doc = "R0, I2C stauts register 1"] pub mod star1 {
#[doc = "Register `STAR1` reader"] pub type R = crate :: R < STAR1_SPEC > ;
#[doc = "Field `SB` reader - RW0, Start bit flag (Master mode)"] pub type SB_R = crate :: BitReader ;
#[doc = "Field `ADDR` reader - RW0, Address sent (master mode)/matched (slave mode) flag"] pub type ADDR_R = crate :: BitReader ;
#[doc = "Field `BTF` reader - RO, Byte transfer finished flag"] pub type BTF_R = crate :: BitReader ;
#[doc = "Field `ADD10` reader - RO, 10-bit header sent flag (Master mode)"] pub type ADD10_R = crate :: BitReader ;
#[doc = "Field `STOPF` reader - RO, Stop detection flag (slave mode)"] pub type STOPF_R = crate :: BitReader ;
#[doc = "Field `RxNE` reader - RO, Data register not empty flag (receivers)"] pub type RX_NE_R = crate :: BitReader ;
#[doc = "Field `TxE` reader - RO, Data register empty flag (transmitters)"] pub type TX_E_R = crate :: BitReader ;
#[doc = "Field `BERR` reader - RW0, Bus error flag"] pub type BERR_R = crate :: BitReader ;
#[doc = "Field `ARLO` reader - RW0, Arbitration lost flag (master mode)"] pub type ARLO_R = crate :: BitReader ;
#[doc = "Field `AF` reader - RW0, Acknowledge failure flag"] pub type AF_R = crate :: BitReader ;
#[doc = "Field `OVR` reader - RW0, Overrun/Underrun flag"] pub type OVR_R = crate :: BitReader ;
#[doc = "Field `PECERR` reader - RW0, PEC Error flag in reception"] pub type PECERR_R = crate :: BitReader ;
#[doc = "Field `TIMEOUT` reader - RW0, Timeout or Tlow error flag"] pub type TIMEOUT_R = crate :: BitReader ;
#[doc = "Field `SMBALERT` reader - RW0, SMBus alert flag"] pub type SMBALERT_R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - RW0, Start bit flag (Master mode)"]
#[inline (always)] pub fn sb (& self) -> SB_R { SB_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW0, Address sent (master mode)/matched (slave mode) flag"]
#[inline (always)] pub fn addr (& self) -> ADDR_R { ADDR_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RO, Byte transfer finished flag"]
#[inline (always)] pub fn btf (& self) -> BTF_R { BTF_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RO, 10-bit header sent flag (Master mode)"]
#[inline (always)] pub fn add10 (& self) -> ADD10_R { ADD10_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RO, Stop detection flag (slave mode)"]
#[inline (always)] pub fn stopf (& self) -> STOPF_R { STOPF_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - RO, Data register not empty flag (receivers)"]
#[inline (always)] pub fn rx_ne (& self) -> RX_NE_R { RX_NE_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RO, Data register empty flag (transmitters)"]
#[inline (always)] pub fn tx_e (& self) -> TX_E_R { TX_E_R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bit 8 - RW0, Bus error flag"]
#[inline (always)] pub fn berr (& self) -> BERR_R { BERR_R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - RW0, Arbitration lost flag (master mode)"]
#[inline (always)] pub fn arlo (& self) -> ARLO_R { ARLO_R :: new (((self . bits >> 9) & 1) != 0) }
#[doc = "Bit 10 - RW0, Acknowledge failure flag"]
#[inline (always)] pub fn af (& self) -> AF_R { AF_R :: new (((self . bits >> 10) & 1) != 0) }
#[doc = "Bit 11 - RW0, Overrun/Underrun flag"]
#[inline (always)] pub fn ovr (& self) -> OVR_R { OVR_R :: new (((self . bits >> 11) & 1) != 0) }
#[doc = "Bit 12 - RW0, PEC Error flag in reception"]
#[inline (always)] pub fn pecerr (& self) -> PECERR_R { PECERR_R :: new (((self . bits >> 12) & 1) != 0) }
#[doc = "Bit 13 - RW0, Timeout or Tlow error flag"]
#[inline (always)] pub fn timeout (& self) -> TIMEOUT_R { TIMEOUT_R :: new (((self . bits >> 13) & 1) != 0) }
#[doc = "Bit 15 - RW0, SMBus alert flag"]
#[inline (always)] pub fn smbalert (& self) -> SMBALERT_R { SMBALERT_R :: new (((self . bits >> 15) & 1) != 0) } }
#[doc = "R0, I2C stauts register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`star1::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct STAR1_SPEC ; impl crate :: RegisterSpec for STAR1_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`star1::R`](R) reader structure"] impl crate :: Readable for STAR1_SPEC { }
#[doc = "`reset()` method sets STAR1 to value 0"] impl crate :: Resettable for STAR1_SPEC { } }
#[doc = "STAR2 (r) register accessor: R0, I2C status register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`star2::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@star2`] module"] pub type STAR2 = crate :: Reg < star2 :: STAR2_SPEC > ;
#[doc = "R0, I2C status register 2"] pub mod star2 {
#[doc = "Register `STAR2` reader"] pub type R = crate :: R < STAR2_SPEC > ;
#[doc = "Field `MSL` reader - RO, Mode statu: 0=Slave mode, 1=Master mode"] pub type MSL_R = crate :: BitReader ;
#[doc = "Field `BUSY` reader - RO, Bus busy flag"] pub type BUSY_R = crate :: BitReader ;
#[doc = "Field `TRA` reader - RO, Trans flag: 0=data bytes received, 1=data bytes transmitted"] pub type TRA_R = crate :: BitReader ;
#[doc = "Field `GENCALL` reader - RO, General call address (Slave mode) received flag"] pub type GENCALL_R = crate :: BitReader ;
#[doc = "Field `SMBDEFAULT` reader - RO, SMBus device default address (Slave mode) received flag"] pub type SMBDEFAULT_R = crate :: BitReader ;
#[doc = "Field `SMBHOST` reader - RO, SMBus host header (Slave mode) received flag"] pub type SMBHOST_R = crate :: BitReader ;
#[doc = "Field `DUALF` reader - RO, Dual flag (Slave mode): 0=Received address matched with OAR1, 1=Received address matched with OAR2"] pub type DUALF_R = crate :: BitReader ;
#[doc = "Field `PECX` reader - RO, Packet error checking register"] pub type PECX_R = crate :: FieldReader ; impl R {
#[doc = "Bit 0 - RO, Mode statu: 0=Slave mode, 1=Master mode"]
#[inline (always)] pub fn msl (& self) -> MSL_R { MSL_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RO, Bus busy flag"]
#[inline (always)] pub fn busy (& self) -> BUSY_R { BUSY_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RO, Trans flag: 0=data bytes received, 1=data bytes transmitted"]
#[inline (always)] pub fn tra (& self) -> TRA_R { TRA_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 4 - RO, General call address (Slave mode) received flag"]
#[inline (always)] pub fn gencall (& self) -> GENCALL_R { GENCALL_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RO, SMBus device default address (Slave mode) received flag"]
#[inline (always)] pub fn smbdefault (& self) -> SMBDEFAULT_R { SMBDEFAULT_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RO, SMBus host header (Slave mode) received flag"]
#[inline (always)] pub fn smbhost (& self) -> SMBHOST_R { SMBHOST_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RO, Dual flag (Slave mode): 0=Received address matched with OAR1, 1=Received address matched with OAR2"]
#[inline (always)] pub fn dualf (& self) -> DUALF_R { DUALF_R :: new (((self . bits >> 7) & 1) != 0) }
#[doc = "Bits 8:15 - RO, Packet error checking register"]
#[inline (always)] pub fn pecx (& self) -> PECX_R { PECX_R :: new (((self . bits >> 8) & 0xff) as u8) } }
#[doc = "R0, I2C status register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`star2::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct STAR2_SPEC ; impl crate :: RegisterSpec for STAR2_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`star2::R`](R) reader structure"] impl crate :: Readable for STAR2_SPEC { }
#[doc = "`reset()` method sets STAR2 to value 0"] impl crate :: Resettable for STAR2_SPEC { } }
#[doc = "PEC (r) register accessor: R0, I2C Packet error checking register\n\nYou can [`read`](crate::Reg::read) this register and get [`pec::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pec`] module"] pub type PEC = crate :: Reg < pec :: PEC_SPEC > ;
#[doc = "R0, I2C Packet error checking register"] pub mod pec {
#[doc = "Register `PEC` reader"] pub type R = crate :: R < PEC_SPEC > ;
#[doc = "Field `SPI0_FIFO_COUNT` reader - RO, SPI0 FIFO count status"] pub type SPI0_FIFO_COUNT_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RO, SPI0 FIFO count status"]
#[inline (always)] pub fn spi0_fifo_count (& self) -> SPI0_FIFO_COUNT_R { SPI0_FIFO_COUNT_R :: new (self . bits) } }
#[doc = "R0, I2C Packet error checking register\n\nYou can [`read`](crate::Reg::read) this register and get [`pec::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PEC_SPEC ; impl crate :: RegisterSpec for PEC_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`pec::R`](R) reader structure"] impl crate :: Readable for PEC_SPEC { }
#[doc = "`reset()` method sets PEC to value 0"] impl crate :: Resettable for PEC_SPEC { } }
#[doc = "CKCFGR (rw) register accessor: RW, I2C clock control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ckcfgr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ckcfgr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ckcfgr`] module"] pub type CKCFGR = crate :: Reg < ckcfgr :: CKCFGR_SPEC > ;
#[doc = "RW, I2C clock control register"] pub mod ckcfgr {
#[doc = "Register `CKCFGR` reader"] pub type R = crate :: R < CKCFGR_SPEC > ;
#[doc = "Register `CKCFGR` writer"] pub type W = crate :: W < CKCFGR_SPEC > ;
#[doc = "Field `CCR` reader - RW, Controls the SCL clock in Fm/Sm mode (Master mode)"] pub type CCR_R = crate :: FieldReader < u16 > ;
#[doc = "Field `CCR` writer - RW, Controls the SCL clock in Fm/Sm mode (Master mode)"] pub type CCR_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ;
#[doc = "Field `DUTY` reader - RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9"] pub type DUTY_R = crate :: BitReader ;
#[doc = "Field `DUTY` writer - RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9"] pub type DUTY_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `F_S` reader - RW, I2C master mode selection: 0=standard mode, 1=fast mode"] pub type F_S_R = crate :: BitReader ;
#[doc = "Field `F_S` writer - RW, I2C master mode selection: 0=standard mode, 1=fast mode"] pub type F_S_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:11 - RW, Controls the SCL clock in Fm/Sm mode (Master mode)"]
#[inline (always)] pub fn ccr (& self) -> CCR_R { CCR_R :: new (self . bits & 0x0fff) }
#[doc = "Bit 14 - RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9"]
#[inline (always)] pub fn duty (& self) -> DUTY_R { DUTY_R :: new (((self . bits >> 14) & 1) != 0) }
#[doc = "Bit 15 - RW, I2C master mode selection: 0=standard mode, 1=fast mode"]
#[inline (always)] pub fn f_s (& self) -> F_S_R { F_S_R :: new (((self . bits >> 15) & 1) != 0) } } impl W {
#[doc = "Bits 0:11 - RW, Controls the SCL clock in Fm/Sm mode (Master mode)"]
#[inline (always)] pub fn ccr (& mut self) -> CCR_W < CKCFGR_SPEC > { CCR_W :: new (self , 0) }
#[doc = "Bit 14 - RW, Fm mode duty cycle: 0=L/H=2, 1=L/H=16/9"]
#[inline (always)] pub fn duty (& mut self) -> DUTY_W < CKCFGR_SPEC > { DUTY_W :: new (self , 14) }
#[doc = "Bit 15 - RW, I2C master mode selection: 0=standard mode, 1=fast mode"]
#[inline (always)] pub fn f_s (& mut self) -> F_S_W < CKCFGR_SPEC > { F_S_W :: new (self , 15) } }
#[doc = "RW, I2C clock control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ckcfgr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ckcfgr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CKCFGR_SPEC ; impl crate :: RegisterSpec for CKCFGR_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`ckcfgr::R`](R) reader structure"] impl crate :: Readable for CKCFGR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`ckcfgr::W`](W) writer structure"] impl crate :: Writable for CKCFGR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CKCFGR to value 0"] impl crate :: Resettable for CKCFGR_SPEC { } }
#[doc = "RTR (rw) register accessor: RW, I2C trise register\n\nYou can [`read`](crate::Reg::read) this register and get [`rtr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rtr`] module"] pub type RTR = crate :: Reg < rtr :: RTR_SPEC > ;
#[doc = "RW, I2C trise register"] pub mod rtr {
#[doc = "Register `RTR` reader"] pub type R = crate :: R < RTR_SPEC > ;
#[doc = "Register `RTR` writer"] pub type W = crate :: W < RTR_SPEC > ;
#[doc = "Field `TRISE` reader - RW, Maximum rise time in Fm/Sm mode (Master mode)"] pub type TRISE_R = crate :: FieldReader ;
#[doc = "Field `TRISE` writer - RW, Maximum rise time in Fm/Sm mode (Master mode)"] pub type TRISE_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ; impl R {
#[doc = "Bits 0:5 - RW, Maximum rise time in Fm/Sm mode (Master mode)"]
#[inline (always)] pub fn trise (& self) -> TRISE_R { TRISE_R :: new ((self . bits & 0x3f) as u8) } } impl W {
#[doc = "Bits 0:5 - RW, Maximum rise time in Fm/Sm mode (Master mode)"]
#[inline (always)] pub fn trise (& mut self) -> TRISE_W < RTR_SPEC > { TRISE_W :: new (self , 0) } }
#[doc = "RW, I2C trise register\n\nYou can [`read`](crate::Reg::read) this register and get [`rtr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RTR_SPEC ; impl crate :: RegisterSpec for RTR_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`rtr::R`](R) reader structure"] impl crate :: Readable for RTR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`rtr::W`](W) writer structure"] impl crate :: Writable for RTR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets RTR to value 0x02"] impl crate :: Resettable for RTR_SPEC { const RESET_VALUE : u16 = 0x02 ; } } }
#[doc = "PWMx register"] pub type PWMX = crate :: Periph < pwmx :: RegisterBlock , 0x4000_5000 > ; impl core :: fmt :: Debug for PWMX { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PWMX") . finish () } }
#[doc = "PWMx register"] pub mod pwmx {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { pwm_out_en : PWM_OUT_EN , pwm_polar : PWM_POLAR , pwm_config : PWM_CONFIG , pwm_clock_div : PWM_CLOCK_DIV , pwm4_data : PWM4_DATA , pwm5_data : PWM5_DATA , pwm6_data : PWM6_DATA , pwm7_data : PWM7_DATA , pwm8_data : PWM8_DATA , pwm9_data : PWM9_DATA , pwm10_data : PWM10_DATA , pwm11_data : PWM11_DATA , pwm_int_ctrl : PWM_INT_CTRL , } impl RegisterBlock {
#[doc = "0x00 - RW, PWM output enable control"]
#[inline (always)] pub const fn pwm_out_en (& self) -> & PWM_OUT_EN { & self . pwm_out_en }
#[doc = "0x01 - RW, PWM output polarity control"]
#[inline (always)] pub const fn pwm_polar (& self) -> & PWM_POLAR { & self . pwm_polar }
#[doc = "0x02 - RW, PWM configuration"]
#[inline (always)] pub const fn pwm_config (& self) -> & PWM_CONFIG { & self . pwm_config }
#[doc = "0x03 - RW, PWM clock divisor"]
#[inline (always)] pub const fn pwm_clock_div (& self) -> & PWM_CLOCK_DIV { & self . pwm_clock_div }
#[doc = "0x04 - RW, PWM4 data holding"]
#[inline (always)] pub const fn pwm4_data (& self) -> & PWM4_DATA { & self . pwm4_data }
#[doc = "0x05 - RW, PWM5 data holding"]
#[inline (always)] pub const fn pwm5_data (& self) -> & PWM5_DATA { & self . pwm5_data }
#[doc = "0x06 - RW, PWM6 data holding"]
#[inline (always)] pub const fn pwm6_data (& self) -> & PWM6_DATA { & self . pwm6_data }
#[doc = "0x07 - RW, PWM7 data holding"]
#[inline (always)] pub const fn pwm7_data (& self) -> & PWM7_DATA { & self . pwm7_data }
#[doc = "0x08 - RW, PWM8 data holding"]
#[inline (always)] pub const fn pwm8_data (& self) -> & PWM8_DATA { & self . pwm8_data }
#[doc = "0x09 - RW, PWM9 data holding"]
#[inline (always)] pub const fn pwm9_data (& self) -> & PWM9_DATA { & self . pwm9_data }
#[doc = "0x0a - RW, PWM10 data holding"]
#[inline (always)] pub const fn pwm10_data (& self) -> & PWM10_DATA { & self . pwm10_data }
#[doc = "0x0b - RW, PWM11 data holding"]
#[inline (always)] pub const fn pwm11_data (& self) -> & PWM11_DATA { & self . pwm11_data }
#[doc = "0x0c - RW, PWM interrupt control"]
#[inline (always)] pub const fn pwm_int_ctrl (& self) -> & PWM_INT_CTRL { & self . pwm_int_ctrl } }
#[doc = "PWM_OUT_EN (rw) register accessor: RW, PWM output enable control\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm_out_en::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm_out_en::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm_out_en`] module"] pub type PWM_OUT_EN = crate :: Reg < pwm_out_en :: PWM_OUT_EN_SPEC > ;
#[doc = "RW, PWM output enable control"] pub mod pwm_out_en {
#[doc = "Register `PWM_OUT_EN` reader"] pub type R = crate :: R < PWM_OUT_EN_SPEC > ;
#[doc = "Register `PWM_OUT_EN` writer"] pub type W = crate :: W < PWM_OUT_EN_SPEC > ;
#[doc = "Field `PWM4_OUT_EN` reader - RW, PWM4 output enable"] pub type PWM4_OUT_EN_R = crate :: BitReader ;
#[doc = "Field `PWM4_OUT_EN` writer - RW, PWM4 output enable"] pub type PWM4_OUT_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWM5_OUT_EN` reader - RW, PWM5 output enable"] pub type PWM5_OUT_EN_R = crate :: BitReader ;
#[doc = "Field `PWM5_OUT_EN` writer - RW, PWM5 output enable"] pub type PWM5_OUT_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWM6_OUT_EN` reader - RW, PWM6 output enable"] pub type PWM6_OUT_EN_R = crate :: BitReader ;
#[doc = "Field `PWM6_OUT_EN` writer - RW, PWM6 output enable"] pub type PWM6_OUT_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWM7_OUT_EN` reader - RW, PWM7 output enable"] pub type PWM7_OUT_EN_R = crate :: BitReader ;
#[doc = "Field `PWM7_OUT_EN` writer - RW, PWM7 output enable"] pub type PWM7_OUT_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWM8_OUT_EN` reader - RW, PWM8 output enable"] pub type PWM8_OUT_EN_R = crate :: BitReader ;
#[doc = "Field `PWM8_OUT_EN` writer - RW, PWM8 output enable"] pub type PWM8_OUT_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWM9_OUT_EN` reader - RW, PWM9 output enable"] pub type PWM9_OUT_EN_R = crate :: BitReader ;
#[doc = "Field `PWM9_OUT_EN` writer - RW, PWM9 output enable"] pub type PWM9_OUT_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWM10_OUT_EN` reader - RW, PWM10 output enable"] pub type PWM10_OUT_EN_R = crate :: BitReader ;
#[doc = "Field `PWM10_OUT_EN` writer - RW, PWM10 output enable"] pub type PWM10_OUT_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWM11_OUT_EN` reader - RW, PWM11 output enable"] pub type PWM11_OUT_EN_R = crate :: BitReader ;
#[doc = "Field `PWM11_OUT_EN` writer - RW, PWM11 output enable"] pub type PWM11_OUT_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, PWM4 output enable"]
#[inline (always)] pub fn pwm4_out_en (& self) -> PWM4_OUT_EN_R { PWM4_OUT_EN_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, PWM5 output enable"]
#[inline (always)] pub fn pwm5_out_en (& self) -> PWM5_OUT_EN_R { PWM5_OUT_EN_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW, PWM6 output enable"]
#[inline (always)] pub fn pwm6_out_en (& self) -> PWM6_OUT_EN_R { PWM6_OUT_EN_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, PWM7 output enable"]
#[inline (always)] pub fn pwm7_out_en (& self) -> PWM7_OUT_EN_R { PWM7_OUT_EN_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW, PWM8 output enable"]
#[inline (always)] pub fn pwm8_out_en (& self) -> PWM8_OUT_EN_R { PWM8_OUT_EN_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RW, PWM9 output enable"]
#[inline (always)] pub fn pwm9_out_en (& self) -> PWM9_OUT_EN_R { PWM9_OUT_EN_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RW, PWM10 output enable"]
#[inline (always)] pub fn pwm10_out_en (& self) -> PWM10_OUT_EN_R { PWM10_OUT_EN_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RW, PWM11 output enable"]
#[inline (always)] pub fn pwm11_out_en (& self) -> PWM11_OUT_EN_R { PWM11_OUT_EN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, PWM4 output enable"]
#[inline (always)] pub fn pwm4_out_en (& mut self) -> PWM4_OUT_EN_W < PWM_OUT_EN_SPEC > { PWM4_OUT_EN_W :: new (self , 0) }
#[doc = "Bit 1 - RW, PWM5 output enable"]
#[inline (always)] pub fn pwm5_out_en (& mut self) -> PWM5_OUT_EN_W < PWM_OUT_EN_SPEC > { PWM5_OUT_EN_W :: new (self , 1) }
#[doc = "Bit 2 - RW, PWM6 output enable"]
#[inline (always)] pub fn pwm6_out_en (& mut self) -> PWM6_OUT_EN_W < PWM_OUT_EN_SPEC > { PWM6_OUT_EN_W :: new (self , 2) }
#[doc = "Bit 3 - RW, PWM7 output enable"]
#[inline (always)] pub fn pwm7_out_en (& mut self) -> PWM7_OUT_EN_W < PWM_OUT_EN_SPEC > { PWM7_OUT_EN_W :: new (self , 3) }
#[doc = "Bit 4 - RW, PWM8 output enable"]
#[inline (always)] pub fn pwm8_out_en (& mut self) -> PWM8_OUT_EN_W < PWM_OUT_EN_SPEC > { PWM8_OUT_EN_W :: new (self , 4) }
#[doc = "Bit 5 - RW, PWM9 output enable"]
#[inline (always)] pub fn pwm9_out_en (& mut self) -> PWM9_OUT_EN_W < PWM_OUT_EN_SPEC > { PWM9_OUT_EN_W :: new (self , 5) }
#[doc = "Bit 6 - RW, PWM10 output enable"]
#[inline (always)] pub fn pwm10_out_en (& mut self) -> PWM10_OUT_EN_W < PWM_OUT_EN_SPEC > { PWM10_OUT_EN_W :: new (self , 6) }
#[doc = "Bit 7 - RW, PWM11 output enable"]
#[inline (always)] pub fn pwm11_out_en (& mut self) -> PWM11_OUT_EN_W < PWM_OUT_EN_SPEC > { PWM11_OUT_EN_W :: new (self , 7) } }
#[doc = "RW, PWM output enable control\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm_out_en::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm_out_en::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PWM_OUT_EN_SPEC ; impl crate :: RegisterSpec for PWM_OUT_EN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`pwm_out_en::R`](R) reader structure"] impl crate :: Readable for PWM_OUT_EN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`pwm_out_en::W`](W) writer structure"] impl crate :: Writable for PWM_OUT_EN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PWM_OUT_EN to value 0"] impl crate :: Resettable for PWM_OUT_EN_SPEC { } }
#[doc = "PWM_POLAR (rw) register accessor: RW, PWM output polarity control\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm_polar::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm_polar::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm_polar`] module"] pub type PWM_POLAR = crate :: Reg < pwm_polar :: PWM_POLAR_SPEC > ;
#[doc = "RW, PWM output polarity control"] pub mod pwm_polar {
#[doc = "Register `PWM_POLAR` reader"] pub type R = crate :: R < PWM_POLAR_SPEC > ;
#[doc = "Register `PWM_POLAR` writer"] pub type W = crate :: W < PWM_POLAR_SPEC > ;
#[doc = "Field `PWM4_POLAR` reader - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action"] pub type PWM4_POLAR_R = crate :: BitReader ;
#[doc = "Field `PWM4_POLAR` writer - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action"] pub type PWM4_POLAR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWM5_POLAR` reader - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action"] pub type PWM5_POLAR_R = crate :: BitReader ;
#[doc = "Field `PWM5_POLAR` writer - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action"] pub type PWM5_POLAR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWM6_POLAR` reader - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action"] pub type PWM6_POLAR_R = crate :: BitReader ;
#[doc = "Field `PWM6_POLAR` writer - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action"] pub type PWM6_POLAR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWM7_POLAR` reader - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action"] pub type PWM7_POLAR_R = crate :: BitReader ;
#[doc = "Field `PWM7_POLAR` writer - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action"] pub type PWM7_POLAR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWM8_POLAR` reader - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action"] pub type PWM8_POLAR_R = crate :: BitReader ;
#[doc = "Field `PWM8_POLAR` writer - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action"] pub type PWM8_POLAR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWM9_POLAR` reader - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action"] pub type PWM9_POLAR_R = crate :: BitReader ;
#[doc = "Field `PWM9_POLAR` writer - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action"] pub type PWM9_POLAR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWM10_POLAR` reader - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action"] pub type PWM10_POLAR_R = crate :: BitReader ;
#[doc = "Field `PWM10_POLAR` writer - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action"] pub type PWM10_POLAR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWM11_POLAR` reader - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action"] pub type PWM11_POLAR_R = crate :: BitReader ;
#[doc = "Field `PWM11_POLAR` writer - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action"] pub type PWM11_POLAR_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action"]
#[inline (always)] pub fn pwm4_polar (& self) -> PWM4_POLAR_R { PWM4_POLAR_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action"]
#[inline (always)] pub fn pwm5_polar (& self) -> PWM5_POLAR_R { PWM5_POLAR_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action"]
#[inline (always)] pub fn pwm6_polar (& self) -> PWM6_POLAR_R { PWM6_POLAR_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action"]
#[inline (always)] pub fn pwm7_polar (& self) -> PWM7_POLAR_R { PWM7_POLAR_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action"]
#[inline (always)] pub fn pwm8_polar (& self) -> PWM8_POLAR_R { PWM8_POLAR_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action"]
#[inline (always)] pub fn pwm9_polar (& self) -> PWM9_POLAR_R { PWM9_POLAR_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action"]
#[inline (always)] pub fn pwm10_polar (& self) -> PWM10_POLAR_R { PWM10_POLAR_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action"]
#[inline (always)] pub fn pwm11_polar (& self) -> PWM11_POLAR_R { PWM11_POLAR_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, PWM4 output polarity: 0=default low and high action, 1=default high and low action"]
#[inline (always)] pub fn pwm4_polar (& mut self) -> PWM4_POLAR_W < PWM_POLAR_SPEC > { PWM4_POLAR_W :: new (self , 0) }
#[doc = "Bit 1 - RW, PWM5 output polarity: 0=default low and high action, 1=default high and low action"]
#[inline (always)] pub fn pwm5_polar (& mut self) -> PWM5_POLAR_W < PWM_POLAR_SPEC > { PWM5_POLAR_W :: new (self , 1) }
#[doc = "Bit 2 - RW, PWM6 output polarity: 0=default low and high action, 1=default high and low action"]
#[inline (always)] pub fn pwm6_polar (& mut self) -> PWM6_POLAR_W < PWM_POLAR_SPEC > { PWM6_POLAR_W :: new (self , 2) }
#[doc = "Bit 3 - RW, PWM7 output polarity: 0=default low and high action, 1=default high and low action"]
#[inline (always)] pub fn pwm7_polar (& mut self) -> PWM7_POLAR_W < PWM_POLAR_SPEC > { PWM7_POLAR_W :: new (self , 3) }
#[doc = "Bit 4 - RW, PWM8 output polarity: 0=default low and high action, 1=default high and low action"]
#[inline (always)] pub fn pwm8_polar (& mut self) -> PWM8_POLAR_W < PWM_POLAR_SPEC > { PWM8_POLAR_W :: new (self , 4) }
#[doc = "Bit 5 - RW, PWM9 output polarity: 0=default low and high action, 1=default high and low action"]
#[inline (always)] pub fn pwm9_polar (& mut self) -> PWM9_POLAR_W < PWM_POLAR_SPEC > { PWM9_POLAR_W :: new (self , 5) }
#[doc = "Bit 6 - RW, PWM10 output polarity: 0=default low and high action, 1=default high and low action"]
#[inline (always)] pub fn pwm10_polar (& mut self) -> PWM10_POLAR_W < PWM_POLAR_SPEC > { PWM10_POLAR_W :: new (self , 6) }
#[doc = "Bit 7 - RW, PWM11 output polarity: 0=default low and high action, 1=default high and low action"]
#[inline (always)] pub fn pwm11_polar (& mut self) -> PWM11_POLAR_W < PWM_POLAR_SPEC > { PWM11_POLAR_W :: new (self , 7) } }
#[doc = "RW, PWM output polarity control\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm_polar::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm_polar::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PWM_POLAR_SPEC ; impl crate :: RegisterSpec for PWM_POLAR_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`pwm_polar::R`](R) reader structure"] impl crate :: Readable for PWM_POLAR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`pwm_polar::W`](W) writer structure"] impl crate :: Writable for PWM_POLAR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PWM_POLAR to value 0"] impl crate :: Resettable for PWM_POLAR_SPEC { } }
#[doc = "PWM_CONFIG (rw) register accessor: RW, PWM configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm_config::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm_config::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm_config`] module"] pub type PWM_CONFIG = crate :: Reg < pwm_config :: PWM_CONFIG_SPEC > ;
#[doc = "RW, PWM configuration"] pub mod pwm_config {
#[doc = "Register `PWM_CONFIG` reader"] pub type R = crate :: R < PWM_CONFIG_SPEC > ;
#[doc = "Register `PWM_CONFIG` writer"] pub type W = crate :: W < PWM_CONFIG_SPEC > ;
#[doc = "Field `PWM_CYCLE_SEL` reader - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks"] pub type PWM_CYCLE_SEL_R = crate :: BitReader ;
#[doc = "Field `PWM_CYCLE_SEL` writer - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks"] pub type PWM_CYCLE_SEL_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWM_STAG_ST` reader - RO, PWM stagger cycle status"] pub type PWM_STAG_ST_R = crate :: BitReader ;
#[doc = "Field `PWM_CYC_MOD` reader - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data"] pub type PWM_CYC_MOD_R = crate :: FieldReader ;
#[doc = "Field `PWM_CYC_MOD` writer - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data"] pub type PWM_CYC_MOD_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `PWM4_5_STAG_EN` reader - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output"] pub type PWM4_5_STAG_EN_R = crate :: BitReader ;
#[doc = "Field `PWM4_5_STAG_EN` writer - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output"] pub type PWM4_5_STAG_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWM6_7_STAG_EN` reader - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output"] pub type PWM6_7_STAG_EN_R = crate :: BitReader ;
#[doc = "Field `PWM6_7_STAG_EN` writer - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output"] pub type PWM6_7_STAG_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWM8_9_STAG_EN` reader - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output"] pub type PWM8_9_STAG_EN_R = crate :: BitReader ;
#[doc = "Field `PWM8_9_STAG_EN` writer - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output"] pub type PWM8_9_STAG_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWM10_11_STAG_EN` reader - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output"] pub type PWM10_11_STAG_EN_R = crate :: BitReader ;
#[doc = "Field `PWM10_11_STAG_EN` writer - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output"] pub type PWM10_11_STAG_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks"]
#[inline (always)] pub fn pwm_cycle_sel (& self) -> PWM_CYCLE_SEL_R { PWM_CYCLE_SEL_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RO, PWM stagger cycle status"]
#[inline (always)] pub fn pwm_stag_st (& self) -> PWM_STAG_ST_R { PWM_STAG_ST_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bits 2:3 - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data"]
#[inline (always)] pub fn pwm_cyc_mod (& self) -> PWM_CYC_MOD_R { PWM_CYC_MOD_R :: new ((self . bits >> 2) & 3) }
#[doc = "Bit 4 - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output"]
#[inline (always)] pub fn pwm4_5_stag_en (& self) -> PWM4_5_STAG_EN_R { PWM4_5_STAG_EN_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output"]
#[inline (always)] pub fn pwm6_7_stag_en (& self) -> PWM6_7_STAG_EN_R { PWM6_7_STAG_EN_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output"]
#[inline (always)] pub fn pwm8_9_stag_en (& self) -> PWM8_9_STAG_EN_R { PWM8_9_STAG_EN_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output"]
#[inline (always)] pub fn pwm10_11_stag_en (& self) -> PWM10_11_STAG_EN_R { PWM10_11_STAG_EN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, PWM cycle selection: 0=256;128;64;32 clocks, 1=255;127;63;31 clocks"]
#[inline (always)] pub fn pwm_cycle_sel (& mut self) -> PWM_CYCLE_SEL_W < PWM_CONFIG_SPEC > { PWM_CYCLE_SEL_W :: new (self , 0) }
#[doc = "Bits 2:3 - RW, PWM data width mode: 00=8 bits data, 01=7 bits data, 10=6 bits data, 11=5 bits data"]
#[inline (always)] pub fn pwm_cyc_mod (& mut self) -> PWM_CYC_MOD_W < PWM_CONFIG_SPEC > { PWM_CYC_MOD_W :: new (self , 2) }
#[doc = "Bit 4 - RW, PWM4/5 stagger output enable: 0=independent output, 1=stagger output"]
#[inline (always)] pub fn pwm4_5_stag_en (& mut self) -> PWM4_5_STAG_EN_W < PWM_CONFIG_SPEC > { PWM4_5_STAG_EN_W :: new (self , 4) }
#[doc = "Bit 5 - RW, PWM6/7 stagger output enable: 0=independent output, 1=stagger output"]
#[inline (always)] pub fn pwm6_7_stag_en (& mut self) -> PWM6_7_STAG_EN_W < PWM_CONFIG_SPEC > { PWM6_7_STAG_EN_W :: new (self , 5) }
#[doc = "Bit 6 - RW, PWM8/9 stagger output enable: 0=independent output, 1=stagger output"]
#[inline (always)] pub fn pwm8_9_stag_en (& mut self) -> PWM8_9_STAG_EN_W < PWM_CONFIG_SPEC > { PWM8_9_STAG_EN_W :: new (self , 6) }
#[doc = "Bit 7 - RW, PWM10/11 stagger output enable: 0=independent output, 1=stagger output"]
#[inline (always)] pub fn pwm10_11_stag_en (& mut self) -> PWM10_11_STAG_EN_W < PWM_CONFIG_SPEC > { PWM10_11_STAG_EN_W :: new (self , 7) } }
#[doc = "RW, PWM configuration\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm_config::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm_config::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PWM_CONFIG_SPEC ; impl crate :: RegisterSpec for PWM_CONFIG_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`pwm_config::R`](R) reader structure"] impl crate :: Readable for PWM_CONFIG_SPEC { }
#[doc = "`write(|w| ..)` method takes [`pwm_config::W`](W) writer structure"] impl crate :: Writable for PWM_CONFIG_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PWM_CONFIG to value 0"] impl crate :: Resettable for PWM_CONFIG_SPEC { } }
#[doc = "PWM_CLOCK_DIV (rw) register accessor: RW, PWM clock divisor\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm_clock_div::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm_clock_div::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm_clock_div`] module"] pub type PWM_CLOCK_DIV = crate :: Reg < pwm_clock_div :: PWM_CLOCK_DIV_SPEC > ;
#[doc = "RW, PWM clock divisor"] pub mod pwm_clock_div {
#[doc = "Register `PWM_CLOCK_DIV` reader"] pub type R = crate :: R < PWM_CLOCK_DIV_SPEC > ;
#[doc = "Register `PWM_CLOCK_DIV` writer"] pub type W = crate :: W < PWM_CLOCK_DIV_SPEC > ;
#[doc = "Field `PWM_CLOCK_DIV` reader - RW, PWM clock divisor"] pub type PWM_CLOCK_DIV_R = crate :: FieldReader ;
#[doc = "Field `PWM_CLOCK_DIV` writer - RW, PWM clock divisor"] pub type PWM_CLOCK_DIV_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW, PWM clock divisor"]
#[inline (always)] pub fn pwm_clock_div (& self) -> PWM_CLOCK_DIV_R { PWM_CLOCK_DIV_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RW, PWM clock divisor"]
#[inline (always)] pub fn pwm_clock_div (& mut self) -> PWM_CLOCK_DIV_W < PWM_CLOCK_DIV_SPEC > { PWM_CLOCK_DIV_W :: new (self , 0) } }
#[doc = "RW, PWM clock divisor\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm_clock_div::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm_clock_div::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PWM_CLOCK_DIV_SPEC ; impl crate :: RegisterSpec for PWM_CLOCK_DIV_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`pwm_clock_div::R`](R) reader structure"] impl crate :: Readable for PWM_CLOCK_DIV_SPEC { }
#[doc = "`write(|w| ..)` method takes [`pwm_clock_div::W`](W) writer structure"] impl crate :: Writable for PWM_CLOCK_DIV_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PWM_CLOCK_DIV to value 0"] impl crate :: Resettable for PWM_CLOCK_DIV_SPEC { } }
#[doc = "PWM4_DATA (rw) register accessor: RW, PWM4 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm4_data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm4_data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm4_data`] module"] pub type PWM4_DATA = crate :: Reg < pwm4_data :: PWM4_DATA_SPEC > ;
#[doc = "RW, PWM4 data holding"] pub mod pwm4_data {
#[doc = "Register `PWM4_DATA` reader"] pub type R = crate :: R < PWM4_DATA_SPEC > ;
#[doc = "Register `PWM4_DATA` writer"] pub type W = crate :: W < PWM4_DATA_SPEC > ;
#[doc = "Field `PWM4_DATA` reader - RW, PWM4 data holding"] pub type PWM4_DATA_R = crate :: FieldReader ;
#[doc = "Field `PWM4_DATA` writer - RW, PWM4 data holding"] pub type PWM4_DATA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW, PWM4 data holding"]
#[inline (always)] pub fn pwm4_data (& self) -> PWM4_DATA_R { PWM4_DATA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RW, PWM4 data holding"]
#[inline (always)] pub fn pwm4_data (& mut self) -> PWM4_DATA_W < PWM4_DATA_SPEC > { PWM4_DATA_W :: new (self , 0) } }
#[doc = "RW, PWM4 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm4_data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm4_data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PWM4_DATA_SPEC ; impl crate :: RegisterSpec for PWM4_DATA_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`pwm4_data::R`](R) reader structure"] impl crate :: Readable for PWM4_DATA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`pwm4_data::W`](W) writer structure"] impl crate :: Writable for PWM4_DATA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PWM4_DATA to value 0"] impl crate :: Resettable for PWM4_DATA_SPEC { } }
#[doc = "PWM5_DATA (rw) register accessor: RW, PWM5 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm5_data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm5_data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm5_data`] module"] pub type PWM5_DATA = crate :: Reg < pwm5_data :: PWM5_DATA_SPEC > ;
#[doc = "RW, PWM5 data holding"] pub mod pwm5_data {
#[doc = "Register `PWM5_DATA` reader"] pub type R = crate :: R < PWM5_DATA_SPEC > ;
#[doc = "Register `PWM5_DATA` writer"] pub type W = crate :: W < PWM5_DATA_SPEC > ;
#[doc = "Field `PWM5_DATA` reader - RW, PWM5 data holding"] pub type PWM5_DATA_R = crate :: FieldReader ;
#[doc = "Field `PWM5_DATA` writer - RW, PWM5 data holding"] pub type PWM5_DATA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW, PWM5 data holding"]
#[inline (always)] pub fn pwm5_data (& self) -> PWM5_DATA_R { PWM5_DATA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RW, PWM5 data holding"]
#[inline (always)] pub fn pwm5_data (& mut self) -> PWM5_DATA_W < PWM5_DATA_SPEC > { PWM5_DATA_W :: new (self , 0) } }
#[doc = "RW, PWM5 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm5_data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm5_data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PWM5_DATA_SPEC ; impl crate :: RegisterSpec for PWM5_DATA_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`pwm5_data::R`](R) reader structure"] impl crate :: Readable for PWM5_DATA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`pwm5_data::W`](W) writer structure"] impl crate :: Writable for PWM5_DATA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PWM5_DATA to value 0"] impl crate :: Resettable for PWM5_DATA_SPEC { } }
#[doc = "PWM6_DATA (rw) register accessor: RW, PWM6 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm6_data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm6_data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm6_data`] module"] pub type PWM6_DATA = crate :: Reg < pwm6_data :: PWM6_DATA_SPEC > ;
#[doc = "RW, PWM6 data holding"] pub mod pwm6_data {
#[doc = "Register `PWM6_DATA` reader"] pub type R = crate :: R < PWM6_DATA_SPEC > ;
#[doc = "Register `PWM6_DATA` writer"] pub type W = crate :: W < PWM6_DATA_SPEC > ;
#[doc = "Field `PWM6_DATA` reader - RW, PWM6 data holding"] pub type PWM6_DATA_R = crate :: FieldReader ;
#[doc = "Field `PWM6_DATA` writer - RW, PWM6 data holding"] pub type PWM6_DATA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW, PWM6 data holding"]
#[inline (always)] pub fn pwm6_data (& self) -> PWM6_DATA_R { PWM6_DATA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RW, PWM6 data holding"]
#[inline (always)] pub fn pwm6_data (& mut self) -> PWM6_DATA_W < PWM6_DATA_SPEC > { PWM6_DATA_W :: new (self , 0) } }
#[doc = "RW, PWM6 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm6_data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm6_data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PWM6_DATA_SPEC ; impl crate :: RegisterSpec for PWM6_DATA_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`pwm6_data::R`](R) reader structure"] impl crate :: Readable for PWM6_DATA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`pwm6_data::W`](W) writer structure"] impl crate :: Writable for PWM6_DATA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PWM6_DATA to value 0"] impl crate :: Resettable for PWM6_DATA_SPEC { } }
#[doc = "PWM7_DATA (rw) register accessor: RW, PWM7 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm7_data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm7_data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm7_data`] module"] pub type PWM7_DATA = crate :: Reg < pwm7_data :: PWM7_DATA_SPEC > ;
#[doc = "RW, PWM7 data holding"] pub mod pwm7_data {
#[doc = "Register `PWM7_DATA` reader"] pub type R = crate :: R < PWM7_DATA_SPEC > ;
#[doc = "Register `PWM7_DATA` writer"] pub type W = crate :: W < PWM7_DATA_SPEC > ;
#[doc = "Field `PWM7_DATA` reader - RW, PWM7 data holding"] pub type PWM7_DATA_R = crate :: FieldReader ;
#[doc = "Field `PWM7_DATA` writer - RW, PWM7 data holding"] pub type PWM7_DATA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW, PWM7 data holding"]
#[inline (always)] pub fn pwm7_data (& self) -> PWM7_DATA_R { PWM7_DATA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RW, PWM7 data holding"]
#[inline (always)] pub fn pwm7_data (& mut self) -> PWM7_DATA_W < PWM7_DATA_SPEC > { PWM7_DATA_W :: new (self , 0) } }
#[doc = "RW, PWM7 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm7_data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm7_data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PWM7_DATA_SPEC ; impl crate :: RegisterSpec for PWM7_DATA_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`pwm7_data::R`](R) reader structure"] impl crate :: Readable for PWM7_DATA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`pwm7_data::W`](W) writer structure"] impl crate :: Writable for PWM7_DATA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PWM7_DATA to value 0"] impl crate :: Resettable for PWM7_DATA_SPEC { } }
#[doc = "PWM8_DATA (rw) register accessor: RW, PWM8 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm8_data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm8_data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm8_data`] module"] pub type PWM8_DATA = crate :: Reg < pwm8_data :: PWM8_DATA_SPEC > ;
#[doc = "RW, PWM8 data holding"] pub mod pwm8_data {
#[doc = "Register `PWM8_DATA` reader"] pub type R = crate :: R < PWM8_DATA_SPEC > ;
#[doc = "Register `PWM8_DATA` writer"] pub type W = crate :: W < PWM8_DATA_SPEC > ;
#[doc = "Field `PWM8_DATA` reader - RW, PWM8 data holding"] pub type PWM8_DATA_R = crate :: FieldReader ;
#[doc = "Field `PWM8_DATA` writer - RW, PWM8 data holding"] pub type PWM8_DATA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW, PWM8 data holding"]
#[inline (always)] pub fn pwm8_data (& self) -> PWM8_DATA_R { PWM8_DATA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RW, PWM8 data holding"]
#[inline (always)] pub fn pwm8_data (& mut self) -> PWM8_DATA_W < PWM8_DATA_SPEC > { PWM8_DATA_W :: new (self , 0) } }
#[doc = "RW, PWM8 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm8_data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm8_data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PWM8_DATA_SPEC ; impl crate :: RegisterSpec for PWM8_DATA_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`pwm8_data::R`](R) reader structure"] impl crate :: Readable for PWM8_DATA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`pwm8_data::W`](W) writer structure"] impl crate :: Writable for PWM8_DATA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PWM8_DATA to value 0"] impl crate :: Resettable for PWM8_DATA_SPEC { } }
#[doc = "PWM9_DATA (rw) register accessor: RW, PWM9 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm9_data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm9_data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm9_data`] module"] pub type PWM9_DATA = crate :: Reg < pwm9_data :: PWM9_DATA_SPEC > ;
#[doc = "RW, PWM9 data holding"] pub mod pwm9_data {
#[doc = "Register `PWM9_DATA` reader"] pub type R = crate :: R < PWM9_DATA_SPEC > ;
#[doc = "Register `PWM9_DATA` writer"] pub type W = crate :: W < PWM9_DATA_SPEC > ;
#[doc = "Field `PWM9_DATA` reader - RW, PWM9 data holding"] pub type PWM9_DATA_R = crate :: FieldReader ;
#[doc = "Field `PWM9_DATA` writer - RW, PWM9 data holding"] pub type PWM9_DATA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW, PWM9 data holding"]
#[inline (always)] pub fn pwm9_data (& self) -> PWM9_DATA_R { PWM9_DATA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RW, PWM9 data holding"]
#[inline (always)] pub fn pwm9_data (& mut self) -> PWM9_DATA_W < PWM9_DATA_SPEC > { PWM9_DATA_W :: new (self , 0) } }
#[doc = "RW, PWM9 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm9_data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm9_data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PWM9_DATA_SPEC ; impl crate :: RegisterSpec for PWM9_DATA_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`pwm9_data::R`](R) reader structure"] impl crate :: Readable for PWM9_DATA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`pwm9_data::W`](W) writer structure"] impl crate :: Writable for PWM9_DATA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PWM9_DATA to value 0"] impl crate :: Resettable for PWM9_DATA_SPEC { } }
#[doc = "PWM10_DATA (rw) register accessor: RW, PWM10 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm10_data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm10_data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm10_data`] module"] pub type PWM10_DATA = crate :: Reg < pwm10_data :: PWM10_DATA_SPEC > ;
#[doc = "RW, PWM10 data holding"] pub mod pwm10_data {
#[doc = "Register `PWM10_DATA` reader"] pub type R = crate :: R < PWM10_DATA_SPEC > ;
#[doc = "Register `PWM10_DATA` writer"] pub type W = crate :: W < PWM10_DATA_SPEC > ;
#[doc = "Field `PWM10_DATA` reader - RW, PWM10 data holding"] pub type PWM10_DATA_R = crate :: FieldReader ;
#[doc = "Field `PWM10_DATA` writer - RW, PWM10 data holding"] pub type PWM10_DATA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW, PWM10 data holding"]
#[inline (always)] pub fn pwm10_data (& self) -> PWM10_DATA_R { PWM10_DATA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RW, PWM10 data holding"]
#[inline (always)] pub fn pwm10_data (& mut self) -> PWM10_DATA_W < PWM10_DATA_SPEC > { PWM10_DATA_W :: new (self , 0) } }
#[doc = "RW, PWM10 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm10_data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm10_data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PWM10_DATA_SPEC ; impl crate :: RegisterSpec for PWM10_DATA_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`pwm10_data::R`](R) reader structure"] impl crate :: Readable for PWM10_DATA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`pwm10_data::W`](W) writer structure"] impl crate :: Writable for PWM10_DATA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PWM10_DATA to value 0"] impl crate :: Resettable for PWM10_DATA_SPEC { } }
#[doc = "PWM11_DATA (rw) register accessor: RW, PWM11 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm11_data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm11_data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm11_data`] module"] pub type PWM11_DATA = crate :: Reg < pwm11_data :: PWM11_DATA_SPEC > ;
#[doc = "RW, PWM11 data holding"] pub mod pwm11_data {
#[doc = "Register `PWM11_DATA` reader"] pub type R = crate :: R < PWM11_DATA_SPEC > ;
#[doc = "Register `PWM11_DATA` writer"] pub type W = crate :: W < PWM11_DATA_SPEC > ;
#[doc = "Field `PWM11_DATA` reader - RW, PWM11 data holding"] pub type PWM11_DATA_R = crate :: FieldReader ;
#[doc = "Field `PWM11_DATA` writer - RW, PWM11 data holding"] pub type PWM11_DATA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW, PWM11 data holding"]
#[inline (always)] pub fn pwm11_data (& self) -> PWM11_DATA_R { PWM11_DATA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - RW, PWM11 data holding"]
#[inline (always)] pub fn pwm11_data (& mut self) -> PWM11_DATA_W < PWM11_DATA_SPEC > { PWM11_DATA_W :: new (self , 0) } }
#[doc = "RW, PWM11 data holding\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm11_data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm11_data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PWM11_DATA_SPEC ; impl crate :: RegisterSpec for PWM11_DATA_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`pwm11_data::R`](R) reader structure"] impl crate :: Readable for PWM11_DATA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`pwm11_data::W`](W) writer structure"] impl crate :: Writable for PWM11_DATA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PWM11_DATA to value 0"] impl crate :: Resettable for PWM11_DATA_SPEC { } }
#[doc = "PWM_INT_CTRL (rw) register accessor: RW, PWM interrupt control\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm_int_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm_int_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pwm_int_ctrl`] module"] pub type PWM_INT_CTRL = crate :: Reg < pwm_int_ctrl :: PWM_INT_CTRL_SPEC > ;
#[doc = "RW, PWM interrupt control"] pub mod pwm_int_ctrl {
#[doc = "Register `PWM_INT_CTRL` reader"] pub type R = crate :: R < PWM_INT_CTRL_SPEC > ;
#[doc = "Register `PWM_INT_CTRL` writer"] pub type W = crate :: W < PWM_INT_CTRL_SPEC > ;
#[doc = "Field `PWM_IE_CYC` reader - RW, enable interrupt for PWM cycle end"] pub type PWM_IE_CYC_R = crate :: BitReader ;
#[doc = "Field `PWM_IE_CYC` writer - RW, enable interrupt for PWM cycle end"] pub type PWM_IE_CYC_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWM_CYC_PRE` reader - RW, select PWM cycle interrupt point"] pub type PWM_CYC_PRE_R = crate :: BitReader ;
#[doc = "Field `PWM_CYC_PRE` writer - RW, select PWM cycle interrupt point"] pub type PWM_CYC_PRE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `PWM_IF_CYC` reader - RW1, interrupt flag for PWM cycle end"] pub type PWM_IF_CYC_R = crate :: BitReader ;
#[doc = "Field `PWM_IF_CYC` writer - RW1, interrupt flag for PWM cycle end"] pub type PWM_IF_CYC_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW, enable interrupt for PWM cycle end"]
#[inline (always)] pub fn pwm_ie_cyc (& self) -> PWM_IE_CYC_R { PWM_IE_CYC_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW, select PWM cycle interrupt point"]
#[inline (always)] pub fn pwm_cyc_pre (& self) -> PWM_CYC_PRE_R { PWM_CYC_PRE_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 7 - RW1, interrupt flag for PWM cycle end"]
#[inline (always)] pub fn pwm_if_cyc (& self) -> PWM_IF_CYC_R { PWM_IF_CYC_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW, enable interrupt for PWM cycle end"]
#[inline (always)] pub fn pwm_ie_cyc (& mut self) -> PWM_IE_CYC_W < PWM_INT_CTRL_SPEC > { PWM_IE_CYC_W :: new (self , 0) }
#[doc = "Bit 1 - RW, select PWM cycle interrupt point"]
#[inline (always)] pub fn pwm_cyc_pre (& mut self) -> PWM_CYC_PRE_W < PWM_INT_CTRL_SPEC > { PWM_CYC_PRE_W :: new (self , 1) }
#[doc = "Bit 7 - RW1, interrupt flag for PWM cycle end"]
#[inline (always)] pub fn pwm_if_cyc (& mut self) -> PWM_IF_CYC_W < PWM_INT_CTRL_SPEC > { PWM_IF_CYC_W :: new (self , 7) } }
#[doc = "RW, PWM interrupt control\n\nYou can [`read`](crate::Reg::read) this register and get [`pwm_int_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pwm_int_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct PWM_INT_CTRL_SPEC ; impl crate :: RegisterSpec for PWM_INT_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`pwm_int_ctrl::R`](R) reader structure"] impl crate :: Readable for PWM_INT_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`pwm_int_ctrl::W`](W) writer structure"] impl crate :: Writable for PWM_INT_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets PWM_INT_CTRL to value 0"] impl crate :: Resettable for PWM_INT_CTRL_SPEC { } } }
#[doc = "USB register"] pub type USB = crate :: Periph < usb :: RegisterBlock , 0x4000_8000 > ; impl core :: fmt :: Debug for USB { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USB") . finish () } }
#[doc = "USB register"] pub mod usb {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ctrl : CTRL , _reserved_1_udev_ctrl : [u8 ; 0x01] , int_en : INT_EN , dev_ad : DEV_AD , _reserved4 : [u8 ; 0x01] , mis_st : MIS_ST , int_fg : INT_FG , int_st : INT_ST , rx_len : RX_LEN , _reserved8 : [u8 ; 0x03] , uep4_1_mod : UEP4_1_MOD , _reserved_9_uh_ep_mod : [u8 ; 0x01] , uep567_mod : UEP567_MOD , _reserved11 : [u8 ; 0x01] , uep0_dma : UEP0_DMA , _reserved12 : [u8 ; 0x02] , uep1_dma : UEP1_DMA , _reserved13 : [u8 ; 0x02] , _reserved_13_uep2_dma : [u8 ; 0x02] , _reserved14 : [u8 ; 0x02] , _reserved_14_uep3_dma : [u8 ; 0x02] , _reserved15 : [u8 ; 0x02] , uep0_t_len : UEP0_T_LEN , _reserved16 : [u8 ; 0x01] , uep0_ctrl : UEP0_CTRL , _reserved17 : [u8 ; 0x01] , uep1_t_len : UEP1_T_LEN , _reserved18 : [u8 ; 0x01] , _reserved_18_uh_setup : [u8 ; 0x01] , _reserved19 : [u8 ; 0x01] , _reserved_19_uh_ep_pid : [u8 ; 0x01] , _reserved20 : [u8 ; 0x01] , _reserved_20_uep2_ctrl : [u8 ; 0x01] , _reserved21 : [u8 ; 0x01] , _reserved_21_uh_tx_len : [u8 ; 0x01] , _reserved22 : [u8 ; 0x01] , _reserved_22_uep3_ctrl : [u8 ; 0x01] , _reserved23 : [u8 ; 0x01] , uep4_t_len : UEP4_T_LEN , _reserved24 : [u8 ; 0x01] , uep4_ctrl : UEP4_CTRL , _reserved25 : [u8 ; 0x21] , uep5_dma : UEP5_DMA , _reserved26 : [u8 ; 0x02] , uep6_dma : UEP6_DMA , _reserved27 : [u8 ; 0x02] , uep7_dma : UEP7_DMA , _reserved28 : [u8 ; 0x06] , uep5_t_len : UEP5_T_LEN , _reserved29 : [u8 ; 0x01] , uep5_ctrl : UEP5_CTRL , _reserved30 : [u8 ; 0x01] , uep6_t_len : UEP6_T_LEN , _reserved31 : [u8 ; 0x01] , uep6_ctrl : UEP6_CTRL , _reserved32 : [u8 ; 0x01] , uep7_t_len : UEP7_T_LEN , _reserved33 : [u8 ; 0x01] , uep7_ctrl : UEP7_CTRL , } impl RegisterBlock {
#[doc = "0x00 - USB base control"]
#[inline (always)] pub const fn ctrl (& self) -> & CTRL { & self . ctrl }
#[doc = "0x01 - USB device physical prot control"]
#[inline (always)] pub const fn uhost_ctrl (& self) -> & UHOST_CTRL { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (1) . cast () } }
#[doc = "0x01 - USB device physical prot control"]
#[inline (always)] pub const fn udev_ctrl (& self) -> & UDEV_CTRL { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (1) . cast () } }
#[doc = "0x02 - USB interrupt enable"]
#[inline (always)] pub const fn int_en (& self) -> & INT_EN { & self . int_en }
#[doc = "0x03 - USB device address"]
#[inline (always)] pub const fn dev_ad (& self) -> & DEV_AD { & self . dev_ad }
#[doc = "0x05 - USB miscellaneous status"]
#[inline (always)] pub const fn mis_st (& self) -> & MIS_ST { & self . mis_st }
#[doc = "0x06 - USB interrupt flag"]
#[inline (always)] pub const fn int_fg (& self) -> & INT_FG { & self . int_fg }
#[doc = "0x07 - USB interrupt status"]
#[inline (always)] pub const fn int_st (& self) -> & INT_ST { & self . int_st }
#[doc = "0x08 - USB receiving length"]
#[inline (always)] pub const fn rx_len (& self) -> & RX_LEN { & self . rx_len }
#[doc = "0x0c - endpoint 4/1 mode"]
#[inline (always)] pub const fn uep4_1_mod (& self) -> & UEP4_1_MOD { & self . uep4_1_mod }
#[doc = "0x0d - host endpoint mode"]
#[inline (always)] pub const fn uh_ep_mod (& self) -> & UH_EP_MOD { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (13) . cast () } }
#[doc = "0x0d - endpoint 2_3 mode"]
#[inline (always)] pub const fn uep2_3_mod (& self) -> & UEP2_3_MOD { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (13) . cast () } }
#[doc = "0x0e - endpoint 5/6/7 mode"]
#[inline (always)] pub const fn uep567_mod (& self) -> & UEP567_MOD { & self . uep567_mod }
#[doc = "0x10 - endpoint 0 DMA buffer address"]
#[inline (always)] pub const fn uep0_dma (& self) -> & UEP0_DMA { & self . uep0_dma }
#[doc = "0x14 - endpoint 1 DMA buffer address"]
#[inline (always)] pub const fn uep1_dma (& self) -> & UEP1_DMA { & self . uep1_dma }
#[doc = "0x18 - host rx endpoint buffer high address"]
#[inline (always)] pub const fn uh_rx_dma (& self) -> & UH_RX_DMA { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x18 - endpoint 2 DMA buffer address"]
#[inline (always)] pub const fn uep2_dma (& self) -> & UEP2_DMA { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x1c - host tx endpoint buffer high address"]
#[inline (always)] pub const fn uh_tx_dma (& self) -> & UH_TX_DMA { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (28) . cast () } }
#[doc = "0x1c - endpoint 3 DMA buffer address"]
#[inline (always)] pub const fn uep3_dma (& self) -> & UEP3_DMA { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (28) . cast () } }
#[doc = "0x20 - endpoint 0 transmittal length"]
#[inline (always)] pub const fn uep0_t_len (& self) -> & UEP0_T_LEN { & self . uep0_t_len }
#[doc = "0x22 - endpoint 0 control"]
#[inline (always)] pub const fn uep0_ctrl (& self) -> & UEP0_CTRL { & self . uep0_ctrl }
#[doc = "0x24 - endpoint 1 transmittal length"]
#[inline (always)] pub const fn uep1_t_len (& self) -> & UEP1_T_LEN { & self . uep1_t_len }
#[doc = "0x26 - host aux setup"]
#[inline (always)] pub const fn uh_setup (& self) -> & UH_SETUP { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (38) . cast () } }
#[doc = "0x26 - endpoint 1 control"]
#[inline (always)] pub const fn uep1_ctrl (& self) -> & UEP1_CTRL { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (38) . cast () } }
#[doc = "0x28 - host endpoint and PID"]
#[inline (always)] pub const fn uh_ep_pid (& self) -> & UH_EP_PID { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (40) . cast () } }
#[doc = "0x28 - endpoint 2 transmittal length"]
#[inline (always)] pub const fn uep2_t_len (& self) -> & UEP2_T_LEN { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (40) . cast () } }
#[doc = "0x2a - host receiver endpoint control"]
#[inline (always)] pub const fn uh_rx_ctrl (& self) -> & UH_RX_CTRL { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (42) . cast () } }
#[doc = "0x2a - endpoint 2 control"]
#[inline (always)] pub const fn uep2_ctrl (& self) -> & UEP2_CTRL { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (42) . cast () } }
#[doc = "0x2c - host transmittal endpoint transmittal length"]
#[inline (always)] pub const fn uh_tx_len (& self) -> & UH_TX_LEN { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (44) . cast () } }
#[doc = "0x2c - endpoint 3 transmittal length"]
#[inline (always)] pub const fn uep3_t_len (& self) -> & UEP3_T_LEN { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (44) . cast () } }
#[doc = "0x2e - host transmittal endpoint control"]
#[inline (always)] pub const fn uh_tx_ctrl (& self) -> & UH_TX_CTRL { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (46) . cast () } }
#[doc = "0x2e - endpoint 3 control"]
#[inline (always)] pub const fn uep3_ctrl (& self) -> & UEP3_CTRL { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (46) . cast () } }
#[doc = "0x30 - endpoint 4 transmittal length"]
#[inline (always)] pub const fn uep4_t_len (& self) -> & UEP4_T_LEN { & self . uep4_t_len }
#[doc = "0x32 - endpoint 4 control"]
#[inline (always)] pub const fn uep4_ctrl (& self) -> & UEP4_CTRL { & self . uep4_ctrl }
#[doc = "0x54 - endpoint 5 DMA buffer address"]
#[inline (always)] pub const fn uep5_dma (& self) -> & UEP5_DMA { & self . uep5_dma }
#[doc = "0x58 - endpoint 6 DMA buffer address"]
#[inline (always)] pub const fn uep6_dma (& self) -> & UEP6_DMA { & self . uep6_dma }
#[doc = "0x5c - endpoint 7 DMA buffer address"]
#[inline (always)] pub const fn uep7_dma (& self) -> & UEP7_DMA { & self . uep7_dma }
#[doc = "0x64 - endpoint 5 transmittal length"]
#[inline (always)] pub const fn uep5_t_len (& self) -> & UEP5_T_LEN { & self . uep5_t_len }
#[doc = "0x66 - endpoint 5 control"]
#[inline (always)] pub const fn uep5_ctrl (& self) -> & UEP5_CTRL { & self . uep5_ctrl }
#[doc = "0x68 - endpoint 6 transmittal length"]
#[inline (always)] pub const fn uep6_t_len (& self) -> & UEP6_T_LEN { & self . uep6_t_len }
#[doc = "0x6a - endpoint 6 control"]
#[inline (always)] pub const fn uep6_ctrl (& self) -> & UEP6_CTRL { & self . uep6_ctrl }
#[doc = "0x6c - endpoint 7 transmittal length"]
#[inline (always)] pub const fn uep7_t_len (& self) -> & UEP7_T_LEN { & self . uep7_t_len }
#[doc = "0x6e - endpoint 7 control"]
#[inline (always)] pub const fn uep7_ctrl (& self) -> & UEP7_CTRL { & self . uep7_ctrl } }
#[doc = "CTRL (rw) register accessor: USB base control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`] module"] pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ;
#[doc = "USB base control"] pub mod ctrl {
#[doc = "Register `CTRL` reader"] pub type R = crate :: R < CTRL_SPEC > ;
#[doc = "Register `CTRL` writer"] pub type W = crate :: W < CTRL_SPEC > ;
#[doc = "Field `UC_DMA_EN` reader - DMA enable and DMA interrupt enable for USB"] pub type UC_DMA_EN_R = crate :: BitReader ;
#[doc = "Field `UC_DMA_EN` writer - DMA enable and DMA interrupt enable for USB"] pub type UC_DMA_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UC_CLR_ALL` reader - force clear FIFO and count of USB"] pub type UC_CLR_ALL_R = crate :: BitReader ;
#[doc = "Field `UC_CLR_ALL` writer - force clear FIFO and count of USB"] pub type UC_CLR_ALL_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UC_RESET_SIE` reader - force reset USB SIE, need software clear"] pub type UC_RESET_SIE_R = crate :: BitReader ;
#[doc = "Field `UC_RESET_SIE` writer - force reset USB SIE, need software clear"] pub type UC_RESET_SIE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UC_INT_BUSY` reader - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid"] pub type UC_INT_BUSY_R = crate :: BitReader ;
#[doc = "Field `UC_INT_BUSY` writer - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid"] pub type UC_INT_BUSY_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UC_SYS_CTRL` reader - bit mask of USB system control"] pub type UC_SYS_CTRL_R = crate :: FieldReader ;
#[doc = "Field `UC_SYS_CTRL` writer - bit mask of USB system control"] pub type UC_SYS_CTRL_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UC_DEV_PU_EN` reader - USB device enable and internal pullup resistance enable"] pub type UC_DEV_PU_EN_R = crate :: BitReader ;
#[doc = "Field `UC_DEV_PU_EN` writer - USB device enable and internal pullup resistance enable"] pub type UC_DEV_PU_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UC_LOW_SPEED` reader - enable USB low speed: 0=12Mbps, 1=1.5Mbps"] pub type UC_LOW_SPEED_R = crate :: BitReader ;
#[doc = "Field `UC_LOW_SPEED` writer - enable USB low speed: 0=12Mbps, 1=1.5Mbps"] pub type UC_LOW_SPEED_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UC_HOST_MODE` reader - enable USB host mode: 0=device mode, 1=host mode"] pub type UC_HOST_MODE_R = crate :: BitReader ;
#[doc = "Field `UC_HOST_MODE` writer - enable USB host mode: 0=device mode, 1=host mode"] pub type UC_HOST_MODE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - DMA enable and DMA interrupt enable for USB"]
#[inline (always)] pub fn uc_dma_en (& self) -> UC_DMA_EN_R { UC_DMA_EN_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - force clear FIFO and count of USB"]
#[inline (always)] pub fn uc_clr_all (& self) -> UC_CLR_ALL_R { UC_CLR_ALL_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - force reset USB SIE, need software clear"]
#[inline (always)] pub fn uc_reset_sie (& self) -> UC_RESET_SIE_R { UC_RESET_SIE_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid"]
#[inline (always)] pub fn uc_int_busy (& self) -> UC_INT_BUSY_R { UC_INT_BUSY_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:5 - bit mask of USB system control"]
#[inline (always)] pub fn uc_sys_ctrl (& self) -> UC_SYS_CTRL_R { UC_SYS_CTRL_R :: new ((self . bits >> 4) & 3) }
#[doc = "Bit 5 - USB device enable and internal pullup resistance enable"]
#[inline (always)] pub fn uc_dev_pu_en (& self) -> UC_DEV_PU_EN_R { UC_DEV_PU_EN_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps"]
#[inline (always)] pub fn uc_low_speed (& self) -> UC_LOW_SPEED_R { UC_LOW_SPEED_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - enable USB host mode: 0=device mode, 1=host mode"]
#[inline (always)] pub fn uc_host_mode (& self) -> UC_HOST_MODE_R { UC_HOST_MODE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - DMA enable and DMA interrupt enable for USB"]
#[inline (always)] pub fn uc_dma_en (& mut self) -> UC_DMA_EN_W < CTRL_SPEC > { UC_DMA_EN_W :: new (self , 0) }
#[doc = "Bit 1 - force clear FIFO and count of USB"]
#[inline (always)] pub fn uc_clr_all (& mut self) -> UC_CLR_ALL_W < CTRL_SPEC > { UC_CLR_ALL_W :: new (self , 1) }
#[doc = "Bit 2 - force reset USB SIE, need software clear"]
#[inline (always)] pub fn uc_reset_sie (& mut self) -> UC_RESET_SIE_W < CTRL_SPEC > { UC_RESET_SIE_W :: new (self , 2) }
#[doc = "Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid"]
#[inline (always)] pub fn uc_int_busy (& mut self) -> UC_INT_BUSY_W < CTRL_SPEC > { UC_INT_BUSY_W :: new (self , 3) }
#[doc = "Bits 4:5 - bit mask of USB system control"]
#[inline (always)] pub fn uc_sys_ctrl (& mut self) -> UC_SYS_CTRL_W < CTRL_SPEC > { UC_SYS_CTRL_W :: new (self , 4) }
#[doc = "Bit 5 - USB device enable and internal pullup resistance enable"]
#[inline (always)] pub fn uc_dev_pu_en (& mut self) -> UC_DEV_PU_EN_W < CTRL_SPEC > { UC_DEV_PU_EN_W :: new (self , 5) }
#[doc = "Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps"]
#[inline (always)] pub fn uc_low_speed (& mut self) -> UC_LOW_SPEED_W < CTRL_SPEC > { UC_LOW_SPEED_W :: new (self , 6) }
#[doc = "Bit 7 - enable USB host mode: 0=device mode, 1=host mode"]
#[inline (always)] pub fn uc_host_mode (& mut self) -> UC_HOST_MODE_W < CTRL_SPEC > { UC_HOST_MODE_W :: new (self , 7) } }
#[doc = "USB base control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`ctrl::R`](R) reader structure"] impl crate :: Readable for CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"] impl crate :: Writable for CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL to value 0x06"] impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : u8 = 0x06 ; } }
#[doc = "UDEV_CTRL (rw) register accessor: USB device physical prot control\n\nYou can [`read`](crate::Reg::read) this register and get [`udev_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`udev_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@udev_ctrl`] module"] pub type UDEV_CTRL = crate :: Reg < udev_ctrl :: UDEV_CTRL_SPEC > ;
#[doc = "USB device physical prot control"] pub mod udev_ctrl {
#[doc = "Register `UDEV_CTRL` reader"] pub type R = crate :: R < UDEV_CTRL_SPEC > ;
#[doc = "Register `UDEV_CTRL` writer"] pub type W = crate :: W < UDEV_CTRL_SPEC > ;
#[doc = "Field `UD_PORT_EN` reader - enable USB physical port I-O: 0=disable, 1=enable"] pub type UD_PORT_EN_R = crate :: BitReader ;
#[doc = "Field `UD_PORT_EN` writer - enable USB physical port I-O: 0=disable, 1=enable"] pub type UD_PORT_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UD_GP_BIT` reader - general purpose bit"] pub type UD_GP_BIT_R = crate :: BitReader ;
#[doc = "Field `UD_GP_BIT` writer - general purpose bit"] pub type UD_GP_BIT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UD_LOW_SPEED` reader - enable USB physical port low speed: 0=full speed, 1=low speed"] pub type UD_LOW_SPEED_R = crate :: BitReader ;
#[doc = "Field `UD_LOW_SPEED` writer - enable USB physical port low speed: 0=full speed, 1=low speed"] pub type UD_LOW_SPEED_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UD_DM_PIN` reader - ReadOnly: indicate current UDM pin level"] pub type UD_DM_PIN_R = crate :: BitReader ;
#[doc = "Field `UD_DP_PIN` reader - ReadOnly: indicate current UDP pin level"] pub type UD_DP_PIN_R = crate :: BitReader ;
#[doc = "Field `UD_PD_DIS` reader - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable"] pub type UD_PD_DIS_R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - enable USB physical port I-O: 0=disable, 1=enable"]
#[inline (always)] pub fn ud_port_en (& self) -> UD_PORT_EN_R { UD_PORT_EN_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - general purpose bit"]
#[inline (always)] pub fn ud_gp_bit (& self) -> UD_GP_BIT_R { UD_GP_BIT_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed"]
#[inline (always)] pub fn ud_low_speed (& self) -> UD_LOW_SPEED_R { UD_LOW_SPEED_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 4 - ReadOnly: indicate current UDM pin level"]
#[inline (always)] pub fn ud_dm_pin (& self) -> UD_DM_PIN_R { UD_DM_PIN_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - ReadOnly: indicate current UDP pin level"]
#[inline (always)] pub fn ud_dp_pin (& self) -> UD_DP_PIN_R { UD_DP_PIN_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 7 - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable"]
#[inline (always)] pub fn ud_pd_dis (& self) -> UD_PD_DIS_R { UD_PD_DIS_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - enable USB physical port I-O: 0=disable, 1=enable"]
#[inline (always)] pub fn ud_port_en (& mut self) -> UD_PORT_EN_W < UDEV_CTRL_SPEC > { UD_PORT_EN_W :: new (self , 0) }
#[doc = "Bit 1 - general purpose bit"]
#[inline (always)] pub fn ud_gp_bit (& mut self) -> UD_GP_BIT_W < UDEV_CTRL_SPEC > { UD_GP_BIT_W :: new (self , 1) }
#[doc = "Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed"]
#[inline (always)] pub fn ud_low_speed (& mut self) -> UD_LOW_SPEED_W < UDEV_CTRL_SPEC > { UD_LOW_SPEED_W :: new (self , 2) } }
#[doc = "USB device physical prot control\n\nYou can [`read`](crate::Reg::read) this register and get [`udev_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`udev_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UDEV_CTRL_SPEC ; impl crate :: RegisterSpec for UDEV_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`udev_ctrl::R`](R) reader structure"] impl crate :: Readable for UDEV_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`udev_ctrl::W`](W) writer structure"] impl crate :: Writable for UDEV_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UDEV_CTRL to value 0"] impl crate :: Resettable for UDEV_CTRL_SPEC { } }
#[doc = "UHOST_CTRL (rw) register accessor: USB device physical prot control\n\nYou can [`read`](crate::Reg::read) this register and get [`uhost_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uhost_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uhost_ctrl`] module"] pub type UHOST_CTRL = crate :: Reg < uhost_ctrl :: UHOST_CTRL_SPEC > ;
#[doc = "USB device physical prot control"] pub mod uhost_ctrl {
#[doc = "Register `UHOST_CTRL` reader"] pub type R = crate :: R < UHOST_CTRL_SPEC > ;
#[doc = "Register `UHOST_CTRL` writer"] pub type W = crate :: W < UHOST_CTRL_SPEC > ;
#[doc = "Field `UH_PORT_EN` reader - enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached"] pub type UH_PORT_EN_R = crate :: BitReader ;
#[doc = "Field `UH_PORT_EN` writer - enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached"] pub type UH_PORT_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UH_BUS_RESET` reader - control USB bus reset: 0=normal, 1=force bus reset"] pub type UH_BUS_RESET_R = crate :: BitReader ;
#[doc = "Field `UH_BUS_RESET` writer - control USB bus reset: 0=normal, 1=force bus reset"] pub type UH_BUS_RESET_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UH_LOW_SPEED` reader - enable USB port low speed: 0=full speed, 1=low speed"] pub type UH_LOW_SPEED_R = crate :: BitReader ;
#[doc = "Field `UH_LOW_SPEED` writer - enable USB port low speed: 0=full speed, 1=low speed"] pub type UH_LOW_SPEED_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UH_DM_PIN` reader - ReadOnly: indicate current UDM pin level"] pub type UH_DM_PIN_R = crate :: BitReader ;
#[doc = "Field `UH_DP_PIN` reader - ReadOnly: indicate current UDP pin level"] pub type UH_DP_PIN_R = crate :: BitReader ;
#[doc = "Field `UH_PD_DIS` reader - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable"] pub type UH_PD_DIS_R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached"]
#[inline (always)] pub fn uh_port_en (& self) -> UH_PORT_EN_R { UH_PORT_EN_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - control USB bus reset: 0=normal, 1=force bus reset"]
#[inline (always)] pub fn uh_bus_reset (& self) -> UH_BUS_RESET_R { UH_BUS_RESET_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - enable USB port low speed: 0=full speed, 1=low speed"]
#[inline (always)] pub fn uh_low_speed (& self) -> UH_LOW_SPEED_R { UH_LOW_SPEED_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 4 - ReadOnly: indicate current UDM pin level"]
#[inline (always)] pub fn uh_dm_pin (& self) -> UH_DM_PIN_R { UH_DM_PIN_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - ReadOnly: indicate current UDP pin level"]
#[inline (always)] pub fn uh_dp_pin (& self) -> UH_DP_PIN_R { UH_DP_PIN_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 7 - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable"]
#[inline (always)] pub fn uh_pd_dis (& self) -> UH_PD_DIS_R { UH_PD_DIS_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached"]
#[inline (always)] pub fn uh_port_en (& mut self) -> UH_PORT_EN_W < UHOST_CTRL_SPEC > { UH_PORT_EN_W :: new (self , 0) }
#[doc = "Bit 1 - control USB bus reset: 0=normal, 1=force bus reset"]
#[inline (always)] pub fn uh_bus_reset (& mut self) -> UH_BUS_RESET_W < UHOST_CTRL_SPEC > { UH_BUS_RESET_W :: new (self , 1) }
#[doc = "Bit 2 - enable USB port low speed: 0=full speed, 1=low speed"]
#[inline (always)] pub fn uh_low_speed (& mut self) -> UH_LOW_SPEED_W < UHOST_CTRL_SPEC > { UH_LOW_SPEED_W :: new (self , 2) } }
#[doc = "USB device physical prot control\n\nYou can [`read`](crate::Reg::read) this register and get [`uhost_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uhost_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UHOST_CTRL_SPEC ; impl crate :: RegisterSpec for UHOST_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uhost_ctrl::R`](R) reader structure"] impl crate :: Readable for UHOST_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uhost_ctrl::W`](W) writer structure"] impl crate :: Writable for UHOST_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UHOST_CTRL to value 0"] impl crate :: Resettable for UHOST_CTRL_SPEC { } }
#[doc = "INT_EN (rw) register accessor: USB interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`int_en::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_en::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_en`] module"] pub type INT_EN = crate :: Reg < int_en :: INT_EN_SPEC > ;
#[doc = "USB interrupt enable"] pub mod int_en {
#[doc = "Register `INT_EN` reader"] pub type R = crate :: R < INT_EN_SPEC > ;
#[doc = "Register `INT_EN` writer"] pub type W = crate :: W < INT_EN_SPEC > ;
#[doc = "Field `UIE_BUS_RST` reader - enable interrupt for USB bus reset event for USB device mode"] pub type UIE_BUS_RST_R = crate :: BitReader ;
#[doc = "Field `UIE_BUS_RST` writer - enable interrupt for USB bus reset event for USB device mode"] pub type UIE_BUS_RST_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UIE_DETECT` reader - enable interrupt for USB device detected event for USB host mode"] pub type UIE_DETECT_R = crate :: BitReader ;
#[doc = "Field `UIE_DETECT` writer - enable interrupt for USB device detected event for USB host mode"] pub type UIE_DETECT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UIE_TRANSFER` reader - enable interrupt for USB transfer completion"] pub type UIE_TRANSFER_R = crate :: BitReader ;
#[doc = "Field `UIE_TRANSFER` writer - enable interrupt for USB transfer completion"] pub type UIE_TRANSFER_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UIE_SUSPEND` reader - enable interrupt for USB suspend or resume event"] pub type UIE_SUSPEND_R = crate :: BitReader ;
#[doc = "Field `UIE_SUSPEND` writer - enable interrupt for USB suspend or resume event"] pub type UIE_SUSPEND_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UIE_HST_SOF` reader - enable interrupt for host SOF timer action for USB host mode"] pub type UIE_HST_SOF_R = crate :: BitReader ;
#[doc = "Field `UIE_HST_SOF` writer - enable interrupt for host SOF timer action for USB host mode"] pub type UIE_HST_SOF_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UIE_FIFO_OV` reader - enable interrupt for FIFO overflow"] pub type UIE_FIFO_OV_R = crate :: BitReader ;
#[doc = "Field `UIE_FIFO_OV` writer - enable interrupt for FIFO overflow"] pub type UIE_FIFO_OV_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UIE_DEV_NAK` reader - enable interrupt for NAK responded for USB device mode"] pub type UIE_DEV_NAK_R = crate :: BitReader ;
#[doc = "Field `UIE_DEV_NAK` writer - enable interrupt for NAK responded for USB device mode"] pub type UIE_DEV_NAK_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UIE_DEV_SOF` reader - enable interrupt for SOF received for USB device mode"] pub type UIE_DEV_SOF_R = crate :: BitReader ;
#[doc = "Field `UIE_DEV_SOF` writer - enable interrupt for SOF received for USB device mode"] pub type UIE_DEV_SOF_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - enable interrupt for USB bus reset event for USB device mode"]
#[inline (always)] pub fn uie_bus_rst (& self) -> UIE_BUS_RST_R { UIE_BUS_RST_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 0 - enable interrupt for USB device detected event for USB host mode"]
#[inline (always)] pub fn uie_detect (& self) -> UIE_DETECT_R { UIE_DETECT_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - enable interrupt for USB transfer completion"]
#[inline (always)] pub fn uie_transfer (& self) -> UIE_TRANSFER_R { UIE_TRANSFER_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - enable interrupt for USB suspend or resume event"]
#[inline (always)] pub fn uie_suspend (& self) -> UIE_SUSPEND_R { UIE_SUSPEND_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - enable interrupt for host SOF timer action for USB host mode"]
#[inline (always)] pub fn uie_hst_sof (& self) -> UIE_HST_SOF_R { UIE_HST_SOF_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - enable interrupt for FIFO overflow"]
#[inline (always)] pub fn uie_fifo_ov (& self) -> UIE_FIFO_OV_R { UIE_FIFO_OV_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - enable interrupt for NAK responded for USB device mode"]
#[inline (always)] pub fn uie_dev_nak (& self) -> UIE_DEV_NAK_R { UIE_DEV_NAK_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - enable interrupt for SOF received for USB device mode"]
#[inline (always)] pub fn uie_dev_sof (& self) -> UIE_DEV_SOF_R { UIE_DEV_SOF_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - enable interrupt for USB bus reset event for USB device mode"]
#[inline (always)] pub fn uie_bus_rst (& mut self) -> UIE_BUS_RST_W < INT_EN_SPEC > { UIE_BUS_RST_W :: new (self , 0) }
#[doc = "Bit 0 - enable interrupt for USB device detected event for USB host mode"]
#[inline (always)] pub fn uie_detect (& mut self) -> UIE_DETECT_W < INT_EN_SPEC > { UIE_DETECT_W :: new (self , 0) }
#[doc = "Bit 1 - enable interrupt for USB transfer completion"]
#[inline (always)] pub fn uie_transfer (& mut self) -> UIE_TRANSFER_W < INT_EN_SPEC > { UIE_TRANSFER_W :: new (self , 1) }
#[doc = "Bit 2 - enable interrupt for USB suspend or resume event"]
#[inline (always)] pub fn uie_suspend (& mut self) -> UIE_SUSPEND_W < INT_EN_SPEC > { UIE_SUSPEND_W :: new (self , 2) }
#[doc = "Bit 3 - enable interrupt for host SOF timer action for USB host mode"]
#[inline (always)] pub fn uie_hst_sof (& mut self) -> UIE_HST_SOF_W < INT_EN_SPEC > { UIE_HST_SOF_W :: new (self , 3) }
#[doc = "Bit 4 - enable interrupt for FIFO overflow"]
#[inline (always)] pub fn uie_fifo_ov (& mut self) -> UIE_FIFO_OV_W < INT_EN_SPEC > { UIE_FIFO_OV_W :: new (self , 4) }
#[doc = "Bit 6 - enable interrupt for NAK responded for USB device mode"]
#[inline (always)] pub fn uie_dev_nak (& mut self) -> UIE_DEV_NAK_W < INT_EN_SPEC > { UIE_DEV_NAK_W :: new (self , 6) }
#[doc = "Bit 7 - enable interrupt for SOF received for USB device mode"]
#[inline (always)] pub fn uie_dev_sof (& mut self) -> UIE_DEV_SOF_W < INT_EN_SPEC > { UIE_DEV_SOF_W :: new (self , 7) } }
#[doc = "USB interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`int_en::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_en::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_EN_SPEC ; impl crate :: RegisterSpec for INT_EN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`int_en::R`](R) reader structure"] impl crate :: Readable for INT_EN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`int_en::W`](W) writer structure"] impl crate :: Writable for INT_EN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INT_EN to value 0"] impl crate :: Resettable for INT_EN_SPEC { } }
#[doc = "DEV_AD (rw) register accessor: USB device address\n\nYou can [`read`](crate::Reg::read) this register and get [`dev_ad::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dev_ad::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dev_ad`] module"] pub type DEV_AD = crate :: Reg < dev_ad :: DEV_AD_SPEC > ;
#[doc = "USB device address"] pub mod dev_ad {
#[doc = "Register `DEV_AD` reader"] pub type R = crate :: R < DEV_AD_SPEC > ;
#[doc = "Register `DEV_AD` writer"] pub type W = crate :: W < DEV_AD_SPEC > ;
#[doc = "Field `ADDR` reader - bit mask for USB device address"] pub type ADDR_R = crate :: FieldReader ;
#[doc = "Field `ADDR` writer - bit mask for USB device address"] pub type ADDR_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `UDA_GP_BIT` reader - general purpose bit"] pub type UDA_GP_BIT_R = crate :: BitReader ;
#[doc = "Field `UDA_GP_BIT` writer - general purpose bit"] pub type UDA_GP_BIT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:6 - bit mask for USB device address"]
#[inline (always)] pub fn addr (& self) -> ADDR_R { ADDR_R :: new (self . bits & 0x7f) }
#[doc = "Bit 7 - general purpose bit"]
#[inline (always)] pub fn uda_gp_bit (& self) -> UDA_GP_BIT_R { UDA_GP_BIT_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:6 - bit mask for USB device address"]
#[inline (always)] pub fn addr (& mut self) -> ADDR_W < DEV_AD_SPEC > { ADDR_W :: new (self , 0) }
#[doc = "Bit 7 - general purpose bit"]
#[inline (always)] pub fn uda_gp_bit (& mut self) -> UDA_GP_BIT_W < DEV_AD_SPEC > { UDA_GP_BIT_W :: new (self , 7) } }
#[doc = "USB device address\n\nYou can [`read`](crate::Reg::read) this register and get [`dev_ad::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dev_ad::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DEV_AD_SPEC ; impl crate :: RegisterSpec for DEV_AD_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`dev_ad::R`](R) reader structure"] impl crate :: Readable for DEV_AD_SPEC { }
#[doc = "`write(|w| ..)` method takes [`dev_ad::W`](W) writer structure"] impl crate :: Writable for DEV_AD_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DEV_AD to value 0"] impl crate :: Resettable for DEV_AD_SPEC { } }
#[doc = "MIS_ST (r) register accessor: USB miscellaneous status\n\nYou can [`read`](crate::Reg::read) this register and get [`mis_st::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mis_st`] module"] pub type MIS_ST = crate :: Reg < mis_st :: MIS_ST_SPEC > ;
#[doc = "USB miscellaneous status"] pub mod mis_st {
#[doc = "Register `MIS_ST` reader"] pub type R = crate :: R < MIS_ST_SPEC > ;
#[doc = "Field `UMS_DEV_ATTACH` reader - RO, indicate device attached status on USB host"] pub type UMS_DEV_ATTACH_R = crate :: BitReader ;
#[doc = "Field `UMS_DM_LEVEL` reader - RO, indicate UDM level saved at device attached to USB host"] pub type UMS_DM_LEVEL_R = crate :: BitReader ;
#[doc = "Field `UMS_SUSPEND` reader - RO, indicate USB suspend status"] pub type UMS_SUSPEND_R = crate :: BitReader ;
#[doc = "Field `UMS_BUS_RESET` reader - RO, indicate USB bus reset status"] pub type UMS_BUS_RESET_R = crate :: BitReader ;
#[doc = "Field `UMS_R_FIFO_RDY` reader - RO, indicate USB receiving FIFO ready status (not empty)"] pub type UMS_R_FIFO_RDY_R = crate :: BitReader ;
#[doc = "Field `UMS_SIE_FREE` reader - RO, indicate USB SIE free status"] pub type UMS_SIE_FREE_R = crate :: BitReader ;
#[doc = "Field `UMS_SOF_ACT` reader - RO, indicate host SOF timer action status for USB host"] pub type UMS_SOF_ACT_R = crate :: BitReader ;
#[doc = "Field `UMS_SOF_PRES` reader - RO, indicate host SOF timer presage status"] pub type UMS_SOF_PRES_R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - RO, indicate device attached status on USB host"]
#[inline (always)] pub fn ums_dev_attach (& self) -> UMS_DEV_ATTACH_R { UMS_DEV_ATTACH_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RO, indicate UDM level saved at device attached to USB host"]
#[inline (always)] pub fn ums_dm_level (& self) -> UMS_DM_LEVEL_R { UMS_DM_LEVEL_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RO, indicate USB suspend status"]
#[inline (always)] pub fn ums_suspend (& self) -> UMS_SUSPEND_R { UMS_SUSPEND_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RO, indicate USB bus reset status"]
#[inline (always)] pub fn ums_bus_reset (& self) -> UMS_BUS_RESET_R { UMS_BUS_RESET_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RO, indicate USB receiving FIFO ready status (not empty)"]
#[inline (always)] pub fn ums_r_fifo_rdy (& self) -> UMS_R_FIFO_RDY_R { UMS_R_FIFO_RDY_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RO, indicate USB SIE free status"]
#[inline (always)] pub fn ums_sie_free (& self) -> UMS_SIE_FREE_R { UMS_SIE_FREE_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RO, indicate host SOF timer action status for USB host"]
#[inline (always)] pub fn ums_sof_act (& self) -> UMS_SOF_ACT_R { UMS_SOF_ACT_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RO, indicate host SOF timer presage status"]
#[inline (always)] pub fn ums_sof_pres (& self) -> UMS_SOF_PRES_R { UMS_SOF_PRES_R :: new (((self . bits >> 7) & 1) != 0) } }
#[doc = "USB miscellaneous status\n\nYou can [`read`](crate::Reg::read) this register and get [`mis_st::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MIS_ST_SPEC ; impl crate :: RegisterSpec for MIS_ST_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`mis_st::R`](R) reader structure"] impl crate :: Readable for MIS_ST_SPEC { }
#[doc = "`reset()` method sets MIS_ST to value 0"] impl crate :: Resettable for MIS_ST_SPEC { } }
#[doc = "INT_FG (rw) register accessor: USB interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_fg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_fg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_fg`] module"] pub type INT_FG = crate :: Reg < int_fg :: INT_FG_SPEC > ;
#[doc = "USB interrupt flag"] pub mod int_fg {
#[doc = "Register `INT_FG` reader"] pub type R = crate :: R < INT_FG_SPEC > ;
#[doc = "Register `INT_FG` writer"] pub type W = crate :: W < INT_FG_SPEC > ;
#[doc = "Field `UIF_BUS_RST` reader - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear"] pub type UIF_BUS_RST_R = crate :: BitReader ;
#[doc = "Field `UIF_BUS_RST` writer - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear"] pub type UIF_BUS_RST_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UIF_DETECT` reader - RW,device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear"] pub type UIF_DETECT_R = crate :: BitReader ;
#[doc = "Field `UIF_DETECT` writer - RW,device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear"] pub type UIF_DETECT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UIF_TRANSFER` reader - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear"] pub type UIF_TRANSFER_R = crate :: BitReader ;
#[doc = "Field `UIF_TRANSFER` writer - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear"] pub type UIF_TRANSFER_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UIF_SUSPEND` reader - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear"] pub type UIF_SUSPEND_R = crate :: BitReader ;
#[doc = "Field `UIF_SUSPEND` writer - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear"] pub type UIF_SUSPEND_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UIF_HST_SOF` reader - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear"] pub type UIF_HST_SOF_R = crate :: BitReader ;
#[doc = "Field `UIF_HST_SOF` writer - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear"] pub type UIF_HST_SOF_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UIF_FIFO_OV` reader - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear"] pub type UIF_FIFO_OV_R = crate :: BitReader ;
#[doc = "Field `UIF_FIFO_OV` writer - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear"] pub type UIF_FIFO_OV_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `U_SIE_FREE` reader - RO, indicate USB SIE free status"] pub type U_SIE_FREE_R = crate :: BitReader ;
#[doc = "Field `U_TOG_OK` reader - RO, indicate current USB transfer toggle is OK"] pub type U_TOG_OK_R = crate :: BitReader ;
#[doc = "Field `U_IS_NAK` reader - RO, indicate current USB transfer is NAK received"] pub type U_IS_NAK_R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear"]
#[inline (always)] pub fn uif_bus_rst (& self) -> UIF_BUS_RST_R { UIF_BUS_RST_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 0 - RW,device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear"]
#[inline (always)] pub fn uif_detect (& self) -> UIF_DETECT_R { UIF_DETECT_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear"]
#[inline (always)] pub fn uif_transfer (& self) -> UIF_TRANSFER_R { UIF_TRANSFER_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear"]
#[inline (always)] pub fn uif_suspend (& self) -> UIF_SUSPEND_R { UIF_SUSPEND_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear"]
#[inline (always)] pub fn uif_hst_sof (& self) -> UIF_HST_SOF_R { UIF_HST_SOF_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear"]
#[inline (always)] pub fn uif_fifo_ov (& self) -> UIF_FIFO_OV_R { UIF_FIFO_OV_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RO, indicate USB SIE free status"]
#[inline (always)] pub fn u_sie_free (& self) -> U_SIE_FREE_R { U_SIE_FREE_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RO, indicate current USB transfer toggle is OK"]
#[inline (always)] pub fn u_tog_ok (& self) -> U_TOG_OK_R { U_TOG_OK_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RO, indicate current USB transfer is NAK received"]
#[inline (always)] pub fn u_is_nak (& self) -> U_IS_NAK_R { U_IS_NAK_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear"]
#[inline (always)] pub fn uif_bus_rst (& mut self) -> UIF_BUS_RST_W < INT_FG_SPEC > { UIF_BUS_RST_W :: new (self , 0) }
#[doc = "Bit 0 - RW,device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear"]
#[inline (always)] pub fn uif_detect (& mut self) -> UIF_DETECT_W < INT_FG_SPEC > { UIF_DETECT_W :: new (self , 0) }
#[doc = "Bit 1 - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear"]
#[inline (always)] pub fn uif_transfer (& mut self) -> UIF_TRANSFER_W < INT_FG_SPEC > { UIF_TRANSFER_W :: new (self , 1) }
#[doc = "Bit 2 - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear"]
#[inline (always)] pub fn uif_suspend (& mut self) -> UIF_SUSPEND_W < INT_FG_SPEC > { UIF_SUSPEND_W :: new (self , 2) }
#[doc = "Bit 3 - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear"]
#[inline (always)] pub fn uif_hst_sof (& mut self) -> UIF_HST_SOF_W < INT_FG_SPEC > { UIF_HST_SOF_W :: new (self , 3) }
#[doc = "Bit 4 - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear"]
#[inline (always)] pub fn uif_fifo_ov (& mut self) -> UIF_FIFO_OV_W < INT_FG_SPEC > { UIF_FIFO_OV_W :: new (self , 4) } }
#[doc = "USB interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_fg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_fg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_FG_SPEC ; impl crate :: RegisterSpec for INT_FG_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`int_fg::R`](R) reader structure"] impl crate :: Readable for INT_FG_SPEC { }
#[doc = "`write(|w| ..)` method takes [`int_fg::W`](W) writer structure"] impl crate :: Writable for INT_FG_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INT_FG to value 0x20"] impl crate :: Resettable for INT_FG_SPEC { const RESET_VALUE : u8 = 0x20 ; } }
#[doc = "INT_ST (r) register accessor: USB interrupt status\n\nYou can [`read`](crate::Reg::read) this register and get [`int_st::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_st`] module"] pub type INT_ST = crate :: Reg < int_st :: INT_ST_SPEC > ;
#[doc = "USB interrupt status"] pub mod int_st {
#[doc = "Register `INT_ST` reader"] pub type R = crate :: R < INT_ST_SPEC > ;
#[doc = "Field `UIS_H_RES` reader - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received"] pub type UIS_H_RES_R = crate :: FieldReader ;
#[doc = "Field `UIS_ENDP` reader - RO, bit mask of current transfer endpoint number for USB device mode"] pub type UIS_ENDP_R = crate :: FieldReader ;
#[doc = "Field `UIS_TOKEN` reader - RO, bit mask of current token PID code received for USB device mode"] pub type UIS_TOKEN_R = crate :: FieldReader ;
#[doc = "Field `UIS_TOG_OK` reader - RO, indicate current USB transfer toggle is OK"] pub type UIS_TOG_OK_R = crate :: BitReader ;
#[doc = "Field `UIS_SETUP_ACT` reader - RO, indicate current USB transfer is NAK received for USB device mode"] pub type UIS_SETUP_ACT_R = crate :: BitReader ; impl R {
#[doc = "Bits 0:3 - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received"]
#[inline (always)] pub fn uis_h_res (& self) -> UIS_H_RES_R { UIS_H_RES_R :: new (self . bits & 0x0f) }
#[doc = "Bits 0:3 - RO, bit mask of current transfer endpoint number for USB device mode"]
#[inline (always)] pub fn uis_endp (& self) -> UIS_ENDP_R { UIS_ENDP_R :: new (self . bits & 0x0f) }
#[doc = "Bits 4:5 - RO, bit mask of current token PID code received for USB device mode"]
#[inline (always)] pub fn uis_token (& self) -> UIS_TOKEN_R { UIS_TOKEN_R :: new ((self . bits >> 4) & 3) }
#[doc = "Bit 6 - RO, indicate current USB transfer toggle is OK"]
#[inline (always)] pub fn uis_tog_ok (& self) -> UIS_TOG_OK_R { UIS_TOG_OK_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RO, indicate current USB transfer is NAK received for USB device mode"]
#[inline (always)] pub fn uis_setup_act (& self) -> UIS_SETUP_ACT_R { UIS_SETUP_ACT_R :: new (((self . bits >> 7) & 1) != 0) } }
#[doc = "USB interrupt status\n\nYou can [`read`](crate::Reg::read) this register and get [`int_st::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_ST_SPEC ; impl crate :: RegisterSpec for INT_ST_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`int_st::R`](R) reader structure"] impl crate :: Readable for INT_ST_SPEC { }
#[doc = "`reset()` method sets INT_ST to value 0"] impl crate :: Resettable for INT_ST_SPEC { } }
#[doc = "RX_LEN (r) register accessor: USB receiving length\n\nYou can [`read`](crate::Reg::read) this register and get [`rx_len::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rx_len`] module"] pub type RX_LEN = crate :: Reg < rx_len :: RX_LEN_SPEC > ;
#[doc = "USB receiving length"] pub mod rx_len {
#[doc = "Register `RX_LEN` reader"] pub type R = crate :: R < RX_LEN_SPEC > ;
#[doc = "Field `RX_LEN` reader - RO,USB receiving length"] pub type RX_LEN_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RO,USB receiving length"]
#[inline (always)] pub fn rx_len (& self) -> RX_LEN_R { RX_LEN_R :: new (self . bits) } }
#[doc = "USB receiving length\n\nYou can [`read`](crate::Reg::read) this register and get [`rx_len::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RX_LEN_SPEC ; impl crate :: RegisterSpec for RX_LEN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`rx_len::R`](R) reader structure"] impl crate :: Readable for RX_LEN_SPEC { }
#[doc = "`reset()` method sets RX_LEN to value 0"] impl crate :: Resettable for RX_LEN_SPEC { } }
#[doc = "UEP4_1_MOD (rw) register accessor: endpoint 4/1 mode\n\nYou can [`read`](crate::Reg::read) this register and get [`uep4_1_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep4_1_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep4_1_mod`] module"] pub type UEP4_1_MOD = crate :: Reg < uep4_1_mod :: UEP4_1_MOD_SPEC > ;
#[doc = "endpoint 4/1 mode"] pub mod uep4_1_mod {
#[doc = "Register `UEP4_1_MOD` reader"] pub type R = crate :: R < UEP4_1_MOD_SPEC > ;
#[doc = "Register `UEP4_1_MOD` writer"] pub type W = crate :: W < UEP4_1_MOD_SPEC > ;
#[doc = "Field `UEP4_TX_EN` reader - enable USB endpoint 4 transmittal (IN)"] pub type UEP4_TX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP4_TX_EN` writer - enable USB endpoint 4 transmittal (IN)"] pub type UEP4_TX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP4_RX_EN` reader - enable USB endpoint 4 receiving (OUT)"] pub type UEP4_RX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP4_RX_EN` writer - enable USB endpoint 4 receiving (OUT)"] pub type UEP4_RX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP1_BUF_MOD` reader - buffer mode of USB endpoint 1"] pub type UEP1_BUF_MOD_R = crate :: BitReader ;
#[doc = "Field `UEP1_BUF_MOD` writer - buffer mode of USB endpoint 1"] pub type UEP1_BUF_MOD_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP1_TX_EN` reader - enable USB endpoint 1 transmittal (IN)"] pub type UEP1_TX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP1_TX_EN` writer - enable USB endpoint 1 transmittal (IN)"] pub type UEP1_TX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP1_RX_EN` reader - enable USB endpoint 1 receiving (OUT)"] pub type UEP1_RX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP1_RX_EN` writer - enable USB endpoint 1 receiving (OUT)"] pub type UEP1_RX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 2 - enable USB endpoint 4 transmittal (IN)"]
#[inline (always)] pub fn uep4_tx_en (& self) -> UEP4_TX_EN_R { UEP4_TX_EN_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - enable USB endpoint 4 receiving (OUT)"]
#[inline (always)] pub fn uep4_rx_en (& self) -> UEP4_RX_EN_R { UEP4_RX_EN_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - buffer mode of USB endpoint 1"]
#[inline (always)] pub fn uep1_buf_mod (& self) -> UEP1_BUF_MOD_R { UEP1_BUF_MOD_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - enable USB endpoint 1 transmittal (IN)"]
#[inline (always)] pub fn uep1_tx_en (& self) -> UEP1_TX_EN_R { UEP1_TX_EN_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - enable USB endpoint 1 receiving (OUT)"]
#[inline (always)] pub fn uep1_rx_en (& self) -> UEP1_RX_EN_R { UEP1_RX_EN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 2 - enable USB endpoint 4 transmittal (IN)"]
#[inline (always)] pub fn uep4_tx_en (& mut self) -> UEP4_TX_EN_W < UEP4_1_MOD_SPEC > { UEP4_TX_EN_W :: new (self , 2) }
#[doc = "Bit 3 - enable USB endpoint 4 receiving (OUT)"]
#[inline (always)] pub fn uep4_rx_en (& mut self) -> UEP4_RX_EN_W < UEP4_1_MOD_SPEC > { UEP4_RX_EN_W :: new (self , 3) }
#[doc = "Bit 4 - buffer mode of USB endpoint 1"]
#[inline (always)] pub fn uep1_buf_mod (& mut self) -> UEP1_BUF_MOD_W < UEP4_1_MOD_SPEC > { UEP1_BUF_MOD_W :: new (self , 4) }
#[doc = "Bit 6 - enable USB endpoint 1 transmittal (IN)"]
#[inline (always)] pub fn uep1_tx_en (& mut self) -> UEP1_TX_EN_W < UEP4_1_MOD_SPEC > { UEP1_TX_EN_W :: new (self , 6) }
#[doc = "Bit 7 - enable USB endpoint 1 receiving (OUT)"]
#[inline (always)] pub fn uep1_rx_en (& mut self) -> UEP1_RX_EN_W < UEP4_1_MOD_SPEC > { UEP1_RX_EN_W :: new (self , 7) } }
#[doc = "endpoint 4/1 mode\n\nYou can [`read`](crate::Reg::read) this register and get [`uep4_1_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep4_1_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP4_1_MOD_SPEC ; impl crate :: RegisterSpec for UEP4_1_MOD_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uep4_1_mod::R`](R) reader structure"] impl crate :: Readable for UEP4_1_MOD_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep4_1_mod::W`](W) writer structure"] impl crate :: Writable for UEP4_1_MOD_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP4_1_MOD to value 0"] impl crate :: Resettable for UEP4_1_MOD_SPEC { } }
#[doc = "UEP2_3_MOD (rw) register accessor: endpoint 2_3 mode\n\nYou can [`read`](crate::Reg::read) this register and get [`uep2_3_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep2_3_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep2_3_mod`] module"] pub type UEP2_3_MOD = crate :: Reg < uep2_3_mod :: UEP2_3_MOD_SPEC > ;
#[doc = "endpoint 2_3 mode"] pub mod uep2_3_mod {
#[doc = "Register `UEP2_3_MOD` reader"] pub type R = crate :: R < UEP2_3_MOD_SPEC > ;
#[doc = "Register `UEP2_3_MOD` writer"] pub type W = crate :: W < UEP2_3_MOD_SPEC > ;
#[doc = "Field `UEP2_BUF_MOD` reader - buffer mode of USB endpoint 2"] pub type UEP2_BUF_MOD_R = crate :: BitReader ;
#[doc = "Field `UEP2_BUF_MOD` writer - buffer mode of USB endpoint 2"] pub type UEP2_BUF_MOD_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP2_TX_EN` reader - enable USB endpoint 2 transmittal (IN)"] pub type UEP2_TX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP2_TX_EN` writer - enable USB endpoint 2 transmittal (IN)"] pub type UEP2_TX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP2_RX_EN` reader - enable USB endpoint 2 receiving (OUT)"] pub type UEP2_RX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP2_RX_EN` writer - enable USB endpoint 2 receiving (OUT)"] pub type UEP2_RX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP3_BUF_MOD` reader - buffer mode of USB endpoint 3"] pub type UEP3_BUF_MOD_R = crate :: BitReader ;
#[doc = "Field `UEP3_BUF_MOD` writer - buffer mode of USB endpoint 3"] pub type UEP3_BUF_MOD_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP3_TX_EN` reader - enable USB endpoint 3 transmittal (IN)"] pub type UEP3_TX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP3_TX_EN` writer - enable USB endpoint 3 transmittal (IN)"] pub type UEP3_TX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP3_RX_EN` reader - enable USB endpoint 3 receiving (OUT)"] pub type UEP3_RX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP3_RX_EN` writer - enable USB endpoint 3 receiving (OUT)"] pub type UEP3_RX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - buffer mode of USB endpoint 2"]
#[inline (always)] pub fn uep2_buf_mod (& self) -> UEP2_BUF_MOD_R { UEP2_BUF_MOD_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 2 - enable USB endpoint 2 transmittal (IN)"]
#[inline (always)] pub fn uep2_tx_en (& self) -> UEP2_TX_EN_R { UEP2_TX_EN_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - enable USB endpoint 2 receiving (OUT)"]
#[inline (always)] pub fn uep2_rx_en (& self) -> UEP2_RX_EN_R { UEP2_RX_EN_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - buffer mode of USB endpoint 3"]
#[inline (always)] pub fn uep3_buf_mod (& self) -> UEP3_BUF_MOD_R { UEP3_BUF_MOD_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - enable USB endpoint 3 transmittal (IN)"]
#[inline (always)] pub fn uep3_tx_en (& self) -> UEP3_TX_EN_R { UEP3_TX_EN_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - enable USB endpoint 3 receiving (OUT)"]
#[inline (always)] pub fn uep3_rx_en (& self) -> UEP3_RX_EN_R { UEP3_RX_EN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - buffer mode of USB endpoint 2"]
#[inline (always)] pub fn uep2_buf_mod (& mut self) -> UEP2_BUF_MOD_W < UEP2_3_MOD_SPEC > { UEP2_BUF_MOD_W :: new (self , 0) }
#[doc = "Bit 2 - enable USB endpoint 2 transmittal (IN)"]
#[inline (always)] pub fn uep2_tx_en (& mut self) -> UEP2_TX_EN_W < UEP2_3_MOD_SPEC > { UEP2_TX_EN_W :: new (self , 2) }
#[doc = "Bit 3 - enable USB endpoint 2 receiving (OUT)"]
#[inline (always)] pub fn uep2_rx_en (& mut self) -> UEP2_RX_EN_W < UEP2_3_MOD_SPEC > { UEP2_RX_EN_W :: new (self , 3) }
#[doc = "Bit 4 - buffer mode of USB endpoint 3"]
#[inline (always)] pub fn uep3_buf_mod (& mut self) -> UEP3_BUF_MOD_W < UEP2_3_MOD_SPEC > { UEP3_BUF_MOD_W :: new (self , 4) }
#[doc = "Bit 6 - enable USB endpoint 3 transmittal (IN)"]
#[inline (always)] pub fn uep3_tx_en (& mut self) -> UEP3_TX_EN_W < UEP2_3_MOD_SPEC > { UEP3_TX_EN_W :: new (self , 6) }
#[doc = "Bit 7 - enable USB endpoint 3 receiving (OUT)"]
#[inline (always)] pub fn uep3_rx_en (& mut self) -> UEP3_RX_EN_W < UEP2_3_MOD_SPEC > { UEP3_RX_EN_W :: new (self , 7) } }
#[doc = "endpoint 2_3 mode\n\nYou can [`read`](crate::Reg::read) this register and get [`uep2_3_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep2_3_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP2_3_MOD_SPEC ; impl crate :: RegisterSpec for UEP2_3_MOD_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uep2_3_mod::R`](R) reader structure"] impl crate :: Readable for UEP2_3_MOD_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep2_3_mod::W`](W) writer structure"] impl crate :: Writable for UEP2_3_MOD_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP2_3_MOD to value 0"] impl crate :: Resettable for UEP2_3_MOD_SPEC { } }
#[doc = "UH_EP_MOD (rw) register accessor: host endpoint mode\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_ep_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_ep_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uh_ep_mod`] module"] pub type UH_EP_MOD = crate :: Reg < uh_ep_mod :: UH_EP_MOD_SPEC > ;
#[doc = "host endpoint mode"] pub mod uh_ep_mod {
#[doc = "Register `UH_EP_MOD` reader"] pub type R = crate :: R < UH_EP_MOD_SPEC > ;
#[doc = "Register `UH_EP_MOD` writer"] pub type W = crate :: W < UH_EP_MOD_SPEC > ;
#[doc = "Field `UH_EP_RBUF_MOD` reader - buffer mode of USB host IN endpoint"] pub type UH_EP_RBUF_MOD_R = crate :: BitReader ;
#[doc = "Field `UH_EP_RBUF_MOD` writer - buffer mode of USB host IN endpoint"] pub type UH_EP_RBUF_MOD_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UH_EP_RX_EN` reader - enable USB host IN endpoint receiving"] pub type UH_EP_RX_EN_R = crate :: BitReader ;
#[doc = "Field `UH_EP_RX_EN` writer - enable USB host IN endpoint receiving"] pub type UH_EP_RX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UH_EP_TBUF_MOD` reader - buffer mode of USB host OUT endpoint"] pub type UH_EP_TBUF_MOD_R = crate :: BitReader ;
#[doc = "Field `UH_EP_TBUF_MOD` writer - buffer mode of USB host OUT endpoint"] pub type UH_EP_TBUF_MOD_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UH_EP_TX_EN` reader - enable USB host OUT endpoint transmittal"] pub type UH_EP_TX_EN_R = crate :: BitReader ;
#[doc = "Field `UH_EP_TX_EN` writer - enable USB host OUT endpoint transmittal"] pub type UH_EP_TX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - buffer mode of USB host IN endpoint"]
#[inline (always)] pub fn uh_ep_rbuf_mod (& self) -> UH_EP_RBUF_MOD_R { UH_EP_RBUF_MOD_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 3 - enable USB host IN endpoint receiving"]
#[inline (always)] pub fn uh_ep_rx_en (& self) -> UH_EP_RX_EN_R { UH_EP_RX_EN_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - buffer mode of USB host OUT endpoint"]
#[inline (always)] pub fn uh_ep_tbuf_mod (& self) -> UH_EP_TBUF_MOD_R { UH_EP_TBUF_MOD_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - enable USB host OUT endpoint transmittal"]
#[inline (always)] pub fn uh_ep_tx_en (& self) -> UH_EP_TX_EN_R { UH_EP_TX_EN_R :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bit 0 - buffer mode of USB host IN endpoint"]
#[inline (always)] pub fn uh_ep_rbuf_mod (& mut self) -> UH_EP_RBUF_MOD_W < UH_EP_MOD_SPEC > { UH_EP_RBUF_MOD_W :: new (self , 0) }
#[doc = "Bit 3 - enable USB host IN endpoint receiving"]
#[inline (always)] pub fn uh_ep_rx_en (& mut self) -> UH_EP_RX_EN_W < UH_EP_MOD_SPEC > { UH_EP_RX_EN_W :: new (self , 3) }
#[doc = "Bit 4 - buffer mode of USB host OUT endpoint"]
#[inline (always)] pub fn uh_ep_tbuf_mod (& mut self) -> UH_EP_TBUF_MOD_W < UH_EP_MOD_SPEC > { UH_EP_TBUF_MOD_W :: new (self , 4) }
#[doc = "Bit 6 - enable USB host OUT endpoint transmittal"]
#[inline (always)] pub fn uh_ep_tx_en (& mut self) -> UH_EP_TX_EN_W < UH_EP_MOD_SPEC > { UH_EP_TX_EN_W :: new (self , 6) } }
#[doc = "host endpoint mode\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_ep_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_ep_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UH_EP_MOD_SPEC ; impl crate :: RegisterSpec for UH_EP_MOD_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uh_ep_mod::R`](R) reader structure"] impl crate :: Readable for UH_EP_MOD_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uh_ep_mod::W`](W) writer structure"] impl crate :: Writable for UH_EP_MOD_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UH_EP_MOD to value 0"] impl crate :: Resettable for UH_EP_MOD_SPEC { } }
#[doc = "UEP567_MOD (rw) register accessor: endpoint 5/6/7 mode\n\nYou can [`read`](crate::Reg::read) this register and get [`uep567_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep567_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep567_mod`] module"] pub type UEP567_MOD = crate :: Reg < uep567_mod :: UEP567_MOD_SPEC > ;
#[doc = "endpoint 5/6/7 mode"] pub mod uep567_mod {
#[doc = "Register `UEP567_MOD` reader"] pub type R = crate :: R < UEP567_MOD_SPEC > ;
#[doc = "Register `UEP567_MOD` writer"] pub type W = crate :: W < UEP567_MOD_SPEC > ;
#[doc = "Field `UEP5_TX_EN` reader - enable USB endpoint 5 transmittal (IN)"] pub type UEP5_TX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP5_TX_EN` writer - enable USB endpoint 5 transmittal (IN)"] pub type UEP5_TX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP5_RX_EN` reader - enable USB endpoint 5 receiving (OUT)"] pub type UEP5_RX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP5_RX_EN` writer - enable USB endpoint 5 receiving (OUT)"] pub type UEP5_RX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP6_TX_EN` reader - enable USB endpoint 6 transmittal (IN)"] pub type UEP6_TX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP6_TX_EN` writer - enable USB endpoint 6 transmittal (IN)"] pub type UEP6_TX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP6_RX_EN` reader - enable USB endpoint 6 receiving (OUT)"] pub type UEP6_RX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP6_RX_EN` writer - enable USB endpoint 6 receiving (OUT)"] pub type UEP6_RX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP7_TX_EN` reader - enable USB endpoint 7 transmittal (IN)"] pub type UEP7_TX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP7_TX_EN` writer - enable USB endpoint 7 transmittal (IN)"] pub type UEP7_TX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP7_RX_EN` reader - enable USB endpoint 7 receiving (OUT)"] pub type UEP7_RX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP7_RX_EN` writer - enable USB endpoint 7 receiving (OUT)"] pub type UEP7_RX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - enable USB endpoint 5 transmittal (IN)"]
#[inline (always)] pub fn uep5_tx_en (& self) -> UEP5_TX_EN_R { UEP5_TX_EN_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - enable USB endpoint 5 receiving (OUT)"]
#[inline (always)] pub fn uep5_rx_en (& self) -> UEP5_RX_EN_R { UEP5_RX_EN_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - enable USB endpoint 6 transmittal (IN)"]
#[inline (always)] pub fn uep6_tx_en (& self) -> UEP6_TX_EN_R { UEP6_TX_EN_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - enable USB endpoint 6 receiving (OUT)"]
#[inline (always)] pub fn uep6_rx_en (& self) -> UEP6_RX_EN_R { UEP6_RX_EN_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - enable USB endpoint 7 transmittal (IN)"]
#[inline (always)] pub fn uep7_tx_en (& self) -> UEP7_TX_EN_R { UEP7_TX_EN_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - enable USB endpoint 7 receiving (OUT)"]
#[inline (always)] pub fn uep7_rx_en (& self) -> UEP7_RX_EN_R { UEP7_RX_EN_R :: new (((self . bits >> 5) & 1) != 0) } } impl W {
#[doc = "Bit 0 - enable USB endpoint 5 transmittal (IN)"]
#[inline (always)] pub fn uep5_tx_en (& mut self) -> UEP5_TX_EN_W < UEP567_MOD_SPEC > { UEP5_TX_EN_W :: new (self , 0) }
#[doc = "Bit 1 - enable USB endpoint 5 receiving (OUT)"]
#[inline (always)] pub fn uep5_rx_en (& mut self) -> UEP5_RX_EN_W < UEP567_MOD_SPEC > { UEP5_RX_EN_W :: new (self , 1) }
#[doc = "Bit 2 - enable USB endpoint 6 transmittal (IN)"]
#[inline (always)] pub fn uep6_tx_en (& mut self) -> UEP6_TX_EN_W < UEP567_MOD_SPEC > { UEP6_TX_EN_W :: new (self , 2) }
#[doc = "Bit 3 - enable USB endpoint 6 receiving (OUT)"]
#[inline (always)] pub fn uep6_rx_en (& mut self) -> UEP6_RX_EN_W < UEP567_MOD_SPEC > { UEP6_RX_EN_W :: new (self , 3) }
#[doc = "Bit 4 - enable USB endpoint 7 transmittal (IN)"]
#[inline (always)] pub fn uep7_tx_en (& mut self) -> UEP7_TX_EN_W < UEP567_MOD_SPEC > { UEP7_TX_EN_W :: new (self , 4) }
#[doc = "Bit 5 - enable USB endpoint 7 receiving (OUT)"]
#[inline (always)] pub fn uep7_rx_en (& mut self) -> UEP7_RX_EN_W < UEP567_MOD_SPEC > { UEP7_RX_EN_W :: new (self , 5) } }
#[doc = "endpoint 5/6/7 mode\n\nYou can [`read`](crate::Reg::read) this register and get [`uep567_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep567_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP567_MOD_SPEC ; impl crate :: RegisterSpec for UEP567_MOD_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uep567_mod::R`](R) reader structure"] impl crate :: Readable for UEP567_MOD_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep567_mod::W`](W) writer structure"] impl crate :: Writable for UEP567_MOD_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP567_MOD to value 0"] impl crate :: Resettable for UEP567_MOD_SPEC { } }
#[doc = "UEP0_DMA (rw) register accessor: endpoint 0 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep0_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep0_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep0_dma`] module"] pub type UEP0_DMA = crate :: Reg < uep0_dma :: UEP0_DMA_SPEC > ;
#[doc = "endpoint 0 DMA buffer address"] pub mod uep0_dma {
#[doc = "Register `UEP0_DMA` reader"] pub type R = crate :: R < UEP0_DMA_SPEC > ;
#[doc = "Register `UEP0_DMA` writer"] pub type W = crate :: W < UEP0_DMA_SPEC > ;
#[doc = "Field `UEP0_DMA` reader - RW,endpoint 0 DMA buffer address"] pub type UEP0_DMA_R = crate :: FieldReader < u16 > ;
#[doc = "Field `UEP0_DMA` writer - RW,endpoint 0 DMA buffer address"] pub type UEP0_DMA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW,endpoint 0 DMA buffer address"]
#[inline (always)] pub fn uep0_dma (& self) -> UEP0_DMA_R { UEP0_DMA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW,endpoint 0 DMA buffer address"]
#[inline (always)] pub fn uep0_dma (& mut self) -> UEP0_DMA_W < UEP0_DMA_SPEC > { UEP0_DMA_W :: new (self , 0) } }
#[doc = "endpoint 0 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep0_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep0_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP0_DMA_SPEC ; impl crate :: RegisterSpec for UEP0_DMA_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`uep0_dma::R`](R) reader structure"] impl crate :: Readable for UEP0_DMA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep0_dma::W`](W) writer structure"] impl crate :: Writable for UEP0_DMA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP0_DMA to value 0"] impl crate :: Resettable for UEP0_DMA_SPEC { } }
#[doc = "UEP1_DMA (rw) register accessor: endpoint 1 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep1_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep1_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep1_dma`] module"] pub type UEP1_DMA = crate :: Reg < uep1_dma :: UEP1_DMA_SPEC > ;
#[doc = "endpoint 1 DMA buffer address"] pub mod uep1_dma {
#[doc = "Register `UEP1_DMA` reader"] pub type R = crate :: R < UEP1_DMA_SPEC > ;
#[doc = "Register `UEP1_DMA` writer"] pub type W = crate :: W < UEP1_DMA_SPEC > ;
#[doc = "Field `UEP1_DMA` reader - RW,endpoint 1 DMA buffer address"] pub type UEP1_DMA_R = crate :: FieldReader < u16 > ;
#[doc = "Field `UEP1_DMA` writer - RW,endpoint 1 DMA buffer address"] pub type UEP1_DMA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW,endpoint 1 DMA buffer address"]
#[inline (always)] pub fn uep1_dma (& self) -> UEP1_DMA_R { UEP1_DMA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW,endpoint 1 DMA buffer address"]
#[inline (always)] pub fn uep1_dma (& mut self) -> UEP1_DMA_W < UEP1_DMA_SPEC > { UEP1_DMA_W :: new (self , 0) } }
#[doc = "endpoint 1 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep1_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep1_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP1_DMA_SPEC ; impl crate :: RegisterSpec for UEP1_DMA_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`uep1_dma::R`](R) reader structure"] impl crate :: Readable for UEP1_DMA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep1_dma::W`](W) writer structure"] impl crate :: Writable for UEP1_DMA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP1_DMA to value 0"] impl crate :: Resettable for UEP1_DMA_SPEC { } }
#[doc = "UEP2_DMA (rw) register accessor: endpoint 2 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep2_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep2_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep2_dma`] module"] pub type UEP2_DMA = crate :: Reg < uep2_dma :: UEP2_DMA_SPEC > ;
#[doc = "endpoint 2 DMA buffer address"] pub mod uep2_dma {
#[doc = "Register `UEP2_DMA` reader"] pub type R = crate :: R < UEP2_DMA_SPEC > ;
#[doc = "Register `UEP2_DMA` writer"] pub type W = crate :: W < UEP2_DMA_SPEC > ;
#[doc = "Field `UEP2_DMA` reader - RW,endpoint 2 DMA buffer address"] pub type UEP2_DMA_R = crate :: FieldReader < u16 > ;
#[doc = "Field `UEP2_DMA` writer - RW,endpoint 2 DMA buffer address"] pub type UEP2_DMA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW,endpoint 2 DMA buffer address"]
#[inline (always)] pub fn uep2_dma (& self) -> UEP2_DMA_R { UEP2_DMA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW,endpoint 2 DMA buffer address"]
#[inline (always)] pub fn uep2_dma (& mut self) -> UEP2_DMA_W < UEP2_DMA_SPEC > { UEP2_DMA_W :: new (self , 0) } }
#[doc = "endpoint 2 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep2_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep2_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP2_DMA_SPEC ; impl crate :: RegisterSpec for UEP2_DMA_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`uep2_dma::R`](R) reader structure"] impl crate :: Readable for UEP2_DMA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep2_dma::W`](W) writer structure"] impl crate :: Writable for UEP2_DMA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP2_DMA to value 0"] impl crate :: Resettable for UEP2_DMA_SPEC { } }
#[doc = "UH_RX_DMA (rw) register accessor: host rx endpoint buffer high address\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_rx_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_rx_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uh_rx_dma`] module"] pub type UH_RX_DMA = crate :: Reg < uh_rx_dma :: UH_RX_DMA_SPEC > ;
#[doc = "host rx endpoint buffer high address"] pub mod uh_rx_dma {
#[doc = "Register `UH_RX_DMA` reader"] pub type R = crate :: R < UH_RX_DMA_SPEC > ;
#[doc = "Register `UH_RX_DMA` writer"] pub type W = crate :: W < UH_RX_DMA_SPEC > ;
#[doc = "Field `UEP2_DMA` reader - RW,host rx endpoint buffer high address"] pub type UEP2_DMA_R = crate :: FieldReader < u16 > ;
#[doc = "Field `UEP2_DMA` writer - RW,host rx endpoint buffer high address"] pub type UEP2_DMA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW,host rx endpoint buffer high address"]
#[inline (always)] pub fn uep2_dma (& self) -> UEP2_DMA_R { UEP2_DMA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW,host rx endpoint buffer high address"]
#[inline (always)] pub fn uep2_dma (& mut self) -> UEP2_DMA_W < UH_RX_DMA_SPEC > { UEP2_DMA_W :: new (self , 0) } }
#[doc = "host rx endpoint buffer high address\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_rx_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_rx_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UH_RX_DMA_SPEC ; impl crate :: RegisterSpec for UH_RX_DMA_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`uh_rx_dma::R`](R) reader structure"] impl crate :: Readable for UH_RX_DMA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uh_rx_dma::W`](W) writer structure"] impl crate :: Writable for UH_RX_DMA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UH_RX_DMA to value 0"] impl crate :: Resettable for UH_RX_DMA_SPEC { } }
#[doc = "UEP3_DMA (rw) register accessor: endpoint 3 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep3_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep3_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep3_dma`] module"] pub type UEP3_DMA = crate :: Reg < uep3_dma :: UEP3_DMA_SPEC > ;
#[doc = "endpoint 3 DMA buffer address"] pub mod uep3_dma {
#[doc = "Register `UEP3_DMA` reader"] pub type R = crate :: R < UEP3_DMA_SPEC > ;
#[doc = "Register `UEP3_DMA` writer"] pub type W = crate :: W < UEP3_DMA_SPEC > ;
#[doc = "Field `UEP3_DMA` reader - RW,endpoint 3 DMA buffer address"] pub type UEP3_DMA_R = crate :: FieldReader < u16 > ;
#[doc = "Field `UEP3_DMA` writer - RW,endpoint 3 DMA buffer address"] pub type UEP3_DMA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW,endpoint 3 DMA buffer address"]
#[inline (always)] pub fn uep3_dma (& self) -> UEP3_DMA_R { UEP3_DMA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW,endpoint 3 DMA buffer address"]
#[inline (always)] pub fn uep3_dma (& mut self) -> UEP3_DMA_W < UEP3_DMA_SPEC > { UEP3_DMA_W :: new (self , 0) } }
#[doc = "endpoint 3 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep3_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep3_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP3_DMA_SPEC ; impl crate :: RegisterSpec for UEP3_DMA_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`uep3_dma::R`](R) reader structure"] impl crate :: Readable for UEP3_DMA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep3_dma::W`](W) writer structure"] impl crate :: Writable for UEP3_DMA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP3_DMA to value 0"] impl crate :: Resettable for UEP3_DMA_SPEC { } }
#[doc = "UH_TX_DMA (rw) register accessor: host tx endpoint buffer high address\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_tx_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_tx_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uh_tx_dma`] module"] pub type UH_TX_DMA = crate :: Reg < uh_tx_dma :: UH_TX_DMA_SPEC > ;
#[doc = "host tx endpoint buffer high address"] pub mod uh_tx_dma {
#[doc = "Register `UH_TX_DMA` reader"] pub type R = crate :: R < UH_TX_DMA_SPEC > ;
#[doc = "Register `UH_TX_DMA` writer"] pub type W = crate :: W < UH_TX_DMA_SPEC > ;
#[doc = "Field `UEP3_DMA` reader - RW,host tx endpoint buffer high address"] pub type UEP3_DMA_R = crate :: FieldReader < u16 > ;
#[doc = "Field `UEP3_DMA` writer - RW,host tx endpoint buffer high address"] pub type UEP3_DMA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW,host tx endpoint buffer high address"]
#[inline (always)] pub fn uep3_dma (& self) -> UEP3_DMA_R { UEP3_DMA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW,host tx endpoint buffer high address"]
#[inline (always)] pub fn uep3_dma (& mut self) -> UEP3_DMA_W < UH_TX_DMA_SPEC > { UEP3_DMA_W :: new (self , 0) } }
#[doc = "host tx endpoint buffer high address\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_tx_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_tx_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UH_TX_DMA_SPEC ; impl crate :: RegisterSpec for UH_TX_DMA_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`uh_tx_dma::R`](R) reader structure"] impl crate :: Readable for UH_TX_DMA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uh_tx_dma::W`](W) writer structure"] impl crate :: Writable for UH_TX_DMA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UH_TX_DMA to value 0"] impl crate :: Resettable for UH_TX_DMA_SPEC { } }
#[doc = "UEP5_DMA (rw) register accessor: endpoint 5 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep5_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep5_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep5_dma`] module"] pub type UEP5_DMA = crate :: Reg < uep5_dma :: UEP5_DMA_SPEC > ;
#[doc = "endpoint 5 DMA buffer address"] pub mod uep5_dma {
#[doc = "Register `UEP5_DMA` reader"] pub type R = crate :: R < UEP5_DMA_SPEC > ;
#[doc = "Register `UEP5_DMA` writer"] pub type W = crate :: W < UEP5_DMA_SPEC > ;
#[doc = "Field `UEP5_DMA` reader - RW,endpoint 5 DMA buffer address"] pub type UEP5_DMA_R = crate :: FieldReader < u16 > ;
#[doc = "Field `UEP5_DMA` writer - RW,endpoint 5 DMA buffer address"] pub type UEP5_DMA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW,endpoint 5 DMA buffer address"]
#[inline (always)] pub fn uep5_dma (& self) -> UEP5_DMA_R { UEP5_DMA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW,endpoint 5 DMA buffer address"]
#[inline (always)] pub fn uep5_dma (& mut self) -> UEP5_DMA_W < UEP5_DMA_SPEC > { UEP5_DMA_W :: new (self , 0) } }
#[doc = "endpoint 5 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep5_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep5_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP5_DMA_SPEC ; impl crate :: RegisterSpec for UEP5_DMA_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`uep5_dma::R`](R) reader structure"] impl crate :: Readable for UEP5_DMA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep5_dma::W`](W) writer structure"] impl crate :: Writable for UEP5_DMA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP5_DMA to value 0"] impl crate :: Resettable for UEP5_DMA_SPEC { } }
#[doc = "UEP6_DMA (rw) register accessor: endpoint 6 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep6_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep6_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep6_dma`] module"] pub type UEP6_DMA = crate :: Reg < uep6_dma :: UEP6_DMA_SPEC > ;
#[doc = "endpoint 6 DMA buffer address"] pub mod uep6_dma {
#[doc = "Register `UEP6_DMA` reader"] pub type R = crate :: R < UEP6_DMA_SPEC > ;
#[doc = "Register `UEP6_DMA` writer"] pub type W = crate :: W < UEP6_DMA_SPEC > ;
#[doc = "Field `UEP6_DMA` reader - RW,endpoint 6 DMA buffer address"] pub type UEP6_DMA_R = crate :: FieldReader < u16 > ;
#[doc = "Field `UEP6_DMA` writer - RW,endpoint 6 DMA buffer address"] pub type UEP6_DMA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW,endpoint 6 DMA buffer address"]
#[inline (always)] pub fn uep6_dma (& self) -> UEP6_DMA_R { UEP6_DMA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW,endpoint 6 DMA buffer address"]
#[inline (always)] pub fn uep6_dma (& mut self) -> UEP6_DMA_W < UEP6_DMA_SPEC > { UEP6_DMA_W :: new (self , 0) } }
#[doc = "endpoint 6 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep6_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep6_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP6_DMA_SPEC ; impl crate :: RegisterSpec for UEP6_DMA_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`uep6_dma::R`](R) reader structure"] impl crate :: Readable for UEP6_DMA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep6_dma::W`](W) writer structure"] impl crate :: Writable for UEP6_DMA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP6_DMA to value 0"] impl crate :: Resettable for UEP6_DMA_SPEC { } }
#[doc = "UEP7_DMA (rw) register accessor: endpoint 7 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep7_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep7_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep7_dma`] module"] pub type UEP7_DMA = crate :: Reg < uep7_dma :: UEP7_DMA_SPEC > ;
#[doc = "endpoint 7 DMA buffer address"] pub mod uep7_dma {
#[doc = "Register `UEP7_DMA` reader"] pub type R = crate :: R < UEP7_DMA_SPEC > ;
#[doc = "Register `UEP7_DMA` writer"] pub type W = crate :: W < UEP7_DMA_SPEC > ;
#[doc = "Field `UEP7_DMA` reader - RW,endpoint 7 DMA buffer address"] pub type UEP7_DMA_R = crate :: FieldReader < u16 > ;
#[doc = "Field `UEP7_DMA` writer - RW,endpoint 7 DMA buffer address"] pub type UEP7_DMA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW,endpoint 7 DMA buffer address"]
#[inline (always)] pub fn uep7_dma (& self) -> UEP7_DMA_R { UEP7_DMA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW,endpoint 7 DMA buffer address"]
#[inline (always)] pub fn uep7_dma (& mut self) -> UEP7_DMA_W < UEP7_DMA_SPEC > { UEP7_DMA_W :: new (self , 0) } }
#[doc = "endpoint 7 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`uep7_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep7_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP7_DMA_SPEC ; impl crate :: RegisterSpec for UEP7_DMA_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`uep7_dma::R`](R) reader structure"] impl crate :: Readable for UEP7_DMA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep7_dma::W`](W) writer structure"] impl crate :: Writable for UEP7_DMA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP7_DMA to value 0"] impl crate :: Resettable for UEP7_DMA_SPEC { } }
#[doc = "UEP0_T_LEN (rw) register accessor: endpoint 0 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep0_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep0_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep0_t_len`] module"] pub type UEP0_T_LEN = crate :: Reg < uep0_t_len :: UEP0_T_LEN_SPEC > ;
#[doc = "endpoint 0 transmittal length"] pub mod uep0_t_len {
#[doc = "Register `UEP0_T_LEN` reader"] pub type R = crate :: R < UEP0_T_LEN_SPEC > ;
#[doc = "Register `UEP0_T_LEN` writer"] pub type W = crate :: W < UEP0_T_LEN_SPEC > ;
#[doc = "Field `UEP0_T_LEN` reader - endpoint 0 transmittal length"] pub type UEP0_T_LEN_R = crate :: FieldReader ;
#[doc = "Field `UEP0_T_LEN` writer - endpoint 0 transmittal length"] pub type UEP0_T_LEN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - endpoint 0 transmittal length"]
#[inline (always)] pub fn uep0_t_len (& self) -> UEP0_T_LEN_R { UEP0_T_LEN_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - endpoint 0 transmittal length"]
#[inline (always)] pub fn uep0_t_len (& mut self) -> UEP0_T_LEN_W < UEP0_T_LEN_SPEC > { UEP0_T_LEN_W :: new (self , 0) } }
#[doc = "endpoint 0 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep0_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep0_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP0_T_LEN_SPEC ; impl crate :: RegisterSpec for UEP0_T_LEN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uep0_t_len::R`](R) reader structure"] impl crate :: Readable for UEP0_T_LEN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep0_t_len::W`](W) writer structure"] impl crate :: Writable for UEP0_T_LEN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP0_T_LEN to value 0"] impl crate :: Resettable for UEP0_T_LEN_SPEC { } }
#[doc = "UEP0_CTRL (rw) register accessor: endpoint 0 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep0_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep0_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep0_ctrl`] module"] pub type UEP0_CTRL = crate :: Reg < uep0_ctrl :: UEP0_CTRL_SPEC > ;
#[doc = "endpoint 0 control"] pub mod uep0_ctrl {
#[doc = "Register `UEP0_CTRL` reader"] pub type R = crate :: R < UEP0_CTRL_SPEC > ;
#[doc = "Register `UEP0_CTRL` writer"] pub type W = crate :: W < UEP0_CTRL_SPEC > ;
#[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& self) -> UEP_T_RES_R { UEP_T_RES_R :: new (self . bits & 3) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& self) -> UEP_R_RES_R { UEP_R_RES_R :: new ((self . bits >> 2) & 3) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& self) -> UEP_AUTO_TOG_R { UEP_AUTO_TOG_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& self) -> UEP_T_TOG_R { UEP_T_TOG_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& self) -> UEP_R_TOG_R { UEP_R_TOG_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& mut self) -> UEP_T_RES_W < UEP0_CTRL_SPEC > { UEP_T_RES_W :: new (self , 0) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& mut self) -> UEP_R_RES_W < UEP0_CTRL_SPEC > { UEP_R_RES_W :: new (self , 2) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& mut self) -> UEP_AUTO_TOG_W < UEP0_CTRL_SPEC > { UEP_AUTO_TOG_W :: new (self , 4) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& mut self) -> UEP_T_TOG_W < UEP0_CTRL_SPEC > { UEP_T_TOG_W :: new (self , 6) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& mut self) -> UEP_R_TOG_W < UEP0_CTRL_SPEC > { UEP_R_TOG_W :: new (self , 7) } }
#[doc = "endpoint 0 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep0_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep0_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP0_CTRL_SPEC ; impl crate :: RegisterSpec for UEP0_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uep0_ctrl::R`](R) reader structure"] impl crate :: Readable for UEP0_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep0_ctrl::W`](W) writer structure"] impl crate :: Writable for UEP0_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP0_CTRL to value 0"] impl crate :: Resettable for UEP0_CTRL_SPEC { } }
#[doc = "UEP1_T_LEN (rw) register accessor: endpoint 1 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep1_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep1_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep1_t_len`] module"] pub type UEP1_T_LEN = crate :: Reg < uep1_t_len :: UEP1_T_LEN_SPEC > ;
#[doc = "endpoint 1 transmittal length"] pub mod uep1_t_len {
#[doc = "Register `UEP1_T_LEN` reader"] pub type R = crate :: R < UEP1_T_LEN_SPEC > ;
#[doc = "Register `UEP1_T_LEN` writer"] pub type W = crate :: W < UEP1_T_LEN_SPEC > ;
#[doc = "Field `UEP1_T_LEN` reader - endpoint 1 transmittal length"] pub type UEP1_T_LEN_R = crate :: FieldReader ;
#[doc = "Field `UEP1_T_LEN` writer - endpoint 1 transmittal length"] pub type UEP1_T_LEN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - endpoint 1 transmittal length"]
#[inline (always)] pub fn uep1_t_len (& self) -> UEP1_T_LEN_R { UEP1_T_LEN_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - endpoint 1 transmittal length"]
#[inline (always)] pub fn uep1_t_len (& mut self) -> UEP1_T_LEN_W < UEP1_T_LEN_SPEC > { UEP1_T_LEN_W :: new (self , 0) } }
#[doc = "endpoint 1 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep1_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep1_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP1_T_LEN_SPEC ; impl crate :: RegisterSpec for UEP1_T_LEN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uep1_t_len::R`](R) reader structure"] impl crate :: Readable for UEP1_T_LEN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep1_t_len::W`](W) writer structure"] impl crate :: Writable for UEP1_T_LEN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP1_T_LEN to value 0"] impl crate :: Resettable for UEP1_T_LEN_SPEC { } }
#[doc = "UEP1_CTRL (rw) register accessor: endpoint 1 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep1_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep1_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep1_ctrl`] module"] pub type UEP1_CTRL = crate :: Reg < uep1_ctrl :: UEP1_CTRL_SPEC > ;
#[doc = "endpoint 1 control"] pub mod uep1_ctrl {
#[doc = "Register `UEP1_CTRL` reader"] pub type R = crate :: R < UEP1_CTRL_SPEC > ;
#[doc = "Register `UEP1_CTRL` writer"] pub type W = crate :: W < UEP1_CTRL_SPEC > ;
#[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& self) -> UEP_T_RES_R { UEP_T_RES_R :: new (self . bits & 3) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& self) -> UEP_R_RES_R { UEP_R_RES_R :: new ((self . bits >> 2) & 3) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& self) -> UEP_AUTO_TOG_R { UEP_AUTO_TOG_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& self) -> UEP_T_TOG_R { UEP_T_TOG_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& self) -> UEP_R_TOG_R { UEP_R_TOG_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& mut self) -> UEP_T_RES_W < UEP1_CTRL_SPEC > { UEP_T_RES_W :: new (self , 0) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& mut self) -> UEP_R_RES_W < UEP1_CTRL_SPEC > { UEP_R_RES_W :: new (self , 2) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& mut self) -> UEP_AUTO_TOG_W < UEP1_CTRL_SPEC > { UEP_AUTO_TOG_W :: new (self , 4) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& mut self) -> UEP_T_TOG_W < UEP1_CTRL_SPEC > { UEP_T_TOG_W :: new (self , 6) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& mut self) -> UEP_R_TOG_W < UEP1_CTRL_SPEC > { UEP_R_TOG_W :: new (self , 7) } }
#[doc = "endpoint 1 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep1_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep1_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP1_CTRL_SPEC ; impl crate :: RegisterSpec for UEP1_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uep1_ctrl::R`](R) reader structure"] impl crate :: Readable for UEP1_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep1_ctrl::W`](W) writer structure"] impl crate :: Writable for UEP1_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP1_CTRL to value 0"] impl crate :: Resettable for UEP1_CTRL_SPEC { } }
#[doc = "UH_SETUP (rw) register accessor: host aux setup\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_setup::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_setup::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uh_setup`] module"] pub type UH_SETUP = crate :: Reg < uh_setup :: UH_SETUP_SPEC > ;
#[doc = "host aux setup"] pub mod uh_setup {
#[doc = "Register `UH_SETUP` reader"] pub type R = crate :: R < UH_SETUP_SPEC > ;
#[doc = "Register `UH_SETUP` writer"] pub type W = crate :: W < UH_SETUP_SPEC > ;
#[doc = "Field `UH_SOF_EN` reader - USB host automatic SOF enable"] pub type UH_SOF_EN_R = crate :: BitReader ;
#[doc = "Field `UH_SOF_EN` writer - USB host automatic SOF enable"] pub type UH_SOF_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UH_PRE_PID_EN` reader - USB host PRE PID enable for low speed device via hub"] pub type UH_PRE_PID_EN_R = crate :: BitReader ;
#[doc = "Field `UH_PRE_PID_EN` writer - USB host PRE PID enable for low speed device via hub"] pub type UH_PRE_PID_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 6 - USB host automatic SOF enable"]
#[inline (always)] pub fn uh_sof_en (& self) -> UH_SOF_EN_R { UH_SOF_EN_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - USB host PRE PID enable for low speed device via hub"]
#[inline (always)] pub fn uh_pre_pid_en (& self) -> UH_PRE_PID_EN_R { UH_PRE_PID_EN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 6 - USB host automatic SOF enable"]
#[inline (always)] pub fn uh_sof_en (& mut self) -> UH_SOF_EN_W < UH_SETUP_SPEC > { UH_SOF_EN_W :: new (self , 6) }
#[doc = "Bit 7 - USB host PRE PID enable for low speed device via hub"]
#[inline (always)] pub fn uh_pre_pid_en (& mut self) -> UH_PRE_PID_EN_W < UH_SETUP_SPEC > { UH_PRE_PID_EN_W :: new (self , 7) } }
#[doc = "host aux setup\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_setup::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_setup::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UH_SETUP_SPEC ; impl crate :: RegisterSpec for UH_SETUP_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uh_setup::R`](R) reader structure"] impl crate :: Readable for UH_SETUP_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uh_setup::W`](W) writer structure"] impl crate :: Writable for UH_SETUP_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UH_SETUP to value 0"] impl crate :: Resettable for UH_SETUP_SPEC { } }
#[doc = "UEP2_T_LEN (rw) register accessor: endpoint 2 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep2_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep2_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep2_t_len`] module"] pub type UEP2_T_LEN = crate :: Reg < uep2_t_len :: UEP2_T_LEN_SPEC > ;
#[doc = "endpoint 2 transmittal length"] pub mod uep2_t_len {
#[doc = "Register `UEP2_T_LEN` reader"] pub type R = crate :: R < UEP2_T_LEN_SPEC > ;
#[doc = "Register `UEP2_T_LEN` writer"] pub type W = crate :: W < UEP2_T_LEN_SPEC > ;
#[doc = "Field `UEP2_T_LEN` reader - endpoint 2 transmittal length"] pub type UEP2_T_LEN_R = crate :: FieldReader ;
#[doc = "Field `UEP2_T_LEN` writer - endpoint 2 transmittal length"] pub type UEP2_T_LEN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - endpoint 2 transmittal length"]
#[inline (always)] pub fn uep2_t_len (& self) -> UEP2_T_LEN_R { UEP2_T_LEN_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - endpoint 2 transmittal length"]
#[inline (always)] pub fn uep2_t_len (& mut self) -> UEP2_T_LEN_W < UEP2_T_LEN_SPEC > { UEP2_T_LEN_W :: new (self , 0) } }
#[doc = "endpoint 2 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep2_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep2_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP2_T_LEN_SPEC ; impl crate :: RegisterSpec for UEP2_T_LEN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uep2_t_len::R`](R) reader structure"] impl crate :: Readable for UEP2_T_LEN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep2_t_len::W`](W) writer structure"] impl crate :: Writable for UEP2_T_LEN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP2_T_LEN to value 0"] impl crate :: Resettable for UEP2_T_LEN_SPEC { } }
#[doc = "UH_EP_PID (rw) register accessor: host endpoint and PID\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_ep_pid::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_ep_pid::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uh_ep_pid`] module"] pub type UH_EP_PID = crate :: Reg < uh_ep_pid :: UH_EP_PID_SPEC > ;
#[doc = "host endpoint and PID"] pub mod uh_ep_pid {
#[doc = "Register `UH_EP_PID` reader"] pub type R = crate :: R < UH_EP_PID_SPEC > ;
#[doc = "Register `UH_EP_PID` writer"] pub type W = crate :: W < UH_EP_PID_SPEC > ;
#[doc = "Field `UH_ENDP` reader - bit mask of endpoint number for USB host transfer"] pub type UH_ENDP_R = crate :: FieldReader ;
#[doc = "Field `UH_ENDP` writer - bit mask of endpoint number for USB host transfer"] pub type UH_ENDP_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `UH_TOKEN` reader - bit mask of token PID for USB host transfer"] pub type UH_TOKEN_R = crate :: FieldReader ;
#[doc = "Field `UH_TOKEN` writer - bit mask of token PID for USB host transfer"] pub type UH_TOKEN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - bit mask of endpoint number for USB host transfer"]
#[inline (always)] pub fn uh_endp (& self) -> UH_ENDP_R { UH_ENDP_R :: new (self . bits & 0x0f) }
#[doc = "Bits 4:7 - bit mask of token PID for USB host transfer"]
#[inline (always)] pub fn uh_token (& self) -> UH_TOKEN_R { UH_TOKEN_R :: new ((self . bits >> 4) & 0x0f) } } impl W {
#[doc = "Bits 0:3 - bit mask of endpoint number for USB host transfer"]
#[inline (always)] pub fn uh_endp (& mut self) -> UH_ENDP_W < UH_EP_PID_SPEC > { UH_ENDP_W :: new (self , 0) }
#[doc = "Bits 4:7 - bit mask of token PID for USB host transfer"]
#[inline (always)] pub fn uh_token (& mut self) -> UH_TOKEN_W < UH_EP_PID_SPEC > { UH_TOKEN_W :: new (self , 4) } }
#[doc = "host endpoint and PID\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_ep_pid::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_ep_pid::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UH_EP_PID_SPEC ; impl crate :: RegisterSpec for UH_EP_PID_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uh_ep_pid::R`](R) reader structure"] impl crate :: Readable for UH_EP_PID_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uh_ep_pid::W`](W) writer structure"] impl crate :: Writable for UH_EP_PID_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UH_EP_PID to value 0"] impl crate :: Resettable for UH_EP_PID_SPEC { } }
#[doc = "UEP2_CTRL (rw) register accessor: endpoint 2 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep2_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep2_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep2_ctrl`] module"] pub type UEP2_CTRL = crate :: Reg < uep2_ctrl :: UEP2_CTRL_SPEC > ;
#[doc = "endpoint 2 control"] pub mod uep2_ctrl {
#[doc = "Register `UEP2_CTRL` reader"] pub type R = crate :: R < UEP2_CTRL_SPEC > ;
#[doc = "Register `UEP2_CTRL` writer"] pub type W = crate :: W < UEP2_CTRL_SPEC > ;
#[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& self) -> UEP_T_RES_R { UEP_T_RES_R :: new (self . bits & 3) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& self) -> UEP_R_RES_R { UEP_R_RES_R :: new ((self . bits >> 2) & 3) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& self) -> UEP_AUTO_TOG_R { UEP_AUTO_TOG_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& self) -> UEP_T_TOG_R { UEP_T_TOG_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& self) -> UEP_R_TOG_R { UEP_R_TOG_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& mut self) -> UEP_T_RES_W < UEP2_CTRL_SPEC > { UEP_T_RES_W :: new (self , 0) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& mut self) -> UEP_R_RES_W < UEP2_CTRL_SPEC > { UEP_R_RES_W :: new (self , 2) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& mut self) -> UEP_AUTO_TOG_W < UEP2_CTRL_SPEC > { UEP_AUTO_TOG_W :: new (self , 4) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& mut self) -> UEP_T_TOG_W < UEP2_CTRL_SPEC > { UEP_T_TOG_W :: new (self , 6) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& mut self) -> UEP_R_TOG_W < UEP2_CTRL_SPEC > { UEP_R_TOG_W :: new (self , 7) } }
#[doc = "endpoint 2 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep2_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep2_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP2_CTRL_SPEC ; impl crate :: RegisterSpec for UEP2_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uep2_ctrl::R`](R) reader structure"] impl crate :: Readable for UEP2_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep2_ctrl::W`](W) writer structure"] impl crate :: Writable for UEP2_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP2_CTRL to value 0"] impl crate :: Resettable for UEP2_CTRL_SPEC { } }
#[doc = "UH_RX_CTRL (rw) register accessor: host receiver endpoint control\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_rx_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_rx_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uh_rx_ctrl`] module"] pub type UH_RX_CTRL = crate :: Reg < uh_rx_ctrl :: UH_RX_CTRL_SPEC > ;
#[doc = "host receiver endpoint control"] pub mod uh_rx_ctrl {
#[doc = "Register `UH_RX_CTRL` reader"] pub type R = crate :: R < UH_RX_CTRL_SPEC > ;
#[doc = "Register `UH_RX_CTRL` writer"] pub type W = crate :: W < UH_RX_CTRL_SPEC > ;
#[doc = "Field `UH_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UH_R_RES_R = crate :: BitReader ;
#[doc = "Field `UH_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UH_R_RES_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UH_R_AUTO_TOG` reader - enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle"] pub type UH_R_AUTO_TOG_R = crate :: BitReader ;
#[doc = "Field `UH_R_AUTO_TOG` writer - enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle"] pub type UH_R_AUTO_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UH_R_TOG` reader - expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1"] pub type UH_R_TOG_R = crate :: BitReader ;
#[doc = "Field `UH_R_TOG` writer - expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1"] pub type UH_R_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 2 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uh_r_res (& self) -> UH_R_RES_R { UH_R_RES_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& self) -> UEP_R_RES_R { UEP_R_RES_R :: new ((self . bits >> 2) & 3) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uh_r_auto_tog (& self) -> UH_R_AUTO_TOG_R { UH_R_AUTO_TOG_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 7 - expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uh_r_tog (& self) -> UH_R_TOG_R { UH_R_TOG_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 2 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uh_r_res (& mut self) -> UH_R_RES_W < UH_RX_CTRL_SPEC > { UH_R_RES_W :: new (self , 2) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& mut self) -> UEP_R_RES_W < UH_RX_CTRL_SPEC > { UEP_R_RES_W :: new (self , 2) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uh_r_auto_tog (& mut self) -> UH_R_AUTO_TOG_W < UH_RX_CTRL_SPEC > { UH_R_AUTO_TOG_W :: new (self , 4) }
#[doc = "Bit 7 - expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uh_r_tog (& mut self) -> UH_R_TOG_W < UH_RX_CTRL_SPEC > { UH_R_TOG_W :: new (self , 7) } }
#[doc = "host receiver endpoint control\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_rx_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_rx_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UH_RX_CTRL_SPEC ; impl crate :: RegisterSpec for UH_RX_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uh_rx_ctrl::R`](R) reader structure"] impl crate :: Readable for UH_RX_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uh_rx_ctrl::W`](W) writer structure"] impl crate :: Writable for UH_RX_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UH_RX_CTRL to value 0"] impl crate :: Resettable for UH_RX_CTRL_SPEC { } }
#[doc = "UEP3_T_LEN (rw) register accessor: endpoint 3 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep3_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep3_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep3_t_len`] module"] pub type UEP3_T_LEN = crate :: Reg < uep3_t_len :: UEP3_T_LEN_SPEC > ;
#[doc = "endpoint 3 transmittal length"] pub mod uep3_t_len {
#[doc = "Register `UEP3_T_LEN` reader"] pub type R = crate :: R < UEP3_T_LEN_SPEC > ;
#[doc = "Register `UEP3_T_LEN` writer"] pub type W = crate :: W < UEP3_T_LEN_SPEC > ;
#[doc = "Field `UEP3_T_LEN` reader - endpoint 1 transmittal length"] pub type UEP3_T_LEN_R = crate :: FieldReader ;
#[doc = "Field `UEP3_T_LEN` writer - endpoint 1 transmittal length"] pub type UEP3_T_LEN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - endpoint 1 transmittal length"]
#[inline (always)] pub fn uep3_t_len (& self) -> UEP3_T_LEN_R { UEP3_T_LEN_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - endpoint 1 transmittal length"]
#[inline (always)] pub fn uep3_t_len (& mut self) -> UEP3_T_LEN_W < UEP3_T_LEN_SPEC > { UEP3_T_LEN_W :: new (self , 0) } }
#[doc = "endpoint 3 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep3_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep3_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP3_T_LEN_SPEC ; impl crate :: RegisterSpec for UEP3_T_LEN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uep3_t_len::R`](R) reader structure"] impl crate :: Readable for UEP3_T_LEN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep3_t_len::W`](W) writer structure"] impl crate :: Writable for UEP3_T_LEN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP3_T_LEN to value 0"] impl crate :: Resettable for UEP3_T_LEN_SPEC { } }
#[doc = "UH_TX_LEN (rw) register accessor: host transmittal endpoint transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_tx_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_tx_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uh_tx_len`] module"] pub type UH_TX_LEN = crate :: Reg < uh_tx_len :: UH_TX_LEN_SPEC > ;
#[doc = "host transmittal endpoint transmittal length"] pub mod uh_tx_len {
#[doc = "Register `UH_TX_LEN` reader"] pub type R = crate :: R < UH_TX_LEN_SPEC > ;
#[doc = "Register `UH_TX_LEN` writer"] pub type W = crate :: W < UH_TX_LEN_SPEC > ;
#[doc = "Field `UH_TX_LEN` reader - endpoint 1 transmittal length"] pub type UH_TX_LEN_R = crate :: FieldReader ;
#[doc = "Field `UH_TX_LEN` writer - endpoint 1 transmittal length"] pub type UH_TX_LEN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - endpoint 1 transmittal length"]
#[inline (always)] pub fn uh_tx_len (& self) -> UH_TX_LEN_R { UH_TX_LEN_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - endpoint 1 transmittal length"]
#[inline (always)] pub fn uh_tx_len (& mut self) -> UH_TX_LEN_W < UH_TX_LEN_SPEC > { UH_TX_LEN_W :: new (self , 0) } }
#[doc = "host transmittal endpoint transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_tx_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_tx_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UH_TX_LEN_SPEC ; impl crate :: RegisterSpec for UH_TX_LEN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uh_tx_len::R`](R) reader structure"] impl crate :: Readable for UH_TX_LEN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uh_tx_len::W`](W) writer structure"] impl crate :: Writable for UH_TX_LEN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UH_TX_LEN to value 0"] impl crate :: Resettable for UH_TX_LEN_SPEC { } }
#[doc = "UEP3_CTRL (rw) register accessor: endpoint 3 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep3_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep3_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep3_ctrl`] module"] pub type UEP3_CTRL = crate :: Reg < uep3_ctrl :: UEP3_CTRL_SPEC > ;
#[doc = "endpoint 3 control"] pub mod uep3_ctrl {
#[doc = "Register `UEP3_CTRL` reader"] pub type R = crate :: R < UEP3_CTRL_SPEC > ;
#[doc = "Register `UEP3_CTRL` writer"] pub type W = crate :: W < UEP3_CTRL_SPEC > ;
#[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& self) -> UEP_T_RES_R { UEP_T_RES_R :: new (self . bits & 3) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& self) -> UEP_R_RES_R { UEP_R_RES_R :: new ((self . bits >> 2) & 3) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& self) -> UEP_AUTO_TOG_R { UEP_AUTO_TOG_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& self) -> UEP_T_TOG_R { UEP_T_TOG_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& self) -> UEP_R_TOG_R { UEP_R_TOG_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& mut self) -> UEP_T_RES_W < UEP3_CTRL_SPEC > { UEP_T_RES_W :: new (self , 0) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& mut self) -> UEP_R_RES_W < UEP3_CTRL_SPEC > { UEP_R_RES_W :: new (self , 2) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& mut self) -> UEP_AUTO_TOG_W < UEP3_CTRL_SPEC > { UEP_AUTO_TOG_W :: new (self , 4) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& mut self) -> UEP_T_TOG_W < UEP3_CTRL_SPEC > { UEP_T_TOG_W :: new (self , 6) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& mut self) -> UEP_R_TOG_W < UEP3_CTRL_SPEC > { UEP_R_TOG_W :: new (self , 7) } }
#[doc = "endpoint 3 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep3_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep3_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP3_CTRL_SPEC ; impl crate :: RegisterSpec for UEP3_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uep3_ctrl::R`](R) reader structure"] impl crate :: Readable for UEP3_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep3_ctrl::W`](W) writer structure"] impl crate :: Writable for UEP3_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP3_CTRL to value 0"] impl crate :: Resettable for UEP3_CTRL_SPEC { } }
#[doc = "UH_TX_CTRL (rw) register accessor: host transmittal endpoint control\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_tx_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_tx_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uh_tx_ctrl`] module"] pub type UH_TX_CTRL = crate :: Reg < uh_tx_ctrl :: UH_TX_CTRL_SPEC > ;
#[doc = "host transmittal endpoint control"] pub mod uh_tx_ctrl {
#[doc = "Register `UH_TX_CTRL` reader"] pub type R = crate :: R < UH_TX_CTRL_SPEC > ;
#[doc = "Register `UH_TX_CTRL` writer"] pub type W = crate :: W < UH_TX_CTRL_SPEC > ;
#[doc = "Field `UH_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UH_T_RES_R = crate :: FieldReader ;
#[doc = "Field `UH_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UH_T_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UH_T_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UH_T_AUTO_TOG_R = crate :: BitReader ;
#[doc = "Field `UH_T_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UH_T_AUTO_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UH_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UH_T_TOG_R = crate :: BitReader ;
#[doc = "Field `UH_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UH_T_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uh_t_res (& self) -> UH_T_RES_R { UH_T_RES_R :: new (self . bits & 3) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uh_t_auto_tog (& self) -> UH_T_AUTO_TOG_R { UH_T_AUTO_TOG_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uh_t_tog (& self) -> UH_T_TOG_R { UH_T_TOG_R :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uh_t_res (& mut self) -> UH_T_RES_W < UH_TX_CTRL_SPEC > { UH_T_RES_W :: new (self , 0) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uh_t_auto_tog (& mut self) -> UH_T_AUTO_TOG_W < UH_TX_CTRL_SPEC > { UH_T_AUTO_TOG_W :: new (self , 4) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uh_t_tog (& mut self) -> UH_T_TOG_W < UH_TX_CTRL_SPEC > { UH_T_TOG_W :: new (self , 6) } }
#[doc = "host transmittal endpoint control\n\nYou can [`read`](crate::Reg::read) this register and get [`uh_tx_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uh_tx_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UH_TX_CTRL_SPEC ; impl crate :: RegisterSpec for UH_TX_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uh_tx_ctrl::R`](R) reader structure"] impl crate :: Readable for UH_TX_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uh_tx_ctrl::W`](W) writer structure"] impl crate :: Writable for UH_TX_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UH_TX_CTRL to value 0"] impl crate :: Resettable for UH_TX_CTRL_SPEC { } }
#[doc = "UEP4_T_LEN (rw) register accessor: endpoint 4 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep4_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep4_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep4_t_len`] module"] pub type UEP4_T_LEN = crate :: Reg < uep4_t_len :: UEP4_T_LEN_SPEC > ;
#[doc = "endpoint 4 transmittal length"] pub mod uep4_t_len {
#[doc = "Register `UEP4_T_LEN` reader"] pub type R = crate :: R < UEP4_T_LEN_SPEC > ;
#[doc = "Register `UEP4_T_LEN` writer"] pub type W = crate :: W < UEP4_T_LEN_SPEC > ;
#[doc = "Field `UEP4_T_LEN` reader - endpoint 4 transmittal length"] pub type UEP4_T_LEN_R = crate :: FieldReader ;
#[doc = "Field `UEP4_T_LEN` writer - endpoint 4 transmittal length"] pub type UEP4_T_LEN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - endpoint 4 transmittal length"]
#[inline (always)] pub fn uep4_t_len (& self) -> UEP4_T_LEN_R { UEP4_T_LEN_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - endpoint 4 transmittal length"]
#[inline (always)] pub fn uep4_t_len (& mut self) -> UEP4_T_LEN_W < UEP4_T_LEN_SPEC > { UEP4_T_LEN_W :: new (self , 0) } }
#[doc = "endpoint 4 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep4_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep4_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP4_T_LEN_SPEC ; impl crate :: RegisterSpec for UEP4_T_LEN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uep4_t_len::R`](R) reader structure"] impl crate :: Readable for UEP4_T_LEN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep4_t_len::W`](W) writer structure"] impl crate :: Writable for UEP4_T_LEN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP4_T_LEN to value 0"] impl crate :: Resettable for UEP4_T_LEN_SPEC { } }
#[doc = "UEP4_CTRL (rw) register accessor: endpoint 4 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep4_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep4_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep4_ctrl`] module"] pub type UEP4_CTRL = crate :: Reg < uep4_ctrl :: UEP4_CTRL_SPEC > ;
#[doc = "endpoint 4 control"] pub mod uep4_ctrl {
#[doc = "Register `UEP4_CTRL` reader"] pub type R = crate :: R < UEP4_CTRL_SPEC > ;
#[doc = "Register `UEP4_CTRL` writer"] pub type W = crate :: W < UEP4_CTRL_SPEC > ;
#[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& self) -> UEP_T_RES_R { UEP_T_RES_R :: new (self . bits & 3) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& self) -> UEP_R_RES_R { UEP_R_RES_R :: new ((self . bits >> 2) & 3) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& self) -> UEP_AUTO_TOG_R { UEP_AUTO_TOG_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& self) -> UEP_T_TOG_R { UEP_T_TOG_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& self) -> UEP_R_TOG_R { UEP_R_TOG_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& mut self) -> UEP_T_RES_W < UEP4_CTRL_SPEC > { UEP_T_RES_W :: new (self , 0) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& mut self) -> UEP_R_RES_W < UEP4_CTRL_SPEC > { UEP_R_RES_W :: new (self , 2) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& mut self) -> UEP_AUTO_TOG_W < UEP4_CTRL_SPEC > { UEP_AUTO_TOG_W :: new (self , 4) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& mut self) -> UEP_T_TOG_W < UEP4_CTRL_SPEC > { UEP_T_TOG_W :: new (self , 6) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& mut self) -> UEP_R_TOG_W < UEP4_CTRL_SPEC > { UEP_R_TOG_W :: new (self , 7) } }
#[doc = "endpoint 4 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep4_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep4_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP4_CTRL_SPEC ; impl crate :: RegisterSpec for UEP4_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uep4_ctrl::R`](R) reader structure"] impl crate :: Readable for UEP4_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep4_ctrl::W`](W) writer structure"] impl crate :: Writable for UEP4_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP4_CTRL to value 0"] impl crate :: Resettable for UEP4_CTRL_SPEC { } }
#[doc = "UEP5_T_LEN (rw) register accessor: endpoint 5 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep5_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep5_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep5_t_len`] module"] pub type UEP5_T_LEN = crate :: Reg < uep5_t_len :: UEP5_T_LEN_SPEC > ;
#[doc = "endpoint 5 transmittal length"] pub mod uep5_t_len {
#[doc = "Register `UEP5_T_LEN` reader"] pub type R = crate :: R < UEP5_T_LEN_SPEC > ;
#[doc = "Register `UEP5_T_LEN` writer"] pub type W = crate :: W < UEP5_T_LEN_SPEC > ;
#[doc = "Field `UEP5_T_LEN` reader - endpoint 5 transmittal length"] pub type UEP5_T_LEN_R = crate :: FieldReader ;
#[doc = "Field `UEP5_T_LEN` writer - endpoint 5 transmittal length"] pub type UEP5_T_LEN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - endpoint 5 transmittal length"]
#[inline (always)] pub fn uep5_t_len (& self) -> UEP5_T_LEN_R { UEP5_T_LEN_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - endpoint 5 transmittal length"]
#[inline (always)] pub fn uep5_t_len (& mut self) -> UEP5_T_LEN_W < UEP5_T_LEN_SPEC > { UEP5_T_LEN_W :: new (self , 0) } }
#[doc = "endpoint 5 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep5_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep5_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP5_T_LEN_SPEC ; impl crate :: RegisterSpec for UEP5_T_LEN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uep5_t_len::R`](R) reader structure"] impl crate :: Readable for UEP5_T_LEN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep5_t_len::W`](W) writer structure"] impl crate :: Writable for UEP5_T_LEN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP5_T_LEN to value 0"] impl crate :: Resettable for UEP5_T_LEN_SPEC { } }
#[doc = "UEP5_CTRL (rw) register accessor: endpoint 5 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep5_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep5_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep5_ctrl`] module"] pub type UEP5_CTRL = crate :: Reg < uep5_ctrl :: UEP5_CTRL_SPEC > ;
#[doc = "endpoint 5 control"] pub mod uep5_ctrl {
#[doc = "Register `UEP5_CTRL` reader"] pub type R = crate :: R < UEP5_CTRL_SPEC > ;
#[doc = "Register `UEP5_CTRL` writer"] pub type W = crate :: W < UEP5_CTRL_SPEC > ;
#[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& self) -> UEP_T_RES_R { UEP_T_RES_R :: new (self . bits & 3) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& self) -> UEP_R_RES_R { UEP_R_RES_R :: new ((self . bits >> 2) & 3) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& self) -> UEP_AUTO_TOG_R { UEP_AUTO_TOG_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& self) -> UEP_T_TOG_R { UEP_T_TOG_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& self) -> UEP_R_TOG_R { UEP_R_TOG_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& mut self) -> UEP_T_RES_W < UEP5_CTRL_SPEC > { UEP_T_RES_W :: new (self , 0) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& mut self) -> UEP_R_RES_W < UEP5_CTRL_SPEC > { UEP_R_RES_W :: new (self , 2) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& mut self) -> UEP_AUTO_TOG_W < UEP5_CTRL_SPEC > { UEP_AUTO_TOG_W :: new (self , 4) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& mut self) -> UEP_T_TOG_W < UEP5_CTRL_SPEC > { UEP_T_TOG_W :: new (self , 6) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& mut self) -> UEP_R_TOG_W < UEP5_CTRL_SPEC > { UEP_R_TOG_W :: new (self , 7) } }
#[doc = "endpoint 5 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep5_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep5_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP5_CTRL_SPEC ; impl crate :: RegisterSpec for UEP5_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uep5_ctrl::R`](R) reader structure"] impl crate :: Readable for UEP5_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep5_ctrl::W`](W) writer structure"] impl crate :: Writable for UEP5_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP5_CTRL to value 0"] impl crate :: Resettable for UEP5_CTRL_SPEC { } }
#[doc = "UEP6_T_LEN (rw) register accessor: endpoint 6 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep6_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep6_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep6_t_len`] module"] pub type UEP6_T_LEN = crate :: Reg < uep6_t_len :: UEP6_T_LEN_SPEC > ;
#[doc = "endpoint 6 transmittal length"] pub mod uep6_t_len {
#[doc = "Register `UEP6_T_LEN` reader"] pub type R = crate :: R < UEP6_T_LEN_SPEC > ;
#[doc = "Register `UEP6_T_LEN` writer"] pub type W = crate :: W < UEP6_T_LEN_SPEC > ;
#[doc = "Field `UEP6_T_LEN` reader - endpoint 6 transmittal length"] pub type UEP6_T_LEN_R = crate :: FieldReader ;
#[doc = "Field `UEP6_T_LEN` writer - endpoint 6 transmittal length"] pub type UEP6_T_LEN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - endpoint 6 transmittal length"]
#[inline (always)] pub fn uep6_t_len (& self) -> UEP6_T_LEN_R { UEP6_T_LEN_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - endpoint 6 transmittal length"]
#[inline (always)] pub fn uep6_t_len (& mut self) -> UEP6_T_LEN_W < UEP6_T_LEN_SPEC > { UEP6_T_LEN_W :: new (self , 0) } }
#[doc = "endpoint 6 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep6_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep6_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP6_T_LEN_SPEC ; impl crate :: RegisterSpec for UEP6_T_LEN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uep6_t_len::R`](R) reader structure"] impl crate :: Readable for UEP6_T_LEN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep6_t_len::W`](W) writer structure"] impl crate :: Writable for UEP6_T_LEN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP6_T_LEN to value 0"] impl crate :: Resettable for UEP6_T_LEN_SPEC { } }
#[doc = "UEP6_CTRL (rw) register accessor: endpoint 6 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep6_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep6_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep6_ctrl`] module"] pub type UEP6_CTRL = crate :: Reg < uep6_ctrl :: UEP6_CTRL_SPEC > ;
#[doc = "endpoint 6 control"] pub mod uep6_ctrl {
#[doc = "Register `UEP6_CTRL` reader"] pub type R = crate :: R < UEP6_CTRL_SPEC > ;
#[doc = "Register `UEP6_CTRL` writer"] pub type W = crate :: W < UEP6_CTRL_SPEC > ;
#[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& self) -> UEP_T_RES_R { UEP_T_RES_R :: new (self . bits & 3) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& self) -> UEP_R_RES_R { UEP_R_RES_R :: new ((self . bits >> 2) & 3) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& self) -> UEP_AUTO_TOG_R { UEP_AUTO_TOG_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& self) -> UEP_T_TOG_R { UEP_T_TOG_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& self) -> UEP_R_TOG_R { UEP_R_TOG_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& mut self) -> UEP_T_RES_W < UEP6_CTRL_SPEC > { UEP_T_RES_W :: new (self , 0) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& mut self) -> UEP_R_RES_W < UEP6_CTRL_SPEC > { UEP_R_RES_W :: new (self , 2) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& mut self) -> UEP_AUTO_TOG_W < UEP6_CTRL_SPEC > { UEP_AUTO_TOG_W :: new (self , 4) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& mut self) -> UEP_T_TOG_W < UEP6_CTRL_SPEC > { UEP_T_TOG_W :: new (self , 6) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& mut self) -> UEP_R_TOG_W < UEP6_CTRL_SPEC > { UEP_R_TOG_W :: new (self , 7) } }
#[doc = "endpoint 6 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep6_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep6_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP6_CTRL_SPEC ; impl crate :: RegisterSpec for UEP6_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uep6_ctrl::R`](R) reader structure"] impl crate :: Readable for UEP6_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep6_ctrl::W`](W) writer structure"] impl crate :: Writable for UEP6_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP6_CTRL to value 0"] impl crate :: Resettable for UEP6_CTRL_SPEC { } }
#[doc = "UEP7_T_LEN (rw) register accessor: endpoint 7 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep7_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep7_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep7_t_len`] module"] pub type UEP7_T_LEN = crate :: Reg < uep7_t_len :: UEP7_T_LEN_SPEC > ;
#[doc = "endpoint 7 transmittal length"] pub mod uep7_t_len {
#[doc = "Register `UEP7_T_LEN` reader"] pub type R = crate :: R < UEP7_T_LEN_SPEC > ;
#[doc = "Register `UEP7_T_LEN` writer"] pub type W = crate :: W < UEP7_T_LEN_SPEC > ;
#[doc = "Field `UEP7_T_LEN` reader - endpoint 7 transmittal length"] pub type UEP7_T_LEN_R = crate :: FieldReader ;
#[doc = "Field `UEP7_T_LEN` writer - endpoint 7 transmittal length"] pub type UEP7_T_LEN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - endpoint 7 transmittal length"]
#[inline (always)] pub fn uep7_t_len (& self) -> UEP7_T_LEN_R { UEP7_T_LEN_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - endpoint 7 transmittal length"]
#[inline (always)] pub fn uep7_t_len (& mut self) -> UEP7_T_LEN_W < UEP7_T_LEN_SPEC > { UEP7_T_LEN_W :: new (self , 0) } }
#[doc = "endpoint 7 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`uep7_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep7_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP7_T_LEN_SPEC ; impl crate :: RegisterSpec for UEP7_T_LEN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uep7_t_len::R`](R) reader structure"] impl crate :: Readable for UEP7_T_LEN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep7_t_len::W`](W) writer structure"] impl crate :: Writable for UEP7_T_LEN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP7_T_LEN to value 0"] impl crate :: Resettable for UEP7_T_LEN_SPEC { } }
#[doc = "UEP7_CTRL (rw) register accessor: endpoint 7 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep7_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep7_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@uep7_ctrl`] module"] pub type UEP7_CTRL = crate :: Reg < uep7_ctrl :: UEP7_CTRL_SPEC > ;
#[doc = "endpoint 7 control"] pub mod uep7_ctrl {
#[doc = "Register `UEP7_CTRL` reader"] pub type R = crate :: R < UEP7_CTRL_SPEC > ;
#[doc = "Register `UEP7_CTRL` writer"] pub type W = crate :: W < UEP7_CTRL_SPEC > ;
#[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& self) -> UEP_T_RES_R { UEP_T_RES_R :: new (self . bits & 3) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& self) -> UEP_R_RES_R { UEP_R_RES_R :: new ((self . bits >> 2) & 3) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& self) -> UEP_AUTO_TOG_R { UEP_AUTO_TOG_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& self) -> UEP_T_TOG_R { UEP_T_TOG_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& self) -> UEP_R_TOG_R { UEP_R_TOG_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& mut self) -> UEP_T_RES_W < UEP7_CTRL_SPEC > { UEP_T_RES_W :: new (self , 0) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& mut self) -> UEP_R_RES_W < UEP7_CTRL_SPEC > { UEP_R_RES_W :: new (self , 2) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& mut self) -> UEP_AUTO_TOG_W < UEP7_CTRL_SPEC > { UEP_AUTO_TOG_W :: new (self , 4) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& mut self) -> UEP_T_TOG_W < UEP7_CTRL_SPEC > { UEP_T_TOG_W :: new (self , 6) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& mut self) -> UEP_R_TOG_W < UEP7_CTRL_SPEC > { UEP_R_TOG_W :: new (self , 7) } }
#[doc = "endpoint 7 control\n\nYou can [`read`](crate::Reg::read) this register and get [`uep7_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`uep7_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct UEP7_CTRL_SPEC ; impl crate :: RegisterSpec for UEP7_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`uep7_ctrl::R`](R) reader structure"] impl crate :: Readable for UEP7_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`uep7_ctrl::W`](W) writer structure"] impl crate :: Writable for UEP7_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets UEP7_CTRL to value 0"] impl crate :: Resettable for UEP7_CTRL_SPEC { } } }
#[doc = "USB2 register"] pub type USB2 = crate :: Periph < usb2 :: RegisterBlock , 0x4000_8400 > ; impl core :: fmt :: Debug for USB2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("USB2") . finish () } }
#[doc = "USB2 register"] pub mod usb2 {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ctrl : CTRL , _reserved_1_u : [u8 ; 0x01] , int_en : INT_EN , dev_ad : DEV_AD , _reserved4 : [u8 ; 0x01] , mis_st : MIS_ST , int_fg : INT_FG , int_st : INT_ST , rx_len : RX_LEN , _reserved8 : [u8 ; 0x03] , u2ep4_1_mod : U2EP4_1_MOD , _reserved_9_u : [u8 ; 0x01] , u2ep567_mod : U2EP567_MOD , _reserved11 : [u8 ; 0x01] , u2ep0_dma : U2EP0_DMA , _reserved12 : [u8 ; 0x02] , u2ep1_dma : U2EP1_DMA , _reserved13 : [u8 ; 0x02] , _reserved_13_u : [u8 ; 0x02] , _reserved14 : [u8 ; 0x02] , _reserved_14_u : [u8 ; 0x02] , _reserved15 : [u8 ; 0x02] , u2ep0_t_len : U2EP0_T_LEN , _reserved16 : [u8 ; 0x01] , u2ep0_ctrl : U2EP0_CTRL , _reserved17 : [u8 ; 0x01] , u2ep1_t_len : U2EP1_T_LEN , _reserved18 : [u8 ; 0x01] , _reserved_18_u : [u8 ; 0x01] , _reserved19 : [u8 ; 0x01] , _reserved_19_u : [u8 ; 0x01] , _reserved20 : [u8 ; 0x01] , _reserved_20_u : [u8 ; 0x01] , _reserved21 : [u8 ; 0x01] , _reserved_21_u : [u8 ; 0x01] , _reserved22 : [u8 ; 0x01] , _reserved_22_u : [u8 ; 0x01] , _reserved23 : [u8 ; 0x01] , u2ep4_t_len : U2EP4_T_LEN , _reserved24 : [u8 ; 0x01] , u2ep4_ctrl : U2EP4_CTRL , _reserved25 : [u8 ; 0x21] , u2ep5_dma : U2EP5_DMA , _reserved26 : [u8 ; 0x02] , u2ep6_dma : U2EP6_DMA , _reserved27 : [u8 ; 0x02] , u2ep7_dma : U2EP7_DMA , _reserved28 : [u8 ; 0x06] , u2ep5_t_len : U2EP5_T_LEN , _reserved29 : [u8 ; 0x01] , u2ep5_ctrl : U2EP5_CTRL , _reserved30 : [u8 ; 0x01] , u2ep6_t_len : U2EP6_T_LEN , _reserved31 : [u8 ; 0x01] , u2ep6_ctrl : U2EP6_CTRL , _reserved32 : [u8 ; 0x01] , u2ep7_t_len : U2EP7_T_LEN , _reserved33 : [u8 ; 0x01] , u2ep7_ctrl : U2EP7_CTRL , } impl RegisterBlock {
#[doc = "0x00 - USB2 base control"]
#[inline (always)] pub const fn ctrl (& self) -> & CTRL { & self . ctrl }
#[doc = "0x01 - USB2 device physical prot control"]
#[inline (always)] pub const fn u2host_ctrl (& self) -> & U2HOST_CTRL { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (1) . cast () } }
#[doc = "0x01 - USB2 device physical prot control"]
#[inline (always)] pub const fn u2dev_ctrl (& self) -> & U2DEV_CTRL { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (1) . cast () } }
#[doc = "0x02 - USB2 interrupt enable"]
#[inline (always)] pub const fn int_en (& self) -> & INT_EN { & self . int_en }
#[doc = "0x03 - USB2 device address"]
#[inline (always)] pub const fn dev_ad (& self) -> & DEV_AD { & self . dev_ad }
#[doc = "0x05 - USB2 miscellaneous status"]
#[inline (always)] pub const fn mis_st (& self) -> & MIS_ST { & self . mis_st }
#[doc = "0x06 - USB2 interrupt flag"]
#[inline (always)] pub const fn int_fg (& self) -> & INT_FG { & self . int_fg }
#[doc = "0x07 - USB2 interrupt status"]
#[inline (always)] pub const fn int_st (& self) -> & INT_ST { & self . int_st }
#[doc = "0x08 - USB2 receiving length"]
#[inline (always)] pub const fn rx_len (& self) -> & RX_LEN { & self . rx_len }
#[doc = "0x0c - endpoint 4/1 mode"]
#[inline (always)] pub const fn u2ep4_1_mod (& self) -> & U2EP4_1_MOD { & self . u2ep4_1_mod }
#[doc = "0x0d - host endpoint mode"]
#[inline (always)] pub const fn u2h_ep_mod (& self) -> & U2H_EP_MOD { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (13) . cast () } }
#[doc = "0x0d - endpoint 2_3 mode"]
#[inline (always)] pub const fn u2ep2_3_mod (& self) -> & U2EP2_3_MOD { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (13) . cast () } }
#[doc = "0x0e - USB2 endpoint 5/6/7 mode"]
#[inline (always)] pub const fn u2ep567_mod (& self) -> & U2EP567_MOD { & self . u2ep567_mod }
#[doc = "0x10 - endpoint 0 DMA buffer address"]
#[inline (always)] pub const fn u2ep0_dma (& self) -> & U2EP0_DMA { & self . u2ep0_dma }
#[doc = "0x14 - USB2 endpoint 1 DMA buffer address"]
#[inline (always)] pub const fn u2ep1_dma (& self) -> & U2EP1_DMA { & self . u2ep1_dma }
#[doc = "0x18 - host rx endpoint buffer high address"]
#[inline (always)] pub const fn u2h_rx_dma (& self) -> & U2H_RX_DMA { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x18 - USB2 endpoint 2 DMA buffer address"]
#[inline (always)] pub const fn u2ep2_dma (& self) -> & U2EP2_DMA { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (24) . cast () } }
#[doc = "0x1c - host tx endpoint buffer high address"]
#[inline (always)] pub const fn u2h_tx_dma (& self) -> & U2H_TX_DMA { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (28) . cast () } }
#[doc = "0x1c - USB2 endpoint 3 DMA buffer address"]
#[inline (always)] pub const fn u2ep3_dma (& self) -> & U2EP3_DMA { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (28) . cast () } }
#[doc = "0x20 - USB2 endpoint 0 transmittal length"]
#[inline (always)] pub const fn u2ep0_t_len (& self) -> & U2EP0_T_LEN { & self . u2ep0_t_len }
#[doc = "0x22 - USB2 endpoint 0 control"]
#[inline (always)] pub const fn u2ep0_ctrl (& self) -> & U2EP0_CTRL { & self . u2ep0_ctrl }
#[doc = "0x24 - USB2 endpoint 1 transmittal length"]
#[inline (always)] pub const fn u2ep1_t_len (& self) -> & U2EP1_T_LEN { & self . u2ep1_t_len }
#[doc = "0x26 - host aux setup"]
#[inline (always)] pub const fn u2h_setup (& self) -> & U2H_SETUP { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (38) . cast () } }
#[doc = "0x26 - USB2 endpoint 1 control"]
#[inline (always)] pub const fn u2ep1_ctrl (& self) -> & U2EP1_CTRL { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (38) . cast () } }
#[doc = "0x28 - host endpoint and PID"]
#[inline (always)] pub const fn u2h_ep_pid (& self) -> & U2H_EP_PID { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (40) . cast () } }
#[doc = "0x28 - USB2 endpoint 2 transmittal length"]
#[inline (always)] pub const fn u2ep2_t_len (& self) -> & U2EP2_T_LEN { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (40) . cast () } }
#[doc = "0x2a - host receiver endpoint control"]
#[inline (always)] pub const fn u2h_rx_ctrl (& self) -> & U2H_RX_CTRL { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (42) . cast () } }
#[doc = "0x2a - USB2 endpoint 2 control"]
#[inline (always)] pub const fn u2ep2_ctrl (& self) -> & U2EP2_CTRL { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (42) . cast () } }
#[doc = "0x2c - host transmittal endpoint transmittal length"]
#[inline (always)] pub const fn u2h_tx_len (& self) -> & U2H_TX_LEN { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (44) . cast () } }
#[doc = "0x2c - USB2 endpoint 3 transmittal length"]
#[inline (always)] pub const fn u2ep3_t_len (& self) -> & U2EP3_T_LEN { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (44) . cast () } }
#[doc = "0x2e - host transmittal endpoint control"]
#[inline (always)] pub const fn u2h_tx_ctrl (& self) -> & U2H_TX_CTRL { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (46) . cast () } }
#[doc = "0x2e - USB2 endpoint 3 control"]
#[inline (always)] pub const fn u2ep3_ctrl (& self) -> & U2EP3_CTRL { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (46) . cast () } }
#[doc = "0x30 - USB2 endpoint 4 transmittal length"]
#[inline (always)] pub const fn u2ep4_t_len (& self) -> & U2EP4_T_LEN { & self . u2ep4_t_len }
#[doc = "0x32 - USB2 endpoint 4 control"]
#[inline (always)] pub const fn u2ep4_ctrl (& self) -> & U2EP4_CTRL { & self . u2ep4_ctrl }
#[doc = "0x54 - USB2 endpoint 5 DMA buffer address"]
#[inline (always)] pub const fn u2ep5_dma (& self) -> & U2EP5_DMA { & self . u2ep5_dma }
#[doc = "0x58 - USB2 endpoint 6 DMA buffer address"]
#[inline (always)] pub const fn u2ep6_dma (& self) -> & U2EP6_DMA { & self . u2ep6_dma }
#[doc = "0x5c - USB2 endpoint 7 DMA buffer address"]
#[inline (always)] pub const fn u2ep7_dma (& self) -> & U2EP7_DMA { & self . u2ep7_dma }
#[doc = "0x64 - USB2 endpoint 5 transmittal length"]
#[inline (always)] pub const fn u2ep5_t_len (& self) -> & U2EP5_T_LEN { & self . u2ep5_t_len }
#[doc = "0x66 - USB2 endpoint 5 control"]
#[inline (always)] pub const fn u2ep5_ctrl (& self) -> & U2EP5_CTRL { & self . u2ep5_ctrl }
#[doc = "0x68 - USB2 endpoint 6 transmittal length"]
#[inline (always)] pub const fn u2ep6_t_len (& self) -> & U2EP6_T_LEN { & self . u2ep6_t_len }
#[doc = "0x6a - USB2 endpoint 6 control"]
#[inline (always)] pub const fn u2ep6_ctrl (& self) -> & U2EP6_CTRL { & self . u2ep6_ctrl }
#[doc = "0x6c - USB2 endpoint 7 transmittal length"]
#[inline (always)] pub const fn u2ep7_t_len (& self) -> & U2EP7_T_LEN { & self . u2ep7_t_len }
#[doc = "0x6e - USB2 endpoint 7 control"]
#[inline (always)] pub const fn u2ep7_ctrl (& self) -> & U2EP7_CTRL { & self . u2ep7_ctrl } }
#[doc = "CTRL (rw) register accessor: USB2 base control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`] module"] pub type CTRL = crate :: Reg < ctrl :: CTRL_SPEC > ;
#[doc = "USB2 base control"] pub mod ctrl {
#[doc = "Register `CTRL` reader"] pub type R = crate :: R < CTRL_SPEC > ;
#[doc = "Register `CTRL` writer"] pub type W = crate :: W < CTRL_SPEC > ;
#[doc = "Field `UC_DMA_EN` reader - DMA enable and DMA interrupt enable for USB"] pub type UC_DMA_EN_R = crate :: BitReader ;
#[doc = "Field `UC_DMA_EN` writer - DMA enable and DMA interrupt enable for USB"] pub type UC_DMA_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UC_CLR_ALL` reader - force clear FIFO and count of USB"] pub type UC_CLR_ALL_R = crate :: BitReader ;
#[doc = "Field `UC_CLR_ALL` writer - force clear FIFO and count of USB"] pub type UC_CLR_ALL_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UC_RESET_SIE` reader - force reset USB SIE, need software clear"] pub type UC_RESET_SIE_R = crate :: BitReader ;
#[doc = "Field `UC_RESET_SIE` writer - force reset USB SIE, need software clear"] pub type UC_RESET_SIE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UC_INT_BUSY` reader - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid"] pub type UC_INT_BUSY_R = crate :: BitReader ;
#[doc = "Field `UC_INT_BUSY` writer - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid"] pub type UC_INT_BUSY_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UC_SYS_CTRL` reader - bit mask of USB system control"] pub type UC_SYS_CTRL_R = crate :: FieldReader ;
#[doc = "Field `UC_SYS_CTRL` writer - bit mask of USB system control"] pub type UC_SYS_CTRL_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UC_DEV_PU_EN` reader - USB device enable and internal pullup resistance enable"] pub type UC_DEV_PU_EN_R = crate :: BitReader ;
#[doc = "Field `UC_DEV_PU_EN` writer - USB device enable and internal pullup resistance enable"] pub type UC_DEV_PU_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UC_LOW_SPEED` reader - enable USB low speed: 0=12Mbps, 1=1.5Mbps"] pub type UC_LOW_SPEED_R = crate :: BitReader ;
#[doc = "Field `UC_LOW_SPEED` writer - enable USB low speed: 0=12Mbps, 1=1.5Mbps"] pub type UC_LOW_SPEED_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UC_HOST_MODE` reader - enable USB host mode: 0=device mode, 1=host mode"] pub type UC_HOST_MODE_R = crate :: BitReader ;
#[doc = "Field `UC_HOST_MODE` writer - enable USB host mode: 0=device mode, 1=host mode"] pub type UC_HOST_MODE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - DMA enable and DMA interrupt enable for USB"]
#[inline (always)] pub fn uc_dma_en (& self) -> UC_DMA_EN_R { UC_DMA_EN_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - force clear FIFO and count of USB"]
#[inline (always)] pub fn uc_clr_all (& self) -> UC_CLR_ALL_R { UC_CLR_ALL_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - force reset USB SIE, need software clear"]
#[inline (always)] pub fn uc_reset_sie (& self) -> UC_RESET_SIE_R { UC_RESET_SIE_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid"]
#[inline (always)] pub fn uc_int_busy (& self) -> UC_INT_BUSY_R { UC_INT_BUSY_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bits 4:5 - bit mask of USB system control"]
#[inline (always)] pub fn uc_sys_ctrl (& self) -> UC_SYS_CTRL_R { UC_SYS_CTRL_R :: new ((self . bits >> 4) & 3) }
#[doc = "Bit 5 - USB device enable and internal pullup resistance enable"]
#[inline (always)] pub fn uc_dev_pu_en (& self) -> UC_DEV_PU_EN_R { UC_DEV_PU_EN_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps"]
#[inline (always)] pub fn uc_low_speed (& self) -> UC_LOW_SPEED_R { UC_LOW_SPEED_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - enable USB host mode: 0=device mode, 1=host mode"]
#[inline (always)] pub fn uc_host_mode (& self) -> UC_HOST_MODE_R { UC_HOST_MODE_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - DMA enable and DMA interrupt enable for USB"]
#[inline (always)] pub fn uc_dma_en (& mut self) -> UC_DMA_EN_W < CTRL_SPEC > { UC_DMA_EN_W :: new (self , 0) }
#[doc = "Bit 1 - force clear FIFO and count of USB"]
#[inline (always)] pub fn uc_clr_all (& mut self) -> UC_CLR_ALL_W < CTRL_SPEC > { UC_CLR_ALL_W :: new (self , 1) }
#[doc = "Bit 2 - force reset USB SIE, need software clear"]
#[inline (always)] pub fn uc_reset_sie (& mut self) -> UC_RESET_SIE_W < CTRL_SPEC > { UC_RESET_SIE_W :: new (self , 2) }
#[doc = "Bit 3 - enable automatic responding busy for device mode or automatic pause for host mode during interrupt flag UIF_TRANSFER valid"]
#[inline (always)] pub fn uc_int_busy (& mut self) -> UC_INT_BUSY_W < CTRL_SPEC > { UC_INT_BUSY_W :: new (self , 3) }
#[doc = "Bits 4:5 - bit mask of USB system control"]
#[inline (always)] pub fn uc_sys_ctrl (& mut self) -> UC_SYS_CTRL_W < CTRL_SPEC > { UC_SYS_CTRL_W :: new (self , 4) }
#[doc = "Bit 5 - USB device enable and internal pullup resistance enable"]
#[inline (always)] pub fn uc_dev_pu_en (& mut self) -> UC_DEV_PU_EN_W < CTRL_SPEC > { UC_DEV_PU_EN_W :: new (self , 5) }
#[doc = "Bit 6 - enable USB low speed: 0=12Mbps, 1=1.5Mbps"]
#[inline (always)] pub fn uc_low_speed (& mut self) -> UC_LOW_SPEED_W < CTRL_SPEC > { UC_LOW_SPEED_W :: new (self , 6) }
#[doc = "Bit 7 - enable USB host mode: 0=device mode, 1=host mode"]
#[inline (always)] pub fn uc_host_mode (& mut self) -> UC_HOST_MODE_W < CTRL_SPEC > { UC_HOST_MODE_W :: new (self , 7) } }
#[doc = "USB2 base control\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CTRL_SPEC ; impl crate :: RegisterSpec for CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`ctrl::R`](R) reader structure"] impl crate :: Readable for CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"] impl crate :: Writable for CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTRL to value 0x06"] impl crate :: Resettable for CTRL_SPEC { const RESET_VALUE : u8 = 0x06 ; } }
#[doc = "U2DEV_CTRL (rw) register accessor: USB2 device physical prot control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2dev_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2dev_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2dev_ctrl`] module"] pub type U2DEV_CTRL = crate :: Reg < u2dev_ctrl :: U2DEV_CTRL_SPEC > ;
#[doc = "USB2 device physical prot control"] pub mod u2dev_ctrl {
#[doc = "Register `U2DEV_CTRL` reader"] pub type R = crate :: R < U2DEV_CTRL_SPEC > ;
#[doc = "Register `U2DEV_CTRL` writer"] pub type W = crate :: W < U2DEV_CTRL_SPEC > ;
#[doc = "Field `UD_PORT_EN` reader - enable USB physical port I-O: 0=disable, 1=enable"] pub type UD_PORT_EN_R = crate :: BitReader ;
#[doc = "Field `UD_PORT_EN` writer - enable USB physical port I-O: 0=disable, 1=enable"] pub type UD_PORT_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UD_GP_BIT` reader - general purpose bit"] pub type UD_GP_BIT_R = crate :: BitReader ;
#[doc = "Field `UD_GP_BIT` writer - general purpose bit"] pub type UD_GP_BIT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UD_LOW_SPEED` reader - enable USB physical port low speed: 0=full speed, 1=low speed"] pub type UD_LOW_SPEED_R = crate :: BitReader ;
#[doc = "Field `UD_LOW_SPEED` writer - enable USB physical port low speed: 0=full speed, 1=low speed"] pub type UD_LOW_SPEED_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UD_DM_PIN` reader - ReadOnly: indicate current UDM pin level"] pub type UD_DM_PIN_R = crate :: BitReader ;
#[doc = "Field `UD_DP_PIN` reader - ReadOnly: indicate current UDP pin level"] pub type UD_DP_PIN_R = crate :: BitReader ;
#[doc = "Field `UD_PD_DIS` reader - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable"] pub type UD_PD_DIS_R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - enable USB physical port I-O: 0=disable, 1=enable"]
#[inline (always)] pub fn ud_port_en (& self) -> UD_PORT_EN_R { UD_PORT_EN_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - general purpose bit"]
#[inline (always)] pub fn ud_gp_bit (& self) -> UD_GP_BIT_R { UD_GP_BIT_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed"]
#[inline (always)] pub fn ud_low_speed (& self) -> UD_LOW_SPEED_R { UD_LOW_SPEED_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 4 - ReadOnly: indicate current UDM pin level"]
#[inline (always)] pub fn ud_dm_pin (& self) -> UD_DM_PIN_R { UD_DM_PIN_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - ReadOnly: indicate current UDP pin level"]
#[inline (always)] pub fn ud_dp_pin (& self) -> UD_DP_PIN_R { UD_DP_PIN_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 7 - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable"]
#[inline (always)] pub fn ud_pd_dis (& self) -> UD_PD_DIS_R { UD_PD_DIS_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - enable USB physical port I-O: 0=disable, 1=enable"]
#[inline (always)] pub fn ud_port_en (& mut self) -> UD_PORT_EN_W < U2DEV_CTRL_SPEC > { UD_PORT_EN_W :: new (self , 0) }
#[doc = "Bit 1 - general purpose bit"]
#[inline (always)] pub fn ud_gp_bit (& mut self) -> UD_GP_BIT_W < U2DEV_CTRL_SPEC > { UD_GP_BIT_W :: new (self , 1) }
#[doc = "Bit 2 - enable USB physical port low speed: 0=full speed, 1=low speed"]
#[inline (always)] pub fn ud_low_speed (& mut self) -> UD_LOW_SPEED_W < U2DEV_CTRL_SPEC > { UD_LOW_SPEED_W :: new (self , 2) } }
#[doc = "USB2 device physical prot control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2dev_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2dev_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2DEV_CTRL_SPEC ; impl crate :: RegisterSpec for U2DEV_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2dev_ctrl::R`](R) reader structure"] impl crate :: Readable for U2DEV_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2dev_ctrl::W`](W) writer structure"] impl crate :: Writable for U2DEV_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2DEV_CTRL to value 0"] impl crate :: Resettable for U2DEV_CTRL_SPEC { } }
#[doc = "U2HOST_CTRL (rw) register accessor: USB2 device physical prot control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2host_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2host_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2host_ctrl`] module"] pub type U2HOST_CTRL = crate :: Reg < u2host_ctrl :: U2HOST_CTRL_SPEC > ;
#[doc = "USB2 device physical prot control"] pub mod u2host_ctrl {
#[doc = "Register `U2HOST_CTRL` reader"] pub type R = crate :: R < U2HOST_CTRL_SPEC > ;
#[doc = "Register `U2HOST_CTRL` writer"] pub type W = crate :: W < U2HOST_CTRL_SPEC > ;
#[doc = "Field `UH_PORT_EN` reader - enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached"] pub type UH_PORT_EN_R = crate :: BitReader ;
#[doc = "Field `UH_PORT_EN` writer - enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached"] pub type UH_PORT_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UH_BUS_RESET` reader - control USB bus reset: 0=normal, 1=force bus reset"] pub type UH_BUS_RESET_R = crate :: BitReader ;
#[doc = "Field `UH_BUS_RESET` writer - control USB bus reset: 0=normal, 1=force bus reset"] pub type UH_BUS_RESET_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UH_LOW_SPEED` reader - enable USB port low speed: 0=full speed, 1=low speed"] pub type UH_LOW_SPEED_R = crate :: BitReader ;
#[doc = "Field `UH_LOW_SPEED` writer - enable USB port low speed: 0=full speed, 1=low speed"] pub type UH_LOW_SPEED_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UH_DM_PIN` reader - ReadOnly: indicate current UDM pin level"] pub type UH_DM_PIN_R = crate :: BitReader ;
#[doc = "Field `UH_DP_PIN` reader - ReadOnly: indicate current UDP pin level"] pub type UH_DP_PIN_R = crate :: BitReader ;
#[doc = "Field `UH_PD_DIS` reader - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable"] pub type UH_PD_DIS_R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached"]
#[inline (always)] pub fn uh_port_en (& self) -> UH_PORT_EN_R { UH_PORT_EN_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - control USB bus reset: 0=normal, 1=force bus reset"]
#[inline (always)] pub fn uh_bus_reset (& self) -> UH_BUS_RESET_R { UH_BUS_RESET_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - enable USB port low speed: 0=full speed, 1=low speed"]
#[inline (always)] pub fn uh_low_speed (& self) -> UH_LOW_SPEED_R { UH_LOW_SPEED_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 4 - ReadOnly: indicate current UDM pin level"]
#[inline (always)] pub fn uh_dm_pin (& self) -> UH_DM_PIN_R { UH_DM_PIN_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - ReadOnly: indicate current UDP pin level"]
#[inline (always)] pub fn uh_dp_pin (& self) -> UH_DP_PIN_R { UH_DP_PIN_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 7 - disable USB UDP-UDM pulldown resistance: 0=enable pulldown, 1=disable"]
#[inline (always)] pub fn uh_pd_dis (& self) -> UH_PD_DIS_R { UH_PD_DIS_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - enable USB port: 0=disable, 1=enable port, automatic disabled if USB device detached"]
#[inline (always)] pub fn uh_port_en (& mut self) -> UH_PORT_EN_W < U2HOST_CTRL_SPEC > { UH_PORT_EN_W :: new (self , 0) }
#[doc = "Bit 1 - control USB bus reset: 0=normal, 1=force bus reset"]
#[inline (always)] pub fn uh_bus_reset (& mut self) -> UH_BUS_RESET_W < U2HOST_CTRL_SPEC > { UH_BUS_RESET_W :: new (self , 1) }
#[doc = "Bit 2 - enable USB port low speed: 0=full speed, 1=low speed"]
#[inline (always)] pub fn uh_low_speed (& mut self) -> UH_LOW_SPEED_W < U2HOST_CTRL_SPEC > { UH_LOW_SPEED_W :: new (self , 2) } }
#[doc = "USB2 device physical prot control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2host_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2host_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2HOST_CTRL_SPEC ; impl crate :: RegisterSpec for U2HOST_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2host_ctrl::R`](R) reader structure"] impl crate :: Readable for U2HOST_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2host_ctrl::W`](W) writer structure"] impl crate :: Writable for U2HOST_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2HOST_CTRL to value 0"] impl crate :: Resettable for U2HOST_CTRL_SPEC { } }
#[doc = "INT_EN (rw) register accessor: USB2 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`int_en::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_en::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_en`] module"] pub type INT_EN = crate :: Reg < int_en :: INT_EN_SPEC > ;
#[doc = "USB2 interrupt enable"] pub mod int_en {
#[doc = "Register `INT_EN` reader"] pub type R = crate :: R < INT_EN_SPEC > ;
#[doc = "Register `INT_EN` writer"] pub type W = crate :: W < INT_EN_SPEC > ;
#[doc = "Field `UIE_BUS_RST` reader - enable interrupt for USB bus reset event for USB device mode"] pub type UIE_BUS_RST_R = crate :: BitReader ;
#[doc = "Field `UIE_BUS_RST` writer - enable interrupt for USB bus reset event for USB device mode"] pub type UIE_BUS_RST_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UIE_DETECT` reader - enable interrupt for USB device detected event for USB host mode"] pub type UIE_DETECT_R = crate :: BitReader ;
#[doc = "Field `UIE_DETECT` writer - enable interrupt for USB device detected event for USB host mode"] pub type UIE_DETECT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UIE_TRANSFER` reader - enable interrupt for USB transfer completion"] pub type UIE_TRANSFER_R = crate :: BitReader ;
#[doc = "Field `UIE_TRANSFER` writer - enable interrupt for USB transfer completion"] pub type UIE_TRANSFER_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UIE_SUSPEND` reader - enable interrupt for USB suspend or resume event"] pub type UIE_SUSPEND_R = crate :: BitReader ;
#[doc = "Field `UIE_SUSPEND` writer - enable interrupt for USB suspend or resume event"] pub type UIE_SUSPEND_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UIE_HST_SOF` reader - enable interrupt for host SOF timer action for USB host mode"] pub type UIE_HST_SOF_R = crate :: BitReader ;
#[doc = "Field `UIE_HST_SOF` writer - enable interrupt for host SOF timer action for USB host mode"] pub type UIE_HST_SOF_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UIE_FIFO_OV` reader - enable interrupt for FIFO overflow"] pub type UIE_FIFO_OV_R = crate :: BitReader ;
#[doc = "Field `UIE_FIFO_OV` writer - enable interrupt for FIFO overflow"] pub type UIE_FIFO_OV_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UIE_DEV_NAK` reader - enable interrupt for NAK responded for USB device mode"] pub type UIE_DEV_NAK_R = crate :: BitReader ;
#[doc = "Field `UIE_DEV_NAK` writer - enable interrupt for NAK responded for USB device mode"] pub type UIE_DEV_NAK_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - enable interrupt for USB bus reset event for USB device mode"]
#[inline (always)] pub fn uie_bus_rst (& self) -> UIE_BUS_RST_R { UIE_BUS_RST_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 0 - enable interrupt for USB device detected event for USB host mode"]
#[inline (always)] pub fn uie_detect (& self) -> UIE_DETECT_R { UIE_DETECT_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - enable interrupt for USB transfer completion"]
#[inline (always)] pub fn uie_transfer (& self) -> UIE_TRANSFER_R { UIE_TRANSFER_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - enable interrupt for USB suspend or resume event"]
#[inline (always)] pub fn uie_suspend (& self) -> UIE_SUSPEND_R { UIE_SUSPEND_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - enable interrupt for host SOF timer action for USB host mode"]
#[inline (always)] pub fn uie_hst_sof (& self) -> UIE_HST_SOF_R { UIE_HST_SOF_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - enable interrupt for FIFO overflow"]
#[inline (always)] pub fn uie_fifo_ov (& self) -> UIE_FIFO_OV_R { UIE_FIFO_OV_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - enable interrupt for NAK responded for USB device mode"]
#[inline (always)] pub fn uie_dev_nak (& self) -> UIE_DEV_NAK_R { UIE_DEV_NAK_R :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bit 0 - enable interrupt for USB bus reset event for USB device mode"]
#[inline (always)] pub fn uie_bus_rst (& mut self) -> UIE_BUS_RST_W < INT_EN_SPEC > { UIE_BUS_RST_W :: new (self , 0) }
#[doc = "Bit 0 - enable interrupt for USB device detected event for USB host mode"]
#[inline (always)] pub fn uie_detect (& mut self) -> UIE_DETECT_W < INT_EN_SPEC > { UIE_DETECT_W :: new (self , 0) }
#[doc = "Bit 1 - enable interrupt for USB transfer completion"]
#[inline (always)] pub fn uie_transfer (& mut self) -> UIE_TRANSFER_W < INT_EN_SPEC > { UIE_TRANSFER_W :: new (self , 1) }
#[doc = "Bit 2 - enable interrupt for USB suspend or resume event"]
#[inline (always)] pub fn uie_suspend (& mut self) -> UIE_SUSPEND_W < INT_EN_SPEC > { UIE_SUSPEND_W :: new (self , 2) }
#[doc = "Bit 3 - enable interrupt for host SOF timer action for USB host mode"]
#[inline (always)] pub fn uie_hst_sof (& mut self) -> UIE_HST_SOF_W < INT_EN_SPEC > { UIE_HST_SOF_W :: new (self , 3) }
#[doc = "Bit 4 - enable interrupt for FIFO overflow"]
#[inline (always)] pub fn uie_fifo_ov (& mut self) -> UIE_FIFO_OV_W < INT_EN_SPEC > { UIE_FIFO_OV_W :: new (self , 4) }
#[doc = "Bit 6 - enable interrupt for NAK responded for USB device mode"]
#[inline (always)] pub fn uie_dev_nak (& mut self) -> UIE_DEV_NAK_W < INT_EN_SPEC > { UIE_DEV_NAK_W :: new (self , 6) } }
#[doc = "USB2 interrupt enable\n\nYou can [`read`](crate::Reg::read) this register and get [`int_en::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_en::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_EN_SPEC ; impl crate :: RegisterSpec for INT_EN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`int_en::R`](R) reader structure"] impl crate :: Readable for INT_EN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`int_en::W`](W) writer structure"] impl crate :: Writable for INT_EN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INT_EN to value 0"] impl crate :: Resettable for INT_EN_SPEC { } }
#[doc = "DEV_AD (rw) register accessor: USB2 device address\n\nYou can [`read`](crate::Reg::read) this register and get [`dev_ad::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dev_ad::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dev_ad`] module"] pub type DEV_AD = crate :: Reg < dev_ad :: DEV_AD_SPEC > ;
#[doc = "USB2 device address"] pub mod dev_ad {
#[doc = "Register `DEV_AD` reader"] pub type R = crate :: R < DEV_AD_SPEC > ;
#[doc = "Register `DEV_AD` writer"] pub type W = crate :: W < DEV_AD_SPEC > ;
#[doc = "Field `USB_ADDR` reader - bit mask for USB device address"] pub type USB_ADDR_R = crate :: FieldReader ;
#[doc = "Field `USB_ADDR` writer - bit mask for USB device address"] pub type USB_ADDR_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ;
#[doc = "Field `UDA_GP_BIT` reader - general purpose bit"] pub type UDA_GP_BIT_R = crate :: BitReader ;
#[doc = "Field `UDA_GP_BIT` writer - general purpose bit"] pub type UDA_GP_BIT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:6 - bit mask for USB device address"]
#[inline (always)] pub fn usb_addr (& self) -> USB_ADDR_R { USB_ADDR_R :: new (self . bits & 0x7f) }
#[doc = "Bit 7 - general purpose bit"]
#[inline (always)] pub fn uda_gp_bit (& self) -> UDA_GP_BIT_R { UDA_GP_BIT_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:6 - bit mask for USB device address"]
#[inline (always)] pub fn usb_addr (& mut self) -> USB_ADDR_W < DEV_AD_SPEC > { USB_ADDR_W :: new (self , 0) }
#[doc = "Bit 7 - general purpose bit"]
#[inline (always)] pub fn uda_gp_bit (& mut self) -> UDA_GP_BIT_W < DEV_AD_SPEC > { UDA_GP_BIT_W :: new (self , 7) } }
#[doc = "USB2 device address\n\nYou can [`read`](crate::Reg::read) this register and get [`dev_ad::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dev_ad::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct DEV_AD_SPEC ; impl crate :: RegisterSpec for DEV_AD_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`dev_ad::R`](R) reader structure"] impl crate :: Readable for DEV_AD_SPEC { }
#[doc = "`write(|w| ..)` method takes [`dev_ad::W`](W) writer structure"] impl crate :: Writable for DEV_AD_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets DEV_AD to value 0"] impl crate :: Resettable for DEV_AD_SPEC { } }
#[doc = "MIS_ST (r) register accessor: USB2 miscellaneous status\n\nYou can [`read`](crate::Reg::read) this register and get [`mis_st::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mis_st`] module"] pub type MIS_ST = crate :: Reg < mis_st :: MIS_ST_SPEC > ;
#[doc = "USB2 miscellaneous status"] pub mod mis_st {
#[doc = "Register `MIS_ST` reader"] pub type R = crate :: R < MIS_ST_SPEC > ;
#[doc = "Field `UMS_DEV_ATTACH` reader - RO, indicate device attached status on USB host"] pub type UMS_DEV_ATTACH_R = crate :: BitReader ;
#[doc = "Field `UMS_DM_LEVEL` reader - RO, indicate UDM level saved at device attached to USB host"] pub type UMS_DM_LEVEL_R = crate :: BitReader ;
#[doc = "Field `UMS_SUSPEND` reader - RO, indicate USB suspend status"] pub type UMS_SUSPEND_R = crate :: BitReader ;
#[doc = "Field `UMS_BUS_RESET` reader - RO, indicate USB bus reset status"] pub type UMS_BUS_RESET_R = crate :: BitReader ;
#[doc = "Field `UMS_R_FIFO_RDY` reader - RO, indicate USB receiving FIFO ready status (not empty)"] pub type UMS_R_FIFO_RDY_R = crate :: BitReader ;
#[doc = "Field `UMS_SIE_FREE` reader - RO, indicate USB SIE free status"] pub type UMS_SIE_FREE_R = crate :: BitReader ;
#[doc = "Field `UMS_SOF_ACT` reader - RO, indicate host SOF timer action status for USB host"] pub type UMS_SOF_ACT_R = crate :: BitReader ;
#[doc = "Field `UMS_SOF_PRES` reader - RO, indicate host SOF timer presage status"] pub type UMS_SOF_PRES_R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - RO, indicate device attached status on USB host"]
#[inline (always)] pub fn ums_dev_attach (& self) -> UMS_DEV_ATTACH_R { UMS_DEV_ATTACH_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RO, indicate UDM level saved at device attached to USB host"]
#[inline (always)] pub fn ums_dm_level (& self) -> UMS_DM_LEVEL_R { UMS_DM_LEVEL_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RO, indicate USB suspend status"]
#[inline (always)] pub fn ums_suspend (& self) -> UMS_SUSPEND_R { UMS_SUSPEND_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RO, indicate USB bus reset status"]
#[inline (always)] pub fn ums_bus_reset (& self) -> UMS_BUS_RESET_R { UMS_BUS_RESET_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RO, indicate USB receiving FIFO ready status (not empty)"]
#[inline (always)] pub fn ums_r_fifo_rdy (& self) -> UMS_R_FIFO_RDY_R { UMS_R_FIFO_RDY_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RO, indicate USB SIE free status"]
#[inline (always)] pub fn ums_sie_free (& self) -> UMS_SIE_FREE_R { UMS_SIE_FREE_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RO, indicate host SOF timer action status for USB host"]
#[inline (always)] pub fn ums_sof_act (& self) -> UMS_SOF_ACT_R { UMS_SOF_ACT_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RO, indicate host SOF timer presage status"]
#[inline (always)] pub fn ums_sof_pres (& self) -> UMS_SOF_PRES_R { UMS_SOF_PRES_R :: new (((self . bits >> 7) & 1) != 0) } }
#[doc = "USB2 miscellaneous status\n\nYou can [`read`](crate::Reg::read) this register and get [`mis_st::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct MIS_ST_SPEC ; impl crate :: RegisterSpec for MIS_ST_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`mis_st::R`](R) reader structure"] impl crate :: Readable for MIS_ST_SPEC { }
#[doc = "`reset()` method sets MIS_ST to value 0"] impl crate :: Resettable for MIS_ST_SPEC { } }
#[doc = "INT_FG (rw) register accessor: USB2 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_fg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_fg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_fg`] module"] pub type INT_FG = crate :: Reg < int_fg :: INT_FG_SPEC > ;
#[doc = "USB2 interrupt flag"] pub mod int_fg {
#[doc = "Register `INT_FG` reader"] pub type R = crate :: R < INT_FG_SPEC > ;
#[doc = "Register `INT_FG` writer"] pub type W = crate :: W < INT_FG_SPEC > ;
#[doc = "Field `UIF_BUS_RST` reader - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear"] pub type UIF_BUS_RST_R = crate :: BitReader ;
#[doc = "Field `UIF_BUS_RST` writer - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear"] pub type UIF_BUS_RST_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UIF_DETECT` reader - RW,device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear"] pub type UIF_DETECT_R = crate :: BitReader ;
#[doc = "Field `UIF_DETECT` writer - RW,device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear"] pub type UIF_DETECT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UIF_TRANSFER` reader - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear"] pub type UIF_TRANSFER_R = crate :: BitReader ;
#[doc = "Field `UIF_TRANSFER` writer - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear"] pub type UIF_TRANSFER_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UIF_SUSPEND` reader - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear"] pub type UIF_SUSPEND_R = crate :: BitReader ;
#[doc = "Field `UIF_SUSPEND` writer - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear"] pub type UIF_SUSPEND_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UIF_HST_SOF` reader - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear"] pub type UIF_HST_SOF_R = crate :: BitReader ;
#[doc = "Field `UIF_HST_SOF` writer - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear"] pub type UIF_HST_SOF_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UIF_FIFO_OV` reader - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear"] pub type UIF_FIFO_OV_R = crate :: BitReader ;
#[doc = "Field `UIF_FIFO_OV` writer - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear"] pub type UIF_FIFO_OV_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `U_SIE_FREE` reader - RO, indicate USB SIE free status"] pub type U_SIE_FREE_R = crate :: BitReader ;
#[doc = "Field `U_TOG_OK` reader - RO, indicate current USB transfer toggle is OK"] pub type U_TOG_OK_R = crate :: BitReader ;
#[doc = "Field `U_IS_NAK` reader - RO, indicate current USB transfer is NAK received"] pub type U_IS_NAK_R = crate :: BitReader ; impl R {
#[doc = "Bit 0 - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear"]
#[inline (always)] pub fn uif_bus_rst (& self) -> UIF_BUS_RST_R { UIF_BUS_RST_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 0 - RW,device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear"]
#[inline (always)] pub fn uif_detect (& self) -> UIF_DETECT_R { UIF_DETECT_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear"]
#[inline (always)] pub fn uif_transfer (& self) -> UIF_TRANSFER_R { UIF_TRANSFER_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear"]
#[inline (always)] pub fn uif_suspend (& self) -> UIF_SUSPEND_R { UIF_SUSPEND_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear"]
#[inline (always)] pub fn uif_hst_sof (& self) -> UIF_HST_SOF_R { UIF_HST_SOF_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear"]
#[inline (always)] pub fn uif_fifo_ov (& self) -> UIF_FIFO_OV_R { UIF_FIFO_OV_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - RO, indicate USB SIE free status"]
#[inline (always)] pub fn u_sie_free (& self) -> U_SIE_FREE_R { U_SIE_FREE_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 6 - RO, indicate current USB transfer toggle is OK"]
#[inline (always)] pub fn u_tog_ok (& self) -> U_TOG_OK_R { U_TOG_OK_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RO, indicate current USB transfer is NAK received"]
#[inline (always)] pub fn u_is_nak (& self) -> U_IS_NAK_R { U_IS_NAK_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW,bus reset event interrupt flag for USB device mode, direct bit address clear or write 1 to clear"]
#[inline (always)] pub fn uif_bus_rst (& mut self) -> UIF_BUS_RST_W < INT_FG_SPEC > { UIF_BUS_RST_W :: new (self , 0) }
#[doc = "Bit 0 - RW,device detected event interrupt flag for USB host mode, direct bit address clear or write 1 to clear"]
#[inline (always)] pub fn uif_detect (& mut self) -> UIF_DETECT_W < INT_FG_SPEC > { UIF_DETECT_W :: new (self , 0) }
#[doc = "Bit 1 - RW,USB transfer completion interrupt flag, direct bit address clear or write 1 to clear"]
#[inline (always)] pub fn uif_transfer (& mut self) -> UIF_TRANSFER_W < INT_FG_SPEC > { UIF_TRANSFER_W :: new (self , 1) }
#[doc = "Bit 2 - RW,USB suspend or resume event interrupt flag, direct bit address clear or write 1 to clear"]
#[inline (always)] pub fn uif_suspend (& mut self) -> UIF_SUSPEND_W < INT_FG_SPEC > { UIF_SUSPEND_W :: new (self , 2) }
#[doc = "Bit 3 - RW,host SOF timer interrupt flag for USB host, direct bit address clear or write 1 to clear"]
#[inline (always)] pub fn uif_hst_sof (& mut self) -> UIF_HST_SOF_W < INT_FG_SPEC > { UIF_HST_SOF_W :: new (self , 3) }
#[doc = "Bit 4 - RW,FIFO overflow interrupt flag for USB, direct bit address clear or write 1 to clear"]
#[inline (always)] pub fn uif_fifo_ov (& mut self) -> UIF_FIFO_OV_W < INT_FG_SPEC > { UIF_FIFO_OV_W :: new (self , 4) } }
#[doc = "USB2 interrupt flag\n\nYou can [`read`](crate::Reg::read) this register and get [`int_fg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_fg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_FG_SPEC ; impl crate :: RegisterSpec for INT_FG_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`int_fg::R`](R) reader structure"] impl crate :: Readable for INT_FG_SPEC { }
#[doc = "`write(|w| ..)` method takes [`int_fg::W`](W) writer structure"] impl crate :: Writable for INT_FG_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets INT_FG to value 0x20"] impl crate :: Resettable for INT_FG_SPEC { const RESET_VALUE : u8 = 0x20 ; } }
#[doc = "INT_ST (r) register accessor: USB2 interrupt status\n\nYou can [`read`](crate::Reg::read) this register and get [`int_st::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_st`] module"] pub type INT_ST = crate :: Reg < int_st :: INT_ST_SPEC > ;
#[doc = "USB2 interrupt status"] pub mod int_st {
#[doc = "Register `INT_ST` reader"] pub type R = crate :: R < INT_ST_SPEC > ;
#[doc = "Field `UIS_H_RES` reader - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received"] pub type UIS_H_RES_R = crate :: FieldReader ;
#[doc = "Field `UIS_ENDP` reader - RO, bit mask of current transfer endpoint number for USB device mode"] pub type UIS_ENDP_R = crate :: FieldReader ;
#[doc = "Field `UIS_TOKEN` reader - RO, bit mask of current token PID code received for USB device mode"] pub type UIS_TOKEN_R = crate :: FieldReader ;
#[doc = "Field `UIS_TOG_OK` reader - RO, indicate current USB transfer toggle is OK"] pub type UIS_TOG_OK_R = crate :: BitReader ;
#[doc = "Field `UIS_SETUP_ACT` reader - RO, indicate current USB transfer is NAK received for USB device mode"] pub type UIS_SETUP_ACT_R = crate :: BitReader ; impl R {
#[doc = "Bits 0:3 - RO, bit mask of current transfer handshake response for USB host mode: 0000=no response, time out from device, others=handshake response PID received"]
#[inline (always)] pub fn uis_h_res (& self) -> UIS_H_RES_R { UIS_H_RES_R :: new (self . bits & 0x0f) }
#[doc = "Bits 0:3 - RO, bit mask of current transfer endpoint number for USB device mode"]
#[inline (always)] pub fn uis_endp (& self) -> UIS_ENDP_R { UIS_ENDP_R :: new (self . bits & 0x0f) }
#[doc = "Bits 4:5 - RO, bit mask of current token PID code received for USB device mode"]
#[inline (always)] pub fn uis_token (& self) -> UIS_TOKEN_R { UIS_TOKEN_R :: new ((self . bits >> 4) & 3) }
#[doc = "Bit 6 - RO, indicate current USB transfer toggle is OK"]
#[inline (always)] pub fn uis_tog_ok (& self) -> UIS_TOG_OK_R { UIS_TOG_OK_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - RO, indicate current USB transfer is NAK received for USB device mode"]
#[inline (always)] pub fn uis_setup_act (& self) -> UIS_SETUP_ACT_R { UIS_SETUP_ACT_R :: new (((self . bits >> 7) & 1) != 0) } }
#[doc = "USB2 interrupt status\n\nYou can [`read`](crate::Reg::read) this register and get [`int_st::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct INT_ST_SPEC ; impl crate :: RegisterSpec for INT_ST_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`int_st::R`](R) reader structure"] impl crate :: Readable for INT_ST_SPEC { }
#[doc = "`reset()` method sets INT_ST to value 0"] impl crate :: Resettable for INT_ST_SPEC { } }
#[doc = "RX_LEN (r) register accessor: USB2 receiving length\n\nYou can [`read`](crate::Reg::read) this register and get [`rx_len::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rx_len`] module"] pub type RX_LEN = crate :: Reg < rx_len :: RX_LEN_SPEC > ;
#[doc = "USB2 receiving length"] pub mod rx_len {
#[doc = "Register `RX_LEN` reader"] pub type R = crate :: R < RX_LEN_SPEC > ;
#[doc = "Field `USB_RX_LEN` reader - RO,USB receiving length"] pub type USB_RX_LEN_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:7 - RO,USB receiving length"]
#[inline (always)] pub fn usb_rx_len (& self) -> USB_RX_LEN_R { USB_RX_LEN_R :: new (self . bits) } }
#[doc = "USB2 receiving length\n\nYou can [`read`](crate::Reg::read) this register and get [`rx_len::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct RX_LEN_SPEC ; impl crate :: RegisterSpec for RX_LEN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`rx_len::R`](R) reader structure"] impl crate :: Readable for RX_LEN_SPEC { }
#[doc = "`reset()` method sets RX_LEN to value 0"] impl crate :: Resettable for RX_LEN_SPEC { } }
#[doc = "U2EP4_1_MOD (rw) register accessor: endpoint 4/1 mode\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep4_1_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep4_1_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep4_1_mod`] module"] pub type U2EP4_1_MOD = crate :: Reg < u2ep4_1_mod :: U2EP4_1_MOD_SPEC > ;
#[doc = "endpoint 4/1 mode"] pub mod u2ep4_1_mod {
#[doc = "Register `U2EP4_1_MOD` reader"] pub type R = crate :: R < U2EP4_1_MOD_SPEC > ;
#[doc = "Register `U2EP4_1_MOD` writer"] pub type W = crate :: W < U2EP4_1_MOD_SPEC > ;
#[doc = "Field `UEP4_TX_EN` reader - enable USB endpoint 4 transmittal (IN)"] pub type UEP4_TX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP4_TX_EN` writer - enable USB endpoint 4 transmittal (IN)"] pub type UEP4_TX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP4_RX_EN` reader - enable USB endpoint 4 receiving (OUT)"] pub type UEP4_RX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP4_RX_EN` writer - enable USB endpoint 4 receiving (OUT)"] pub type UEP4_RX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP1_BUF_MOD` reader - buffer mode of USB endpoint 1"] pub type UEP1_BUF_MOD_R = crate :: BitReader ;
#[doc = "Field `UEP1_BUF_MOD` writer - buffer mode of USB endpoint 1"] pub type UEP1_BUF_MOD_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP1_TX_EN` reader - enable USB endpoint 1 transmittal (IN)"] pub type UEP1_TX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP1_TX_EN` writer - enable USB endpoint 1 transmittal (IN)"] pub type UEP1_TX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP1_RX_EN` reader - enable USB endpoint 1 receiving (OUT)"] pub type UEP1_RX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP1_RX_EN` writer - enable USB endpoint 1 receiving (OUT)"] pub type UEP1_RX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 2 - enable USB endpoint 4 transmittal (IN)"]
#[inline (always)] pub fn uep4_tx_en (& self) -> UEP4_TX_EN_R { UEP4_TX_EN_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - enable USB endpoint 4 receiving (OUT)"]
#[inline (always)] pub fn uep4_rx_en (& self) -> UEP4_RX_EN_R { UEP4_RX_EN_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - buffer mode of USB endpoint 1"]
#[inline (always)] pub fn uep1_buf_mod (& self) -> UEP1_BUF_MOD_R { UEP1_BUF_MOD_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - enable USB endpoint 1 transmittal (IN)"]
#[inline (always)] pub fn uep1_tx_en (& self) -> UEP1_TX_EN_R { UEP1_TX_EN_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - enable USB endpoint 1 receiving (OUT)"]
#[inline (always)] pub fn uep1_rx_en (& self) -> UEP1_RX_EN_R { UEP1_RX_EN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 2 - enable USB endpoint 4 transmittal (IN)"]
#[inline (always)] pub fn uep4_tx_en (& mut self) -> UEP4_TX_EN_W < U2EP4_1_MOD_SPEC > { UEP4_TX_EN_W :: new (self , 2) }
#[doc = "Bit 3 - enable USB endpoint 4 receiving (OUT)"]
#[inline (always)] pub fn uep4_rx_en (& mut self) -> UEP4_RX_EN_W < U2EP4_1_MOD_SPEC > { UEP4_RX_EN_W :: new (self , 3) }
#[doc = "Bit 4 - buffer mode of USB endpoint 1"]
#[inline (always)] pub fn uep1_buf_mod (& mut self) -> UEP1_BUF_MOD_W < U2EP4_1_MOD_SPEC > { UEP1_BUF_MOD_W :: new (self , 4) }
#[doc = "Bit 6 - enable USB endpoint 1 transmittal (IN)"]
#[inline (always)] pub fn uep1_tx_en (& mut self) -> UEP1_TX_EN_W < U2EP4_1_MOD_SPEC > { UEP1_TX_EN_W :: new (self , 6) }
#[doc = "Bit 7 - enable USB endpoint 1 receiving (OUT)"]
#[inline (always)] pub fn uep1_rx_en (& mut self) -> UEP1_RX_EN_W < U2EP4_1_MOD_SPEC > { UEP1_RX_EN_W :: new (self , 7) } }
#[doc = "endpoint 4/1 mode\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep4_1_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep4_1_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP4_1_MOD_SPEC ; impl crate :: RegisterSpec for U2EP4_1_MOD_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2ep4_1_mod::R`](R) reader structure"] impl crate :: Readable for U2EP4_1_MOD_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep4_1_mod::W`](W) writer structure"] impl crate :: Writable for U2EP4_1_MOD_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP4_1_MOD to value 0"] impl crate :: Resettable for U2EP4_1_MOD_SPEC { } }
#[doc = "U2EP2_3_MOD (rw) register accessor: endpoint 2_3 mode\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep2_3_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep2_3_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep2_3_mod`] module"] pub type U2EP2_3_MOD = crate :: Reg < u2ep2_3_mod :: U2EP2_3_MOD_SPEC > ;
#[doc = "endpoint 2_3 mode"] pub mod u2ep2_3_mod {
#[doc = "Register `U2EP2_3_MOD` reader"] pub type R = crate :: R < U2EP2_3_MOD_SPEC > ;
#[doc = "Register `U2EP2_3_MOD` writer"] pub type W = crate :: W < U2EP2_3_MOD_SPEC > ;
#[doc = "Field `UEP2_BUF_MOD` reader - buffer mode of USB endpoint 2"] pub type UEP2_BUF_MOD_R = crate :: BitReader ;
#[doc = "Field `UEP2_BUF_MOD` writer - buffer mode of USB endpoint 2"] pub type UEP2_BUF_MOD_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP2_TX_EN` reader - enable USB endpoint 2 transmittal (IN)"] pub type UEP2_TX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP2_TX_EN` writer - enable USB endpoint 2 transmittal (IN)"] pub type UEP2_TX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP2_RX_EN` reader - enable USB endpoint 2 receiving (OUT)"] pub type UEP2_RX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP2_RX_EN` writer - enable USB endpoint 2 receiving (OUT)"] pub type UEP2_RX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP3_BUF_MOD` reader - buffer mode of USB endpoint 3"] pub type UEP3_BUF_MOD_R = crate :: BitReader ;
#[doc = "Field `UEP3_BUF_MOD` writer - buffer mode of USB endpoint 3"] pub type UEP3_BUF_MOD_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP3_TX_EN` reader - enable USB endpoint 3 transmittal (IN)"] pub type UEP3_TX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP3_TX_EN` writer - enable USB endpoint 3 transmittal (IN)"] pub type UEP3_TX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP3_RX_EN` reader - enable USB endpoint 3 receiving (OUT)"] pub type UEP3_RX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP3_RX_EN` writer - enable USB endpoint 3 receiving (OUT)"] pub type UEP3_RX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - buffer mode of USB endpoint 2"]
#[inline (always)] pub fn uep2_buf_mod (& self) -> UEP2_BUF_MOD_R { UEP2_BUF_MOD_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 2 - enable USB endpoint 2 transmittal (IN)"]
#[inline (always)] pub fn uep2_tx_en (& self) -> UEP2_TX_EN_R { UEP2_TX_EN_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - enable USB endpoint 2 receiving (OUT)"]
#[inline (always)] pub fn uep2_rx_en (& self) -> UEP2_RX_EN_R { UEP2_RX_EN_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - buffer mode of USB endpoint 3"]
#[inline (always)] pub fn uep3_buf_mod (& self) -> UEP3_BUF_MOD_R { UEP3_BUF_MOD_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - enable USB endpoint 3 transmittal (IN)"]
#[inline (always)] pub fn uep3_tx_en (& self) -> UEP3_TX_EN_R { UEP3_TX_EN_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - enable USB endpoint 3 receiving (OUT)"]
#[inline (always)] pub fn uep3_rx_en (& self) -> UEP3_RX_EN_R { UEP3_RX_EN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 0 - buffer mode of USB endpoint 2"]
#[inline (always)] pub fn uep2_buf_mod (& mut self) -> UEP2_BUF_MOD_W < U2EP2_3_MOD_SPEC > { UEP2_BUF_MOD_W :: new (self , 0) }
#[doc = "Bit 2 - enable USB endpoint 2 transmittal (IN)"]
#[inline (always)] pub fn uep2_tx_en (& mut self) -> UEP2_TX_EN_W < U2EP2_3_MOD_SPEC > { UEP2_TX_EN_W :: new (self , 2) }
#[doc = "Bit 3 - enable USB endpoint 2 receiving (OUT)"]
#[inline (always)] pub fn uep2_rx_en (& mut self) -> UEP2_RX_EN_W < U2EP2_3_MOD_SPEC > { UEP2_RX_EN_W :: new (self , 3) }
#[doc = "Bit 4 - buffer mode of USB endpoint 3"]
#[inline (always)] pub fn uep3_buf_mod (& mut self) -> UEP3_BUF_MOD_W < U2EP2_3_MOD_SPEC > { UEP3_BUF_MOD_W :: new (self , 4) }
#[doc = "Bit 6 - enable USB endpoint 3 transmittal (IN)"]
#[inline (always)] pub fn uep3_tx_en (& mut self) -> UEP3_TX_EN_W < U2EP2_3_MOD_SPEC > { UEP3_TX_EN_W :: new (self , 6) }
#[doc = "Bit 7 - enable USB endpoint 3 receiving (OUT)"]
#[inline (always)] pub fn uep3_rx_en (& mut self) -> UEP3_RX_EN_W < U2EP2_3_MOD_SPEC > { UEP3_RX_EN_W :: new (self , 7) } }
#[doc = "endpoint 2_3 mode\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep2_3_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep2_3_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP2_3_MOD_SPEC ; impl crate :: RegisterSpec for U2EP2_3_MOD_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2ep2_3_mod::R`](R) reader structure"] impl crate :: Readable for U2EP2_3_MOD_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep2_3_mod::W`](W) writer structure"] impl crate :: Writable for U2EP2_3_MOD_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP2_3_MOD to value 0"] impl crate :: Resettable for U2EP2_3_MOD_SPEC { } }
#[doc = "U2H_EP_MOD (rw) register accessor: host endpoint mode\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_ep_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_ep_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2h_ep_mod`] module"] pub type U2H_EP_MOD = crate :: Reg < u2h_ep_mod :: U2H_EP_MOD_SPEC > ;
#[doc = "host endpoint mode"] pub mod u2h_ep_mod {
#[doc = "Register `U2H_EP_MOD` reader"] pub type R = crate :: R < U2H_EP_MOD_SPEC > ;
#[doc = "Register `U2H_EP_MOD` writer"] pub type W = crate :: W < U2H_EP_MOD_SPEC > ;
#[doc = "Field `UH_EP_RBUF_MOD` reader - buffer mode of USB host IN endpoint"] pub type UH_EP_RBUF_MOD_R = crate :: BitReader ;
#[doc = "Field `UH_EP_RBUF_MOD` writer - buffer mode of USB host IN endpoint"] pub type UH_EP_RBUF_MOD_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UH_EP_RX_EN` reader - enable USB host IN endpoint receiving"] pub type UH_EP_RX_EN_R = crate :: BitReader ;
#[doc = "Field `UH_EP_RX_EN` writer - enable USB host IN endpoint receiving"] pub type UH_EP_RX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UH_EP_TBUF_MOD` reader - buffer mode of USB host OUT endpoint"] pub type UH_EP_TBUF_MOD_R = crate :: BitReader ;
#[doc = "Field `UH_EP_TBUF_MOD` writer - buffer mode of USB host OUT endpoint"] pub type UH_EP_TBUF_MOD_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UH_EP_TX_EN` reader - enable USB host OUT endpoint transmittal"] pub type UH_EP_TX_EN_R = crate :: BitReader ;
#[doc = "Field `UH_EP_TX_EN` writer - enable USB host OUT endpoint transmittal"] pub type UH_EP_TX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - buffer mode of USB host IN endpoint"]
#[inline (always)] pub fn uh_ep_rbuf_mod (& self) -> UH_EP_RBUF_MOD_R { UH_EP_RBUF_MOD_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 3 - enable USB host IN endpoint receiving"]
#[inline (always)] pub fn uh_ep_rx_en (& self) -> UH_EP_RX_EN_R { UH_EP_RX_EN_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - buffer mode of USB host OUT endpoint"]
#[inline (always)] pub fn uh_ep_tbuf_mod (& self) -> UH_EP_TBUF_MOD_R { UH_EP_TBUF_MOD_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - enable USB host OUT endpoint transmittal"]
#[inline (always)] pub fn uh_ep_tx_en (& self) -> UH_EP_TX_EN_R { UH_EP_TX_EN_R :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bit 0 - buffer mode of USB host IN endpoint"]
#[inline (always)] pub fn uh_ep_rbuf_mod (& mut self) -> UH_EP_RBUF_MOD_W < U2H_EP_MOD_SPEC > { UH_EP_RBUF_MOD_W :: new (self , 0) }
#[doc = "Bit 3 - enable USB host IN endpoint receiving"]
#[inline (always)] pub fn uh_ep_rx_en (& mut self) -> UH_EP_RX_EN_W < U2H_EP_MOD_SPEC > { UH_EP_RX_EN_W :: new (self , 3) }
#[doc = "Bit 4 - buffer mode of USB host OUT endpoint"]
#[inline (always)] pub fn uh_ep_tbuf_mod (& mut self) -> UH_EP_TBUF_MOD_W < U2H_EP_MOD_SPEC > { UH_EP_TBUF_MOD_W :: new (self , 4) }
#[doc = "Bit 6 - enable USB host OUT endpoint transmittal"]
#[inline (always)] pub fn uh_ep_tx_en (& mut self) -> UH_EP_TX_EN_W < U2H_EP_MOD_SPEC > { UH_EP_TX_EN_W :: new (self , 6) } }
#[doc = "host endpoint mode\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_ep_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_ep_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2H_EP_MOD_SPEC ; impl crate :: RegisterSpec for U2H_EP_MOD_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2h_ep_mod::R`](R) reader structure"] impl crate :: Readable for U2H_EP_MOD_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2h_ep_mod::W`](W) writer structure"] impl crate :: Writable for U2H_EP_MOD_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2H_EP_MOD to value 0"] impl crate :: Resettable for U2H_EP_MOD_SPEC { } }
#[doc = "U2EP567_MOD (rw) register accessor: USB2 endpoint 5/6/7 mode\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep567_mod::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep567_mod::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep567_mod`] module"] pub type U2EP567_MOD = crate :: Reg < u2ep567_mod :: U2EP567_MOD_SPEC > ;
#[doc = "USB2 endpoint 5/6/7 mode"] pub mod u2ep567_mod {
#[doc = "Register `U2EP567_MOD` reader"] pub type R = crate :: R < U2EP567_MOD_SPEC > ;
#[doc = "Register `U2EP567_MOD` writer"] pub type W = crate :: W < U2EP567_MOD_SPEC > ;
#[doc = "Field `UEP5_TX_EN` reader - enable USB endpoint 5 transmittal (IN)"] pub type UEP5_TX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP5_TX_EN` writer - enable USB endpoint 5 transmittal (IN)"] pub type UEP5_TX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP5_RX_EN` reader - enable USB endpoint 5 receiving (OUT)"] pub type UEP5_RX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP5_RX_EN` writer - enable USB endpoint 5 receiving (OUT)"] pub type UEP5_RX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP6_TX_EN` reader - enable USB endpoint 6 transmittal (IN)"] pub type UEP6_TX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP6_TX_EN` writer - enable USB endpoint 6 transmittal (IN)"] pub type UEP6_TX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP6_RX_EN` reader - enable USB endpoint 6 receiving (OUT)"] pub type UEP6_RX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP6_RX_EN` writer - enable USB endpoint 6 receiving (OUT)"] pub type UEP6_RX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP7_TX_EN` reader - enable USB endpoint 7 transmittal (IN)"] pub type UEP7_TX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP7_TX_EN` writer - enable USB endpoint 7 transmittal (IN)"] pub type UEP7_TX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP7_RX_EN` reader - enable USB endpoint 7 receiving (OUT)"] pub type UEP7_RX_EN_R = crate :: BitReader ;
#[doc = "Field `UEP7_RX_EN` writer - enable USB endpoint 7 receiving (OUT)"] pub type UEP7_RX_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - enable USB endpoint 5 transmittal (IN)"]
#[inline (always)] pub fn uep5_tx_en (& self) -> UEP5_TX_EN_R { UEP5_TX_EN_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - enable USB endpoint 5 receiving (OUT)"]
#[inline (always)] pub fn uep5_rx_en (& self) -> UEP5_RX_EN_R { UEP5_RX_EN_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - enable USB endpoint 6 transmittal (IN)"]
#[inline (always)] pub fn uep6_tx_en (& self) -> UEP6_TX_EN_R { UEP6_TX_EN_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - enable USB endpoint 6 receiving (OUT)"]
#[inline (always)] pub fn uep6_rx_en (& self) -> UEP6_RX_EN_R { UEP6_RX_EN_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - enable USB endpoint 7 transmittal (IN)"]
#[inline (always)] pub fn uep7_tx_en (& self) -> UEP7_TX_EN_R { UEP7_TX_EN_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - enable USB endpoint 7 receiving (OUT)"]
#[inline (always)] pub fn uep7_rx_en (& self) -> UEP7_RX_EN_R { UEP7_RX_EN_R :: new (((self . bits >> 5) & 1) != 0) } } impl W {
#[doc = "Bit 0 - enable USB endpoint 5 transmittal (IN)"]
#[inline (always)] pub fn uep5_tx_en (& mut self) -> UEP5_TX_EN_W < U2EP567_MOD_SPEC > { UEP5_TX_EN_W :: new (self , 0) }
#[doc = "Bit 1 - enable USB endpoint 5 receiving (OUT)"]
#[inline (always)] pub fn uep5_rx_en (& mut self) -> UEP5_RX_EN_W < U2EP567_MOD_SPEC > { UEP5_RX_EN_W :: new (self , 1) }
#[doc = "Bit 2 - enable USB endpoint 6 transmittal (IN)"]
#[inline (always)] pub fn uep6_tx_en (& mut self) -> UEP6_TX_EN_W < U2EP567_MOD_SPEC > { UEP6_TX_EN_W :: new (self , 2) }
#[doc = "Bit 3 - enable USB endpoint 6 receiving (OUT)"]
#[inline (always)] pub fn uep6_rx_en (& mut self) -> UEP6_RX_EN_W < U2EP567_MOD_SPEC > { UEP6_RX_EN_W :: new (self , 3) }
#[doc = "Bit 4 - enable USB endpoint 7 transmittal (IN)"]
#[inline (always)] pub fn uep7_tx_en (& mut self) -> UEP7_TX_EN_W < U2EP567_MOD_SPEC > { UEP7_TX_EN_W :: new (self , 4) }
#[doc = "Bit 5 - enable USB endpoint 7 receiving (OUT)"]
#[inline (always)] pub fn uep7_rx_en (& mut self) -> UEP7_RX_EN_W < U2EP567_MOD_SPEC > { UEP7_RX_EN_W :: new (self , 5) } }
#[doc = "USB2 endpoint 5/6/7 mode\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep567_mod::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep567_mod::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP567_MOD_SPEC ; impl crate :: RegisterSpec for U2EP567_MOD_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2ep567_mod::R`](R) reader structure"] impl crate :: Readable for U2EP567_MOD_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep567_mod::W`](W) writer structure"] impl crate :: Writable for U2EP567_MOD_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP567_MOD to value 0"] impl crate :: Resettable for U2EP567_MOD_SPEC { } }
#[doc = "U2EP0_DMA (rw) register accessor: endpoint 0 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep0_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep0_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep0_dma`] module"] pub type U2EP0_DMA = crate :: Reg < u2ep0_dma :: U2EP0_DMA_SPEC > ;
#[doc = "endpoint 0 DMA buffer address"] pub mod u2ep0_dma {
#[doc = "Register `U2EP0_DMA` reader"] pub type R = crate :: R < U2EP0_DMA_SPEC > ;
#[doc = "Register `U2EP0_DMA` writer"] pub type W = crate :: W < U2EP0_DMA_SPEC > ;
#[doc = "Field `UEP0_DMA` reader - RW,endpoint 0 DMA buffer address"] pub type UEP0_DMA_R = crate :: FieldReader < u16 > ;
#[doc = "Field `UEP0_DMA` writer - RW,endpoint 0 DMA buffer address"] pub type UEP0_DMA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW,endpoint 0 DMA buffer address"]
#[inline (always)] pub fn uep0_dma (& self) -> UEP0_DMA_R { UEP0_DMA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW,endpoint 0 DMA buffer address"]
#[inline (always)] pub fn uep0_dma (& mut self) -> UEP0_DMA_W < U2EP0_DMA_SPEC > { UEP0_DMA_W :: new (self , 0) } }
#[doc = "endpoint 0 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep0_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep0_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP0_DMA_SPEC ; impl crate :: RegisterSpec for U2EP0_DMA_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`u2ep0_dma::R`](R) reader structure"] impl crate :: Readable for U2EP0_DMA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep0_dma::W`](W) writer structure"] impl crate :: Writable for U2EP0_DMA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP0_DMA to value 0"] impl crate :: Resettable for U2EP0_DMA_SPEC { } }
#[doc = "U2EP1_DMA (rw) register accessor: USB2 endpoint 1 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep1_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep1_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep1_dma`] module"] pub type U2EP1_DMA = crate :: Reg < u2ep1_dma :: U2EP1_DMA_SPEC > ;
#[doc = "USB2 endpoint 1 DMA buffer address"] pub mod u2ep1_dma {
#[doc = "Register `U2EP1_DMA` reader"] pub type R = crate :: R < U2EP1_DMA_SPEC > ;
#[doc = "Register `U2EP1_DMA` writer"] pub type W = crate :: W < U2EP1_DMA_SPEC > ;
#[doc = "Field `UEP1_DMA` reader - RW,endpoint 1 DMA buffer address"] pub type UEP1_DMA_R = crate :: FieldReader < u16 > ;
#[doc = "Field `UEP1_DMA` writer - RW,endpoint 1 DMA buffer address"] pub type UEP1_DMA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW,endpoint 1 DMA buffer address"]
#[inline (always)] pub fn uep1_dma (& self) -> UEP1_DMA_R { UEP1_DMA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW,endpoint 1 DMA buffer address"]
#[inline (always)] pub fn uep1_dma (& mut self) -> UEP1_DMA_W < U2EP1_DMA_SPEC > { UEP1_DMA_W :: new (self , 0) } }
#[doc = "USB2 endpoint 1 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep1_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep1_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP1_DMA_SPEC ; impl crate :: RegisterSpec for U2EP1_DMA_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`u2ep1_dma::R`](R) reader structure"] impl crate :: Readable for U2EP1_DMA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep1_dma::W`](W) writer structure"] impl crate :: Writable for U2EP1_DMA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP1_DMA to value 0"] impl crate :: Resettable for U2EP1_DMA_SPEC { } }
#[doc = "U2EP2_DMA (rw) register accessor: USB2 endpoint 2 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep2_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep2_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep2_dma`] module"] pub type U2EP2_DMA = crate :: Reg < u2ep2_dma :: U2EP2_DMA_SPEC > ;
#[doc = "USB2 endpoint 2 DMA buffer address"] pub mod u2ep2_dma {
#[doc = "Register `U2EP2_DMA` reader"] pub type R = crate :: R < U2EP2_DMA_SPEC > ;
#[doc = "Register `U2EP2_DMA` writer"] pub type W = crate :: W < U2EP2_DMA_SPEC > ;
#[doc = "Field `UEP2_DMA` reader - RW,endpoint 2 DMA buffer address"] pub type UEP2_DMA_R = crate :: FieldReader < u16 > ;
#[doc = "Field `UEP2_DMA` writer - RW,endpoint 2 DMA buffer address"] pub type UEP2_DMA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW,endpoint 2 DMA buffer address"]
#[inline (always)] pub fn uep2_dma (& self) -> UEP2_DMA_R { UEP2_DMA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW,endpoint 2 DMA buffer address"]
#[inline (always)] pub fn uep2_dma (& mut self) -> UEP2_DMA_W < U2EP2_DMA_SPEC > { UEP2_DMA_W :: new (self , 0) } }
#[doc = "USB2 endpoint 2 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep2_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep2_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP2_DMA_SPEC ; impl crate :: RegisterSpec for U2EP2_DMA_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`u2ep2_dma::R`](R) reader structure"] impl crate :: Readable for U2EP2_DMA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep2_dma::W`](W) writer structure"] impl crate :: Writable for U2EP2_DMA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP2_DMA to value 0"] impl crate :: Resettable for U2EP2_DMA_SPEC { } }
#[doc = "U2H_RX_DMA (rw) register accessor: host rx endpoint buffer high address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_rx_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_rx_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2h_rx_dma`] module"] pub type U2H_RX_DMA = crate :: Reg < u2h_rx_dma :: U2H_RX_DMA_SPEC > ;
#[doc = "host rx endpoint buffer high address"] pub mod u2h_rx_dma {
#[doc = "Register `U2H_RX_DMA` reader"] pub type R = crate :: R < U2H_RX_DMA_SPEC > ;
#[doc = "Register `U2H_RX_DMA` writer"] pub type W = crate :: W < U2H_RX_DMA_SPEC > ;
#[doc = "Field `UH_RX_DMA` reader - RW,host rx endpoint buffer high address"] pub type UH_RX_DMA_R = crate :: FieldReader < u16 > ;
#[doc = "Field `UH_RX_DMA` writer - RW,host rx endpoint buffer high address"] pub type UH_RX_DMA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW,host rx endpoint buffer high address"]
#[inline (always)] pub fn uh_rx_dma (& self) -> UH_RX_DMA_R { UH_RX_DMA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW,host rx endpoint buffer high address"]
#[inline (always)] pub fn uh_rx_dma (& mut self) -> UH_RX_DMA_W < U2H_RX_DMA_SPEC > { UH_RX_DMA_W :: new (self , 0) } }
#[doc = "host rx endpoint buffer high address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_rx_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_rx_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2H_RX_DMA_SPEC ; impl crate :: RegisterSpec for U2H_RX_DMA_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`u2h_rx_dma::R`](R) reader structure"] impl crate :: Readable for U2H_RX_DMA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2h_rx_dma::W`](W) writer structure"] impl crate :: Writable for U2H_RX_DMA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2H_RX_DMA to value 0"] impl crate :: Resettable for U2H_RX_DMA_SPEC { } }
#[doc = "U2EP3_DMA (rw) register accessor: USB2 endpoint 3 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep3_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep3_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep3_dma`] module"] pub type U2EP3_DMA = crate :: Reg < u2ep3_dma :: U2EP3_DMA_SPEC > ;
#[doc = "USB2 endpoint 3 DMA buffer address"] pub mod u2ep3_dma {
#[doc = "Register `U2EP3_DMA` reader"] pub type R = crate :: R < U2EP3_DMA_SPEC > ;
#[doc = "Register `U2EP3_DMA` writer"] pub type W = crate :: W < U2EP3_DMA_SPEC > ;
#[doc = "Field `UEP3_DMA` reader - RW,endpoint 3 DMA buffer address"] pub type UEP3_DMA_R = crate :: FieldReader < u16 > ;
#[doc = "Field `UEP3_DMA` writer - RW,endpoint 3 DMA buffer address"] pub type UEP3_DMA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW,endpoint 3 DMA buffer address"]
#[inline (always)] pub fn uep3_dma (& self) -> UEP3_DMA_R { UEP3_DMA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW,endpoint 3 DMA buffer address"]
#[inline (always)] pub fn uep3_dma (& mut self) -> UEP3_DMA_W < U2EP3_DMA_SPEC > { UEP3_DMA_W :: new (self , 0) } }
#[doc = "USB2 endpoint 3 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep3_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep3_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP3_DMA_SPEC ; impl crate :: RegisterSpec for U2EP3_DMA_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`u2ep3_dma::R`](R) reader structure"] impl crate :: Readable for U2EP3_DMA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep3_dma::W`](W) writer structure"] impl crate :: Writable for U2EP3_DMA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP3_DMA to value 0"] impl crate :: Resettable for U2EP3_DMA_SPEC { } }
#[doc = "U2H_TX_DMA (rw) register accessor: host tx endpoint buffer high address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_tx_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_tx_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2h_tx_dma`] module"] pub type U2H_TX_DMA = crate :: Reg < u2h_tx_dma :: U2H_TX_DMA_SPEC > ;
#[doc = "host tx endpoint buffer high address"] pub mod u2h_tx_dma {
#[doc = "Register `U2H_TX_DMA` reader"] pub type R = crate :: R < U2H_TX_DMA_SPEC > ;
#[doc = "Register `U2H_TX_DMA` writer"] pub type W = crate :: W < U2H_TX_DMA_SPEC > ;
#[doc = "Field `UH_TX_DMA` reader - RW,host tx endpoint buffer high address"] pub type UH_TX_DMA_R = crate :: FieldReader < u16 > ;
#[doc = "Field `UH_TX_DMA` writer - RW,host tx endpoint buffer high address"] pub type UH_TX_DMA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW,host tx endpoint buffer high address"]
#[inline (always)] pub fn uh_tx_dma (& self) -> UH_TX_DMA_R { UH_TX_DMA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW,host tx endpoint buffer high address"]
#[inline (always)] pub fn uh_tx_dma (& mut self) -> UH_TX_DMA_W < U2H_TX_DMA_SPEC > { UH_TX_DMA_W :: new (self , 0) } }
#[doc = "host tx endpoint buffer high address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_tx_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_tx_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2H_TX_DMA_SPEC ; impl crate :: RegisterSpec for U2H_TX_DMA_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`u2h_tx_dma::R`](R) reader structure"] impl crate :: Readable for U2H_TX_DMA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2h_tx_dma::W`](W) writer structure"] impl crate :: Writable for U2H_TX_DMA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2H_TX_DMA to value 0"] impl crate :: Resettable for U2H_TX_DMA_SPEC { } }
#[doc = "U2EP5_DMA (rw) register accessor: USB2 endpoint 5 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep5_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep5_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep5_dma`] module"] pub type U2EP5_DMA = crate :: Reg < u2ep5_dma :: U2EP5_DMA_SPEC > ;
#[doc = "USB2 endpoint 5 DMA buffer address"] pub mod u2ep5_dma {
#[doc = "Register `U2EP5_DMA` reader"] pub type R = crate :: R < U2EP5_DMA_SPEC > ;
#[doc = "Register `U2EP5_DMA` writer"] pub type W = crate :: W < U2EP5_DMA_SPEC > ;
#[doc = "Field `UEP5_DMA` reader - RW,endpoint 5 DMA buffer address"] pub type UEP5_DMA_R = crate :: FieldReader < u16 > ;
#[doc = "Field `UEP5_DMA` writer - RW,endpoint 5 DMA buffer address"] pub type UEP5_DMA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW,endpoint 5 DMA buffer address"]
#[inline (always)] pub fn uep5_dma (& self) -> UEP5_DMA_R { UEP5_DMA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW,endpoint 5 DMA buffer address"]
#[inline (always)] pub fn uep5_dma (& mut self) -> UEP5_DMA_W < U2EP5_DMA_SPEC > { UEP5_DMA_W :: new (self , 0) } }
#[doc = "USB2 endpoint 5 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep5_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep5_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP5_DMA_SPEC ; impl crate :: RegisterSpec for U2EP5_DMA_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`u2ep5_dma::R`](R) reader structure"] impl crate :: Readable for U2EP5_DMA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep5_dma::W`](W) writer structure"] impl crate :: Writable for U2EP5_DMA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP5_DMA to value 0"] impl crate :: Resettable for U2EP5_DMA_SPEC { } }
#[doc = "U2EP6_DMA (rw) register accessor: USB2 endpoint 6 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep6_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep6_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep6_dma`] module"] pub type U2EP6_DMA = crate :: Reg < u2ep6_dma :: U2EP6_DMA_SPEC > ;
#[doc = "USB2 endpoint 6 DMA buffer address"] pub mod u2ep6_dma {
#[doc = "Register `U2EP6_DMA` reader"] pub type R = crate :: R < U2EP6_DMA_SPEC > ;
#[doc = "Register `U2EP6_DMA` writer"] pub type W = crate :: W < U2EP6_DMA_SPEC > ;
#[doc = "Field `UEP6_DMA` reader - RW,endpoint 6 DMA buffer address"] pub type UEP6_DMA_R = crate :: FieldReader < u16 > ;
#[doc = "Field `UEP6_DMA` writer - RW,endpoint 6 DMA buffer address"] pub type UEP6_DMA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW,endpoint 6 DMA buffer address"]
#[inline (always)] pub fn uep6_dma (& self) -> UEP6_DMA_R { UEP6_DMA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW,endpoint 6 DMA buffer address"]
#[inline (always)] pub fn uep6_dma (& mut self) -> UEP6_DMA_W < U2EP6_DMA_SPEC > { UEP6_DMA_W :: new (self , 0) } }
#[doc = "USB2 endpoint 6 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep6_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep6_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP6_DMA_SPEC ; impl crate :: RegisterSpec for U2EP6_DMA_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`u2ep6_dma::R`](R) reader structure"] impl crate :: Readable for U2EP6_DMA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep6_dma::W`](W) writer structure"] impl crate :: Writable for U2EP6_DMA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP6_DMA to value 0"] impl crate :: Resettable for U2EP6_DMA_SPEC { } }
#[doc = "U2EP7_DMA (rw) register accessor: USB2 endpoint 7 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep7_dma::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep7_dma::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep7_dma`] module"] pub type U2EP7_DMA = crate :: Reg < u2ep7_dma :: U2EP7_DMA_SPEC > ;
#[doc = "USB2 endpoint 7 DMA buffer address"] pub mod u2ep7_dma {
#[doc = "Register `U2EP7_DMA` reader"] pub type R = crate :: R < U2EP7_DMA_SPEC > ;
#[doc = "Register `U2EP7_DMA` writer"] pub type W = crate :: W < U2EP7_DMA_SPEC > ;
#[doc = "Field `UEP7_DMA` reader - RW,endpoint 7 DMA buffer address"] pub type UEP7_DMA_R = crate :: FieldReader < u16 > ;
#[doc = "Field `UEP7_DMA` writer - RW,endpoint 7 DMA buffer address"] pub type UEP7_DMA_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R {
#[doc = "Bits 0:15 - RW,endpoint 7 DMA buffer address"]
#[inline (always)] pub fn uep7_dma (& self) -> UEP7_DMA_R { UEP7_DMA_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:15 - RW,endpoint 7 DMA buffer address"]
#[inline (always)] pub fn uep7_dma (& mut self) -> UEP7_DMA_W < U2EP7_DMA_SPEC > { UEP7_DMA_W :: new (self , 0) } }
#[doc = "USB2 endpoint 7 DMA buffer address\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep7_dma::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep7_dma::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP7_DMA_SPEC ; impl crate :: RegisterSpec for U2EP7_DMA_SPEC { type Ux = u16 ; }
#[doc = "`read()` method returns [`u2ep7_dma::R`](R) reader structure"] impl crate :: Readable for U2EP7_DMA_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep7_dma::W`](W) writer structure"] impl crate :: Writable for U2EP7_DMA_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP7_DMA to value 0"] impl crate :: Resettable for U2EP7_DMA_SPEC { } }
#[doc = "U2EP0_T_LEN (rw) register accessor: USB2 endpoint 0 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep0_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep0_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep0_t_len`] module"] pub type U2EP0_T_LEN = crate :: Reg < u2ep0_t_len :: U2EP0_T_LEN_SPEC > ;
#[doc = "USB2 endpoint 0 transmittal length"] pub mod u2ep0_t_len {
#[doc = "Register `U2EP0_T_LEN` reader"] pub type R = crate :: R < U2EP0_T_LEN_SPEC > ;
#[doc = "Register `U2EP0_T_LEN` writer"] pub type W = crate :: W < U2EP0_T_LEN_SPEC > ;
#[doc = "Field `UEP0_T_LEN` reader - endpoint 0 transmittal length"] pub type UEP0_T_LEN_R = crate :: FieldReader ;
#[doc = "Field `UEP0_T_LEN` writer - endpoint 0 transmittal length"] pub type UEP0_T_LEN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - endpoint 0 transmittal length"]
#[inline (always)] pub fn uep0_t_len (& self) -> UEP0_T_LEN_R { UEP0_T_LEN_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - endpoint 0 transmittal length"]
#[inline (always)] pub fn uep0_t_len (& mut self) -> UEP0_T_LEN_W < U2EP0_T_LEN_SPEC > { UEP0_T_LEN_W :: new (self , 0) } }
#[doc = "USB2 endpoint 0 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep0_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep0_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP0_T_LEN_SPEC ; impl crate :: RegisterSpec for U2EP0_T_LEN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2ep0_t_len::R`](R) reader structure"] impl crate :: Readable for U2EP0_T_LEN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep0_t_len::W`](W) writer structure"] impl crate :: Writable for U2EP0_T_LEN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP0_T_LEN to value 0"] impl crate :: Resettable for U2EP0_T_LEN_SPEC { } }
#[doc = "U2EP0_CTRL (rw) register accessor: USB2 endpoint 0 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep0_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep0_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep0_ctrl`] module"] pub type U2EP0_CTRL = crate :: Reg < u2ep0_ctrl :: U2EP0_CTRL_SPEC > ;
#[doc = "USB2 endpoint 0 control"] pub mod u2ep0_ctrl {
#[doc = "Register `U2EP0_CTRL` reader"] pub type R = crate :: R < U2EP0_CTRL_SPEC > ;
#[doc = "Register `U2EP0_CTRL` writer"] pub type W = crate :: W < U2EP0_CTRL_SPEC > ;
#[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& self) -> UEP_T_RES_R { UEP_T_RES_R :: new (self . bits & 3) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& self) -> UEP_R_RES_R { UEP_R_RES_R :: new ((self . bits >> 2) & 3) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& self) -> UEP_AUTO_TOG_R { UEP_AUTO_TOG_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& self) -> UEP_T_TOG_R { UEP_T_TOG_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& self) -> UEP_R_TOG_R { UEP_R_TOG_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& mut self) -> UEP_T_RES_W < U2EP0_CTRL_SPEC > { UEP_T_RES_W :: new (self , 0) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& mut self) -> UEP_R_RES_W < U2EP0_CTRL_SPEC > { UEP_R_RES_W :: new (self , 2) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& mut self) -> UEP_AUTO_TOG_W < U2EP0_CTRL_SPEC > { UEP_AUTO_TOG_W :: new (self , 4) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& mut self) -> UEP_T_TOG_W < U2EP0_CTRL_SPEC > { UEP_T_TOG_W :: new (self , 6) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& mut self) -> UEP_R_TOG_W < U2EP0_CTRL_SPEC > { UEP_R_TOG_W :: new (self , 7) } }
#[doc = "USB2 endpoint 0 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep0_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep0_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP0_CTRL_SPEC ; impl crate :: RegisterSpec for U2EP0_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2ep0_ctrl::R`](R) reader structure"] impl crate :: Readable for U2EP0_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep0_ctrl::W`](W) writer structure"] impl crate :: Writable for U2EP0_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP0_CTRL to value 0"] impl crate :: Resettable for U2EP0_CTRL_SPEC { } }
#[doc = "U2EP1_T_LEN (rw) register accessor: USB2 endpoint 1 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep1_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep1_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep1_t_len`] module"] pub type U2EP1_T_LEN = crate :: Reg < u2ep1_t_len :: U2EP1_T_LEN_SPEC > ;
#[doc = "USB2 endpoint 1 transmittal length"] pub mod u2ep1_t_len {
#[doc = "Register `U2EP1_T_LEN` reader"] pub type R = crate :: R < U2EP1_T_LEN_SPEC > ;
#[doc = "Register `U2EP1_T_LEN` writer"] pub type W = crate :: W < U2EP1_T_LEN_SPEC > ;
#[doc = "Field `UEP1_T_LEN` reader - endpoint 1 transmittal length"] pub type UEP1_T_LEN_R = crate :: FieldReader ;
#[doc = "Field `UEP1_T_LEN` writer - endpoint 1 transmittal length"] pub type UEP1_T_LEN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - endpoint 1 transmittal length"]
#[inline (always)] pub fn uep1_t_len (& self) -> UEP1_T_LEN_R { UEP1_T_LEN_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - endpoint 1 transmittal length"]
#[inline (always)] pub fn uep1_t_len (& mut self) -> UEP1_T_LEN_W < U2EP1_T_LEN_SPEC > { UEP1_T_LEN_W :: new (self , 0) } }
#[doc = "USB2 endpoint 1 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep1_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep1_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP1_T_LEN_SPEC ; impl crate :: RegisterSpec for U2EP1_T_LEN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2ep1_t_len::R`](R) reader structure"] impl crate :: Readable for U2EP1_T_LEN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep1_t_len::W`](W) writer structure"] impl crate :: Writable for U2EP1_T_LEN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP1_T_LEN to value 0"] impl crate :: Resettable for U2EP1_T_LEN_SPEC { } }
#[doc = "U2EP1_CTRL (rw) register accessor: USB2 endpoint 1 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep1_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep1_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep1_ctrl`] module"] pub type U2EP1_CTRL = crate :: Reg < u2ep1_ctrl :: U2EP1_CTRL_SPEC > ;
#[doc = "USB2 endpoint 1 control"] pub mod u2ep1_ctrl {
#[doc = "Register `U2EP1_CTRL` reader"] pub type R = crate :: R < U2EP1_CTRL_SPEC > ;
#[doc = "Register `U2EP1_CTRL` writer"] pub type W = crate :: W < U2EP1_CTRL_SPEC > ;
#[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& self) -> UEP_T_RES_R { UEP_T_RES_R :: new (self . bits & 3) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& self) -> UEP_R_RES_R { UEP_R_RES_R :: new ((self . bits >> 2) & 3) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& self) -> UEP_AUTO_TOG_R { UEP_AUTO_TOG_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& self) -> UEP_T_TOG_R { UEP_T_TOG_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& self) -> UEP_R_TOG_R { UEP_R_TOG_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& mut self) -> UEP_T_RES_W < U2EP1_CTRL_SPEC > { UEP_T_RES_W :: new (self , 0) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& mut self) -> UEP_R_RES_W < U2EP1_CTRL_SPEC > { UEP_R_RES_W :: new (self , 2) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& mut self) -> UEP_AUTO_TOG_W < U2EP1_CTRL_SPEC > { UEP_AUTO_TOG_W :: new (self , 4) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& mut self) -> UEP_T_TOG_W < U2EP1_CTRL_SPEC > { UEP_T_TOG_W :: new (self , 6) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& mut self) -> UEP_R_TOG_W < U2EP1_CTRL_SPEC > { UEP_R_TOG_W :: new (self , 7) } }
#[doc = "USB2 endpoint 1 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep1_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep1_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP1_CTRL_SPEC ; impl crate :: RegisterSpec for U2EP1_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2ep1_ctrl::R`](R) reader structure"] impl crate :: Readable for U2EP1_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep1_ctrl::W`](W) writer structure"] impl crate :: Writable for U2EP1_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP1_CTRL to value 0"] impl crate :: Resettable for U2EP1_CTRL_SPEC { } }
#[doc = "U2H_SETUP (rw) register accessor: host aux setup\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_setup::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_setup::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2h_setup`] module"] pub type U2H_SETUP = crate :: Reg < u2h_setup :: U2H_SETUP_SPEC > ;
#[doc = "host aux setup"] pub mod u2h_setup {
#[doc = "Register `U2H_SETUP` reader"] pub type R = crate :: R < U2H_SETUP_SPEC > ;
#[doc = "Register `U2H_SETUP` writer"] pub type W = crate :: W < U2H_SETUP_SPEC > ;
#[doc = "Field `UH_SOF_EN` reader - USB host automatic SOF enable"] pub type UH_SOF_EN_R = crate :: BitReader ;
#[doc = "Field `UH_SOF_EN` writer - USB host automatic SOF enable"] pub type UH_SOF_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UH_PRE_PID_EN` reader - USB host PRE PID enable for low speed device via hub"] pub type UH_PRE_PID_EN_R = crate :: BitReader ;
#[doc = "Field `UH_PRE_PID_EN` writer - USB host PRE PID enable for low speed device via hub"] pub type UH_PRE_PID_EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 6 - USB host automatic SOF enable"]
#[inline (always)] pub fn uh_sof_en (& self) -> UH_SOF_EN_R { UH_SOF_EN_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - USB host PRE PID enable for low speed device via hub"]
#[inline (always)] pub fn uh_pre_pid_en (& self) -> UH_PRE_PID_EN_R { UH_PRE_PID_EN_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 6 - USB host automatic SOF enable"]
#[inline (always)] pub fn uh_sof_en (& mut self) -> UH_SOF_EN_W < U2H_SETUP_SPEC > { UH_SOF_EN_W :: new (self , 6) }
#[doc = "Bit 7 - USB host PRE PID enable for low speed device via hub"]
#[inline (always)] pub fn uh_pre_pid_en (& mut self) -> UH_PRE_PID_EN_W < U2H_SETUP_SPEC > { UH_PRE_PID_EN_W :: new (self , 7) } }
#[doc = "host aux setup\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_setup::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_setup::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2H_SETUP_SPEC ; impl crate :: RegisterSpec for U2H_SETUP_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2h_setup::R`](R) reader structure"] impl crate :: Readable for U2H_SETUP_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2h_setup::W`](W) writer structure"] impl crate :: Writable for U2H_SETUP_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2H_SETUP to value 0"] impl crate :: Resettable for U2H_SETUP_SPEC { } }
#[doc = "U2EP2_T_LEN (rw) register accessor: USB2 endpoint 2 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep2_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep2_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep2_t_len`] module"] pub type U2EP2_T_LEN = crate :: Reg < u2ep2_t_len :: U2EP2_T_LEN_SPEC > ;
#[doc = "USB2 endpoint 2 transmittal length"] pub mod u2ep2_t_len {
#[doc = "Register `U2EP2_T_LEN` reader"] pub type R = crate :: R < U2EP2_T_LEN_SPEC > ;
#[doc = "Register `U2EP2_T_LEN` writer"] pub type W = crate :: W < U2EP2_T_LEN_SPEC > ;
#[doc = "Field `UEP2_T_LEN` reader - endpoint 2 transmittal length"] pub type UEP2_T_LEN_R = crate :: FieldReader ;
#[doc = "Field `UEP2_T_LEN` writer - endpoint 2 transmittal length"] pub type UEP2_T_LEN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - endpoint 2 transmittal length"]
#[inline (always)] pub fn uep2_t_len (& self) -> UEP2_T_LEN_R { UEP2_T_LEN_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - endpoint 2 transmittal length"]
#[inline (always)] pub fn uep2_t_len (& mut self) -> UEP2_T_LEN_W < U2EP2_T_LEN_SPEC > { UEP2_T_LEN_W :: new (self , 0) } }
#[doc = "USB2 endpoint 2 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep2_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep2_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP2_T_LEN_SPEC ; impl crate :: RegisterSpec for U2EP2_T_LEN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2ep2_t_len::R`](R) reader structure"] impl crate :: Readable for U2EP2_T_LEN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep2_t_len::W`](W) writer structure"] impl crate :: Writable for U2EP2_T_LEN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP2_T_LEN to value 0"] impl crate :: Resettable for U2EP2_T_LEN_SPEC { } }
#[doc = "U2H_EP_PID (rw) register accessor: host endpoint and PID\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_ep_pid::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_ep_pid::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2h_ep_pid`] module"] pub type U2H_EP_PID = crate :: Reg < u2h_ep_pid :: U2H_EP_PID_SPEC > ;
#[doc = "host endpoint and PID"] pub mod u2h_ep_pid {
#[doc = "Register `U2H_EP_PID` reader"] pub type R = crate :: R < U2H_EP_PID_SPEC > ;
#[doc = "Register `U2H_EP_PID` writer"] pub type W = crate :: W < U2H_EP_PID_SPEC > ;
#[doc = "Field `UH_ENDP` reader - bit mask of endpoint number for USB host transfer"] pub type UH_ENDP_R = crate :: FieldReader ;
#[doc = "Field `UH_ENDP` writer - bit mask of endpoint number for USB host transfer"] pub type UH_ENDP_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ;
#[doc = "Field `UH_TOKEN` reader - bit mask of token PID for USB host transfer"] pub type UH_TOKEN_R = crate :: FieldReader ;
#[doc = "Field `UH_TOKEN` writer - bit mask of token PID for USB host transfer"] pub type UH_TOKEN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - bit mask of endpoint number for USB host transfer"]
#[inline (always)] pub fn uh_endp (& self) -> UH_ENDP_R { UH_ENDP_R :: new (self . bits & 0x0f) }
#[doc = "Bits 4:7 - bit mask of token PID for USB host transfer"]
#[inline (always)] pub fn uh_token (& self) -> UH_TOKEN_R { UH_TOKEN_R :: new ((self . bits >> 4) & 0x0f) } } impl W {
#[doc = "Bits 0:3 - bit mask of endpoint number for USB host transfer"]
#[inline (always)] pub fn uh_endp (& mut self) -> UH_ENDP_W < U2H_EP_PID_SPEC > { UH_ENDP_W :: new (self , 0) }
#[doc = "Bits 4:7 - bit mask of token PID for USB host transfer"]
#[inline (always)] pub fn uh_token (& mut self) -> UH_TOKEN_W < U2H_EP_PID_SPEC > { UH_TOKEN_W :: new (self , 4) } }
#[doc = "host endpoint and PID\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_ep_pid::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_ep_pid::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2H_EP_PID_SPEC ; impl crate :: RegisterSpec for U2H_EP_PID_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2h_ep_pid::R`](R) reader structure"] impl crate :: Readable for U2H_EP_PID_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2h_ep_pid::W`](W) writer structure"] impl crate :: Writable for U2H_EP_PID_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2H_EP_PID to value 0"] impl crate :: Resettable for U2H_EP_PID_SPEC { } }
#[doc = "U2EP2_CTRL (rw) register accessor: USB2 endpoint 2 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep2_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep2_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep2_ctrl`] module"] pub type U2EP2_CTRL = crate :: Reg < u2ep2_ctrl :: U2EP2_CTRL_SPEC > ;
#[doc = "USB2 endpoint 2 control"] pub mod u2ep2_ctrl {
#[doc = "Register `U2EP2_CTRL` reader"] pub type R = crate :: R < U2EP2_CTRL_SPEC > ;
#[doc = "Register `U2EP2_CTRL` writer"] pub type W = crate :: W < U2EP2_CTRL_SPEC > ;
#[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& self) -> UEP_T_RES_R { UEP_T_RES_R :: new (self . bits & 3) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& self) -> UEP_R_RES_R { UEP_R_RES_R :: new ((self . bits >> 2) & 3) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& self) -> UEP_AUTO_TOG_R { UEP_AUTO_TOG_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& self) -> UEP_T_TOG_R { UEP_T_TOG_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& self) -> UEP_R_TOG_R { UEP_R_TOG_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& mut self) -> UEP_T_RES_W < U2EP2_CTRL_SPEC > { UEP_T_RES_W :: new (self , 0) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& mut self) -> UEP_R_RES_W < U2EP2_CTRL_SPEC > { UEP_R_RES_W :: new (self , 2) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& mut self) -> UEP_AUTO_TOG_W < U2EP2_CTRL_SPEC > { UEP_AUTO_TOG_W :: new (self , 4) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& mut self) -> UEP_T_TOG_W < U2EP2_CTRL_SPEC > { UEP_T_TOG_W :: new (self , 6) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& mut self) -> UEP_R_TOG_W < U2EP2_CTRL_SPEC > { UEP_R_TOG_W :: new (self , 7) } }
#[doc = "USB2 endpoint 2 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep2_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep2_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP2_CTRL_SPEC ; impl crate :: RegisterSpec for U2EP2_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2ep2_ctrl::R`](R) reader structure"] impl crate :: Readable for U2EP2_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep2_ctrl::W`](W) writer structure"] impl crate :: Writable for U2EP2_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP2_CTRL to value 0"] impl crate :: Resettable for U2EP2_CTRL_SPEC { } }
#[doc = "U2H_RX_CTRL (rw) register accessor: host receiver endpoint control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_rx_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_rx_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2h_rx_ctrl`] module"] pub type U2H_RX_CTRL = crate :: Reg < u2h_rx_ctrl :: U2H_RX_CTRL_SPEC > ;
#[doc = "host receiver endpoint control"] pub mod u2h_rx_ctrl {
#[doc = "Register `U2H_RX_CTRL` reader"] pub type R = crate :: R < U2H_RX_CTRL_SPEC > ;
#[doc = "Register `U2H_RX_CTRL` writer"] pub type W = crate :: W < U2H_RX_CTRL_SPEC > ;
#[doc = "Field `UH_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UH_R_RES_R = crate :: BitReader ;
#[doc = "Field `UH_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UH_R_RES_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UH_R_AUTO_TOG` reader - enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle"] pub type UH_R_AUTO_TOG_R = crate :: BitReader ;
#[doc = "Field `UH_R_AUTO_TOG` writer - enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle"] pub type UH_R_AUTO_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UH_R_TOG` reader - expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1"] pub type UH_R_TOG_R = crate :: BitReader ;
#[doc = "Field `UH_R_TOG` writer - expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1"] pub type UH_R_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 2 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uh_r_res (& self) -> UH_R_RES_R { UH_R_RES_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uh_r_auto_tog (& self) -> UH_R_AUTO_TOG_R { UH_R_AUTO_TOG_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 7 - expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uh_r_tog (& self) -> UH_R_TOG_R { UH_R_TOG_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bit 2 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uh_r_res (& mut self) -> UH_R_RES_W < U2H_RX_CTRL_SPEC > { UH_R_RES_W :: new (self , 2) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uh_r_auto_tog (& mut self) -> UH_R_AUTO_TOG_W < U2H_RX_CTRL_SPEC > { UH_R_AUTO_TOG_W :: new (self , 4) }
#[doc = "Bit 7 - expected data toggle flag of host receiving (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uh_r_tog (& mut self) -> UH_R_TOG_W < U2H_RX_CTRL_SPEC > { UH_R_TOG_W :: new (self , 7) } }
#[doc = "host receiver endpoint control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_rx_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_rx_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2H_RX_CTRL_SPEC ; impl crate :: RegisterSpec for U2H_RX_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2h_rx_ctrl::R`](R) reader structure"] impl crate :: Readable for U2H_RX_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2h_rx_ctrl::W`](W) writer structure"] impl crate :: Writable for U2H_RX_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2H_RX_CTRL to value 0"] impl crate :: Resettable for U2H_RX_CTRL_SPEC { } }
#[doc = "U2EP3_T_LEN (rw) register accessor: USB2 endpoint 3 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep3_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep3_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep3_t_len`] module"] pub type U2EP3_T_LEN = crate :: Reg < u2ep3_t_len :: U2EP3_T_LEN_SPEC > ;
#[doc = "USB2 endpoint 3 transmittal length"] pub mod u2ep3_t_len {
#[doc = "Register `U2EP3_T_LEN` reader"] pub type R = crate :: R < U2EP3_T_LEN_SPEC > ;
#[doc = "Register `U2EP3_T_LEN` writer"] pub type W = crate :: W < U2EP3_T_LEN_SPEC > ;
#[doc = "Field `UEP3_T_LEN` reader - endpoint 3 transmittal length"] pub type UEP3_T_LEN_R = crate :: FieldReader ;
#[doc = "Field `UEP3_T_LEN` writer - endpoint 3 transmittal length"] pub type UEP3_T_LEN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - endpoint 3 transmittal length"]
#[inline (always)] pub fn uep3_t_len (& self) -> UEP3_T_LEN_R { UEP3_T_LEN_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - endpoint 3 transmittal length"]
#[inline (always)] pub fn uep3_t_len (& mut self) -> UEP3_T_LEN_W < U2EP3_T_LEN_SPEC > { UEP3_T_LEN_W :: new (self , 0) } }
#[doc = "USB2 endpoint 3 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep3_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep3_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP3_T_LEN_SPEC ; impl crate :: RegisterSpec for U2EP3_T_LEN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2ep3_t_len::R`](R) reader structure"] impl crate :: Readable for U2EP3_T_LEN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep3_t_len::W`](W) writer structure"] impl crate :: Writable for U2EP3_T_LEN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP3_T_LEN to value 0"] impl crate :: Resettable for U2EP3_T_LEN_SPEC { } }
#[doc = "U2H_TX_LEN (rw) register accessor: host transmittal endpoint transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_tx_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_tx_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2h_tx_len`] module"] pub type U2H_TX_LEN = crate :: Reg < u2h_tx_len :: U2H_TX_LEN_SPEC > ;
#[doc = "host transmittal endpoint transmittal length"] pub mod u2h_tx_len {
#[doc = "Register `U2H_TX_LEN` reader"] pub type R = crate :: R < U2H_TX_LEN_SPEC > ;
#[doc = "Register `U2H_TX_LEN` writer"] pub type W = crate :: W < U2H_TX_LEN_SPEC > ;
#[doc = "Field `UH_TX_LEN` reader - host transmittal endpoint transmittal length"] pub type UH_TX_LEN_R = crate :: FieldReader ;
#[doc = "Field `UH_TX_LEN` writer - host transmittal endpoint transmittal length"] pub type UH_TX_LEN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - host transmittal endpoint transmittal length"]
#[inline (always)] pub fn uh_tx_len (& self) -> UH_TX_LEN_R { UH_TX_LEN_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - host transmittal endpoint transmittal length"]
#[inline (always)] pub fn uh_tx_len (& mut self) -> UH_TX_LEN_W < U2H_TX_LEN_SPEC > { UH_TX_LEN_W :: new (self , 0) } }
#[doc = "host transmittal endpoint transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_tx_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_tx_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2H_TX_LEN_SPEC ; impl crate :: RegisterSpec for U2H_TX_LEN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2h_tx_len::R`](R) reader structure"] impl crate :: Readable for U2H_TX_LEN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2h_tx_len::W`](W) writer structure"] impl crate :: Writable for U2H_TX_LEN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2H_TX_LEN to value 0"] impl crate :: Resettable for U2H_TX_LEN_SPEC { } }
#[doc = "U2EP3_CTRL (rw) register accessor: USB2 endpoint 3 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep3_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep3_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep3_ctrl`] module"] pub type U2EP3_CTRL = crate :: Reg < u2ep3_ctrl :: U2EP3_CTRL_SPEC > ;
#[doc = "USB2 endpoint 3 control"] pub mod u2ep3_ctrl {
#[doc = "Register `U2EP3_CTRL` reader"] pub type R = crate :: R < U2EP3_CTRL_SPEC > ;
#[doc = "Register `U2EP3_CTRL` writer"] pub type W = crate :: W < U2EP3_CTRL_SPEC > ;
#[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& self) -> UEP_T_RES_R { UEP_T_RES_R :: new (self . bits & 3) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& self) -> UEP_R_RES_R { UEP_R_RES_R :: new ((self . bits >> 2) & 3) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& self) -> UEP_AUTO_TOG_R { UEP_AUTO_TOG_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& self) -> UEP_T_TOG_R { UEP_T_TOG_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& self) -> UEP_R_TOG_R { UEP_R_TOG_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& mut self) -> UEP_T_RES_W < U2EP3_CTRL_SPEC > { UEP_T_RES_W :: new (self , 0) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& mut self) -> UEP_R_RES_W < U2EP3_CTRL_SPEC > { UEP_R_RES_W :: new (self , 2) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& mut self) -> UEP_AUTO_TOG_W < U2EP3_CTRL_SPEC > { UEP_AUTO_TOG_W :: new (self , 4) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& mut self) -> UEP_T_TOG_W < U2EP3_CTRL_SPEC > { UEP_T_TOG_W :: new (self , 6) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& mut self) -> UEP_R_TOG_W < U2EP3_CTRL_SPEC > { UEP_R_TOG_W :: new (self , 7) } }
#[doc = "USB2 endpoint 3 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep3_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep3_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP3_CTRL_SPEC ; impl crate :: RegisterSpec for U2EP3_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2ep3_ctrl::R`](R) reader structure"] impl crate :: Readable for U2EP3_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep3_ctrl::W`](W) writer structure"] impl crate :: Writable for U2EP3_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP3_CTRL to value 0"] impl crate :: Resettable for U2EP3_CTRL_SPEC { } }
#[doc = "U2H_TX_CTRL (rw) register accessor: host transmittal endpoint control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_tx_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_tx_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2h_tx_ctrl`] module"] pub type U2H_TX_CTRL = crate :: Reg < u2h_tx_ctrl :: U2H_TX_CTRL_SPEC > ;
#[doc = "host transmittal endpoint control"] pub mod u2h_tx_ctrl {
#[doc = "Register `U2H_TX_CTRL` reader"] pub type R = crate :: R < U2H_TX_CTRL_SPEC > ;
#[doc = "Register `U2H_TX_CTRL` writer"] pub type W = crate :: W < U2H_TX_CTRL_SPEC > ;
#[doc = "Field `UH_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UH_T_RES_R = crate :: FieldReader ;
#[doc = "Field `UH_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UH_T_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UH_T_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UH_T_AUTO_TOG_R = crate :: BitReader ;
#[doc = "Field `UH_T_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UH_T_AUTO_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UH_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UH_T_TOG_R = crate :: BitReader ;
#[doc = "Field `UH_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UH_T_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uh_t_res (& self) -> UH_T_RES_R { UH_T_RES_R :: new (self . bits & 3) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uh_t_auto_tog (& self) -> UH_T_AUTO_TOG_R { UH_T_AUTO_TOG_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uh_t_tog (& self) -> UH_T_TOG_R { UH_T_TOG_R :: new (((self . bits >> 6) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uh_t_res (& mut self) -> UH_T_RES_W < U2H_TX_CTRL_SPEC > { UH_T_RES_W :: new (self , 0) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uh_t_auto_tog (& mut self) -> UH_T_AUTO_TOG_W < U2H_TX_CTRL_SPEC > { UH_T_AUTO_TOG_W :: new (self , 4) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uh_t_tog (& mut self) -> UH_T_TOG_W < U2H_TX_CTRL_SPEC > { UH_T_TOG_W :: new (self , 6) } }
#[doc = "host transmittal endpoint control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2h_tx_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2h_tx_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2H_TX_CTRL_SPEC ; impl crate :: RegisterSpec for U2H_TX_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2h_tx_ctrl::R`](R) reader structure"] impl crate :: Readable for U2H_TX_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2h_tx_ctrl::W`](W) writer structure"] impl crate :: Writable for U2H_TX_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2H_TX_CTRL to value 0"] impl crate :: Resettable for U2H_TX_CTRL_SPEC { } }
#[doc = "U2EP4_T_LEN (rw) register accessor: USB2 endpoint 4 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep4_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep4_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep4_t_len`] module"] pub type U2EP4_T_LEN = crate :: Reg < u2ep4_t_len :: U2EP4_T_LEN_SPEC > ;
#[doc = "USB2 endpoint 4 transmittal length"] pub mod u2ep4_t_len {
#[doc = "Register `U2EP4_T_LEN` reader"] pub type R = crate :: R < U2EP4_T_LEN_SPEC > ;
#[doc = "Register `U2EP4_T_LEN` writer"] pub type W = crate :: W < U2EP4_T_LEN_SPEC > ;
#[doc = "Field `UEP4_T_LEN` reader - endpoint 4 transmittal length"] pub type UEP4_T_LEN_R = crate :: FieldReader ;
#[doc = "Field `UEP4_T_LEN` writer - endpoint 4 transmittal length"] pub type UEP4_T_LEN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - endpoint 4 transmittal length"]
#[inline (always)] pub fn uep4_t_len (& self) -> UEP4_T_LEN_R { UEP4_T_LEN_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - endpoint 4 transmittal length"]
#[inline (always)] pub fn uep4_t_len (& mut self) -> UEP4_T_LEN_W < U2EP4_T_LEN_SPEC > { UEP4_T_LEN_W :: new (self , 0) } }
#[doc = "USB2 endpoint 4 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep4_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep4_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP4_T_LEN_SPEC ; impl crate :: RegisterSpec for U2EP4_T_LEN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2ep4_t_len::R`](R) reader structure"] impl crate :: Readable for U2EP4_T_LEN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep4_t_len::W`](W) writer structure"] impl crate :: Writable for U2EP4_T_LEN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP4_T_LEN to value 0"] impl crate :: Resettable for U2EP4_T_LEN_SPEC { } }
#[doc = "U2EP4_CTRL (rw) register accessor: USB2 endpoint 4 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep4_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep4_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep4_ctrl`] module"] pub type U2EP4_CTRL = crate :: Reg < u2ep4_ctrl :: U2EP4_CTRL_SPEC > ;
#[doc = "USB2 endpoint 4 control"] pub mod u2ep4_ctrl {
#[doc = "Register `U2EP4_CTRL` reader"] pub type R = crate :: R < U2EP4_CTRL_SPEC > ;
#[doc = "Register `U2EP4_CTRL` writer"] pub type W = crate :: W < U2EP4_CTRL_SPEC > ;
#[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& self) -> UEP_T_RES_R { UEP_T_RES_R :: new (self . bits & 3) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& self) -> UEP_R_RES_R { UEP_R_RES_R :: new ((self . bits >> 2) & 3) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& self) -> UEP_AUTO_TOG_R { UEP_AUTO_TOG_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& self) -> UEP_T_TOG_R { UEP_T_TOG_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& self) -> UEP_R_TOG_R { UEP_R_TOG_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& mut self) -> UEP_T_RES_W < U2EP4_CTRL_SPEC > { UEP_T_RES_W :: new (self , 0) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& mut self) -> UEP_R_RES_W < U2EP4_CTRL_SPEC > { UEP_R_RES_W :: new (self , 2) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& mut self) -> UEP_AUTO_TOG_W < U2EP4_CTRL_SPEC > { UEP_AUTO_TOG_W :: new (self , 4) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& mut self) -> UEP_T_TOG_W < U2EP4_CTRL_SPEC > { UEP_T_TOG_W :: new (self , 6) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& mut self) -> UEP_R_TOG_W < U2EP4_CTRL_SPEC > { UEP_R_TOG_W :: new (self , 7) } }
#[doc = "USB2 endpoint 4 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep4_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep4_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP4_CTRL_SPEC ; impl crate :: RegisterSpec for U2EP4_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2ep4_ctrl::R`](R) reader structure"] impl crate :: Readable for U2EP4_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep4_ctrl::W`](W) writer structure"] impl crate :: Writable for U2EP4_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP4_CTRL to value 0"] impl crate :: Resettable for U2EP4_CTRL_SPEC { } }
#[doc = "U2EP5_T_LEN (rw) register accessor: USB2 endpoint 5 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep5_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep5_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep5_t_len`] module"] pub type U2EP5_T_LEN = crate :: Reg < u2ep5_t_len :: U2EP5_T_LEN_SPEC > ;
#[doc = "USB2 endpoint 5 transmittal length"] pub mod u2ep5_t_len {
#[doc = "Register `U2EP5_T_LEN` reader"] pub type R = crate :: R < U2EP5_T_LEN_SPEC > ;
#[doc = "Register `U2EP5_T_LEN` writer"] pub type W = crate :: W < U2EP5_T_LEN_SPEC > ;
#[doc = "Field `UEP5_T_LEN` reader - endpoint 5 transmittal length"] pub type UEP5_T_LEN_R = crate :: FieldReader ;
#[doc = "Field `UEP5_T_LEN` writer - endpoint 5 transmittal length"] pub type UEP5_T_LEN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - endpoint 5 transmittal length"]
#[inline (always)] pub fn uep5_t_len (& self) -> UEP5_T_LEN_R { UEP5_T_LEN_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - endpoint 5 transmittal length"]
#[inline (always)] pub fn uep5_t_len (& mut self) -> UEP5_T_LEN_W < U2EP5_T_LEN_SPEC > { UEP5_T_LEN_W :: new (self , 0) } }
#[doc = "USB2 endpoint 5 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep5_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep5_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP5_T_LEN_SPEC ; impl crate :: RegisterSpec for U2EP5_T_LEN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2ep5_t_len::R`](R) reader structure"] impl crate :: Readable for U2EP5_T_LEN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep5_t_len::W`](W) writer structure"] impl crate :: Writable for U2EP5_T_LEN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP5_T_LEN to value 0"] impl crate :: Resettable for U2EP5_T_LEN_SPEC { } }
#[doc = "U2EP5_CTRL (rw) register accessor: USB2 endpoint 5 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep5_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep5_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep5_ctrl`] module"] pub type U2EP5_CTRL = crate :: Reg < u2ep5_ctrl :: U2EP5_CTRL_SPEC > ;
#[doc = "USB2 endpoint 5 control"] pub mod u2ep5_ctrl {
#[doc = "Register `U2EP5_CTRL` reader"] pub type R = crate :: R < U2EP5_CTRL_SPEC > ;
#[doc = "Register `U2EP5_CTRL` writer"] pub type W = crate :: W < U2EP5_CTRL_SPEC > ;
#[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& self) -> UEP_T_RES_R { UEP_T_RES_R :: new (self . bits & 3) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& self) -> UEP_R_RES_R { UEP_R_RES_R :: new ((self . bits >> 2) & 3) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& self) -> UEP_AUTO_TOG_R { UEP_AUTO_TOG_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& self) -> UEP_T_TOG_R { UEP_T_TOG_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& self) -> UEP_R_TOG_R { UEP_R_TOG_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& mut self) -> UEP_T_RES_W < U2EP5_CTRL_SPEC > { UEP_T_RES_W :: new (self , 0) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& mut self) -> UEP_R_RES_W < U2EP5_CTRL_SPEC > { UEP_R_RES_W :: new (self , 2) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& mut self) -> UEP_AUTO_TOG_W < U2EP5_CTRL_SPEC > { UEP_AUTO_TOG_W :: new (self , 4) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& mut self) -> UEP_T_TOG_W < U2EP5_CTRL_SPEC > { UEP_T_TOG_W :: new (self , 6) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& mut self) -> UEP_R_TOG_W < U2EP5_CTRL_SPEC > { UEP_R_TOG_W :: new (self , 7) } }
#[doc = "USB2 endpoint 5 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep5_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep5_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP5_CTRL_SPEC ; impl crate :: RegisterSpec for U2EP5_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2ep5_ctrl::R`](R) reader structure"] impl crate :: Readable for U2EP5_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep5_ctrl::W`](W) writer structure"] impl crate :: Writable for U2EP5_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP5_CTRL to value 0"] impl crate :: Resettable for U2EP5_CTRL_SPEC { } }
#[doc = "U2EP6_T_LEN (rw) register accessor: USB2 endpoint 6 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep6_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep6_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep6_t_len`] module"] pub type U2EP6_T_LEN = crate :: Reg < u2ep6_t_len :: U2EP6_T_LEN_SPEC > ;
#[doc = "USB2 endpoint 6 transmittal length"] pub mod u2ep6_t_len {
#[doc = "Register `U2EP6_T_LEN` reader"] pub type R = crate :: R < U2EP6_T_LEN_SPEC > ;
#[doc = "Register `U2EP6_T_LEN` writer"] pub type W = crate :: W < U2EP6_T_LEN_SPEC > ;
#[doc = "Field `UEP6_T_LEN` reader - endpoint 6 transmittal length"] pub type UEP6_T_LEN_R = crate :: FieldReader ;
#[doc = "Field `UEP6_T_LEN` writer - endpoint 6 transmittal length"] pub type UEP6_T_LEN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - endpoint 6 transmittal length"]
#[inline (always)] pub fn uep6_t_len (& self) -> UEP6_T_LEN_R { UEP6_T_LEN_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - endpoint 6 transmittal length"]
#[inline (always)] pub fn uep6_t_len (& mut self) -> UEP6_T_LEN_W < U2EP6_T_LEN_SPEC > { UEP6_T_LEN_W :: new (self , 0) } }
#[doc = "USB2 endpoint 6 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep6_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep6_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP6_T_LEN_SPEC ; impl crate :: RegisterSpec for U2EP6_T_LEN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2ep6_t_len::R`](R) reader structure"] impl crate :: Readable for U2EP6_T_LEN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep6_t_len::W`](W) writer structure"] impl crate :: Writable for U2EP6_T_LEN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP6_T_LEN to value 0"] impl crate :: Resettable for U2EP6_T_LEN_SPEC { } }
#[doc = "U2EP6_CTRL (rw) register accessor: USB2 endpoint 6 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep6_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep6_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep6_ctrl`] module"] pub type U2EP6_CTRL = crate :: Reg < u2ep6_ctrl :: U2EP6_CTRL_SPEC > ;
#[doc = "USB2 endpoint 6 control"] pub mod u2ep6_ctrl {
#[doc = "Register `U2EP6_CTRL` reader"] pub type R = crate :: R < U2EP6_CTRL_SPEC > ;
#[doc = "Register `U2EP6_CTRL` writer"] pub type W = crate :: W < U2EP6_CTRL_SPEC > ;
#[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& self) -> UEP_T_RES_R { UEP_T_RES_R :: new (self . bits & 3) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& self) -> UEP_R_RES_R { UEP_R_RES_R :: new ((self . bits >> 2) & 3) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& self) -> UEP_AUTO_TOG_R { UEP_AUTO_TOG_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& self) -> UEP_T_TOG_R { UEP_T_TOG_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& self) -> UEP_R_TOG_R { UEP_R_TOG_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& mut self) -> UEP_T_RES_W < U2EP6_CTRL_SPEC > { UEP_T_RES_W :: new (self , 0) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& mut self) -> UEP_R_RES_W < U2EP6_CTRL_SPEC > { UEP_R_RES_W :: new (self , 2) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& mut self) -> UEP_AUTO_TOG_W < U2EP6_CTRL_SPEC > { UEP_AUTO_TOG_W :: new (self , 4) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& mut self) -> UEP_T_TOG_W < U2EP6_CTRL_SPEC > { UEP_T_TOG_W :: new (self , 6) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& mut self) -> UEP_R_TOG_W < U2EP6_CTRL_SPEC > { UEP_R_TOG_W :: new (self , 7) } }
#[doc = "USB2 endpoint 6 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep6_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep6_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP6_CTRL_SPEC ; impl crate :: RegisterSpec for U2EP6_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2ep6_ctrl::R`](R) reader structure"] impl crate :: Readable for U2EP6_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep6_ctrl::W`](W) writer structure"] impl crate :: Writable for U2EP6_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP6_CTRL to value 0"] impl crate :: Resettable for U2EP6_CTRL_SPEC { } }
#[doc = "U2EP7_T_LEN (rw) register accessor: USB2 endpoint 7 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep7_t_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep7_t_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep7_t_len`] module"] pub type U2EP7_T_LEN = crate :: Reg < u2ep7_t_len :: U2EP7_T_LEN_SPEC > ;
#[doc = "USB2 endpoint 7 transmittal length"] pub mod u2ep7_t_len {
#[doc = "Register `U2EP7_T_LEN` reader"] pub type R = crate :: R < U2EP7_T_LEN_SPEC > ;
#[doc = "Register `U2EP7_T_LEN` writer"] pub type W = crate :: W < U2EP7_T_LEN_SPEC > ;
#[doc = "Field `UEP7_T_LEN` reader - endpoint 7 transmittal length"] pub type UEP7_T_LEN_R = crate :: FieldReader ;
#[doc = "Field `UEP7_T_LEN` writer - endpoint 7 transmittal length"] pub type UEP7_T_LEN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - endpoint 7 transmittal length"]
#[inline (always)] pub fn uep7_t_len (& self) -> UEP7_T_LEN_R { UEP7_T_LEN_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:7 - endpoint 7 transmittal length"]
#[inline (always)] pub fn uep7_t_len (& mut self) -> UEP7_T_LEN_W < U2EP7_T_LEN_SPEC > { UEP7_T_LEN_W :: new (self , 0) } }
#[doc = "USB2 endpoint 7 transmittal length\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep7_t_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep7_t_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP7_T_LEN_SPEC ; impl crate :: RegisterSpec for U2EP7_T_LEN_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2ep7_t_len::R`](R) reader structure"] impl crate :: Readable for U2EP7_T_LEN_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep7_t_len::W`](W) writer structure"] impl crate :: Writable for U2EP7_T_LEN_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP7_T_LEN to value 0"] impl crate :: Resettable for U2EP7_T_LEN_SPEC { } }
#[doc = "U2EP7_CTRL (rw) register accessor: USB2 endpoint 7 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep7_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep7_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@u2ep7_ctrl`] module"] pub type U2EP7_CTRL = crate :: Reg < u2ep7_ctrl :: U2EP7_CTRL_SPEC > ;
#[doc = "USB2 endpoint 7 control"] pub mod u2ep7_ctrl {
#[doc = "Register `U2EP7_CTRL` reader"] pub type R = crate :: R < U2EP7_CTRL_SPEC > ;
#[doc = "Register `U2EP7_CTRL` writer"] pub type W = crate :: W < U2EP7_CTRL_SPEC > ;
#[doc = "Field `UEP_T_RES` reader - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_T_RES` writer - bit mask of handshake response type for USB endpoint X transmittal (IN)"] pub type UEP_T_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_R_RES` reader - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_R = crate :: FieldReader ;
#[doc = "Field `UEP_R_RES` writer - bit mask of handshake response type for USB endpoint X receiving (OUT)"] pub type UEP_R_RES_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ;
#[doc = "Field `UEP_AUTO_TOG` reader - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_AUTO_TOG` writer - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"] pub type UEP_AUTO_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_T_TOG` reader - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_T_TOG` writer - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"] pub type UEP_T_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `UEP_R_TOG` reader - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_R = crate :: BitReader ;
#[doc = "Field `UEP_R_TOG` writer - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"] pub type UEP_R_TOG_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& self) -> UEP_T_RES_R { UEP_T_RES_R :: new (self . bits & 3) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& self) -> UEP_R_RES_R { UEP_R_RES_R :: new ((self . bits >> 2) & 3) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& self) -> UEP_AUTO_TOG_R { UEP_AUTO_TOG_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& self) -> UEP_T_TOG_R { UEP_T_TOG_R :: new (((self . bits >> 6) & 1) != 0) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& self) -> UEP_R_TOG_R { UEP_R_TOG_R :: new (((self . bits >> 7) & 1) != 0) } } impl W {
#[doc = "Bits 0:1 - bit mask of handshake response type for USB endpoint X transmittal (IN)"]
#[inline (always)] pub fn uep_t_res (& mut self) -> UEP_T_RES_W < U2EP7_CTRL_SPEC > { UEP_T_RES_W :: new (self , 0) }
#[doc = "Bits 2:3 - bit mask of handshake response type for USB endpoint X receiving (OUT)"]
#[inline (always)] pub fn uep_r_res (& mut self) -> UEP_R_RES_W < U2EP7_CTRL_SPEC > { UEP_R_RES_W :: new (self , 2) }
#[doc = "Bit 4 - enable automatic toggle after successful transfer completion on endpoint 1_2_3: 0=manual toggle, 1=automatic toggle"]
#[inline (always)] pub fn uep_auto_tog (& mut self) -> UEP_AUTO_TOG_W < U2EP7_CTRL_SPEC > { UEP_AUTO_TOG_W :: new (self , 4) }
#[doc = "Bit 6 - prepared data toggle flag of USB endpoint X transmittal (IN): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_t_tog (& mut self) -> UEP_T_TOG_W < U2EP7_CTRL_SPEC > { UEP_T_TOG_W :: new (self , 6) }
#[doc = "Bit 7 - expected data toggle flag of USB endpoint X receiving (OUT): 0=DATA0, 1=DATA1"]
#[inline (always)] pub fn uep_r_tog (& mut self) -> UEP_R_TOG_W < U2EP7_CTRL_SPEC > { UEP_R_TOG_W :: new (self , 7) } }
#[doc = "USB2 endpoint 7 control\n\nYou can [`read`](crate::Reg::read) this register and get [`u2ep7_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`u2ep7_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct U2EP7_CTRL_SPEC ; impl crate :: RegisterSpec for U2EP7_CTRL_SPEC { type Ux = u8 ; }
#[doc = "`read()` method returns [`u2ep7_ctrl::R`](R) reader structure"] impl crate :: Readable for U2EP7_CTRL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`u2ep7_ctrl::W`](W) writer structure"] impl crate :: Writable for U2EP7_CTRL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets U2EP7_CTRL to value 0"] impl crate :: Resettable for U2EP7_CTRL_SPEC { } } }
#[doc = "Program Fast Interrupt Controller"] pub type PFIC = crate :: Periph < pfic :: RegisterBlock , 0xe000_e000 > ; impl core :: fmt :: Debug for PFIC { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PFIC") . finish () } }
#[doc = "Program Fast Interrupt Controller"] pub mod pfic {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { isr1 : ISR1 , isr2 : ISR2 , _reserved2 : [u8 ; 0x18] , ipr1 : IPR1 , ipr2 : IPR2 , _reserved4 : [u8 ; 0x18] , ithresdr : ITHRESDR , _reserved5 : [u8 ; 0x04] , cfgr : CFGR , gisr : GISR , idcfgr : IDCFGR , _reserved8 : [u8 ; 0x0c] , fiaddrr0 : FIADDRR0 , fiaddrr1 : FIADDRR1 , fiaddrr2 : FIADDRR2 , fiaddrr3 : FIADDRR3 , _reserved12 : [u8 ; 0x90] , ienr1 : IENR1 , ienr2 : IENR2 , _reserved14 : [u8 ; 0x78] , irer1 : IRER1 , irer2 : IRER2 , _reserved16 : [u8 ; 0x78] , ipsr1 : IPSR1 , ipsr2 : IPSR2 , _reserved18 : [u8 ; 0x78] , iprr1 : IPRR1 , iprr2 : IPRR2 , _reserved20 : [u8 ; 0x78] , iactr1 : IACTR1 , iactr2 : IACTR2 , _reserved22 : [u8 ; 0xf8] , iprior0 : IPRIOR0 , _reserved23 : [u8 ; 0x1c] , iprior1 : IPRIOR1 , _reserved24 : [u8 ; 0x1c] , iprior2 : IPRIOR2 , _reserved25 : [u8 ; 0x1c] , iprior3 : IPRIOR3 , _reserved26 : [u8 ; 0x1c] , iprior4 : IPRIOR4 , _reserved27 : [u8 ; 0x1c] , iprior5 : IPRIOR5 , _reserved28 : [u8 ; 0x1c] , iprior6 : IPRIOR6 , _reserved29 : [u8 ; 0x1c] , iprior7 : IPRIOR7 , _reserved30 : [u8 ; 0x1c] , iprior8 : IPRIOR8 , _reserved31 : [u8 ; 0x1c] , iprior9 : IPRIOR9 , _reserved32 : [u8 ; 0x1c] , iprior10 : IPRIOR10 , _reserved33 : [u8 ; 0x1c] , iprior11 : IPRIOR11 , _reserved34 : [u8 ; 0x1c] , iprior12 : IPRIOR12 , _reserved35 : [u8 ; 0x1c] , iprior13 : IPRIOR13 , _reserved36 : [u8 ; 0x1c] , iprior14 : IPRIOR14 , _reserved37 : [u8 ; 0x1c] , iprior15 : IPRIOR15 , _reserved38 : [u8 ; 0x1c] , iprior16 : IPRIOR16 , _reserved39 : [u8 ; 0x1c] , iprior17 : IPRIOR17 , _reserved40 : [u8 ; 0x1c] , iprior18 : IPRIOR18 , _reserved41 : [u8 ; 0x1c] , iprior19 : IPRIOR19 , _reserved42 : [u8 ; 0x1c] , iprior20 : IPRIOR20 , _reserved43 : [u8 ; 0x1c] , iprior21 : IPRIOR21 , _reserved44 : [u8 ; 0x1c] , iprior22 : IPRIOR22 , _reserved45 : [u8 ; 0x1c] , iprior23 : IPRIOR23 , _reserved46 : [u8 ; 0x1c] , iprior24 : IPRIOR24 , _reserved47 : [u8 ; 0x1c] , iprior25 : IPRIOR25 , _reserved48 : [u8 ; 0x1c] , iprior26 : IPRIOR26 , _reserved49 : [u8 ; 0x1c] , iprior27 : IPRIOR27 , _reserved50 : [u8 ; 0x1c] , iprior28 : IPRIOR28 , _reserved51 : [u8 ; 0x1c] , iprior29 : IPRIOR29 , _reserved52 : [u8 ; 0x1c] , iprior30 : IPRIOR30 , _reserved53 : [u8 ; 0x1c] , iprior31 : IPRIOR31 , _reserved54 : [u8 ; 0x1c] , iprior32 : IPRIOR32 , _reserved55 : [u8 ; 0x1c] , iprior33 : IPRIOR33 , _reserved56 : [u8 ; 0x1c] , iprior34 : IPRIOR34 , _reserved57 : [u8 ; 0x1c] , iprior35 : IPRIOR35 , _reserved58 : [u8 ; 0x1c] , iprior36 : IPRIOR36 , _reserved59 : [u8 ; 0x1c] , iprior37 : IPRIOR37 , _reserved60 : [u8 ; 0x1c] , iprior38 : IPRIOR38 , _reserved61 : [u8 ; 0x1c] , iprior39 : IPRIOR39 , _reserved62 : [u8 ; 0x1c] , iprior40 : IPRIOR40 , _reserved63 : [u8 ; 0x1c] , iprior41 : IPRIOR41 , _reserved64 : [u8 ; 0x1c] , iprior42 : IPRIOR42 , _reserved65 : [u8 ; 0x1c] , iprior43 : IPRIOR43 , _reserved66 : [u8 ; 0x1c] , iprior44 : IPRIOR44 , _reserved67 : [u8 ; 0x1c] , iprior45 : IPRIOR45 , _reserved68 : [u8 ; 0x1c] , iprior46 : IPRIOR46 , _reserved69 : [u8 ; 0x1c] , iprior47 : IPRIOR47 , _reserved70 : [u8 ; 0x1c] , iprior48 : IPRIOR48 , _reserved71 : [u8 ; 0x1c] , iprior49 : IPRIOR49 , _reserved72 : [u8 ; 0x1c] , iprior50 : IPRIOR50 , _reserved73 : [u8 ; 0x1c] , iprior51 : IPRIOR51 , _reserved74 : [u8 ; 0x1c] , iprior52 : IPRIOR52 , _reserved75 : [u8 ; 0x1c] , iprior53 : IPRIOR53 , _reserved76 : [u8 ; 0x2c] , iprior54 : IPRIOR54 , _reserved77 : [u8 ; 0x0c] , iprior55 : IPRIOR55 , _reserved78 : [u8 ; 0x1c] , iprior56 : IPRIOR56 , _reserved79 : [u8 ; 0x1c] , iprior57 : IPRIOR57 , _reserved80 : [u8 ; 0x1c] , iprior58 : IPRIOR58 , _reserved81 : [u8 ; 0x1c] , iprior59 : IPRIOR59 , _reserved82 : [u8 ; 0x1c] , iprior60 : IPRIOR60 , _reserved83 : [u8 ; 0x1c] , iprior61 : IPRIOR61 , _reserved84 : [u8 ; 0x3c] , iprior62 : IPRIOR62 , _reserved85 : [u8 ; 0x1c] , iprior63 : IPRIOR63 , _reserved86 : [u8 ; 0x010c] , sctlr : SCTLR , } impl RegisterBlock {
#[doc = "0x00 - RO,Interrupt Status Register 1"]
#[inline (always)] pub const fn isr1 (& self) -> & ISR1 { & self . isr1 }
#[doc = "0x04 - RO,Interrupt Status Register 2"]
#[inline (always)] pub const fn isr2 (& self) -> & ISR2 { & self . isr2 }
#[doc = "0x20 - RO,Interrupt Pending Register 1"]
#[inline (always)] pub const fn ipr1 (& self) -> & IPR1 { & self . ipr1 }
#[doc = "0x24 - RO,Interrupt Pending Register 2"]
#[inline (always)] pub const fn ipr2 (& self) -> & IPR2 { & self . ipr2 }
#[doc = "0x40 - RW,Interrupt Priority Register"]
#[inline (always)] pub const fn ithresdr (& self) -> & ITHRESDR { & self . ithresdr }
#[doc = "0x48 - Interrupt Config Register"]
#[inline (always)] pub const fn cfgr (& self) -> & CFGR { & self . cfgr }
#[doc = "0x4c - Interrupt Global Register"]
#[inline (always)] pub const fn gisr (& self) -> & GISR { & self . gisr }
#[doc = "0x50 - RW,Interrupt Fast ID Config Register"]
#[inline (always)] pub const fn idcfgr (& self) -> & IDCFGR { & self . idcfgr }
#[doc = "0x60 - Interrupt 0 address Register"]
#[inline (always)] pub const fn fiaddrr0 (& self) -> & FIADDRR0 { & self . fiaddrr0 }
#[doc = "0x64 - Interrupt 1 address Register"]
#[inline (always)] pub const fn fiaddrr1 (& self) -> & FIADDRR1 { & self . fiaddrr1 }
#[doc = "0x68 - Interrupt 2 address Register"]
#[inline (always)] pub const fn fiaddrr2 (& self) -> & FIADDRR2 { & self . fiaddrr2 }
#[doc = "0x6c - Interrupt 3 address Register"]
#[inline (always)] pub const fn fiaddrr3 (& self) -> & FIADDRR3 { & self . fiaddrr3 }
#[doc = "0x100 - Interrupt Setting Register"]
#[inline (always)] pub const fn ienr1 (& self) -> & IENR1 { & self . ienr1 }
#[doc = "0x104 - Interrupt Setting Register"]
#[inline (always)] pub const fn ienr2 (& self) -> & IENR2 { & self . ienr2 }
#[doc = "0x180 - Interrupt Clear Register"]
#[inline (always)] pub const fn irer1 (& self) -> & IRER1 { & self . irer1 }
#[doc = "0x184 - Interrupt Clear Register"]
#[inline (always)] pub const fn irer2 (& self) -> & IRER2 { & self . irer2 }
#[doc = "0x200 - Interrupt Pending Register"]
#[inline (always)] pub const fn ipsr1 (& self) -> & IPSR1 { & self . ipsr1 }
#[doc = "0x204 - Interrupt Pending Register"]
#[inline (always)] pub const fn ipsr2 (& self) -> & IPSR2 { & self . ipsr2 }
#[doc = "0x280 - Interrupt Pending Clear Register"]
#[inline (always)] pub const fn iprr1 (& self) -> & IPRR1 { & self . iprr1 }
#[doc = "0x284 - Interrupt Pending Clear Register"]
#[inline (always)] pub const fn iprr2 (& self) -> & IPRR2 { & self . iprr2 }
#[doc = "0x300 - Interrupt ACTIVE Register"]
#[inline (always)] pub const fn iactr1 (& self) -> & IACTR1 { & self . iactr1 }
#[doc = "0x304 - Interrupt ACTIVE Register"]
#[inline (always)] pub const fn iactr2 (& self) -> & IACTR2 { & self . iactr2 }
#[doc = "0x400 - Interrupt Priority configuration Register 0"]
#[inline (always)] pub const fn iprior0 (& self) -> & IPRIOR0 { & self . iprior0 }
#[doc = "0x420 - Interrupt Priority configuration Register 1"]
#[inline (always)] pub const fn iprior1 (& self) -> & IPRIOR1 { & self . iprior1 }
#[doc = "0x440 - Interrupt Priority configuration Register 2"]
#[inline (always)] pub const fn iprior2 (& self) -> & IPRIOR2 { & self . iprior2 }
#[doc = "0x460 - Interrupt Priority configuration Register 3"]
#[inline (always)] pub const fn iprior3 (& self) -> & IPRIOR3 { & self . iprior3 }
#[doc = "0x480 - Interrupt Priority configuration Register 4"]
#[inline (always)] pub const fn iprior4 (& self) -> & IPRIOR4 { & self . iprior4 }
#[doc = "0x4a0 - Interrupt Priority configuration Register 5"]
#[inline (always)] pub const fn iprior5 (& self) -> & IPRIOR5 { & self . iprior5 }
#[doc = "0x4c0 - Interrupt Priority configuration Register 6"]
#[inline (always)] pub const fn iprior6 (& self) -> & IPRIOR6 { & self . iprior6 }
#[doc = "0x4e0 - Interrupt Priority configuration Register 7"]
#[inline (always)] pub const fn iprior7 (& self) -> & IPRIOR7 { & self . iprior7 }
#[doc = "0x500 - Interrupt Priority configuration Register 8"]
#[inline (always)] pub const fn iprior8 (& self) -> & IPRIOR8 { & self . iprior8 }
#[doc = "0x520 - Interrupt Priority configuration Register 9"]
#[inline (always)] pub const fn iprior9 (& self) -> & IPRIOR9 { & self . iprior9 }
#[doc = "0x540 - Interrupt Priority configuration Register 10"]
#[inline (always)] pub const fn iprior10 (& self) -> & IPRIOR10 { & self . iprior10 }
#[doc = "0x560 - Interrupt Priority configuration Register 11"]
#[inline (always)] pub const fn iprior11 (& self) -> & IPRIOR11 { & self . iprior11 }
#[doc = "0x580 - Interrupt Priority configuration Register 12"]
#[inline (always)] pub const fn iprior12 (& self) -> & IPRIOR12 { & self . iprior12 }
#[doc = "0x5a0 - Interrupt Priority configuration Register 13"]
#[inline (always)] pub const fn iprior13 (& self) -> & IPRIOR13 { & self . iprior13 }
#[doc = "0x5c0 - Interrupt Priority configuration Register 14"]
#[inline (always)] pub const fn iprior14 (& self) -> & IPRIOR14 { & self . iprior14 }
#[doc = "0x5e0 - Interrupt Priority configuration Register 15"]
#[inline (always)] pub const fn iprior15 (& self) -> & IPRIOR15 { & self . iprior15 }
#[doc = "0x600 - Interrupt Priority configuration Register 16"]
#[inline (always)] pub const fn iprior16 (& self) -> & IPRIOR16 { & self . iprior16 }
#[doc = "0x620 - Interrupt Priority configuration Register 17"]
#[inline (always)] pub const fn iprior17 (& self) -> & IPRIOR17 { & self . iprior17 }
#[doc = "0x640 - Interrupt Priority configuration Register 18"]
#[inline (always)] pub const fn iprior18 (& self) -> & IPRIOR18 { & self . iprior18 }
#[doc = "0x660 - Interrupt Priority configuration Register 19"]
#[inline (always)] pub const fn iprior19 (& self) -> & IPRIOR19 { & self . iprior19 }
#[doc = "0x680 - Interrupt Priority configuration Register 20"]
#[inline (always)] pub const fn iprior20 (& self) -> & IPRIOR20 { & self . iprior20 }
#[doc = "0x6a0 - Interrupt Priority configuration Register 21"]
#[inline (always)] pub const fn iprior21 (& self) -> & IPRIOR21 { & self . iprior21 }
#[doc = "0x6c0 - Interrupt Priority configuration Register 22"]
#[inline (always)] pub const fn iprior22 (& self) -> & IPRIOR22 { & self . iprior22 }
#[doc = "0x6e0 - Interrupt Priority configuration Register 23"]
#[inline (always)] pub const fn iprior23 (& self) -> & IPRIOR23 { & self . iprior23 }
#[doc = "0x700 - Interrupt Priority configuration Register 24"]
#[inline (always)] pub const fn iprior24 (& self) -> & IPRIOR24 { & self . iprior24 }
#[doc = "0x720 - Interrupt Priority configuration Register 25"]
#[inline (always)] pub const fn iprior25 (& self) -> & IPRIOR25 { & self . iprior25 }
#[doc = "0x740 - Interrupt Priority configuration Register 26"]
#[inline (always)] pub const fn iprior26 (& self) -> & IPRIOR26 { & self . iprior26 }
#[doc = "0x760 - Interrupt Priority configuration Register 27"]
#[inline (always)] pub const fn iprior27 (& self) -> & IPRIOR27 { & self . iprior27 }
#[doc = "0x780 - Interrupt Priority configuration Register 28"]
#[inline (always)] pub const fn iprior28 (& self) -> & IPRIOR28 { & self . iprior28 }
#[doc = "0x7a0 - Interrupt Priority configuration Register 29"]
#[inline (always)] pub const fn iprior29 (& self) -> & IPRIOR29 { & self . iprior29 }
#[doc = "0x7c0 - Interrupt Priority configuration Register 30"]
#[inline (always)] pub const fn iprior30 (& self) -> & IPRIOR30 { & self . iprior30 }
#[doc = "0x7e0 - Interrupt Priority configuration Register 31"]
#[inline (always)] pub const fn iprior31 (& self) -> & IPRIOR31 { & self . iprior31 }
#[doc = "0x800 - Interrupt Priority configuration Register 32"]
#[inline (always)] pub const fn iprior32 (& self) -> & IPRIOR32 { & self . iprior32 }
#[doc = "0x820 - Interrupt Priority configuration Register 33"]
#[inline (always)] pub const fn iprior33 (& self) -> & IPRIOR33 { & self . iprior33 }
#[doc = "0x840 - Interrupt Priority configuration Register 34"]
#[inline (always)] pub const fn iprior34 (& self) -> & IPRIOR34 { & self . iprior34 }
#[doc = "0x860 - Interrupt Priority configuration Register 35"]
#[inline (always)] pub const fn iprior35 (& self) -> & IPRIOR35 { & self . iprior35 }
#[doc = "0x880 - Interrupt Priority configuration Register 36"]
#[inline (always)] pub const fn iprior36 (& self) -> & IPRIOR36 { & self . iprior36 }
#[doc = "0x8a0 - Interrupt Priority configuration Register 37"]
#[inline (always)] pub const fn iprior37 (& self) -> & IPRIOR37 { & self . iprior37 }
#[doc = "0x8c0 - Interrupt Priority configuration Register 38"]
#[inline (always)] pub const fn iprior38 (& self) -> & IPRIOR38 { & self . iprior38 }
#[doc = "0x8e0 - Interrupt Priority configuration Register 39"]
#[inline (always)] pub const fn iprior39 (& self) -> & IPRIOR39 { & self . iprior39 }
#[doc = "0x900 - Interrupt Priority configuration Register 40"]
#[inline (always)] pub const fn iprior40 (& self) -> & IPRIOR40 { & self . iprior40 }
#[doc = "0x920 - Interrupt Priority configuration Register 41"]
#[inline (always)] pub const fn iprior41 (& self) -> & IPRIOR41 { & self . iprior41 }
#[doc = "0x940 - Interrupt Priority configuration Register 42"]
#[inline (always)] pub const fn iprior42 (& self) -> & IPRIOR42 { & self . iprior42 }
#[doc = "0x960 - Interrupt Priority configuration Register 43"]
#[inline (always)] pub const fn iprior43 (& self) -> & IPRIOR43 { & self . iprior43 }
#[doc = "0x980 - Interrupt Priority configuration Register 44"]
#[inline (always)] pub const fn iprior44 (& self) -> & IPRIOR44 { & self . iprior44 }
#[doc = "0x9a0 - Interrupt Priority configuration Register 45"]
#[inline (always)] pub const fn iprior45 (& self) -> & IPRIOR45 { & self . iprior45 }
#[doc = "0x9c0 - Interrupt Priority configuration Register 46"]
#[inline (always)] pub const fn iprior46 (& self) -> & IPRIOR46 { & self . iprior46 }
#[doc = "0x9e0 - Interrupt Priority configuration Register 47"]
#[inline (always)] pub const fn iprior47 (& self) -> & IPRIOR47 { & self . iprior47 }
#[doc = "0xa00 - Interrupt Priority configuration Register 48"]
#[inline (always)] pub const fn iprior48 (& self) -> & IPRIOR48 { & self . iprior48 }
#[doc = "0xa20 - Interrupt Priority configuration Register 49"]
#[inline (always)] pub const fn iprior49 (& self) -> & IPRIOR49 { & self . iprior49 }
#[doc = "0xa40 - Interrupt Priority configuration Register 50"]
#[inline (always)] pub const fn iprior50 (& self) -> & IPRIOR50 { & self . iprior50 }
#[doc = "0xa60 - Interrupt Priority configuration Register 51"]
#[inline (always)] pub const fn iprior51 (& self) -> & IPRIOR51 { & self . iprior51 }
#[doc = "0xa80 - Interrupt Priority configuration Register 52"]
#[inline (always)] pub const fn iprior52 (& self) -> & IPRIOR52 { & self . iprior52 }
#[doc = "0xaa0 - Interrupt Priority configuration Register 53"]
#[inline (always)] pub const fn iprior53 (& self) -> & IPRIOR53 { & self . iprior53 }
#[doc = "0xad0 - Interrupt Priority configuration Register 54"]
#[inline (always)] pub const fn iprior54 (& self) -> & IPRIOR54 { & self . iprior54 }
#[doc = "0xae0 - Interrupt Priority configuration Register 55"]
#[inline (always)] pub const fn iprior55 (& self) -> & IPRIOR55 { & self . iprior55 }
#[doc = "0xb00 - Interrupt Priority configuration Register 56"]
#[inline (always)] pub const fn iprior56 (& self) -> & IPRIOR56 { & self . iprior56 }
#[doc = "0xb20 - Interrupt Priority configuration Register 57"]
#[inline (always)] pub const fn iprior57 (& self) -> & IPRIOR57 { & self . iprior57 }
#[doc = "0xb40 - Interrupt Priority configuration Register 58"]
#[inline (always)] pub const fn iprior58 (& self) -> & IPRIOR58 { & self . iprior58 }
#[doc = "0xb60 - Interrupt Priority configuration Register 59"]
#[inline (always)] pub const fn iprior59 (& self) -> & IPRIOR59 { & self . iprior59 }
#[doc = "0xb80 - Interrupt Priority configuration Register 60"]
#[inline (always)] pub const fn iprior60 (& self) -> & IPRIOR60 { & self . iprior60 }
#[doc = "0xba0 - Interrupt Priority configuration Register 61"]
#[inline (always)] pub const fn iprior61 (& self) -> & IPRIOR61 { & self . iprior61 }
#[doc = "0xbe0 - Interrupt Priority configuration Register 62"]
#[inline (always)] pub const fn iprior62 (& self) -> & IPRIOR62 { & self . iprior62 }
#[doc = "0xc00 - Interrupt Priority configuration Register 63"]
#[inline (always)] pub const fn iprior63 (& self) -> & IPRIOR63 { & self . iprior63 }
#[doc = "0xd10 - System Control Register"]
#[inline (always)] pub const fn sctlr (& self) -> & SCTLR { & self . sctlr } }
#[doc = "ISR1 (r) register accessor: RO,Interrupt Status Register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`isr1::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@isr1`] module"] pub type ISR1 = crate :: Reg < isr1 :: ISR1_SPEC > ;
#[doc = "RO,Interrupt Status Register 1"] pub mod isr1 {
#[doc = "Register `ISR1` reader"] pub type R = crate :: R < ISR1_SPEC > ;
#[doc = "Field `INTENSTA` reader - Interrupt ID Status"] pub type INTENSTA_R = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 12:31 - Interrupt ID Status"]
#[inline (always)] pub fn intensta (& self) -> INTENSTA_R { INTENSTA_R :: new ((self . bits >> 12) & 0x000f_ffff) } }
#[doc = "RO,Interrupt Status Register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`isr1::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ISR1_SPEC ; impl crate :: RegisterSpec for ISR1_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`isr1::R`](R) reader structure"] impl crate :: Readable for ISR1_SPEC { }
#[doc = "`reset()` method sets ISR1 to value 0"] impl crate :: Resettable for ISR1_SPEC { } }
#[doc = "ISR2 (r) register accessor: RO,Interrupt Status Register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`isr2::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@isr2`] module"] pub type ISR2 = crate :: Reg < isr2 :: ISR2_SPEC > ;
#[doc = "RO,Interrupt Status Register 2"] pub mod isr2 {
#[doc = "Register `ISR2` reader"] pub type R = crate :: R < ISR2_SPEC > ;
#[doc = "Field `INTENSTA` reader - Interrupt ID Status"] pub type INTENSTA_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:3 - Interrupt ID Status"]
#[inline (always)] pub fn intensta (& self) -> INTENSTA_R { INTENSTA_R :: new ((self . bits & 0x0f) as u8) } }
#[doc = "RO,Interrupt Status Register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`isr2::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ISR2_SPEC ; impl crate :: RegisterSpec for ISR2_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`isr2::R`](R) reader structure"] impl crate :: Readable for ISR2_SPEC { }
#[doc = "`reset()` method sets ISR2 to value 0"] impl crate :: Resettable for ISR2_SPEC { } }
#[doc = "IPR1 (r) register accessor: RO,Interrupt Pending Register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ipr1::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ipr1`] module"] pub type IPR1 = crate :: Reg < ipr1 :: IPR1_SPEC > ;
#[doc = "RO,Interrupt Pending Register 1"] pub mod ipr1 {
#[doc = "Register `IPR1` reader"] pub type R = crate :: R < IPR1_SPEC > ;
#[doc = "Field `PENDSTA` reader - PENDSTA"] pub type PENDSTA_R = crate :: FieldReader < u32 > ; impl R {
#[doc = "Bits 12:31 - PENDSTA"]
#[inline (always)] pub fn pendsta (& self) -> PENDSTA_R { PENDSTA_R :: new ((self . bits >> 12) & 0x000f_ffff) } }
#[doc = "RO,Interrupt Pending Register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ipr1::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPR1_SPEC ; impl crate :: RegisterSpec for IPR1_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`ipr1::R`](R) reader structure"] impl crate :: Readable for IPR1_SPEC { }
#[doc = "`reset()` method sets IPR1 to value 0"] impl crate :: Resettable for IPR1_SPEC { } }
#[doc = "IPR2 (r) register accessor: RO,Interrupt Pending Register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ipr2::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ipr2`] module"] pub type IPR2 = crate :: Reg < ipr2 :: IPR2_SPEC > ;
#[doc = "RO,Interrupt Pending Register 2"] pub mod ipr2 {
#[doc = "Register `IPR2` reader"] pub type R = crate :: R < IPR2_SPEC > ;
#[doc = "Field `PENDSTA` reader - PENDSTA"] pub type PENDSTA_R = crate :: FieldReader ; impl R {
#[doc = "Bits 0:3 - PENDSTA"]
#[inline (always)] pub fn pendsta (& self) -> PENDSTA_R { PENDSTA_R :: new ((self . bits & 0x0f) as u8) } }
#[doc = "RO,Interrupt Pending Register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ipr2::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPR2_SPEC ; impl crate :: RegisterSpec for IPR2_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`ipr2::R`](R) reader structure"] impl crate :: Readable for IPR2_SPEC { }
#[doc = "`reset()` method sets IPR2 to value 0"] impl crate :: Resettable for IPR2_SPEC { } }
#[doc = "ITHRESDR (rw) register accessor: RW,Interrupt Priority Register\n\nYou can [`read`](crate::Reg::read) this register and get [`ithresdr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ithresdr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ithresdr`] module"] pub type ITHRESDR = crate :: Reg < ithresdr :: ITHRESDR_SPEC > ;
#[doc = "RW,Interrupt Priority Register"] pub mod ithresdr {
#[doc = "Register `ITHRESDR` reader"] pub type R = crate :: R < ITHRESDR_SPEC > ;
#[doc = "Register `ITHRESDR` writer"] pub type W = crate :: W < ITHRESDR_SPEC > ;
#[doc = "Field `THRESHOLD` reader - RW,THRESHOLD"] pub type THRESHOLD_R = crate :: FieldReader ;
#[doc = "Field `THRESHOLD` writer - RW,THRESHOLD"] pub type THRESHOLD_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW,THRESHOLD"]
#[inline (always)] pub fn threshold (& self) -> THRESHOLD_R { THRESHOLD_R :: new ((self . bits & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - RW,THRESHOLD"]
#[inline (always)] pub fn threshold (& mut self) -> THRESHOLD_W < ITHRESDR_SPEC > { THRESHOLD_W :: new (self , 0) } }
#[doc = "RW,Interrupt Priority Register\n\nYou can [`read`](crate::Reg::read) this register and get [`ithresdr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ithresdr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ITHRESDR_SPEC ; impl crate :: RegisterSpec for ITHRESDR_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`ithresdr::R`](R) reader structure"] impl crate :: Readable for ITHRESDR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`ithresdr::W`](W) writer structure"] impl crate :: Writable for ITHRESDR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets ITHRESDR to value 0"] impl crate :: Resettable for ITHRESDR_SPEC { } }
#[doc = "CFGR (w) register accessor: Interrupt Config Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfgr`] module"] pub type CFGR = crate :: Reg < cfgr :: CFGR_SPEC > ;
#[doc = "Interrupt Config Register"] pub mod cfgr {
#[doc = "Register `CFGR` writer"] pub type W = crate :: W < CFGR_SPEC > ;
#[doc = "Field `RESETSYS` writer - WO,RESETSYS"] pub type RESETSYS_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `KEYCODE` writer - WO,KEYCODE"] pub type KEYCODE_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl W {
#[doc = "Bit 7 - WO,RESETSYS"]
#[inline (always)] pub fn resetsys (& mut self) -> RESETSYS_W < CFGR_SPEC > { RESETSYS_W :: new (self , 7) }
#[doc = "Bits 16:31 - WO,KEYCODE"]
#[inline (always)] pub fn keycode (& mut self) -> KEYCODE_W < CFGR_SPEC > { KEYCODE_W :: new (self , 16) } }
#[doc = "Interrupt Config Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CFGR_SPEC ; impl crate :: RegisterSpec for CFGR_SPEC { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`cfgr::W`](W) writer structure"] impl crate :: Writable for CFGR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CFGR to value 0"] impl crate :: Resettable for CFGR_SPEC { } }
#[doc = "GISR (r) register accessor: Interrupt Global Register\n\nYou can [`read`](crate::Reg::read) this register and get [`gisr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@gisr`] module"] pub type GISR = crate :: Reg < gisr :: GISR_SPEC > ;
#[doc = "Interrupt Global Register"] pub mod gisr {
#[doc = "Register `GISR` reader"] pub type R = crate :: R < GISR_SPEC > ;
#[doc = "Field `NESTSTA` reader - RO,NESTSTA"] pub type NESTSTA_R = crate :: FieldReader ;
#[doc = "Field `GACTSTA` reader - RO,GACTSTA"] pub type GACTSTA_R = crate :: BitReader ;
#[doc = "Field `GPENDSTA` reader - RO,GPENDSTA"] pub type GPENDSTA_R = crate :: BitReader ; impl R {
#[doc = "Bits 0:7 - RO,NESTSTA"]
#[inline (always)] pub fn neststa (& self) -> NESTSTA_R { NESTSTA_R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bit 8 - RO,GACTSTA"]
#[inline (always)] pub fn gactsta (& self) -> GACTSTA_R { GACTSTA_R :: new (((self . bits >> 8) & 1) != 0) }
#[doc = "Bit 9 - RO,GPENDSTA"]
#[inline (always)] pub fn gpendsta (& self) -> GPENDSTA_R { GPENDSTA_R :: new (((self . bits >> 9) & 1) != 0) } }
#[doc = "Interrupt Global Register\n\nYou can [`read`](crate::Reg::read) this register and get [`gisr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct GISR_SPEC ; impl crate :: RegisterSpec for GISR_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`gisr::R`](R) reader structure"] impl crate :: Readable for GISR_SPEC { }
#[doc = "`reset()` method sets GISR to value 0"] impl crate :: Resettable for GISR_SPEC { } }
#[doc = "IDCFGR (rw) register accessor: RW,Interrupt Fast ID Config Register\n\nYou can [`read`](crate::Reg::read) this register and get [`idcfgr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`idcfgr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@idcfgr`] module"] pub type IDCFGR = crate :: Reg < idcfgr :: IDCFGR_SPEC > ;
#[doc = "RW,Interrupt Fast ID Config Register"] pub mod idcfgr {
#[doc = "Register `IDCFGR` reader"] pub type R = crate :: R < IDCFGR_SPEC > ;
#[doc = "Register `IDCFGR` writer"] pub type W = crate :: W < IDCFGR_SPEC > ;
#[doc = "Field `FIID0` reader - RW,FIID0"] pub type FIID0_R = crate :: FieldReader ;
#[doc = "Field `FIID0` writer - RW,FIID0"] pub type FIID0_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `FIID1` reader - RW,FIID1"] pub type FIID1_R = crate :: FieldReader ;
#[doc = "Field `FIID1` writer - RW,FIID1"] pub type FIID1_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `FIID2` reader - RW,FIID2"] pub type FIID2_R = crate :: FieldReader ;
#[doc = "Field `FIID2` writer - RW,FIID2"] pub type FIID2_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ;
#[doc = "Field `FIID3` reader - RW,FIID3"] pub type FIID3_R = crate :: FieldReader ;
#[doc = "Field `FIID3` writer - RW,FIID3"] pub type FIID3_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R {
#[doc = "Bits 0:7 - RW,FIID0"]
#[inline (always)] pub fn fiid0 (& self) -> FIID0_R { FIID0_R :: new ((self . bits & 0xff) as u8) }
#[doc = "Bits 8:15 - RW,FIID1"]
#[inline (always)] pub fn fiid1 (& self) -> FIID1_R { FIID1_R :: new (((self . bits >> 8) & 0xff) as u8) }
#[doc = "Bits 16:23 - RW,FIID2"]
#[inline (always)] pub fn fiid2 (& self) -> FIID2_R { FIID2_R :: new (((self . bits >> 16) & 0xff) as u8) }
#[doc = "Bits 24:31 - RW,FIID3"]
#[inline (always)] pub fn fiid3 (& self) -> FIID3_R { FIID3_R :: new (((self . bits >> 24) & 0xff) as u8) } } impl W {
#[doc = "Bits 0:7 - RW,FIID0"]
#[inline (always)] pub fn fiid0 (& mut self) -> FIID0_W < IDCFGR_SPEC > { FIID0_W :: new (self , 0) }
#[doc = "Bits 8:15 - RW,FIID1"]
#[inline (always)] pub fn fiid1 (& mut self) -> FIID1_W < IDCFGR_SPEC > { FIID1_W :: new (self , 8) }
#[doc = "Bits 16:23 - RW,FIID2"]
#[inline (always)] pub fn fiid2 (& mut self) -> FIID2_W < IDCFGR_SPEC > { FIID2_W :: new (self , 16) }
#[doc = "Bits 24:31 - RW,FIID3"]
#[inline (always)] pub fn fiid3 (& mut self) -> FIID3_W < IDCFGR_SPEC > { FIID3_W :: new (self , 24) } }
#[doc = "RW,Interrupt Fast ID Config Register\n\nYou can [`read`](crate::Reg::read) this register and get [`idcfgr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`idcfgr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IDCFGR_SPEC ; impl crate :: RegisterSpec for IDCFGR_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`idcfgr::R`](R) reader structure"] impl crate :: Readable for IDCFGR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`idcfgr::W`](W) writer structure"] impl crate :: Writable for IDCFGR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IDCFGR to value 0"] impl crate :: Resettable for IDCFGR_SPEC { } }
#[doc = "FIADDRR0 (rw) register accessor: Interrupt 0 address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fiaddrr0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fiaddrr0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fiaddrr0`] module"] pub type FIADDRR0 = crate :: Reg < fiaddrr0 :: FIADDRR0_SPEC > ;
#[doc = "Interrupt 0 address Register"] pub mod fiaddrr0 {
#[doc = "Register `FIADDRR0` reader"] pub type R = crate :: R < FIADDRR0_SPEC > ;
#[doc = "Register `FIADDRR0` writer"] pub type W = crate :: W < FIADDRR0_SPEC > ;
#[doc = "Field `FI0EN` reader - RW,FI0EN"] pub type FI0EN_R = crate :: BitReader ;
#[doc = "Field `FI0EN` writer - RW,FI0EN"] pub type FI0EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADDR0` reader - RW,ADDR0"] pub type ADDR0_R = crate :: FieldReader < u32 > ;
#[doc = "Field `ADDR0` writer - RW,ADDR0"] pub type ADDR0_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 31 , u32 > ; impl R {
#[doc = "Bit 0 - RW,FI0EN"]
#[inline (always)] pub fn fi0en (& self) -> FI0EN_R { FI0EN_R :: new ((self . bits & 1) != 0) }
#[doc = "Bits 1:31 - RW,ADDR0"]
#[inline (always)] pub fn addr0 (& self) -> ADDR0_R { ADDR0_R :: new ((self . bits >> 1) & 0x7fff_ffff) } } impl W {
#[doc = "Bit 0 - RW,FI0EN"]
#[inline (always)] pub fn fi0en (& mut self) -> FI0EN_W < FIADDRR0_SPEC > { FI0EN_W :: new (self , 0) }
#[doc = "Bits 1:31 - RW,ADDR0"]
#[inline (always)] pub fn addr0 (& mut self) -> ADDR0_W < FIADDRR0_SPEC > { ADDR0_W :: new (self , 1) } }
#[doc = "Interrupt 0 address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fiaddrr0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fiaddrr0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FIADDRR0_SPEC ; impl crate :: RegisterSpec for FIADDRR0_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`fiaddrr0::R`](R) reader structure"] impl crate :: Readable for FIADDRR0_SPEC { }
#[doc = "`write(|w| ..)` method takes [`fiaddrr0::W`](W) writer structure"] impl crate :: Writable for FIADDRR0_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FIADDRR0 to value 0"] impl crate :: Resettable for FIADDRR0_SPEC { } }
#[doc = "FIADDRR1 (rw) register accessor: Interrupt 1 address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fiaddrr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fiaddrr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fiaddrr1`] module"] pub type FIADDRR1 = crate :: Reg < fiaddrr1 :: FIADDRR1_SPEC > ;
#[doc = "Interrupt 1 address Register"] pub mod fiaddrr1 {
#[doc = "Register `FIADDRR1` reader"] pub type R = crate :: R < FIADDRR1_SPEC > ;
#[doc = "Register `FIADDRR1` writer"] pub type W = crate :: W < FIADDRR1_SPEC > ;
#[doc = "Field `FI1EN` reader - RW,FI1EN"] pub type FI1EN_R = crate :: BitReader ;
#[doc = "Field `FI1EN` writer - RW,FI1EN"] pub type FI1EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADDR1` reader - RW,ADDR1"] pub type ADDR1_R = crate :: FieldReader < u32 > ;
#[doc = "Field `ADDR1` writer - RW,ADDR1"] pub type ADDR1_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 31 , u32 > ; impl R {
#[doc = "Bit 0 - RW,FI1EN"]
#[inline (always)] pub fn fi1en (& self) -> FI1EN_R { FI1EN_R :: new ((self . bits & 1) != 0) }
#[doc = "Bits 1:31 - RW,ADDR1"]
#[inline (always)] pub fn addr1 (& self) -> ADDR1_R { ADDR1_R :: new ((self . bits >> 1) & 0x7fff_ffff) } } impl W {
#[doc = "Bit 0 - RW,FI1EN"]
#[inline (always)] pub fn fi1en (& mut self) -> FI1EN_W < FIADDRR1_SPEC > { FI1EN_W :: new (self , 0) }
#[doc = "Bits 1:31 - RW,ADDR1"]
#[inline (always)] pub fn addr1 (& mut self) -> ADDR1_W < FIADDRR1_SPEC > { ADDR1_W :: new (self , 1) } }
#[doc = "Interrupt 1 address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fiaddrr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fiaddrr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FIADDRR1_SPEC ; impl crate :: RegisterSpec for FIADDRR1_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`fiaddrr1::R`](R) reader structure"] impl crate :: Readable for FIADDRR1_SPEC { }
#[doc = "`write(|w| ..)` method takes [`fiaddrr1::W`](W) writer structure"] impl crate :: Writable for FIADDRR1_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FIADDRR1 to value 0"] impl crate :: Resettable for FIADDRR1_SPEC { } }
#[doc = "FIADDRR2 (rw) register accessor: Interrupt 2 address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fiaddrr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fiaddrr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fiaddrr2`] module"] pub type FIADDRR2 = crate :: Reg < fiaddrr2 :: FIADDRR2_SPEC > ;
#[doc = "Interrupt 2 address Register"] pub mod fiaddrr2 {
#[doc = "Register `FIADDRR2` reader"] pub type R = crate :: R < FIADDRR2_SPEC > ;
#[doc = "Register `FIADDRR2` writer"] pub type W = crate :: W < FIADDRR2_SPEC > ;
#[doc = "Field `FI2EN` reader - RW,FI2EN"] pub type FI2EN_R = crate :: BitReader ;
#[doc = "Field `FI2EN` writer - RW,FI2EN"] pub type FI2EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADDR2` reader - RW,ADDR2"] pub type ADDR2_R = crate :: FieldReader < u32 > ;
#[doc = "Field `ADDR2` writer - RW,ADDR2"] pub type ADDR2_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 31 , u32 > ; impl R {
#[doc = "Bit 0 - RW,FI2EN"]
#[inline (always)] pub fn fi2en (& self) -> FI2EN_R { FI2EN_R :: new ((self . bits & 1) != 0) }
#[doc = "Bits 1:31 - RW,ADDR2"]
#[inline (always)] pub fn addr2 (& self) -> ADDR2_R { ADDR2_R :: new ((self . bits >> 1) & 0x7fff_ffff) } } impl W {
#[doc = "Bit 0 - RW,FI2EN"]
#[inline (always)] pub fn fi2en (& mut self) -> FI2EN_W < FIADDRR2_SPEC > { FI2EN_W :: new (self , 0) }
#[doc = "Bits 1:31 - RW,ADDR2"]
#[inline (always)] pub fn addr2 (& mut self) -> ADDR2_W < FIADDRR2_SPEC > { ADDR2_W :: new (self , 1) } }
#[doc = "Interrupt 2 address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fiaddrr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fiaddrr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FIADDRR2_SPEC ; impl crate :: RegisterSpec for FIADDRR2_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`fiaddrr2::R`](R) reader structure"] impl crate :: Readable for FIADDRR2_SPEC { }
#[doc = "`write(|w| ..)` method takes [`fiaddrr2::W`](W) writer structure"] impl crate :: Writable for FIADDRR2_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FIADDRR2 to value 0"] impl crate :: Resettable for FIADDRR2_SPEC { } }
#[doc = "FIADDRR3 (rw) register accessor: Interrupt 3 address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fiaddrr3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fiaddrr3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@fiaddrr3`] module"] pub type FIADDRR3 = crate :: Reg < fiaddrr3 :: FIADDRR3_SPEC > ;
#[doc = "Interrupt 3 address Register"] pub mod fiaddrr3 {
#[doc = "Register `FIADDRR3` reader"] pub type R = crate :: R < FIADDRR3_SPEC > ;
#[doc = "Register `FIADDRR3` writer"] pub type W = crate :: W < FIADDRR3_SPEC > ;
#[doc = "Field `FI3EN` reader - RW,FI3EN"] pub type FI3EN_R = crate :: BitReader ;
#[doc = "Field `FI3EN` writer - RW,FI3EN"] pub type FI3EN_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `ADDR3` reader - RW,ADDR3"] pub type ADDR3_R = crate :: FieldReader < u32 > ;
#[doc = "Field `ADDR3` writer - RW,ADDR3"] pub type ADDR3_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 31 , u32 > ; impl R {
#[doc = "Bit 0 - RW,FI3EN"]
#[inline (always)] pub fn fi3en (& self) -> FI3EN_R { FI3EN_R :: new ((self . bits & 1) != 0) }
#[doc = "Bits 1:31 - RW,ADDR3"]
#[inline (always)] pub fn addr3 (& self) -> ADDR3_R { ADDR3_R :: new ((self . bits >> 1) & 0x7fff_ffff) } } impl W {
#[doc = "Bit 0 - RW,FI3EN"]
#[inline (always)] pub fn fi3en (& mut self) -> FI3EN_W < FIADDRR3_SPEC > { FI3EN_W :: new (self , 0) }
#[doc = "Bits 1:31 - RW,ADDR3"]
#[inline (always)] pub fn addr3 (& mut self) -> ADDR3_W < FIADDRR3_SPEC > { ADDR3_W :: new (self , 1) } }
#[doc = "Interrupt 3 address Register\n\nYou can [`read`](crate::Reg::read) this register and get [`fiaddrr3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`fiaddrr3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct FIADDRR3_SPEC ; impl crate :: RegisterSpec for FIADDRR3_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`fiaddrr3::R`](R) reader structure"] impl crate :: Readable for FIADDRR3_SPEC { }
#[doc = "`write(|w| ..)` method takes [`fiaddrr3::W`](W) writer structure"] impl crate :: Writable for FIADDRR3_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets FIADDRR3 to value 0"] impl crate :: Resettable for FIADDRR3_SPEC { } }
#[doc = "IENR1 (w) register accessor: Interrupt Setting Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ienr1::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ienr1`] module"] pub type IENR1 = crate :: Reg < ienr1 :: IENR1_SPEC > ;
#[doc = "Interrupt Setting Register"] pub mod ienr1 {
#[doc = "Register `IENR1` writer"] pub type W = crate :: W < IENR1_SPEC > ;
#[doc = "Field `INTEN` writer - RW1,INTEN"] pub type INTEN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 20 , u32 > ; impl W {
#[doc = "Bits 12:31 - RW1,INTEN"]
#[inline (always)] pub fn inten (& mut self) -> INTEN_W < IENR1_SPEC > { INTEN_W :: new (self , 12) } }
#[doc = "Interrupt Setting Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ienr1::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IENR1_SPEC ; impl crate :: RegisterSpec for IENR1_SPEC { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`ienr1::W`](W) writer structure"] impl crate :: Writable for IENR1_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IENR1 to value 0"] impl crate :: Resettable for IENR1_SPEC { } }
#[doc = "IENR2 (w) register accessor: Interrupt Setting Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ienr2::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ienr2`] module"] pub type IENR2 = crate :: Reg < ienr2 :: IENR2_SPEC > ;
#[doc = "Interrupt Setting Register"] pub mod ienr2 {
#[doc = "Register `IENR2` writer"] pub type W = crate :: W < IENR2_SPEC > ;
#[doc = "Field `INTEN` writer - RW1,INTEN"] pub type INTEN_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl W {
#[doc = "Bits 0:3 - RW1,INTEN"]
#[inline (always)] pub fn inten (& mut self) -> INTEN_W < IENR2_SPEC > { INTEN_W :: new (self , 0) } }
#[doc = "Interrupt Setting Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ienr2::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IENR2_SPEC ; impl crate :: RegisterSpec for IENR2_SPEC { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`ienr2::W`](W) writer structure"] impl crate :: Writable for IENR2_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IENR2 to value 0"] impl crate :: Resettable for IENR2_SPEC { } }
#[doc = "IRER1 (w) register accessor: Interrupt Clear Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`irer1::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@irer1`] module"] pub type IRER1 = crate :: Reg < irer1 :: IRER1_SPEC > ;
#[doc = "Interrupt Clear Register"] pub mod irer1 {
#[doc = "Register `IRER1` writer"] pub type W = crate :: W < IRER1_SPEC > ;
#[doc = "Field `INTRESET` writer - RW1,INTRESET"] pub type INTRESET_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 20 , u32 > ; impl W {
#[doc = "Bits 12:31 - RW1,INTRESET"]
#[inline (always)] pub fn intreset (& mut self) -> INTRESET_W < IRER1_SPEC > { INTRESET_W :: new (self , 12) } }
#[doc = "Interrupt Clear Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`irer1::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IRER1_SPEC ; impl crate :: RegisterSpec for IRER1_SPEC { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`irer1::W`](W) writer structure"] impl crate :: Writable for IRER1_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IRER1 to value 0"] impl crate :: Resettable for IRER1_SPEC { } }
#[doc = "IRER2 (w) register accessor: Interrupt Clear Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`irer2::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@irer2`] module"] pub type IRER2 = crate :: Reg < irer2 :: IRER2_SPEC > ;
#[doc = "Interrupt Clear Register"] pub mod irer2 {
#[doc = "Register `IRER2` writer"] pub type W = crate :: W < IRER2_SPEC > ;
#[doc = "Field `INTRESET` writer - RW1,INTRESET"] pub type INTRESET_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl W {
#[doc = "Bits 0:3 - RW1,INTRESET"]
#[inline (always)] pub fn intreset (& mut self) -> INTRESET_W < IRER2_SPEC > { INTRESET_W :: new (self , 0) } }
#[doc = "Interrupt Clear Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`irer2::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IRER2_SPEC ; impl crate :: RegisterSpec for IRER2_SPEC { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`irer2::W`](W) writer structure"] impl crate :: Writable for IRER2_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IRER2 to value 0"] impl crate :: Resettable for IRER2_SPEC { } }
#[doc = "IPSR1 (w) register accessor: Interrupt Pending Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ipsr1::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ipsr1`] module"] pub type IPSR1 = crate :: Reg < ipsr1 :: IPSR1_SPEC > ;
#[doc = "Interrupt Pending Register"] pub mod ipsr1 {
#[doc = "Register `IPSR1` writer"] pub type W = crate :: W < IPSR1_SPEC > ;
#[doc = "Field `PENDSET` writer - RW1,PENDSET"] pub type PENDSET_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 20 , u32 > ; impl W {
#[doc = "Bits 12:31 - RW1,PENDSET"]
#[inline (always)] pub fn pendset (& mut self) -> PENDSET_W < IPSR1_SPEC > { PENDSET_W :: new (self , 12) } }
#[doc = "Interrupt Pending Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ipsr1::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPSR1_SPEC ; impl crate :: RegisterSpec for IPSR1_SPEC { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`ipsr1::W`](W) writer structure"] impl crate :: Writable for IPSR1_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPSR1 to value 0"] impl crate :: Resettable for IPSR1_SPEC { } }
#[doc = "IPSR2 (w) register accessor: Interrupt Pending Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ipsr2::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ipsr2`] module"] pub type IPSR2 = crate :: Reg < ipsr2 :: IPSR2_SPEC > ;
#[doc = "Interrupt Pending Register"] pub mod ipsr2 {
#[doc = "Register `IPSR2` writer"] pub type W = crate :: W < IPSR2_SPEC > ;
#[doc = "Field `PENDSET` writer - RW1,PENDSET"] pub type PENDSET_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl W {
#[doc = "Bits 0:3 - RW1,PENDSET"]
#[inline (always)] pub fn pendset (& mut self) -> PENDSET_W < IPSR2_SPEC > { PENDSET_W :: new (self , 0) } }
#[doc = "Interrupt Pending Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ipsr2::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPSR2_SPEC ; impl crate :: RegisterSpec for IPSR2_SPEC { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`ipsr2::W`](W) writer structure"] impl crate :: Writable for IPSR2_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPSR2 to value 0"] impl crate :: Resettable for IPSR2_SPEC { } }
#[doc = "IPRR1 (w) register accessor: Interrupt Pending Clear Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprr1::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprr1`] module"] pub type IPRR1 = crate :: Reg < iprr1 :: IPRR1_SPEC > ;
#[doc = "Interrupt Pending Clear Register"] pub mod iprr1 {
#[doc = "Register `IPRR1` writer"] pub type W = crate :: W < IPRR1_SPEC > ;
#[doc = "Field `PENDRESET` writer - RW1,PENDRESET"] pub type PENDRESET_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 20 , u32 > ; impl W {
#[doc = "Bits 12:31 - RW1,PENDRESET"]
#[inline (always)] pub fn pendreset (& mut self) -> PENDRESET_W < IPRR1_SPEC > { PENDRESET_W :: new (self , 12) } }
#[doc = "Interrupt Pending Clear Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprr1::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRR1_SPEC ; impl crate :: RegisterSpec for IPRR1_SPEC { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`iprr1::W`](W) writer structure"] impl crate :: Writable for IPRR1_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRR1 to value 0"] impl crate :: Resettable for IPRR1_SPEC { } }
#[doc = "IPRR2 (w) register accessor: Interrupt Pending Clear Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprr2::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprr2`] module"] pub type IPRR2 = crate :: Reg < iprr2 :: IPRR2_SPEC > ;
#[doc = "Interrupt Pending Clear Register"] pub mod iprr2 {
#[doc = "Register `IPRR2` writer"] pub type W = crate :: W < IPRR2_SPEC > ;
#[doc = "Field `PENDRESET` writer - RW1,PENDRESET"] pub type PENDRESET_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl W {
#[doc = "Bits 0:3 - RW1,PENDRESET"]
#[inline (always)] pub fn pendreset (& mut self) -> PENDRESET_W < IPRR2_SPEC > { PENDRESET_W :: new (self , 0) } }
#[doc = "Interrupt Pending Clear Register\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprr2::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRR2_SPEC ; impl crate :: RegisterSpec for IPRR2_SPEC { type Ux = u32 ; }
#[doc = "`write(|w| ..)` method takes [`iprr2::W`](W) writer structure"] impl crate :: Writable for IPRR2_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRR2 to value 0"] impl crate :: Resettable for IPRR2_SPEC { } }
#[doc = "IACTR1 (rw) register accessor: Interrupt ACTIVE Register\n\nYou can [`read`](crate::Reg::read) this register and get [`iactr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iactr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iactr1`] module"] pub type IACTR1 = crate :: Reg < iactr1 :: IACTR1_SPEC > ;
#[doc = "Interrupt ACTIVE Register"] pub mod iactr1 {
#[doc = "Register `IACTR1` reader"] pub type R = crate :: R < IACTR1_SPEC > ;
#[doc = "Register `IACTR1` writer"] pub type W = crate :: W < IACTR1_SPEC > ;
#[doc = "Field `IACTS` reader - RW1,IACTS"] pub type IACTS_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IACTS` writer - RW1,IACTS"] pub type IACTS_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 20 , u32 > ; impl R {
#[doc = "Bits 12:31 - RW1,IACTS"]
#[inline (always)] pub fn iacts (& self) -> IACTS_R { IACTS_R :: new ((self . bits >> 12) & 0x000f_ffff) } } impl W {
#[doc = "Bits 12:31 - RW1,IACTS"]
#[inline (always)] pub fn iacts (& mut self) -> IACTS_W < IACTR1_SPEC > { IACTS_W :: new (self , 12) } }
#[doc = "Interrupt ACTIVE Register\n\nYou can [`read`](crate::Reg::read) this register and get [`iactr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iactr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IACTR1_SPEC ; impl crate :: RegisterSpec for IACTR1_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iactr1::R`](R) reader structure"] impl crate :: Readable for IACTR1_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iactr1::W`](W) writer structure"] impl crate :: Writable for IACTR1_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IACTR1 to value 0"] impl crate :: Resettable for IACTR1_SPEC { } }
#[doc = "IACTR2 (rw) register accessor: Interrupt ACTIVE Register\n\nYou can [`read`](crate::Reg::read) this register and get [`iactr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iactr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iactr2`] module"] pub type IACTR2 = crate :: Reg < iactr2 :: IACTR2_SPEC > ;
#[doc = "Interrupt ACTIVE Register"] pub mod iactr2 {
#[doc = "Register `IACTR2` reader"] pub type R = crate :: R < IACTR2_SPEC > ;
#[doc = "Register `IACTR2` writer"] pub type W = crate :: W < IACTR2_SPEC > ;
#[doc = "Field `IACTS` reader - RW1,IACTS"] pub type IACTS_R = crate :: FieldReader ;
#[doc = "Field `IACTS` writer - RW1,IACTS"] pub type IACTS_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R {
#[doc = "Bits 0:3 - RW1,IACTS"]
#[inline (always)] pub fn iacts (& self) -> IACTS_R { IACTS_R :: new ((self . bits & 0x0f) as u8) } } impl W {
#[doc = "Bits 0:3 - RW1,IACTS"]
#[inline (always)] pub fn iacts (& mut self) -> IACTS_W < IACTR2_SPEC > { IACTS_W :: new (self , 0) } }
#[doc = "Interrupt ACTIVE Register\n\nYou can [`read`](crate::Reg::read) this register and get [`iactr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iactr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IACTR2_SPEC ; impl crate :: RegisterSpec for IACTR2_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iactr2::R`](R) reader structure"] impl crate :: Readable for IACTR2_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iactr2::W`](W) writer structure"] impl crate :: Writable for IACTR2_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IACTR2 to value 0"] impl crate :: Resettable for IACTR2_SPEC { } }
#[doc = "IPRIOR0 (rw) register accessor: Interrupt Priority configuration Register 0\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior0`] module"] pub type IPRIOR0 = crate :: Reg < iprior0 :: IPRIOR0_SPEC > ;
#[doc = "Interrupt Priority configuration Register 0"] pub mod iprior0 {
#[doc = "Register `IPRIOR0` reader"] pub type R = crate :: R < IPRIOR0_SPEC > ;
#[doc = "Register `IPRIOR0` writer"] pub type W = crate :: W < IPRIOR0_SPEC > ;
#[doc = "Field `IPRIOR0` reader - RW,Interrupt priority for number 0-3"] pub type IPRIOR0_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR0` writer - RW,Interrupt priority for number 0-3"] pub type IPRIOR0_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 0-3"]
#[inline (always)] pub fn iprior0 (& self) -> IPRIOR0_R { IPRIOR0_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 0-3"]
#[inline (always)] pub fn iprior0 (& mut self) -> IPRIOR0_W < IPRIOR0_SPEC > { IPRIOR0_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 0\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR0_SPEC ; impl crate :: RegisterSpec for IPRIOR0_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior0::R`](R) reader structure"] impl crate :: Readable for IPRIOR0_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior0::W`](W) writer structure"] impl crate :: Writable for IPRIOR0_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR0 to value 0"] impl crate :: Resettable for IPRIOR0_SPEC { } }
#[doc = "IPRIOR1 (rw) register accessor: Interrupt Priority configuration Register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior1`] module"] pub type IPRIOR1 = crate :: Reg < iprior1 :: IPRIOR1_SPEC > ;
#[doc = "Interrupt Priority configuration Register 1"] pub mod iprior1 {
#[doc = "Register `IPRIOR1` reader"] pub type R = crate :: R < IPRIOR1_SPEC > ;
#[doc = "Register `IPRIOR1` writer"] pub type W = crate :: W < IPRIOR1_SPEC > ;
#[doc = "Field `IPRIOR1` reader - >RW,Interrupt priority for number 4-7"] pub type IPRIOR1_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR1` writer - >RW,Interrupt priority for number 4-7"] pub type IPRIOR1_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - >RW,Interrupt priority for number 4-7"]
#[inline (always)] pub fn iprior1 (& self) -> IPRIOR1_R { IPRIOR1_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - >RW,Interrupt priority for number 4-7"]
#[inline (always)] pub fn iprior1 (& mut self) -> IPRIOR1_W < IPRIOR1_SPEC > { IPRIOR1_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 1\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR1_SPEC ; impl crate :: RegisterSpec for IPRIOR1_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior1::R`](R) reader structure"] impl crate :: Readable for IPRIOR1_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior1::W`](W) writer structure"] impl crate :: Writable for IPRIOR1_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR1 to value 0"] impl crate :: Resettable for IPRIOR1_SPEC { } }
#[doc = "IPRIOR2 (rw) register accessor: Interrupt Priority configuration Register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior2`] module"] pub type IPRIOR2 = crate :: Reg < iprior2 :: IPRIOR2_SPEC > ;
#[doc = "Interrupt Priority configuration Register 2"] pub mod iprior2 {
#[doc = "Register `IPRIOR2` reader"] pub type R = crate :: R < IPRIOR2_SPEC > ;
#[doc = "Register `IPRIOR2` writer"] pub type W = crate :: W < IPRIOR2_SPEC > ;
#[doc = "Field `IPRIOR2` reader - >RW,Interrupt priority for number 8-11"] pub type IPRIOR2_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR2` writer - >RW,Interrupt priority for number 8-11"] pub type IPRIOR2_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - >RW,Interrupt priority for number 8-11"]
#[inline (always)] pub fn iprior2 (& self) -> IPRIOR2_R { IPRIOR2_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - >RW,Interrupt priority for number 8-11"]
#[inline (always)] pub fn iprior2 (& mut self) -> IPRIOR2_W < IPRIOR2_SPEC > { IPRIOR2_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 2\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR2_SPEC ; impl crate :: RegisterSpec for IPRIOR2_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior2::R`](R) reader structure"] impl crate :: Readable for IPRIOR2_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior2::W`](W) writer structure"] impl crate :: Writable for IPRIOR2_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR2 to value 0"] impl crate :: Resettable for IPRIOR2_SPEC { } }
#[doc = "IPRIOR3 (rw) register accessor: Interrupt Priority configuration Register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior3`] module"] pub type IPRIOR3 = crate :: Reg < iprior3 :: IPRIOR3_SPEC > ;
#[doc = "Interrupt Priority configuration Register 3"] pub mod iprior3 {
#[doc = "Register `IPRIOR3` reader"] pub type R = crate :: R < IPRIOR3_SPEC > ;
#[doc = "Register `IPRIOR3` writer"] pub type W = crate :: W < IPRIOR3_SPEC > ;
#[doc = "Field `IPRIOR3` reader - >RW,Interrupt priority for number 12-15"] pub type IPRIOR3_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR3` writer - >RW,Interrupt priority for number 12-15"] pub type IPRIOR3_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - >RW,Interrupt priority for number 12-15"]
#[inline (always)] pub fn iprior3 (& self) -> IPRIOR3_R { IPRIOR3_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - >RW,Interrupt priority for number 12-15"]
#[inline (always)] pub fn iprior3 (& mut self) -> IPRIOR3_W < IPRIOR3_SPEC > { IPRIOR3_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 3\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR3_SPEC ; impl crate :: RegisterSpec for IPRIOR3_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior3::R`](R) reader structure"] impl crate :: Readable for IPRIOR3_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior3::W`](W) writer structure"] impl crate :: Writable for IPRIOR3_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR3 to value 0"] impl crate :: Resettable for IPRIOR3_SPEC { } }
#[doc = "IPRIOR4 (rw) register accessor: Interrupt Priority configuration Register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior4`] module"] pub type IPRIOR4 = crate :: Reg < iprior4 :: IPRIOR4_SPEC > ;
#[doc = "Interrupt Priority configuration Register 4"] pub mod iprior4 {
#[doc = "Register `IPRIOR4` reader"] pub type R = crate :: R < IPRIOR4_SPEC > ;
#[doc = "Register `IPRIOR4` writer"] pub type W = crate :: W < IPRIOR4_SPEC > ;
#[doc = "Field `IPRIOR4` reader - >RW,Interrupt priority for number 16-19"] pub type IPRIOR4_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR4` writer - >RW,Interrupt priority for number 16-19"] pub type IPRIOR4_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - >RW,Interrupt priority for number 16-19"]
#[inline (always)] pub fn iprior4 (& self) -> IPRIOR4_R { IPRIOR4_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - >RW,Interrupt priority for number 16-19"]
#[inline (always)] pub fn iprior4 (& mut self) -> IPRIOR4_W < IPRIOR4_SPEC > { IPRIOR4_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 4\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR4_SPEC ; impl crate :: RegisterSpec for IPRIOR4_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior4::R`](R) reader structure"] impl crate :: Readable for IPRIOR4_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior4::W`](W) writer structure"] impl crate :: Writable for IPRIOR4_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR4 to value 0"] impl crate :: Resettable for IPRIOR4_SPEC { } }
#[doc = "IPRIOR5 (rw) register accessor: Interrupt Priority configuration Register 5\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior5`] module"] pub type IPRIOR5 = crate :: Reg < iprior5 :: IPRIOR5_SPEC > ;
#[doc = "Interrupt Priority configuration Register 5"] pub mod iprior5 {
#[doc = "Register `IPRIOR5` reader"] pub type R = crate :: R < IPRIOR5_SPEC > ;
#[doc = "Register `IPRIOR5` writer"] pub type W = crate :: W < IPRIOR5_SPEC > ;
#[doc = "Field `IPRIOR5` reader - >RW,Interrupt priority for number 20-23"] pub type IPRIOR5_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR5` writer - >RW,Interrupt priority for number 20-23"] pub type IPRIOR5_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - >RW,Interrupt priority for number 20-23"]
#[inline (always)] pub fn iprior5 (& self) -> IPRIOR5_R { IPRIOR5_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - >RW,Interrupt priority for number 20-23"]
#[inline (always)] pub fn iprior5 (& mut self) -> IPRIOR5_W < IPRIOR5_SPEC > { IPRIOR5_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 5\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR5_SPEC ; impl crate :: RegisterSpec for IPRIOR5_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior5::R`](R) reader structure"] impl crate :: Readable for IPRIOR5_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior5::W`](W) writer structure"] impl crate :: Writable for IPRIOR5_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR5 to value 0"] impl crate :: Resettable for IPRIOR5_SPEC { } }
#[doc = "IPRIOR6 (rw) register accessor: Interrupt Priority configuration Register 6\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior6`] module"] pub type IPRIOR6 = crate :: Reg < iprior6 :: IPRIOR6_SPEC > ;
#[doc = "Interrupt Priority configuration Register 6"] pub mod iprior6 {
#[doc = "Register `IPRIOR6` reader"] pub type R = crate :: R < IPRIOR6_SPEC > ;
#[doc = "Register `IPRIOR6` writer"] pub type W = crate :: W < IPRIOR6_SPEC > ;
#[doc = "Field `IPRIOR6` reader - >RW,Interrupt priority for number 24-27"] pub type IPRIOR6_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR6` writer - >RW,Interrupt priority for number 24-27"] pub type IPRIOR6_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - >RW,Interrupt priority for number 24-27"]
#[inline (always)] pub fn iprior6 (& self) -> IPRIOR6_R { IPRIOR6_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - >RW,Interrupt priority for number 24-27"]
#[inline (always)] pub fn iprior6 (& mut self) -> IPRIOR6_W < IPRIOR6_SPEC > { IPRIOR6_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 6\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR6_SPEC ; impl crate :: RegisterSpec for IPRIOR6_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior6::R`](R) reader structure"] impl crate :: Readable for IPRIOR6_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior6::W`](W) writer structure"] impl crate :: Writable for IPRIOR6_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR6 to value 0"] impl crate :: Resettable for IPRIOR6_SPEC { } }
#[doc = "IPRIOR7 (rw) register accessor: Interrupt Priority configuration Register 7\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior7`] module"] pub type IPRIOR7 = crate :: Reg < iprior7 :: IPRIOR7_SPEC > ;
#[doc = "Interrupt Priority configuration Register 7"] pub mod iprior7 {
#[doc = "Register `IPRIOR7` reader"] pub type R = crate :: R < IPRIOR7_SPEC > ;
#[doc = "Register `IPRIOR7` writer"] pub type W = crate :: W < IPRIOR7_SPEC > ;
#[doc = "Field `IPRIOR7` reader - >RW,Interrupt priority for number 28-31"] pub type IPRIOR7_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR7` writer - >RW,Interrupt priority for number 28-31"] pub type IPRIOR7_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - >RW,Interrupt priority for number 28-31"]
#[inline (always)] pub fn iprior7 (& self) -> IPRIOR7_R { IPRIOR7_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - >RW,Interrupt priority for number 28-31"]
#[inline (always)] pub fn iprior7 (& mut self) -> IPRIOR7_W < IPRIOR7_SPEC > { IPRIOR7_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 7\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR7_SPEC ; impl crate :: RegisterSpec for IPRIOR7_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior7::R`](R) reader structure"] impl crate :: Readable for IPRIOR7_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior7::W`](W) writer structure"] impl crate :: Writable for IPRIOR7_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR7 to value 0"] impl crate :: Resettable for IPRIOR7_SPEC { } }
#[doc = "IPRIOR8 (rw) register accessor: Interrupt Priority configuration Register 8\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior8::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior8::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior8`] module"] pub type IPRIOR8 = crate :: Reg < iprior8 :: IPRIOR8_SPEC > ;
#[doc = "Interrupt Priority configuration Register 8"] pub mod iprior8 {
#[doc = "Register `IPRIOR8` reader"] pub type R = crate :: R < IPRIOR8_SPEC > ;
#[doc = "Register `IPRIOR8` writer"] pub type W = crate :: W < IPRIOR8_SPEC > ;
#[doc = "Field `IPRIOR8` reader - >RW,Interrupt priority for number 32-35"] pub type IPRIOR8_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR8` writer - >RW,Interrupt priority for number 32-35"] pub type IPRIOR8_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - >RW,Interrupt priority for number 32-35"]
#[inline (always)] pub fn iprior8 (& self) -> IPRIOR8_R { IPRIOR8_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - >RW,Interrupt priority for number 32-35"]
#[inline (always)] pub fn iprior8 (& mut self) -> IPRIOR8_W < IPRIOR8_SPEC > { IPRIOR8_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 8\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior8::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior8::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR8_SPEC ; impl crate :: RegisterSpec for IPRIOR8_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior8::R`](R) reader structure"] impl crate :: Readable for IPRIOR8_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior8::W`](W) writer structure"] impl crate :: Writable for IPRIOR8_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR8 to value 0"] impl crate :: Resettable for IPRIOR8_SPEC { } }
#[doc = "IPRIOR9 (rw) register accessor: Interrupt Priority configuration Register 9\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior9::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior9::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior9`] module"] pub type IPRIOR9 = crate :: Reg < iprior9 :: IPRIOR9_SPEC > ;
#[doc = "Interrupt Priority configuration Register 9"] pub mod iprior9 {
#[doc = "Register `IPRIOR9` reader"] pub type R = crate :: R < IPRIOR9_SPEC > ;
#[doc = "Register `IPRIOR9` writer"] pub type W = crate :: W < IPRIOR9_SPEC > ;
#[doc = "Field `IPRIOR9` reader - >RW,Interrupt priority for number 36-39"] pub type IPRIOR9_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR9` writer - >RW,Interrupt priority for number 36-39"] pub type IPRIOR9_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - >RW,Interrupt priority for number 36-39"]
#[inline (always)] pub fn iprior9 (& self) -> IPRIOR9_R { IPRIOR9_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - >RW,Interrupt priority for number 36-39"]
#[inline (always)] pub fn iprior9 (& mut self) -> IPRIOR9_W < IPRIOR9_SPEC > { IPRIOR9_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 9\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior9::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior9::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR9_SPEC ; impl crate :: RegisterSpec for IPRIOR9_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior9::R`](R) reader structure"] impl crate :: Readable for IPRIOR9_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior9::W`](W) writer structure"] impl crate :: Writable for IPRIOR9_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR9 to value 0"] impl crate :: Resettable for IPRIOR9_SPEC { } }
#[doc = "IPRIOR10 (rw) register accessor: Interrupt Priority configuration Register 10\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior10::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior10::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior10`] module"] pub type IPRIOR10 = crate :: Reg < iprior10 :: IPRIOR10_SPEC > ;
#[doc = "Interrupt Priority configuration Register 10"] pub mod iprior10 {
#[doc = "Register `IPRIOR10` reader"] pub type R = crate :: R < IPRIOR10_SPEC > ;
#[doc = "Register `IPRIOR10` writer"] pub type W = crate :: W < IPRIOR10_SPEC > ;
#[doc = "Field `IPRIOR10` reader - >RW,Interrupt priority for number 40-43"] pub type IPRIOR10_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR10` writer - >RW,Interrupt priority for number 40-43"] pub type IPRIOR10_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - >RW,Interrupt priority for number 40-43"]
#[inline (always)] pub fn iprior10 (& self) -> IPRIOR10_R { IPRIOR10_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - >RW,Interrupt priority for number 40-43"]
#[inline (always)] pub fn iprior10 (& mut self) -> IPRIOR10_W < IPRIOR10_SPEC > { IPRIOR10_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 10\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior10::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior10::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR10_SPEC ; impl crate :: RegisterSpec for IPRIOR10_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior10::R`](R) reader structure"] impl crate :: Readable for IPRIOR10_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior10::W`](W) writer structure"] impl crate :: Writable for IPRIOR10_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR10 to value 0"] impl crate :: Resettable for IPRIOR10_SPEC { } }
#[doc = "IPRIOR11 (rw) register accessor: Interrupt Priority configuration Register 11\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior11::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior11::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior11`] module"] pub type IPRIOR11 = crate :: Reg < iprior11 :: IPRIOR11_SPEC > ;
#[doc = "Interrupt Priority configuration Register 11"] pub mod iprior11 {
#[doc = "Register `IPRIOR11` reader"] pub type R = crate :: R < IPRIOR11_SPEC > ;
#[doc = "Register `IPRIOR11` writer"] pub type W = crate :: W < IPRIOR11_SPEC > ;
#[doc = "Field `IPRIOR11` reader - RW,Interrupt priority for number 44-47"] pub type IPRIOR11_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR11` writer - RW,Interrupt priority for number 44-47"] pub type IPRIOR11_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 44-47"]
#[inline (always)] pub fn iprior11 (& self) -> IPRIOR11_R { IPRIOR11_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 44-47"]
#[inline (always)] pub fn iprior11 (& mut self) -> IPRIOR11_W < IPRIOR11_SPEC > { IPRIOR11_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 11\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior11::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior11::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR11_SPEC ; impl crate :: RegisterSpec for IPRIOR11_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior11::R`](R) reader structure"] impl crate :: Readable for IPRIOR11_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior11::W`](W) writer structure"] impl crate :: Writable for IPRIOR11_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR11 to value 0"] impl crate :: Resettable for IPRIOR11_SPEC { } }
#[doc = "IPRIOR12 (rw) register accessor: Interrupt Priority configuration Register 12\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior12::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior12::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior12`] module"] pub type IPRIOR12 = crate :: Reg < iprior12 :: IPRIOR12_SPEC > ;
#[doc = "Interrupt Priority configuration Register 12"] pub mod iprior12 {
#[doc = "Register `IPRIOR12` reader"] pub type R = crate :: R < IPRIOR12_SPEC > ;
#[doc = "Register `IPRIOR12` writer"] pub type W = crate :: W < IPRIOR12_SPEC > ;
#[doc = "Field `IPRIOR12` reader - RW,Interrupt priority for number 48-51"] pub type IPRIOR12_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR12` writer - RW,Interrupt priority for number 48-51"] pub type IPRIOR12_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 48-51"]
#[inline (always)] pub fn iprior12 (& self) -> IPRIOR12_R { IPRIOR12_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 48-51"]
#[inline (always)] pub fn iprior12 (& mut self) -> IPRIOR12_W < IPRIOR12_SPEC > { IPRIOR12_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 12\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior12::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior12::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR12_SPEC ; impl crate :: RegisterSpec for IPRIOR12_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior12::R`](R) reader structure"] impl crate :: Readable for IPRIOR12_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior12::W`](W) writer structure"] impl crate :: Writable for IPRIOR12_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR12 to value 0"] impl crate :: Resettable for IPRIOR12_SPEC { } }
#[doc = "IPRIOR13 (rw) register accessor: Interrupt Priority configuration Register 13\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior13::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior13::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior13`] module"] pub type IPRIOR13 = crate :: Reg < iprior13 :: IPRIOR13_SPEC > ;
#[doc = "Interrupt Priority configuration Register 13"] pub mod iprior13 {
#[doc = "Register `IPRIOR13` reader"] pub type R = crate :: R < IPRIOR13_SPEC > ;
#[doc = "Register `IPRIOR13` writer"] pub type W = crate :: W < IPRIOR13_SPEC > ;
#[doc = "Field `IPRIOR13` reader - RW,Interrupt priority for number 52-55"] pub type IPRIOR13_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR13` writer - RW,Interrupt priority for number 52-55"] pub type IPRIOR13_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 52-55"]
#[inline (always)] pub fn iprior13 (& self) -> IPRIOR13_R { IPRIOR13_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 52-55"]
#[inline (always)] pub fn iprior13 (& mut self) -> IPRIOR13_W < IPRIOR13_SPEC > { IPRIOR13_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 13\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior13::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior13::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR13_SPEC ; impl crate :: RegisterSpec for IPRIOR13_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior13::R`](R) reader structure"] impl crate :: Readable for IPRIOR13_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior13::W`](W) writer structure"] impl crate :: Writable for IPRIOR13_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR13 to value 0"] impl crate :: Resettable for IPRIOR13_SPEC { } }
#[doc = "IPRIOR14 (rw) register accessor: Interrupt Priority configuration Register 14\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior14::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior14::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior14`] module"] pub type IPRIOR14 = crate :: Reg < iprior14 :: IPRIOR14_SPEC > ;
#[doc = "Interrupt Priority configuration Register 14"] pub mod iprior14 {
#[doc = "Register `IPRIOR14` reader"] pub type R = crate :: R < IPRIOR14_SPEC > ;
#[doc = "Register `IPRIOR14` writer"] pub type W = crate :: W < IPRIOR14_SPEC > ;
#[doc = "Field `IPRIOR14` reader - RW,Interrupt priority for number 56-59"] pub type IPRIOR14_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR14` writer - RW,Interrupt priority for number 56-59"] pub type IPRIOR14_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 56-59"]
#[inline (always)] pub fn iprior14 (& self) -> IPRIOR14_R { IPRIOR14_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 56-59"]
#[inline (always)] pub fn iprior14 (& mut self) -> IPRIOR14_W < IPRIOR14_SPEC > { IPRIOR14_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 14\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior14::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior14::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR14_SPEC ; impl crate :: RegisterSpec for IPRIOR14_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior14::R`](R) reader structure"] impl crate :: Readable for IPRIOR14_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior14::W`](W) writer structure"] impl crate :: Writable for IPRIOR14_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR14 to value 0"] impl crate :: Resettable for IPRIOR14_SPEC { } }
#[doc = "IPRIOR15 (rw) register accessor: Interrupt Priority configuration Register 15\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior15::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior15::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior15`] module"] pub type IPRIOR15 = crate :: Reg < iprior15 :: IPRIOR15_SPEC > ;
#[doc = "Interrupt Priority configuration Register 15"] pub mod iprior15 {
#[doc = "Register `IPRIOR15` reader"] pub type R = crate :: R < IPRIOR15_SPEC > ;
#[doc = "Register `IPRIOR15` writer"] pub type W = crate :: W < IPRIOR15_SPEC > ;
#[doc = "Field `IPRIOR15` reader - RW,Interrupt priority for number 60-63"] pub type IPRIOR15_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR15` writer - RW,Interrupt priority for number 60-63"] pub type IPRIOR15_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 60-63"]
#[inline (always)] pub fn iprior15 (& self) -> IPRIOR15_R { IPRIOR15_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 60-63"]
#[inline (always)] pub fn iprior15 (& mut self) -> IPRIOR15_W < IPRIOR15_SPEC > { IPRIOR15_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 15\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior15::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior15::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR15_SPEC ; impl crate :: RegisterSpec for IPRIOR15_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior15::R`](R) reader structure"] impl crate :: Readable for IPRIOR15_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior15::W`](W) writer structure"] impl crate :: Writable for IPRIOR15_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR15 to value 0"] impl crate :: Resettable for IPRIOR15_SPEC { } }
#[doc = "IPRIOR16 (rw) register accessor: Interrupt Priority configuration Register 16\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior16::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior16::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior16`] module"] pub type IPRIOR16 = crate :: Reg < iprior16 :: IPRIOR16_SPEC > ;
#[doc = "Interrupt Priority configuration Register 16"] pub mod iprior16 {
#[doc = "Register `IPRIOR16` reader"] pub type R = crate :: R < IPRIOR16_SPEC > ;
#[doc = "Register `IPRIOR16` writer"] pub type W = crate :: W < IPRIOR16_SPEC > ;
#[doc = "Field `IPRIOR16` reader - RW,Interrupt priority for number 64-67"] pub type IPRIOR16_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR16` writer - RW,Interrupt priority for number 64-67"] pub type IPRIOR16_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 64-67"]
#[inline (always)] pub fn iprior16 (& self) -> IPRIOR16_R { IPRIOR16_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 64-67"]
#[inline (always)] pub fn iprior16 (& mut self) -> IPRIOR16_W < IPRIOR16_SPEC > { IPRIOR16_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 16\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior16::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior16::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR16_SPEC ; impl crate :: RegisterSpec for IPRIOR16_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior16::R`](R) reader structure"] impl crate :: Readable for IPRIOR16_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior16::W`](W) writer structure"] impl crate :: Writable for IPRIOR16_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR16 to value 0"] impl crate :: Resettable for IPRIOR16_SPEC { } }
#[doc = "IPRIOR17 (rw) register accessor: Interrupt Priority configuration Register 17\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior17::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior17::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior17`] module"] pub type IPRIOR17 = crate :: Reg < iprior17 :: IPRIOR17_SPEC > ;
#[doc = "Interrupt Priority configuration Register 17"] pub mod iprior17 {
#[doc = "Register `IPRIOR17` reader"] pub type R = crate :: R < IPRIOR17_SPEC > ;
#[doc = "Register `IPRIOR17` writer"] pub type W = crate :: W < IPRIOR17_SPEC > ;
#[doc = "Field `IPRIOR17` reader - RW,Interrupt priority for number 68-71"] pub type IPRIOR17_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR17` writer - RW,Interrupt priority for number 68-71"] pub type IPRIOR17_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 68-71"]
#[inline (always)] pub fn iprior17 (& self) -> IPRIOR17_R { IPRIOR17_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 68-71"]
#[inline (always)] pub fn iprior17 (& mut self) -> IPRIOR17_W < IPRIOR17_SPEC > { IPRIOR17_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 17\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior17::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior17::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR17_SPEC ; impl crate :: RegisterSpec for IPRIOR17_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior17::R`](R) reader structure"] impl crate :: Readable for IPRIOR17_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior17::W`](W) writer structure"] impl crate :: Writable for IPRIOR17_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR17 to value 0"] impl crate :: Resettable for IPRIOR17_SPEC { } }
#[doc = "IPRIOR18 (rw) register accessor: Interrupt Priority configuration Register 18\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior18::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior18::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior18`] module"] pub type IPRIOR18 = crate :: Reg < iprior18 :: IPRIOR18_SPEC > ;
#[doc = "Interrupt Priority configuration Register 18"] pub mod iprior18 {
#[doc = "Register `IPRIOR18` reader"] pub type R = crate :: R < IPRIOR18_SPEC > ;
#[doc = "Register `IPRIOR18` writer"] pub type W = crate :: W < IPRIOR18_SPEC > ;
#[doc = "Field `IPRIOR18` reader - RW,Interrupt priority for number 72-75"] pub type IPRIOR18_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR18` writer - RW,Interrupt priority for number 72-75"] pub type IPRIOR18_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 72-75"]
#[inline (always)] pub fn iprior18 (& self) -> IPRIOR18_R { IPRIOR18_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 72-75"]
#[inline (always)] pub fn iprior18 (& mut self) -> IPRIOR18_W < IPRIOR18_SPEC > { IPRIOR18_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 18\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior18::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior18::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR18_SPEC ; impl crate :: RegisterSpec for IPRIOR18_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior18::R`](R) reader structure"] impl crate :: Readable for IPRIOR18_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior18::W`](W) writer structure"] impl crate :: Writable for IPRIOR18_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR18 to value 0"] impl crate :: Resettable for IPRIOR18_SPEC { } }
#[doc = "IPRIOR19 (rw) register accessor: Interrupt Priority configuration Register 19\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior19::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior19::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior19`] module"] pub type IPRIOR19 = crate :: Reg < iprior19 :: IPRIOR19_SPEC > ;
#[doc = "Interrupt Priority configuration Register 19"] pub mod iprior19 {
#[doc = "Register `IPRIOR19` reader"] pub type R = crate :: R < IPRIOR19_SPEC > ;
#[doc = "Register `IPRIOR19` writer"] pub type W = crate :: W < IPRIOR19_SPEC > ;
#[doc = "Field `IPRIOR19` reader - RW,Interrupt priority for number 76-79"] pub type IPRIOR19_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR19` writer - RW,Interrupt priority for number 76-79"] pub type IPRIOR19_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 76-79"]
#[inline (always)] pub fn iprior19 (& self) -> IPRIOR19_R { IPRIOR19_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 76-79"]
#[inline (always)] pub fn iprior19 (& mut self) -> IPRIOR19_W < IPRIOR19_SPEC > { IPRIOR19_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 19\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior19::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior19::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR19_SPEC ; impl crate :: RegisterSpec for IPRIOR19_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior19::R`](R) reader structure"] impl crate :: Readable for IPRIOR19_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior19::W`](W) writer structure"] impl crate :: Writable for IPRIOR19_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR19 to value 0"] impl crate :: Resettable for IPRIOR19_SPEC { } }
#[doc = "IPRIOR20 (rw) register accessor: Interrupt Priority configuration Register 20\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior20::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior20::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior20`] module"] pub type IPRIOR20 = crate :: Reg < iprior20 :: IPRIOR20_SPEC > ;
#[doc = "Interrupt Priority configuration Register 20"] pub mod iprior20 {
#[doc = "Register `IPRIOR20` reader"] pub type R = crate :: R < IPRIOR20_SPEC > ;
#[doc = "Register `IPRIOR20` writer"] pub type W = crate :: W < IPRIOR20_SPEC > ;
#[doc = "Field `IPRIOR20` reader - RW,RW,Interrupt priority for number 80-83"] pub type IPRIOR20_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR20` writer - RW,RW,Interrupt priority for number 80-83"] pub type IPRIOR20_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,RW,Interrupt priority for number 80-83"]
#[inline (always)] pub fn iprior20 (& self) -> IPRIOR20_R { IPRIOR20_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,RW,Interrupt priority for number 80-83"]
#[inline (always)] pub fn iprior20 (& mut self) -> IPRIOR20_W < IPRIOR20_SPEC > { IPRIOR20_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 20\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior20::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior20::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR20_SPEC ; impl crate :: RegisterSpec for IPRIOR20_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior20::R`](R) reader structure"] impl crate :: Readable for IPRIOR20_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior20::W`](W) writer structure"] impl crate :: Writable for IPRIOR20_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR20 to value 0"] impl crate :: Resettable for IPRIOR20_SPEC { } }
#[doc = "IPRIOR21 (rw) register accessor: Interrupt Priority configuration Register 21\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior21::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior21::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior21`] module"] pub type IPRIOR21 = crate :: Reg < iprior21 :: IPRIOR21_SPEC > ;
#[doc = "Interrupt Priority configuration Register 21"] pub mod iprior21 {
#[doc = "Register `IPRIOR21` reader"] pub type R = crate :: R < IPRIOR21_SPEC > ;
#[doc = "Register `IPRIOR21` writer"] pub type W = crate :: W < IPRIOR21_SPEC > ;
#[doc = "Field `IPRIOR21` reader - RW,Interrupt priority for number 84-87"] pub type IPRIOR21_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR21` writer - RW,Interrupt priority for number 84-87"] pub type IPRIOR21_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 84-87"]
#[inline (always)] pub fn iprior21 (& self) -> IPRIOR21_R { IPRIOR21_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 84-87"]
#[inline (always)] pub fn iprior21 (& mut self) -> IPRIOR21_W < IPRIOR21_SPEC > { IPRIOR21_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 21\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior21::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior21::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR21_SPEC ; impl crate :: RegisterSpec for IPRIOR21_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior21::R`](R) reader structure"] impl crate :: Readable for IPRIOR21_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior21::W`](W) writer structure"] impl crate :: Writable for IPRIOR21_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR21 to value 0"] impl crate :: Resettable for IPRIOR21_SPEC { } }
#[doc = "IPRIOR22 (rw) register accessor: Interrupt Priority configuration Register 22\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior22::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior22::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior22`] module"] pub type IPRIOR22 = crate :: Reg < iprior22 :: IPRIOR22_SPEC > ;
#[doc = "Interrupt Priority configuration Register 22"] pub mod iprior22 {
#[doc = "Register `IPRIOR22` reader"] pub type R = crate :: R < IPRIOR22_SPEC > ;
#[doc = "Register `IPRIOR22` writer"] pub type W = crate :: W < IPRIOR22_SPEC > ;
#[doc = "Field `IPRIOR22` reader - RW,Interrupt priority for number 88-91"] pub type IPRIOR22_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR22` writer - RW,Interrupt priority for number 88-91"] pub type IPRIOR22_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 88-91"]
#[inline (always)] pub fn iprior22 (& self) -> IPRIOR22_R { IPRIOR22_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 88-91"]
#[inline (always)] pub fn iprior22 (& mut self) -> IPRIOR22_W < IPRIOR22_SPEC > { IPRIOR22_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 22\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior22::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior22::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR22_SPEC ; impl crate :: RegisterSpec for IPRIOR22_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior22::R`](R) reader structure"] impl crate :: Readable for IPRIOR22_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior22::W`](W) writer structure"] impl crate :: Writable for IPRIOR22_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR22 to value 0"] impl crate :: Resettable for IPRIOR22_SPEC { } }
#[doc = "IPRIOR23 (rw) register accessor: Interrupt Priority configuration Register 23\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior23::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior23::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior23`] module"] pub type IPRIOR23 = crate :: Reg < iprior23 :: IPRIOR23_SPEC > ;
#[doc = "Interrupt Priority configuration Register 23"] pub mod iprior23 {
#[doc = "Register `IPRIOR23` reader"] pub type R = crate :: R < IPRIOR23_SPEC > ;
#[doc = "Register `IPRIOR23` writer"] pub type W = crate :: W < IPRIOR23_SPEC > ;
#[doc = "Field `IPRIOR23` reader - RW,Interrupt priority for number 92-95"] pub type IPRIOR23_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR23` writer - RW,Interrupt priority for number 92-95"] pub type IPRIOR23_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 92-95"]
#[inline (always)] pub fn iprior23 (& self) -> IPRIOR23_R { IPRIOR23_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 92-95"]
#[inline (always)] pub fn iprior23 (& mut self) -> IPRIOR23_W < IPRIOR23_SPEC > { IPRIOR23_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 23\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior23::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior23::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR23_SPEC ; impl crate :: RegisterSpec for IPRIOR23_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior23::R`](R) reader structure"] impl crate :: Readable for IPRIOR23_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior23::W`](W) writer structure"] impl crate :: Writable for IPRIOR23_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR23 to value 0"] impl crate :: Resettable for IPRIOR23_SPEC { } }
#[doc = "IPRIOR24 (rw) register accessor: Interrupt Priority configuration Register 24\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior24::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior24::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior24`] module"] pub type IPRIOR24 = crate :: Reg < iprior24 :: IPRIOR24_SPEC > ;
#[doc = "Interrupt Priority configuration Register 24"] pub mod iprior24 {
#[doc = "Register `IPRIOR24` reader"] pub type R = crate :: R < IPRIOR24_SPEC > ;
#[doc = "Register `IPRIOR24` writer"] pub type W = crate :: W < IPRIOR24_SPEC > ;
#[doc = "Field `IPRIOR24` reader - RW,Interrupt priority for number 96-99"] pub type IPRIOR24_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR24` writer - RW,Interrupt priority for number 96-99"] pub type IPRIOR24_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 96-99"]
#[inline (always)] pub fn iprior24 (& self) -> IPRIOR24_R { IPRIOR24_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 96-99"]
#[inline (always)] pub fn iprior24 (& mut self) -> IPRIOR24_W < IPRIOR24_SPEC > { IPRIOR24_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 24\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior24::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior24::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR24_SPEC ; impl crate :: RegisterSpec for IPRIOR24_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior24::R`](R) reader structure"] impl crate :: Readable for IPRIOR24_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior24::W`](W) writer structure"] impl crate :: Writable for IPRIOR24_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR24 to value 0"] impl crate :: Resettable for IPRIOR24_SPEC { } }
#[doc = "IPRIOR25 (rw) register accessor: Interrupt Priority configuration Register 25\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior25::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior25::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior25`] module"] pub type IPRIOR25 = crate :: Reg < iprior25 :: IPRIOR25_SPEC > ;
#[doc = "Interrupt Priority configuration Register 25"] pub mod iprior25 {
#[doc = "Register `IPRIOR25` reader"] pub type R = crate :: R < IPRIOR25_SPEC > ;
#[doc = "Register `IPRIOR25` writer"] pub type W = crate :: W < IPRIOR25_SPEC > ;
#[doc = "Field `IPRIOR25` reader - RW,Interrupt priority for number 100-103"] pub type IPRIOR25_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR25` writer - RW,Interrupt priority for number 100-103"] pub type IPRIOR25_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 100-103"]
#[inline (always)] pub fn iprior25 (& self) -> IPRIOR25_R { IPRIOR25_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 100-103"]
#[inline (always)] pub fn iprior25 (& mut self) -> IPRIOR25_W < IPRIOR25_SPEC > { IPRIOR25_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 25\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior25::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior25::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR25_SPEC ; impl crate :: RegisterSpec for IPRIOR25_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior25::R`](R) reader structure"] impl crate :: Readable for IPRIOR25_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior25::W`](W) writer structure"] impl crate :: Writable for IPRIOR25_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR25 to value 0"] impl crate :: Resettable for IPRIOR25_SPEC { } }
#[doc = "IPRIOR26 (rw) register accessor: Interrupt Priority configuration Register 26\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior26::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior26::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior26`] module"] pub type IPRIOR26 = crate :: Reg < iprior26 :: IPRIOR26_SPEC > ;
#[doc = "Interrupt Priority configuration Register 26"] pub mod iprior26 {
#[doc = "Register `IPRIOR26` reader"] pub type R = crate :: R < IPRIOR26_SPEC > ;
#[doc = "Register `IPRIOR26` writer"] pub type W = crate :: W < IPRIOR26_SPEC > ;
#[doc = "Field `IPRIOR26` reader - RW,Interrupt priority for number 104-107"] pub type IPRIOR26_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR26` writer - RW,Interrupt priority for number 104-107"] pub type IPRIOR26_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 104-107"]
#[inline (always)] pub fn iprior26 (& self) -> IPRIOR26_R { IPRIOR26_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 104-107"]
#[inline (always)] pub fn iprior26 (& mut self) -> IPRIOR26_W < IPRIOR26_SPEC > { IPRIOR26_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 26\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior26::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior26::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR26_SPEC ; impl crate :: RegisterSpec for IPRIOR26_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior26::R`](R) reader structure"] impl crate :: Readable for IPRIOR26_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior26::W`](W) writer structure"] impl crate :: Writable for IPRIOR26_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR26 to value 0"] impl crate :: Resettable for IPRIOR26_SPEC { } }
#[doc = "IPRIOR27 (rw) register accessor: Interrupt Priority configuration Register 27\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior27::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior27::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior27`] module"] pub type IPRIOR27 = crate :: Reg < iprior27 :: IPRIOR27_SPEC > ;
#[doc = "Interrupt Priority configuration Register 27"] pub mod iprior27 {
#[doc = "Register `IPRIOR27` reader"] pub type R = crate :: R < IPRIOR27_SPEC > ;
#[doc = "Register `IPRIOR27` writer"] pub type W = crate :: W < IPRIOR27_SPEC > ;
#[doc = "Field `IPRIOR27` reader - RW,Interrupt priority for number 108-111"] pub type IPRIOR27_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR27` writer - RW,Interrupt priority for number 108-111"] pub type IPRIOR27_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 108-111"]
#[inline (always)] pub fn iprior27 (& self) -> IPRIOR27_R { IPRIOR27_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 108-111"]
#[inline (always)] pub fn iprior27 (& mut self) -> IPRIOR27_W < IPRIOR27_SPEC > { IPRIOR27_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 27\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior27::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior27::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR27_SPEC ; impl crate :: RegisterSpec for IPRIOR27_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior27::R`](R) reader structure"] impl crate :: Readable for IPRIOR27_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior27::W`](W) writer structure"] impl crate :: Writable for IPRIOR27_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR27 to value 0"] impl crate :: Resettable for IPRIOR27_SPEC { } }
#[doc = "IPRIOR28 (rw) register accessor: Interrupt Priority configuration Register 28\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior28::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior28::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior28`] module"] pub type IPRIOR28 = crate :: Reg < iprior28 :: IPRIOR28_SPEC > ;
#[doc = "Interrupt Priority configuration Register 28"] pub mod iprior28 {
#[doc = "Register `IPRIOR28` reader"] pub type R = crate :: R < IPRIOR28_SPEC > ;
#[doc = "Register `IPRIOR28` writer"] pub type W = crate :: W < IPRIOR28_SPEC > ;
#[doc = "Field `IPRIOR28` reader - RW,Interrupt priority for number 112-115"] pub type IPRIOR28_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR28` writer - RW,Interrupt priority for number 112-115"] pub type IPRIOR28_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 112-115"]
#[inline (always)] pub fn iprior28 (& self) -> IPRIOR28_R { IPRIOR28_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 112-115"]
#[inline (always)] pub fn iprior28 (& mut self) -> IPRIOR28_W < IPRIOR28_SPEC > { IPRIOR28_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 28\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior28::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior28::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR28_SPEC ; impl crate :: RegisterSpec for IPRIOR28_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior28::R`](R) reader structure"] impl crate :: Readable for IPRIOR28_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior28::W`](W) writer structure"] impl crate :: Writable for IPRIOR28_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR28 to value 0"] impl crate :: Resettable for IPRIOR28_SPEC { } }
#[doc = "IPRIOR29 (rw) register accessor: Interrupt Priority configuration Register 29\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior29::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior29::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior29`] module"] pub type IPRIOR29 = crate :: Reg < iprior29 :: IPRIOR29_SPEC > ;
#[doc = "Interrupt Priority configuration Register 29"] pub mod iprior29 {
#[doc = "Register `IPRIOR29` reader"] pub type R = crate :: R < IPRIOR29_SPEC > ;
#[doc = "Register `IPRIOR29` writer"] pub type W = crate :: W < IPRIOR29_SPEC > ;
#[doc = "Field `IPRIOR29` reader - RW,Interrupt priority for number 116-119"] pub type IPRIOR29_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR29` writer - RW,Interrupt priority for number 116-119"] pub type IPRIOR29_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 116-119"]
#[inline (always)] pub fn iprior29 (& self) -> IPRIOR29_R { IPRIOR29_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 116-119"]
#[inline (always)] pub fn iprior29 (& mut self) -> IPRIOR29_W < IPRIOR29_SPEC > { IPRIOR29_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 29\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior29::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior29::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR29_SPEC ; impl crate :: RegisterSpec for IPRIOR29_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior29::R`](R) reader structure"] impl crate :: Readable for IPRIOR29_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior29::W`](W) writer structure"] impl crate :: Writable for IPRIOR29_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR29 to value 0"] impl crate :: Resettable for IPRIOR29_SPEC { } }
#[doc = "IPRIOR30 (rw) register accessor: Interrupt Priority configuration Register 30\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior30::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior30::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior30`] module"] pub type IPRIOR30 = crate :: Reg < iprior30 :: IPRIOR30_SPEC > ;
#[doc = "Interrupt Priority configuration Register 30"] pub mod iprior30 {
#[doc = "Register `IPRIOR30` reader"] pub type R = crate :: R < IPRIOR30_SPEC > ;
#[doc = "Register `IPRIOR30` writer"] pub type W = crate :: W < IPRIOR30_SPEC > ;
#[doc = "Field `IPRIOR30` reader - RW,Interrupt priority for number 120-123"] pub type IPRIOR30_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR30` writer - RW,Interrupt priority for number 120-123"] pub type IPRIOR30_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 120-123"]
#[inline (always)] pub fn iprior30 (& self) -> IPRIOR30_R { IPRIOR30_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 120-123"]
#[inline (always)] pub fn iprior30 (& mut self) -> IPRIOR30_W < IPRIOR30_SPEC > { IPRIOR30_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 30\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior30::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior30::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR30_SPEC ; impl crate :: RegisterSpec for IPRIOR30_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior30::R`](R) reader structure"] impl crate :: Readable for IPRIOR30_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior30::W`](W) writer structure"] impl crate :: Writable for IPRIOR30_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR30 to value 0"] impl crate :: Resettable for IPRIOR30_SPEC { } }
#[doc = "IPRIOR31 (rw) register accessor: Interrupt Priority configuration Register 31\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior31::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior31::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior31`] module"] pub type IPRIOR31 = crate :: Reg < iprior31 :: IPRIOR31_SPEC > ;
#[doc = "Interrupt Priority configuration Register 31"] pub mod iprior31 {
#[doc = "Register `IPRIOR31` reader"] pub type R = crate :: R < IPRIOR31_SPEC > ;
#[doc = "Register `IPRIOR31` writer"] pub type W = crate :: W < IPRIOR31_SPEC > ;
#[doc = "Field `IPRIOR31` reader - RW,Interrupt priority for number 124-127"] pub type IPRIOR31_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR31` writer - RW,Interrupt priority for number 124-127"] pub type IPRIOR31_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 124-127"]
#[inline (always)] pub fn iprior31 (& self) -> IPRIOR31_R { IPRIOR31_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 124-127"]
#[inline (always)] pub fn iprior31 (& mut self) -> IPRIOR31_W < IPRIOR31_SPEC > { IPRIOR31_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 31\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior31::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior31::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR31_SPEC ; impl crate :: RegisterSpec for IPRIOR31_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior31::R`](R) reader structure"] impl crate :: Readable for IPRIOR31_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior31::W`](W) writer structure"] impl crate :: Writable for IPRIOR31_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR31 to value 0"] impl crate :: Resettable for IPRIOR31_SPEC { } }
#[doc = "IPRIOR32 (rw) register accessor: Interrupt Priority configuration Register 32\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior32::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior32::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior32`] module"] pub type IPRIOR32 = crate :: Reg < iprior32 :: IPRIOR32_SPEC > ;
#[doc = "Interrupt Priority configuration Register 32"] pub mod iprior32 {
#[doc = "Register `IPRIOR32` reader"] pub type R = crate :: R < IPRIOR32_SPEC > ;
#[doc = "Register `IPRIOR32` writer"] pub type W = crate :: W < IPRIOR32_SPEC > ;
#[doc = "Field `IPRIOR32` reader - RW,Interrupt priority for number 128-131"] pub type IPRIOR32_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR32` writer - RW,Interrupt priority for number 128-131"] pub type IPRIOR32_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 128-131"]
#[inline (always)] pub fn iprior32 (& self) -> IPRIOR32_R { IPRIOR32_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 128-131"]
#[inline (always)] pub fn iprior32 (& mut self) -> IPRIOR32_W < IPRIOR32_SPEC > { IPRIOR32_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 32\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior32::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior32::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR32_SPEC ; impl crate :: RegisterSpec for IPRIOR32_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior32::R`](R) reader structure"] impl crate :: Readable for IPRIOR32_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior32::W`](W) writer structure"] impl crate :: Writable for IPRIOR32_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR32 to value 0"] impl crate :: Resettable for IPRIOR32_SPEC { } }
#[doc = "IPRIOR33 (rw) register accessor: Interrupt Priority configuration Register 33\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior33::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior33::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior33`] module"] pub type IPRIOR33 = crate :: Reg < iprior33 :: IPRIOR33_SPEC > ;
#[doc = "Interrupt Priority configuration Register 33"] pub mod iprior33 {
#[doc = "Register `IPRIOR33` reader"] pub type R = crate :: R < IPRIOR33_SPEC > ;
#[doc = "Register `IPRIOR33` writer"] pub type W = crate :: W < IPRIOR33_SPEC > ;
#[doc = "Field `IPRIOR33` reader - RW,Interrupt priority for number 132-135"] pub type IPRIOR33_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR33` writer - RW,Interrupt priority for number 132-135"] pub type IPRIOR33_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 132-135"]
#[inline (always)] pub fn iprior33 (& self) -> IPRIOR33_R { IPRIOR33_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 132-135"]
#[inline (always)] pub fn iprior33 (& mut self) -> IPRIOR33_W < IPRIOR33_SPEC > { IPRIOR33_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 33\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior33::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior33::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR33_SPEC ; impl crate :: RegisterSpec for IPRIOR33_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior33::R`](R) reader structure"] impl crate :: Readable for IPRIOR33_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior33::W`](W) writer structure"] impl crate :: Writable for IPRIOR33_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR33 to value 0"] impl crate :: Resettable for IPRIOR33_SPEC { } }
#[doc = "IPRIOR34 (rw) register accessor: Interrupt Priority configuration Register 34\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior34::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior34::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior34`] module"] pub type IPRIOR34 = crate :: Reg < iprior34 :: IPRIOR34_SPEC > ;
#[doc = "Interrupt Priority configuration Register 34"] pub mod iprior34 {
#[doc = "Register `IPRIOR34` reader"] pub type R = crate :: R < IPRIOR34_SPEC > ;
#[doc = "Register `IPRIOR34` writer"] pub type W = crate :: W < IPRIOR34_SPEC > ;
#[doc = "Field `IPRIOR34` reader - RW,Interrupt priority for number 136-139"] pub type IPRIOR34_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR34` writer - RW,Interrupt priority for number 136-139"] pub type IPRIOR34_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 136-139"]
#[inline (always)] pub fn iprior34 (& self) -> IPRIOR34_R { IPRIOR34_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 136-139"]
#[inline (always)] pub fn iprior34 (& mut self) -> IPRIOR34_W < IPRIOR34_SPEC > { IPRIOR34_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 34\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior34::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior34::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR34_SPEC ; impl crate :: RegisterSpec for IPRIOR34_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior34::R`](R) reader structure"] impl crate :: Readable for IPRIOR34_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior34::W`](W) writer structure"] impl crate :: Writable for IPRIOR34_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR34 to value 0"] impl crate :: Resettable for IPRIOR34_SPEC { } }
#[doc = "IPRIOR35 (rw) register accessor: Interrupt Priority configuration Register 35\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior35::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior35::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior35`] module"] pub type IPRIOR35 = crate :: Reg < iprior35 :: IPRIOR35_SPEC > ;
#[doc = "Interrupt Priority configuration Register 35"] pub mod iprior35 {
#[doc = "Register `IPRIOR35` reader"] pub type R = crate :: R < IPRIOR35_SPEC > ;
#[doc = "Register `IPRIOR35` writer"] pub type W = crate :: W < IPRIOR35_SPEC > ;
#[doc = "Field `IPRIOR35` reader - RW,Interrupt priority for number 140-143"] pub type IPRIOR35_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR35` writer - RW,Interrupt priority for number 140-143"] pub type IPRIOR35_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 140-143"]
#[inline (always)] pub fn iprior35 (& self) -> IPRIOR35_R { IPRIOR35_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 140-143"]
#[inline (always)] pub fn iprior35 (& mut self) -> IPRIOR35_W < IPRIOR35_SPEC > { IPRIOR35_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 35\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior35::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior35::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR35_SPEC ; impl crate :: RegisterSpec for IPRIOR35_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior35::R`](R) reader structure"] impl crate :: Readable for IPRIOR35_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior35::W`](W) writer structure"] impl crate :: Writable for IPRIOR35_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR35 to value 0"] impl crate :: Resettable for IPRIOR35_SPEC { } }
#[doc = "IPRIOR36 (rw) register accessor: Interrupt Priority configuration Register 36\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior36::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior36::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior36`] module"] pub type IPRIOR36 = crate :: Reg < iprior36 :: IPRIOR36_SPEC > ;
#[doc = "Interrupt Priority configuration Register 36"] pub mod iprior36 {
#[doc = "Register `IPRIOR36` reader"] pub type R = crate :: R < IPRIOR36_SPEC > ;
#[doc = "Register `IPRIOR36` writer"] pub type W = crate :: W < IPRIOR36_SPEC > ;
#[doc = "Field `IPRIOR36` reader - RW,Interrupt priority for number 144-147"] pub type IPRIOR36_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR36` writer - RW,Interrupt priority for number 144-147"] pub type IPRIOR36_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 144-147"]
#[inline (always)] pub fn iprior36 (& self) -> IPRIOR36_R { IPRIOR36_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 144-147"]
#[inline (always)] pub fn iprior36 (& mut self) -> IPRIOR36_W < IPRIOR36_SPEC > { IPRIOR36_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 36\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior36::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior36::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR36_SPEC ; impl crate :: RegisterSpec for IPRIOR36_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior36::R`](R) reader structure"] impl crate :: Readable for IPRIOR36_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior36::W`](W) writer structure"] impl crate :: Writable for IPRIOR36_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR36 to value 0"] impl crate :: Resettable for IPRIOR36_SPEC { } }
#[doc = "IPRIOR37 (rw) register accessor: Interrupt Priority configuration Register 37\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior37::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior37::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior37`] module"] pub type IPRIOR37 = crate :: Reg < iprior37 :: IPRIOR37_SPEC > ;
#[doc = "Interrupt Priority configuration Register 37"] pub mod iprior37 {
#[doc = "Register `IPRIOR37` reader"] pub type R = crate :: R < IPRIOR37_SPEC > ;
#[doc = "Register `IPRIOR37` writer"] pub type W = crate :: W < IPRIOR37_SPEC > ;
#[doc = "Field `IPRIOR37` reader - RW,Interrupt priority for number 148-151"] pub type IPRIOR37_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR37` writer - RW,Interrupt priority for number 148-151"] pub type IPRIOR37_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 148-151"]
#[inline (always)] pub fn iprior37 (& self) -> IPRIOR37_R { IPRIOR37_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 148-151"]
#[inline (always)] pub fn iprior37 (& mut self) -> IPRIOR37_W < IPRIOR37_SPEC > { IPRIOR37_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 37\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior37::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior37::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR37_SPEC ; impl crate :: RegisterSpec for IPRIOR37_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior37::R`](R) reader structure"] impl crate :: Readable for IPRIOR37_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior37::W`](W) writer structure"] impl crate :: Writable for IPRIOR37_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR37 to value 0"] impl crate :: Resettable for IPRIOR37_SPEC { } }
#[doc = "IPRIOR38 (rw) register accessor: Interrupt Priority configuration Register 38\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior38::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior38::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior38`] module"] pub type IPRIOR38 = crate :: Reg < iprior38 :: IPRIOR38_SPEC > ;
#[doc = "Interrupt Priority configuration Register 38"] pub mod iprior38 {
#[doc = "Register `IPRIOR38` reader"] pub type R = crate :: R < IPRIOR38_SPEC > ;
#[doc = "Register `IPRIOR38` writer"] pub type W = crate :: W < IPRIOR38_SPEC > ;
#[doc = "Field `IPRIOR38` reader - RW,Interrupt priority for number 152-155"] pub type IPRIOR38_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR38` writer - RW,Interrupt priority for number 152-155"] pub type IPRIOR38_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 152-155"]
#[inline (always)] pub fn iprior38 (& self) -> IPRIOR38_R { IPRIOR38_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 152-155"]
#[inline (always)] pub fn iprior38 (& mut self) -> IPRIOR38_W < IPRIOR38_SPEC > { IPRIOR38_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 38\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior38::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior38::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR38_SPEC ; impl crate :: RegisterSpec for IPRIOR38_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior38::R`](R) reader structure"] impl crate :: Readable for IPRIOR38_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior38::W`](W) writer structure"] impl crate :: Writable for IPRIOR38_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR38 to value 0"] impl crate :: Resettable for IPRIOR38_SPEC { } }
#[doc = "IPRIOR39 (rw) register accessor: Interrupt Priority configuration Register 39\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior39::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior39::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior39`] module"] pub type IPRIOR39 = crate :: Reg < iprior39 :: IPRIOR39_SPEC > ;
#[doc = "Interrupt Priority configuration Register 39"] pub mod iprior39 {
#[doc = "Register `IPRIOR39` reader"] pub type R = crate :: R < IPRIOR39_SPEC > ;
#[doc = "Register `IPRIOR39` writer"] pub type W = crate :: W < IPRIOR39_SPEC > ;
#[doc = "Field `IPRIOR39` reader - RW,Interrupt priority for number 156-159"] pub type IPRIOR39_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR39` writer - RW,Interrupt priority for number 156-159"] pub type IPRIOR39_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 156-159"]
#[inline (always)] pub fn iprior39 (& self) -> IPRIOR39_R { IPRIOR39_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 156-159"]
#[inline (always)] pub fn iprior39 (& mut self) -> IPRIOR39_W < IPRIOR39_SPEC > { IPRIOR39_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 39\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior39::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior39::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR39_SPEC ; impl crate :: RegisterSpec for IPRIOR39_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior39::R`](R) reader structure"] impl crate :: Readable for IPRIOR39_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior39::W`](W) writer structure"] impl crate :: Writable for IPRIOR39_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR39 to value 0"] impl crate :: Resettable for IPRIOR39_SPEC { } }
#[doc = "IPRIOR40 (rw) register accessor: Interrupt Priority configuration Register 40\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior40::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior40::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior40`] module"] pub type IPRIOR40 = crate :: Reg < iprior40 :: IPRIOR40_SPEC > ;
#[doc = "Interrupt Priority configuration Register 40"] pub mod iprior40 {
#[doc = "Register `IPRIOR40` reader"] pub type R = crate :: R < IPRIOR40_SPEC > ;
#[doc = "Register `IPRIOR40` writer"] pub type W = crate :: W < IPRIOR40_SPEC > ;
#[doc = "Field `IPRIOR40` reader - RW,Interrupt priority for number 160-163"] pub type IPRIOR40_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR40` writer - RW,Interrupt priority for number 160-163"] pub type IPRIOR40_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 160-163"]
#[inline (always)] pub fn iprior40 (& self) -> IPRIOR40_R { IPRIOR40_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 160-163"]
#[inline (always)] pub fn iprior40 (& mut self) -> IPRIOR40_W < IPRIOR40_SPEC > { IPRIOR40_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 40\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior40::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior40::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR40_SPEC ; impl crate :: RegisterSpec for IPRIOR40_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior40::R`](R) reader structure"] impl crate :: Readable for IPRIOR40_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior40::W`](W) writer structure"] impl crate :: Writable for IPRIOR40_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR40 to value 0"] impl crate :: Resettable for IPRIOR40_SPEC { } }
#[doc = "IPRIOR41 (rw) register accessor: Interrupt Priority configuration Register 41\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior41::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior41::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior41`] module"] pub type IPRIOR41 = crate :: Reg < iprior41 :: IPRIOR41_SPEC > ;
#[doc = "Interrupt Priority configuration Register 41"] pub mod iprior41 {
#[doc = "Register `IPRIOR41` reader"] pub type R = crate :: R < IPRIOR41_SPEC > ;
#[doc = "Register `IPRIOR41` writer"] pub type W = crate :: W < IPRIOR41_SPEC > ;
#[doc = "Field `IPRIOR41` reader - RW,Interrupt priority for number 164-167"] pub type IPRIOR41_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR41` writer - RW,Interrupt priority for number 164-167"] pub type IPRIOR41_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 164-167"]
#[inline (always)] pub fn iprior41 (& self) -> IPRIOR41_R { IPRIOR41_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 164-167"]
#[inline (always)] pub fn iprior41 (& mut self) -> IPRIOR41_W < IPRIOR41_SPEC > { IPRIOR41_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 41\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior41::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior41::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR41_SPEC ; impl crate :: RegisterSpec for IPRIOR41_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior41::R`](R) reader structure"] impl crate :: Readable for IPRIOR41_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior41::W`](W) writer structure"] impl crate :: Writable for IPRIOR41_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR41 to value 0"] impl crate :: Resettable for IPRIOR41_SPEC { } }
#[doc = "IPRIOR42 (rw) register accessor: Interrupt Priority configuration Register 42\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior42::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior42::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior42`] module"] pub type IPRIOR42 = crate :: Reg < iprior42 :: IPRIOR42_SPEC > ;
#[doc = "Interrupt Priority configuration Register 42"] pub mod iprior42 {
#[doc = "Register `IPRIOR42` reader"] pub type R = crate :: R < IPRIOR42_SPEC > ;
#[doc = "Register `IPRIOR42` writer"] pub type W = crate :: W < IPRIOR42_SPEC > ;
#[doc = "Field `IPRIOR42` reader - RW,Interrupt priority for number 168-171"] pub type IPRIOR42_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR42` writer - RW,Interrupt priority for number 168-171"] pub type IPRIOR42_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 168-171"]
#[inline (always)] pub fn iprior42 (& self) -> IPRIOR42_R { IPRIOR42_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 168-171"]
#[inline (always)] pub fn iprior42 (& mut self) -> IPRIOR42_W < IPRIOR42_SPEC > { IPRIOR42_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 42\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior42::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior42::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR42_SPEC ; impl crate :: RegisterSpec for IPRIOR42_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior42::R`](R) reader structure"] impl crate :: Readable for IPRIOR42_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior42::W`](W) writer structure"] impl crate :: Writable for IPRIOR42_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR42 to value 0"] impl crate :: Resettable for IPRIOR42_SPEC { } }
#[doc = "IPRIOR43 (rw) register accessor: Interrupt Priority configuration Register 43\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior43::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior43::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior43`] module"] pub type IPRIOR43 = crate :: Reg < iprior43 :: IPRIOR43_SPEC > ;
#[doc = "Interrupt Priority configuration Register 43"] pub mod iprior43 {
#[doc = "Register `IPRIOR43` reader"] pub type R = crate :: R < IPRIOR43_SPEC > ;
#[doc = "Register `IPRIOR43` writer"] pub type W = crate :: W < IPRIOR43_SPEC > ;
#[doc = "Field `IPRIOR43` reader - RW,Interrupt priority for number 172-175"] pub type IPRIOR43_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR43` writer - RW,Interrupt priority for number 172-175"] pub type IPRIOR43_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 172-175"]
#[inline (always)] pub fn iprior43 (& self) -> IPRIOR43_R { IPRIOR43_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 172-175"]
#[inline (always)] pub fn iprior43 (& mut self) -> IPRIOR43_W < IPRIOR43_SPEC > { IPRIOR43_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 43\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior43::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior43::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR43_SPEC ; impl crate :: RegisterSpec for IPRIOR43_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior43::R`](R) reader structure"] impl crate :: Readable for IPRIOR43_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior43::W`](W) writer structure"] impl crate :: Writable for IPRIOR43_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR43 to value 0"] impl crate :: Resettable for IPRIOR43_SPEC { } }
#[doc = "IPRIOR44 (rw) register accessor: Interrupt Priority configuration Register 44\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior44::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior44::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior44`] module"] pub type IPRIOR44 = crate :: Reg < iprior44 :: IPRIOR44_SPEC > ;
#[doc = "Interrupt Priority configuration Register 44"] pub mod iprior44 {
#[doc = "Register `IPRIOR44` reader"] pub type R = crate :: R < IPRIOR44_SPEC > ;
#[doc = "Register `IPRIOR44` writer"] pub type W = crate :: W < IPRIOR44_SPEC > ;
#[doc = "Field `IPRIOR44` reader - RW,Interrupt priority for number 176-179"] pub type IPRIOR44_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR44` writer - RW,Interrupt priority for number 176-179"] pub type IPRIOR44_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 176-179"]
#[inline (always)] pub fn iprior44 (& self) -> IPRIOR44_R { IPRIOR44_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 176-179"]
#[inline (always)] pub fn iprior44 (& mut self) -> IPRIOR44_W < IPRIOR44_SPEC > { IPRIOR44_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 44\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior44::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior44::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR44_SPEC ; impl crate :: RegisterSpec for IPRIOR44_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior44::R`](R) reader structure"] impl crate :: Readable for IPRIOR44_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior44::W`](W) writer structure"] impl crate :: Writable for IPRIOR44_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR44 to value 0"] impl crate :: Resettable for IPRIOR44_SPEC { } }
#[doc = "IPRIOR45 (rw) register accessor: Interrupt Priority configuration Register 45\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior45::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior45::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior45`] module"] pub type IPRIOR45 = crate :: Reg < iprior45 :: IPRIOR45_SPEC > ;
#[doc = "Interrupt Priority configuration Register 45"] pub mod iprior45 {
#[doc = "Register `IPRIOR45` reader"] pub type R = crate :: R < IPRIOR45_SPEC > ;
#[doc = "Register `IPRIOR45` writer"] pub type W = crate :: W < IPRIOR45_SPEC > ;
#[doc = "Field `IPRIOR45` reader - RW,Interrupt priority for number 180-183"] pub type IPRIOR45_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR45` writer - RW,Interrupt priority for number 180-183"] pub type IPRIOR45_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 180-183"]
#[inline (always)] pub fn iprior45 (& self) -> IPRIOR45_R { IPRIOR45_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 180-183"]
#[inline (always)] pub fn iprior45 (& mut self) -> IPRIOR45_W < IPRIOR45_SPEC > { IPRIOR45_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 45\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior45::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior45::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR45_SPEC ; impl crate :: RegisterSpec for IPRIOR45_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior45::R`](R) reader structure"] impl crate :: Readable for IPRIOR45_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior45::W`](W) writer structure"] impl crate :: Writable for IPRIOR45_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR45 to value 0"] impl crate :: Resettable for IPRIOR45_SPEC { } }
#[doc = "IPRIOR46 (rw) register accessor: Interrupt Priority configuration Register 46\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior46::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior46::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior46`] module"] pub type IPRIOR46 = crate :: Reg < iprior46 :: IPRIOR46_SPEC > ;
#[doc = "Interrupt Priority configuration Register 46"] pub mod iprior46 {
#[doc = "Register `IPRIOR46` reader"] pub type R = crate :: R < IPRIOR46_SPEC > ;
#[doc = "Register `IPRIOR46` writer"] pub type W = crate :: W < IPRIOR46_SPEC > ;
#[doc = "Field `IPRIOR46` reader - RW,Interrupt priority for number 184-187"] pub type IPRIOR46_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR46` writer - RW,Interrupt priority for number 184-187"] pub type IPRIOR46_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 184-187"]
#[inline (always)] pub fn iprior46 (& self) -> IPRIOR46_R { IPRIOR46_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 184-187"]
#[inline (always)] pub fn iprior46 (& mut self) -> IPRIOR46_W < IPRIOR46_SPEC > { IPRIOR46_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 46\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior46::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior46::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR46_SPEC ; impl crate :: RegisterSpec for IPRIOR46_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior46::R`](R) reader structure"] impl crate :: Readable for IPRIOR46_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior46::W`](W) writer structure"] impl crate :: Writable for IPRIOR46_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR46 to value 0"] impl crate :: Resettable for IPRIOR46_SPEC { } }
#[doc = "IPRIOR47 (rw) register accessor: Interrupt Priority configuration Register 47\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior47::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior47::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior47`] module"] pub type IPRIOR47 = crate :: Reg < iprior47 :: IPRIOR47_SPEC > ;
#[doc = "Interrupt Priority configuration Register 47"] pub mod iprior47 {
#[doc = "Register `IPRIOR47` reader"] pub type R = crate :: R < IPRIOR47_SPEC > ;
#[doc = "Register `IPRIOR47` writer"] pub type W = crate :: W < IPRIOR47_SPEC > ;
#[doc = "Field `IPRIOR47` reader - RW,Interrupt priority for number 188-191"] pub type IPRIOR47_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR47` writer - RW,Interrupt priority for number 188-191"] pub type IPRIOR47_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 188-191"]
#[inline (always)] pub fn iprior47 (& self) -> IPRIOR47_R { IPRIOR47_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 188-191"]
#[inline (always)] pub fn iprior47 (& mut self) -> IPRIOR47_W < IPRIOR47_SPEC > { IPRIOR47_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 47\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior47::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior47::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR47_SPEC ; impl crate :: RegisterSpec for IPRIOR47_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior47::R`](R) reader structure"] impl crate :: Readable for IPRIOR47_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior47::W`](W) writer structure"] impl crate :: Writable for IPRIOR47_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR47 to value 0"] impl crate :: Resettable for IPRIOR47_SPEC { } }
#[doc = "IPRIOR48 (rw) register accessor: Interrupt Priority configuration Register 48\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior48::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior48::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior48`] module"] pub type IPRIOR48 = crate :: Reg < iprior48 :: IPRIOR48_SPEC > ;
#[doc = "Interrupt Priority configuration Register 48"] pub mod iprior48 {
#[doc = "Register `IPRIOR48` reader"] pub type R = crate :: R < IPRIOR48_SPEC > ;
#[doc = "Register `IPRIOR48` writer"] pub type W = crate :: W < IPRIOR48_SPEC > ;
#[doc = "Field `IPRIOR48` reader - RW,Interrupt priority for number 192-195"] pub type IPRIOR48_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR48` writer - RW,Interrupt priority for number 192-195"] pub type IPRIOR48_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 192-195"]
#[inline (always)] pub fn iprior48 (& self) -> IPRIOR48_R { IPRIOR48_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 192-195"]
#[inline (always)] pub fn iprior48 (& mut self) -> IPRIOR48_W < IPRIOR48_SPEC > { IPRIOR48_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 48\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior48::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior48::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR48_SPEC ; impl crate :: RegisterSpec for IPRIOR48_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior48::R`](R) reader structure"] impl crate :: Readable for IPRIOR48_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior48::W`](W) writer structure"] impl crate :: Writable for IPRIOR48_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR48 to value 0"] impl crate :: Resettable for IPRIOR48_SPEC { } }
#[doc = "IPRIOR49 (rw) register accessor: Interrupt Priority configuration Register 49\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior49::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior49::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior49`] module"] pub type IPRIOR49 = crate :: Reg < iprior49 :: IPRIOR49_SPEC > ;
#[doc = "Interrupt Priority configuration Register 49"] pub mod iprior49 {
#[doc = "Register `IPRIOR49` reader"] pub type R = crate :: R < IPRIOR49_SPEC > ;
#[doc = "Register `IPRIOR49` writer"] pub type W = crate :: W < IPRIOR49_SPEC > ;
#[doc = "Field `IPRIOR49` reader - RW,Interrupt priority for number 196-199"] pub type IPRIOR49_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR49` writer - RW,Interrupt priority for number 196-199"] pub type IPRIOR49_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 196-199"]
#[inline (always)] pub fn iprior49 (& self) -> IPRIOR49_R { IPRIOR49_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 196-199"]
#[inline (always)] pub fn iprior49 (& mut self) -> IPRIOR49_W < IPRIOR49_SPEC > { IPRIOR49_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 49\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior49::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior49::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR49_SPEC ; impl crate :: RegisterSpec for IPRIOR49_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior49::R`](R) reader structure"] impl crate :: Readable for IPRIOR49_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior49::W`](W) writer structure"] impl crate :: Writable for IPRIOR49_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR49 to value 0"] impl crate :: Resettable for IPRIOR49_SPEC { } }
#[doc = "IPRIOR50 (rw) register accessor: Interrupt Priority configuration Register 50\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior50::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior50::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior50`] module"] pub type IPRIOR50 = crate :: Reg < iprior50 :: IPRIOR50_SPEC > ;
#[doc = "Interrupt Priority configuration Register 50"] pub mod iprior50 {
#[doc = "Register `IPRIOR50` reader"] pub type R = crate :: R < IPRIOR50_SPEC > ;
#[doc = "Register `IPRIOR50` writer"] pub type W = crate :: W < IPRIOR50_SPEC > ;
#[doc = "Field `IPRIOR50` reader - RW,Interrupt priority for number 200-203"] pub type IPRIOR50_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR50` writer - RW,Interrupt priority for number 200-203"] pub type IPRIOR50_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 200-203"]
#[inline (always)] pub fn iprior50 (& self) -> IPRIOR50_R { IPRIOR50_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 200-203"]
#[inline (always)] pub fn iprior50 (& mut self) -> IPRIOR50_W < IPRIOR50_SPEC > { IPRIOR50_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 50\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior50::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior50::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR50_SPEC ; impl crate :: RegisterSpec for IPRIOR50_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior50::R`](R) reader structure"] impl crate :: Readable for IPRIOR50_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior50::W`](W) writer structure"] impl crate :: Writable for IPRIOR50_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR50 to value 0"] impl crate :: Resettable for IPRIOR50_SPEC { } }
#[doc = "IPRIOR51 (rw) register accessor: Interrupt Priority configuration Register 51\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior51::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior51::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior51`] module"] pub type IPRIOR51 = crate :: Reg < iprior51 :: IPRIOR51_SPEC > ;
#[doc = "Interrupt Priority configuration Register 51"] pub mod iprior51 {
#[doc = "Register `IPRIOR51` reader"] pub type R = crate :: R < IPRIOR51_SPEC > ;
#[doc = "Register `IPRIOR51` writer"] pub type W = crate :: W < IPRIOR51_SPEC > ;
#[doc = "Field `IPRIOR51` reader - RW,Interrupt priority for number 204-207"] pub type IPRIOR51_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR51` writer - RW,Interrupt priority for number 204-207"] pub type IPRIOR51_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 204-207"]
#[inline (always)] pub fn iprior51 (& self) -> IPRIOR51_R { IPRIOR51_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 204-207"]
#[inline (always)] pub fn iprior51 (& mut self) -> IPRIOR51_W < IPRIOR51_SPEC > { IPRIOR51_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 51\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior51::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior51::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR51_SPEC ; impl crate :: RegisterSpec for IPRIOR51_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior51::R`](R) reader structure"] impl crate :: Readable for IPRIOR51_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior51::W`](W) writer structure"] impl crate :: Writable for IPRIOR51_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR51 to value 0"] impl crate :: Resettable for IPRIOR51_SPEC { } }
#[doc = "IPRIOR52 (rw) register accessor: Interrupt Priority configuration Register 52\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior52::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior52::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior52`] module"] pub type IPRIOR52 = crate :: Reg < iprior52 :: IPRIOR52_SPEC > ;
#[doc = "Interrupt Priority configuration Register 52"] pub mod iprior52 {
#[doc = "Register `IPRIOR52` reader"] pub type R = crate :: R < IPRIOR52_SPEC > ;
#[doc = "Register `IPRIOR52` writer"] pub type W = crate :: W < IPRIOR52_SPEC > ;
#[doc = "Field `IPRIOR52` reader - RW,Interrupt priority for number 208-211"] pub type IPRIOR52_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR52` writer - RW,Interrupt priority for number 208-211"] pub type IPRIOR52_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 208-211"]
#[inline (always)] pub fn iprior52 (& self) -> IPRIOR52_R { IPRIOR52_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 208-211"]
#[inline (always)] pub fn iprior52 (& mut self) -> IPRIOR52_W < IPRIOR52_SPEC > { IPRIOR52_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 52\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior52::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior52::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR52_SPEC ; impl crate :: RegisterSpec for IPRIOR52_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior52::R`](R) reader structure"] impl crate :: Readable for IPRIOR52_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior52::W`](W) writer structure"] impl crate :: Writable for IPRIOR52_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR52 to value 0"] impl crate :: Resettable for IPRIOR52_SPEC { } }
#[doc = "IPRIOR53 (rw) register accessor: Interrupt Priority configuration Register 53\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior53::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior53::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior53`] module"] pub type IPRIOR53 = crate :: Reg < iprior53 :: IPRIOR53_SPEC > ;
#[doc = "Interrupt Priority configuration Register 53"] pub mod iprior53 {
#[doc = "Register `IPRIOR53` reader"] pub type R = crate :: R < IPRIOR53_SPEC > ;
#[doc = "Register `IPRIOR53` writer"] pub type W = crate :: W < IPRIOR53_SPEC > ;
#[doc = "Field `IPRIOR53` reader - RW,Interrupt priority for number 212-215"] pub type IPRIOR53_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR53` writer - RW,Interrupt priority for number 212-215"] pub type IPRIOR53_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 212-215"]
#[inline (always)] pub fn iprior53 (& self) -> IPRIOR53_R { IPRIOR53_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 212-215"]
#[inline (always)] pub fn iprior53 (& mut self) -> IPRIOR53_W < IPRIOR53_SPEC > { IPRIOR53_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 53\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior53::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior53::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR53_SPEC ; impl crate :: RegisterSpec for IPRIOR53_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior53::R`](R) reader structure"] impl crate :: Readable for IPRIOR53_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior53::W`](W) writer structure"] impl crate :: Writable for IPRIOR53_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR53 to value 0"] impl crate :: Resettable for IPRIOR53_SPEC { } }
#[doc = "IPRIOR54 (rw) register accessor: Interrupt Priority configuration Register 54\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior54::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior54::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior54`] module"] pub type IPRIOR54 = crate :: Reg < iprior54 :: IPRIOR54_SPEC > ;
#[doc = "Interrupt Priority configuration Register 54"] pub mod iprior54 {
#[doc = "Register `IPRIOR54` reader"] pub type R = crate :: R < IPRIOR54_SPEC > ;
#[doc = "Register `IPRIOR54` writer"] pub type W = crate :: W < IPRIOR54_SPEC > ;
#[doc = "Field `IPRIOR54` reader - RW,Interrupt priority for number 216-219"] pub type IPRIOR54_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR54` writer - RW,Interrupt priority for number 216-219"] pub type IPRIOR54_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 216-219"]
#[inline (always)] pub fn iprior54 (& self) -> IPRIOR54_R { IPRIOR54_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 216-219"]
#[inline (always)] pub fn iprior54 (& mut self) -> IPRIOR54_W < IPRIOR54_SPEC > { IPRIOR54_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 54\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior54::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior54::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR54_SPEC ; impl crate :: RegisterSpec for IPRIOR54_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior54::R`](R) reader structure"] impl crate :: Readable for IPRIOR54_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior54::W`](W) writer structure"] impl crate :: Writable for IPRIOR54_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR54 to value 0"] impl crate :: Resettable for IPRIOR54_SPEC { } }
#[doc = "IPRIOR55 (rw) register accessor: Interrupt Priority configuration Register 55\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior55::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior55::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior55`] module"] pub type IPRIOR55 = crate :: Reg < iprior55 :: IPRIOR55_SPEC > ;
#[doc = "Interrupt Priority configuration Register 55"] pub mod iprior55 {
#[doc = "Register `IPRIOR55` reader"] pub type R = crate :: R < IPRIOR55_SPEC > ;
#[doc = "Register `IPRIOR55` writer"] pub type W = crate :: W < IPRIOR55_SPEC > ;
#[doc = "Field `IPRIOR55` reader - RW,Interrupt priority for number 220-223"] pub type IPRIOR55_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR55` writer - RW,Interrupt priority for number 220-223"] pub type IPRIOR55_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 220-223"]
#[inline (always)] pub fn iprior55 (& self) -> IPRIOR55_R { IPRIOR55_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 220-223"]
#[inline (always)] pub fn iprior55 (& mut self) -> IPRIOR55_W < IPRIOR55_SPEC > { IPRIOR55_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 55\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior55::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior55::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR55_SPEC ; impl crate :: RegisterSpec for IPRIOR55_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior55::R`](R) reader structure"] impl crate :: Readable for IPRIOR55_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior55::W`](W) writer structure"] impl crate :: Writable for IPRIOR55_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR55 to value 0"] impl crate :: Resettable for IPRIOR55_SPEC { } }
#[doc = "IPRIOR56 (rw) register accessor: Interrupt Priority configuration Register 56\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior56::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior56::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior56`] module"] pub type IPRIOR56 = crate :: Reg < iprior56 :: IPRIOR56_SPEC > ;
#[doc = "Interrupt Priority configuration Register 56"] pub mod iprior56 {
#[doc = "Register `IPRIOR56` reader"] pub type R = crate :: R < IPRIOR56_SPEC > ;
#[doc = "Register `IPRIOR56` writer"] pub type W = crate :: W < IPRIOR56_SPEC > ;
#[doc = "Field `IPRIOR56` reader - RW,Interrupt priority for number 224-227"] pub type IPRIOR56_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR56` writer - RW,Interrupt priority for number 224-227"] pub type IPRIOR56_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 224-227"]
#[inline (always)] pub fn iprior56 (& self) -> IPRIOR56_R { IPRIOR56_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 224-227"]
#[inline (always)] pub fn iprior56 (& mut self) -> IPRIOR56_W < IPRIOR56_SPEC > { IPRIOR56_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 56\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior56::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior56::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR56_SPEC ; impl crate :: RegisterSpec for IPRIOR56_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior56::R`](R) reader structure"] impl crate :: Readable for IPRIOR56_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior56::W`](W) writer structure"] impl crate :: Writable for IPRIOR56_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR56 to value 0"] impl crate :: Resettable for IPRIOR56_SPEC { } }
#[doc = "IPRIOR57 (rw) register accessor: Interrupt Priority configuration Register 57\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior57::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior57::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior57`] module"] pub type IPRIOR57 = crate :: Reg < iprior57 :: IPRIOR57_SPEC > ;
#[doc = "Interrupt Priority configuration Register 57"] pub mod iprior57 {
#[doc = "Register `IPRIOR57` reader"] pub type R = crate :: R < IPRIOR57_SPEC > ;
#[doc = "Register `IPRIOR57` writer"] pub type W = crate :: W < IPRIOR57_SPEC > ;
#[doc = "Field `IPRIOR57` reader - RW,Interrupt priority for number 228-231"] pub type IPRIOR57_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR57` writer - RW,Interrupt priority for number 228-231"] pub type IPRIOR57_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 228-231"]
#[inline (always)] pub fn iprior57 (& self) -> IPRIOR57_R { IPRIOR57_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 228-231"]
#[inline (always)] pub fn iprior57 (& mut self) -> IPRIOR57_W < IPRIOR57_SPEC > { IPRIOR57_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 57\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior57::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior57::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR57_SPEC ; impl crate :: RegisterSpec for IPRIOR57_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior57::R`](R) reader structure"] impl crate :: Readable for IPRIOR57_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior57::W`](W) writer structure"] impl crate :: Writable for IPRIOR57_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR57 to value 0"] impl crate :: Resettable for IPRIOR57_SPEC { } }
#[doc = "IPRIOR58 (rw) register accessor: Interrupt Priority configuration Register 58\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior58::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior58::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior58`] module"] pub type IPRIOR58 = crate :: Reg < iprior58 :: IPRIOR58_SPEC > ;
#[doc = "Interrupt Priority configuration Register 58"] pub mod iprior58 {
#[doc = "Register `IPRIOR58` reader"] pub type R = crate :: R < IPRIOR58_SPEC > ;
#[doc = "Register `IPRIOR58` writer"] pub type W = crate :: W < IPRIOR58_SPEC > ;
#[doc = "Field `IPRIOR58` reader - RW,Interrupt priority for number 232-235"] pub type IPRIOR58_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR58` writer - RW,Interrupt priority for number 232-235"] pub type IPRIOR58_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 232-235"]
#[inline (always)] pub fn iprior58 (& self) -> IPRIOR58_R { IPRIOR58_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 232-235"]
#[inline (always)] pub fn iprior58 (& mut self) -> IPRIOR58_W < IPRIOR58_SPEC > { IPRIOR58_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 58\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior58::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior58::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR58_SPEC ; impl crate :: RegisterSpec for IPRIOR58_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior58::R`](R) reader structure"] impl crate :: Readable for IPRIOR58_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior58::W`](W) writer structure"] impl crate :: Writable for IPRIOR58_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR58 to value 0"] impl crate :: Resettable for IPRIOR58_SPEC { } }
#[doc = "IPRIOR59 (rw) register accessor: Interrupt Priority configuration Register 59\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior59::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior59::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior59`] module"] pub type IPRIOR59 = crate :: Reg < iprior59 :: IPRIOR59_SPEC > ;
#[doc = "Interrupt Priority configuration Register 59"] pub mod iprior59 {
#[doc = "Register `IPRIOR59` reader"] pub type R = crate :: R < IPRIOR59_SPEC > ;
#[doc = "Register `IPRIOR59` writer"] pub type W = crate :: W < IPRIOR59_SPEC > ;
#[doc = "Field `IPRIOR59` reader - RW,Interrupt priority for number 236-239"] pub type IPRIOR59_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR59` writer - RW,Interrupt priority for number 236-239"] pub type IPRIOR59_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 236-239"]
#[inline (always)] pub fn iprior59 (& self) -> IPRIOR59_R { IPRIOR59_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 236-239"]
#[inline (always)] pub fn iprior59 (& mut self) -> IPRIOR59_W < IPRIOR59_SPEC > { IPRIOR59_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 59\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior59::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior59::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR59_SPEC ; impl crate :: RegisterSpec for IPRIOR59_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior59::R`](R) reader structure"] impl crate :: Readable for IPRIOR59_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior59::W`](W) writer structure"] impl crate :: Writable for IPRIOR59_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR59 to value 0"] impl crate :: Resettable for IPRIOR59_SPEC { } }
#[doc = "IPRIOR60 (rw) register accessor: Interrupt Priority configuration Register 60\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior60::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior60::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior60`] module"] pub type IPRIOR60 = crate :: Reg < iprior60 :: IPRIOR60_SPEC > ;
#[doc = "Interrupt Priority configuration Register 60"] pub mod iprior60 {
#[doc = "Register `IPRIOR60` reader"] pub type R = crate :: R < IPRIOR60_SPEC > ;
#[doc = "Register `IPRIOR60` writer"] pub type W = crate :: W < IPRIOR60_SPEC > ;
#[doc = "Field `IPRIOR60` reader - RW,Interrupt priority for number 240-243"] pub type IPRIOR60_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR60` writer - RW,Interrupt priority for number 240-243"] pub type IPRIOR60_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 240-243"]
#[inline (always)] pub fn iprior60 (& self) -> IPRIOR60_R { IPRIOR60_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 240-243"]
#[inline (always)] pub fn iprior60 (& mut self) -> IPRIOR60_W < IPRIOR60_SPEC > { IPRIOR60_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 60\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior60::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior60::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR60_SPEC ; impl crate :: RegisterSpec for IPRIOR60_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior60::R`](R) reader structure"] impl crate :: Readable for IPRIOR60_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior60::W`](W) writer structure"] impl crate :: Writable for IPRIOR60_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR60 to value 0"] impl crate :: Resettable for IPRIOR60_SPEC { } }
#[doc = "IPRIOR61 (rw) register accessor: Interrupt Priority configuration Register 61\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior61::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior61::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior61`] module"] pub type IPRIOR61 = crate :: Reg < iprior61 :: IPRIOR61_SPEC > ;
#[doc = "Interrupt Priority configuration Register 61"] pub mod iprior61 {
#[doc = "Register `IPRIOR61` reader"] pub type R = crate :: R < IPRIOR61_SPEC > ;
#[doc = "Register `IPRIOR61` writer"] pub type W = crate :: W < IPRIOR61_SPEC > ;
#[doc = "Field `IPRIOR61` reader - RW,Interrupt priority for number 244-247"] pub type IPRIOR61_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR61` writer - RW,Interrupt priority for number 244-247"] pub type IPRIOR61_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 244-247"]
#[inline (always)] pub fn iprior61 (& self) -> IPRIOR61_R { IPRIOR61_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 244-247"]
#[inline (always)] pub fn iprior61 (& mut self) -> IPRIOR61_W < IPRIOR61_SPEC > { IPRIOR61_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 61\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior61::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior61::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR61_SPEC ; impl crate :: RegisterSpec for IPRIOR61_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior61::R`](R) reader structure"] impl crate :: Readable for IPRIOR61_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior61::W`](W) writer structure"] impl crate :: Writable for IPRIOR61_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR61 to value 0"] impl crate :: Resettable for IPRIOR61_SPEC { } }
#[doc = "IPRIOR62 (rw) register accessor: Interrupt Priority configuration Register 62\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior62::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior62::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior62`] module"] pub type IPRIOR62 = crate :: Reg < iprior62 :: IPRIOR62_SPEC > ;
#[doc = "Interrupt Priority configuration Register 62"] pub mod iprior62 {
#[doc = "Register `IPRIOR62` reader"] pub type R = crate :: R < IPRIOR62_SPEC > ;
#[doc = "Register `IPRIOR62` writer"] pub type W = crate :: W < IPRIOR62_SPEC > ;
#[doc = "Field `IPRIOR62` reader - RW,Interrupt priority for number 248-251"] pub type IPRIOR62_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR62` writer - RW,Interrupt priority for number 248-251"] pub type IPRIOR62_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 248-251"]
#[inline (always)] pub fn iprior62 (& self) -> IPRIOR62_R { IPRIOR62_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 248-251"]
#[inline (always)] pub fn iprior62 (& mut self) -> IPRIOR62_W < IPRIOR62_SPEC > { IPRIOR62_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 62\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior62::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior62::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR62_SPEC ; impl crate :: RegisterSpec for IPRIOR62_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior62::R`](R) reader structure"] impl crate :: Readable for IPRIOR62_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior62::W`](W) writer structure"] impl crate :: Writable for IPRIOR62_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR62 to value 0"] impl crate :: Resettable for IPRIOR62_SPEC { } }
#[doc = "IPRIOR63 (rw) register accessor: Interrupt Priority configuration Register 63\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior63::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior63::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@iprior63`] module"] pub type IPRIOR63 = crate :: Reg < iprior63 :: IPRIOR63_SPEC > ;
#[doc = "Interrupt Priority configuration Register 63"] pub mod iprior63 {
#[doc = "Register `IPRIOR63` reader"] pub type R = crate :: R < IPRIOR63_SPEC > ;
#[doc = "Register `IPRIOR63` writer"] pub type W = crate :: W < IPRIOR63_SPEC > ;
#[doc = "Field `IPRIOR63` reader - RW,Interrupt priority for number 252-255"] pub type IPRIOR63_R = crate :: FieldReader < u32 > ;
#[doc = "Field `IPRIOR63` writer - RW,Interrupt priority for number 252-255"] pub type IPRIOR63_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 252-255"]
#[inline (always)] pub fn iprior63 (& self) -> IPRIOR63_R { IPRIOR63_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,Interrupt priority for number 252-255"]
#[inline (always)] pub fn iprior63 (& mut self) -> IPRIOR63_W < IPRIOR63_SPEC > { IPRIOR63_W :: new (self , 0) } }
#[doc = "Interrupt Priority configuration Register 63\n\nYou can [`read`](crate::Reg::read) this register and get [`iprior63::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`iprior63::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct IPRIOR63_SPEC ; impl crate :: RegisterSpec for IPRIOR63_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`iprior63::R`](R) reader structure"] impl crate :: Readable for IPRIOR63_SPEC { }
#[doc = "`write(|w| ..)` method takes [`iprior63::W`](W) writer structure"] impl crate :: Writable for IPRIOR63_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets IPRIOR63 to value 0"] impl crate :: Resettable for IPRIOR63_SPEC { } }
#[doc = "SCTLR (rw) register accessor: System Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`sctlr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sctlr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sctlr`] module"] pub type SCTLR = crate :: Reg < sctlr :: SCTLR_SPEC > ;
#[doc = "System Control Register"] pub mod sctlr {
#[doc = "Register `SCTLR` reader"] pub type R = crate :: R < SCTLR_SPEC > ;
#[doc = "Register `SCTLR` writer"] pub type W = crate :: W < SCTLR_SPEC > ;
#[doc = "Field `SLEEPONEXIT` reader - RW,SLEEPONEXIT"] pub type SLEEPONEXIT_R = crate :: BitReader ;
#[doc = "Field `SLEEPONEXIT` writer - RW,SLEEPONEXIT"] pub type SLEEPONEXIT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SLEEPDEEP` reader - RW,SLEEPDEEP"] pub type SLEEPDEEP_R = crate :: BitReader ;
#[doc = "Field `SLEEPDEEP` writer - RW,SLEEPDEEP"] pub type SLEEPDEEP_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `WFITOWFE` reader - RW,WFITOWFE"] pub type WFITOWFE_R = crate :: BitReader ;
#[doc = "Field `WFITOWFE` writer - RW,WFITOWFE"] pub type WFITOWFE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SEVONPEND` reader - RW,SEVONPEND"] pub type SEVONPEND_R = crate :: BitReader ;
#[doc = "Field `SEVONPEND` writer - RW,SEVONPEND"] pub type SEVONPEND_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SETEVENT` reader - WO,SETEVENT"] pub type SETEVENT_R = crate :: BitReader ;
#[doc = "Field `SETEVENT` writer - WO,SETEVENT"] pub type SETEVENT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 1 - RW,SLEEPONEXIT"]
#[inline (always)] pub fn sleeponexit (& self) -> SLEEPONEXIT_R { SLEEPONEXIT_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - RW,SLEEPDEEP"]
#[inline (always)] pub fn sleepdeep (& self) -> SLEEPDEEP_R { SLEEPDEEP_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - RW,WFITOWFE"]
#[inline (always)] pub fn wfitowfe (& self) -> WFITOWFE_R { WFITOWFE_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - RW,SEVONPEND"]
#[inline (always)] pub fn sevonpend (& self) -> SEVONPEND_R { SEVONPEND_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - WO,SETEVENT"]
#[inline (always)] pub fn setevent (& self) -> SETEVENT_R { SETEVENT_R :: new (((self . bits >> 5) & 1) != 0) } } impl W {
#[doc = "Bit 1 - RW,SLEEPONEXIT"]
#[inline (always)] pub fn sleeponexit (& mut self) -> SLEEPONEXIT_W < SCTLR_SPEC > { SLEEPONEXIT_W :: new (self , 1) }
#[doc = "Bit 2 - RW,SLEEPDEEP"]
#[inline (always)] pub fn sleepdeep (& mut self) -> SLEEPDEEP_W < SCTLR_SPEC > { SLEEPDEEP_W :: new (self , 2) }
#[doc = "Bit 3 - RW,WFITOWFE"]
#[inline (always)] pub fn wfitowfe (& mut self) -> WFITOWFE_W < SCTLR_SPEC > { WFITOWFE_W :: new (self , 3) }
#[doc = "Bit 4 - RW,SEVONPEND"]
#[inline (always)] pub fn sevonpend (& mut self) -> SEVONPEND_W < SCTLR_SPEC > { SEVONPEND_W :: new (self , 4) }
#[doc = "Bit 5 - WO,SETEVENT"]
#[inline (always)] pub fn setevent (& mut self) -> SETEVENT_W < SCTLR_SPEC > { SETEVENT_W :: new (self , 5) } }
#[doc = "System Control Register\n\nYou can [`read`](crate::Reg::read) this register and get [`sctlr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sctlr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SCTLR_SPEC ; impl crate :: RegisterSpec for SCTLR_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`sctlr::R`](R) reader structure"] impl crate :: Readable for SCTLR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`sctlr::W`](W) writer structure"] impl crate :: Writable for SCTLR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SCTLR to value 0"] impl crate :: Resettable for SCTLR_SPEC { } } }
#[doc = "Systick register"] pub type SYSTICK = crate :: Periph < systick :: RegisterBlock , 0xe000_f000 > ; impl core :: fmt :: Debug for SYSTICK { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SYSTICK") . finish () } }
#[doc = "Systick register"] pub mod systick {
#[repr (C)]
#[doc = "Register block"] pub struct RegisterBlock { ctlr : CTLR , sr : SR , cntl : CNTL , cnth : CNTH , cmplr : CMPLR , cmphr : CMPHR , } impl RegisterBlock {
#[doc = "0x00 - Systick counter control register"]
#[inline (always)] pub const fn ctlr (& self) -> & CTLR { & self . ctlr }
#[doc = "0x04 - Systick count status register"]
#[inline (always)] pub const fn sr (& self) -> & SR { & self . sr }
#[doc = "0x08 - Systick counter low register"]
#[inline (always)] pub const fn cntl (& self) -> & CNTL { & self . cntl }
#[doc = "0x0c - Systick counter high register"]
#[inline (always)] pub const fn cnth (& self) -> & CNTH { & self . cnth }
#[doc = "0x10 - Systick compare low register"]
#[inline (always)] pub const fn cmplr (& self) -> & CMPLR { & self . cmplr }
#[doc = "0x14 - Systick compare high register"]
#[inline (always)] pub const fn cmphr (& self) -> & CMPHR { & self . cmphr } }
#[doc = "CTLR (rw) register accessor: Systick counter control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctlr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctlr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctlr`] module"] pub type CTLR = crate :: Reg < ctlr :: CTLR_SPEC > ;
#[doc = "Systick counter control register"] pub mod ctlr {
#[doc = "Register `CTLR` reader"] pub type R = crate :: R < CTLR_SPEC > ;
#[doc = "Register `CTLR` writer"] pub type W = crate :: W < CTLR_SPEC > ;
#[doc = "Field `STE` reader - Systick counter enable"] pub type STE_R = crate :: BitReader ;
#[doc = "Field `STE` writer - Systick counter enable"] pub type STE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STIE` reader - Systick counter interrupt enable"] pub type STIE_R = crate :: BitReader ;
#[doc = "Field `STIE` writer - Systick counter interrupt enable"] pub type STIE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STCLK` reader - System counter clock Source selection"] pub type STCLK_R = crate :: BitReader ;
#[doc = "Field `STCLK` writer - System counter clock Source selection"] pub type STCLK_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `STRE` reader - System counter reload control"] pub type STRE_R = crate :: BitReader ;
#[doc = "Field `STRE` writer - System counter reload control"] pub type STRE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `MODE` reader - counter mode"] pub type MODE_R = crate :: BitReader ;
#[doc = "Field `MODE` writer - counter mode"] pub type MODE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `INIT` reader - Initial counter value updated"] pub type INIT_R = crate :: BitReader ;
#[doc = "Field `INIT` writer - Initial counter value updated"] pub type INIT_W < 'a , REG > = crate :: BitWriter < 'a , REG > ;
#[doc = "Field `SWIE` reader - RW0,System soft interrupt enable"] pub type SWIE_R = crate :: BitReader ;
#[doc = "Field `SWIE` writer - RW0,System soft interrupt enable"] pub type SWIE_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - Systick counter enable"]
#[inline (always)] pub fn ste (& self) -> STE_R { STE_R :: new ((self . bits & 1) != 0) }
#[doc = "Bit 1 - Systick counter interrupt enable"]
#[inline (always)] pub fn stie (& self) -> STIE_R { STIE_R :: new (((self . bits >> 1) & 1) != 0) }
#[doc = "Bit 2 - System counter clock Source selection"]
#[inline (always)] pub fn stclk (& self) -> STCLK_R { STCLK_R :: new (((self . bits >> 2) & 1) != 0) }
#[doc = "Bit 3 - System counter reload control"]
#[inline (always)] pub fn stre (& self) -> STRE_R { STRE_R :: new (((self . bits >> 3) & 1) != 0) }
#[doc = "Bit 4 - counter mode"]
#[inline (always)] pub fn mode (& self) -> MODE_R { MODE_R :: new (((self . bits >> 4) & 1) != 0) }
#[doc = "Bit 5 - Initial counter value updated"]
#[inline (always)] pub fn init (& self) -> INIT_R { INIT_R :: new (((self . bits >> 5) & 1) != 0) }
#[doc = "Bit 31 - RW0,System soft interrupt enable"]
#[inline (always)] pub fn swie (& self) -> SWIE_R { SWIE_R :: new (((self . bits >> 31) & 1) != 0) } } impl W {
#[doc = "Bit 0 - Systick counter enable"]
#[inline (always)] pub fn ste (& mut self) -> STE_W < CTLR_SPEC > { STE_W :: new (self , 0) }
#[doc = "Bit 1 - Systick counter interrupt enable"]
#[inline (always)] pub fn stie (& mut self) -> STIE_W < CTLR_SPEC > { STIE_W :: new (self , 1) }
#[doc = "Bit 2 - System counter clock Source selection"]
#[inline (always)] pub fn stclk (& mut self) -> STCLK_W < CTLR_SPEC > { STCLK_W :: new (self , 2) }
#[doc = "Bit 3 - System counter reload control"]
#[inline (always)] pub fn stre (& mut self) -> STRE_W < CTLR_SPEC > { STRE_W :: new (self , 3) }
#[doc = "Bit 4 - counter mode"]
#[inline (always)] pub fn mode (& mut self) -> MODE_W < CTLR_SPEC > { MODE_W :: new (self , 4) }
#[doc = "Bit 5 - Initial counter value updated"]
#[inline (always)] pub fn init (& mut self) -> INIT_W < CTLR_SPEC > { INIT_W :: new (self , 5) }
#[doc = "Bit 31 - RW0,System soft interrupt enable"]
#[inline (always)] pub fn swie (& mut self) -> SWIE_W < CTLR_SPEC > { SWIE_W :: new (self , 31) } }
#[doc = "Systick counter control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctlr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctlr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CTLR_SPEC ; impl crate :: RegisterSpec for CTLR_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`ctlr::R`](R) reader structure"] impl crate :: Readable for CTLR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`ctlr::W`](W) writer structure"] impl crate :: Writable for CTLR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CTLR to value 0"] impl crate :: Resettable for CTLR_SPEC { } }
#[doc = "SR (rw) register accessor: Systick count status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sr`] module"] pub type SR = crate :: Reg < sr :: SR_SPEC > ;
#[doc = "Systick count status register"] pub mod sr {
#[doc = "Register `SR` reader"] pub type R = crate :: R < SR_SPEC > ;
#[doc = "Register `SR` writer"] pub type W = crate :: W < SR_SPEC > ;
#[doc = "Field `CNTIF` reader - RW,CNTIF"] pub type CNTIF_R = crate :: BitReader ;
#[doc = "Field `CNTIF` writer - RW,CNTIF"] pub type CNTIF_W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R {
#[doc = "Bit 0 - RW,CNTIF"]
#[inline (always)] pub fn cntif (& self) -> CNTIF_R { CNTIF_R :: new ((self . bits & 1) != 0) } } impl W {
#[doc = "Bit 0 - RW,CNTIF"]
#[inline (always)] pub fn cntif (& mut self) -> CNTIF_W < SR_SPEC > { CNTIF_W :: new (self , 0) } }
#[doc = "Systick count status register\n\nYou can [`read`](crate::Reg::read) this register and get [`sr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SR_SPEC ; impl crate :: RegisterSpec for SR_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`sr::R`](R) reader structure"] impl crate :: Readable for SR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`sr::W`](W) writer structure"] impl crate :: Writable for SR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets SR to value 0"] impl crate :: Resettable for SR_SPEC { } }
#[doc = "CNTL (rw) register accessor: Systick counter low register\n\nYou can [`read`](crate::Reg::read) this register and get [`cntl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cntl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cntl`] module"] pub type CNTL = crate :: Reg < cntl :: CNTL_SPEC > ;
#[doc = "Systick counter low register"] pub mod cntl {
#[doc = "Register `CNTL` reader"] pub type R = crate :: R < CNTL_SPEC > ;
#[doc = "Register `CNTL` writer"] pub type W = crate :: W < CNTL_SPEC > ;
#[doc = "Field `CNTL` reader - RW,CNTL"] pub type CNTL_R = crate :: FieldReader < u32 > ;
#[doc = "Field `CNTL` writer - RW,CNTL"] pub type CNTL_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,CNTL"]
#[inline (always)] pub fn cntl (& self) -> CNTL_R { CNTL_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,CNTL"]
#[inline (always)] pub fn cntl (& mut self) -> CNTL_W < CNTL_SPEC > { CNTL_W :: new (self , 0) } }
#[doc = "Systick counter low register\n\nYou can [`read`](crate::Reg::read) this register and get [`cntl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cntl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CNTL_SPEC ; impl crate :: RegisterSpec for CNTL_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`cntl::R`](R) reader structure"] impl crate :: Readable for CNTL_SPEC { }
#[doc = "`write(|w| ..)` method takes [`cntl::W`](W) writer structure"] impl crate :: Writable for CNTL_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNTL to value 0"] impl crate :: Resettable for CNTL_SPEC { } }
#[doc = "CNTH (rw) register accessor: Systick counter high register\n\nYou can [`read`](crate::Reg::read) this register and get [`cnth::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnth::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnth`] module"] pub type CNTH = crate :: Reg < cnth :: CNTH_SPEC > ;
#[doc = "Systick counter high register"] pub mod cnth {
#[doc = "Register `CNTH` reader"] pub type R = crate :: R < CNTH_SPEC > ;
#[doc = "Register `CNTH` writer"] pub type W = crate :: W < CNTH_SPEC > ;
#[doc = "Field `CNTH` reader - RW,CNTH"] pub type CNTH_R = crate :: FieldReader < u32 > ;
#[doc = "Field `CNTH` writer - RW,CNTH"] pub type CNTH_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,CNTH"]
#[inline (always)] pub fn cnth (& self) -> CNTH_R { CNTH_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,CNTH"]
#[inline (always)] pub fn cnth (& mut self) -> CNTH_W < CNTH_SPEC > { CNTH_W :: new (self , 0) } }
#[doc = "Systick counter high register\n\nYou can [`read`](crate::Reg::read) this register and get [`cnth::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnth::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CNTH_SPEC ; impl crate :: RegisterSpec for CNTH_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`cnth::R`](R) reader structure"] impl crate :: Readable for CNTH_SPEC { }
#[doc = "`write(|w| ..)` method takes [`cnth::W`](W) writer structure"] impl crate :: Writable for CNTH_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CNTH to value 0"] impl crate :: Resettable for CNTH_SPEC { } }
#[doc = "CMPLR (rw) register accessor: Systick compare low register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmplr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmplr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmplr`] module"] pub type CMPLR = crate :: Reg < cmplr :: CMPLR_SPEC > ;
#[doc = "Systick compare low register"] pub mod cmplr {
#[doc = "Register `CMPLR` reader"] pub type R = crate :: R < CMPLR_SPEC > ;
#[doc = "Register `CMPLR` writer"] pub type W = crate :: W < CMPLR_SPEC > ;
#[doc = "Field `CMPL` reader - RW,CMPL"] pub type CMPL_R = crate :: FieldReader < u32 > ;
#[doc = "Field `CMPL` writer - RW,CMPL"] pub type CMPL_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,CMPL"]
#[inline (always)] pub fn cmpl (& self) -> CMPL_R { CMPL_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,CMPL"]
#[inline (always)] pub fn cmpl (& mut self) -> CMPL_W < CMPLR_SPEC > { CMPL_W :: new (self , 0) } }
#[doc = "Systick compare low register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmplr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmplr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CMPLR_SPEC ; impl crate :: RegisterSpec for CMPLR_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmplr::R`](R) reader structure"] impl crate :: Readable for CMPLR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`cmplr::W`](W) writer structure"] impl crate :: Writable for CMPLR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMPLR to value 0"] impl crate :: Resettable for CMPLR_SPEC { } }
#[doc = "CMPHR (rw) register accessor: Systick compare high register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmphr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmphr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmphr`] module"] pub type CMPHR = crate :: Reg < cmphr :: CMPHR_SPEC > ;
#[doc = "Systick compare high register"] pub mod cmphr {
#[doc = "Register `CMPHR` reader"] pub type R = crate :: R < CMPHR_SPEC > ;
#[doc = "Register `CMPHR` writer"] pub type W = crate :: W < CMPHR_SPEC > ;
#[doc = "Field `CMPH` reader - RW,CMPH"] pub type CMPH_R = crate :: FieldReader < u32 > ;
#[doc = "Field `CMPH` writer - RW,CMPH"] pub type CMPH_W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R {
#[doc = "Bits 0:31 - RW,CMPH"]
#[inline (always)] pub fn cmph (& self) -> CMPH_R { CMPH_R :: new (self . bits) } } impl W {
#[doc = "Bits 0:31 - RW,CMPH"]
#[inline (always)] pub fn cmph (& mut self) -> CMPH_W < CMPHR_SPEC > { CMPH_W :: new (self , 0) } }
#[doc = "Systick compare high register\n\nYou can [`read`](crate::Reg::read) this register and get [`cmphr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmphr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CMPHR_SPEC ; impl crate :: RegisterSpec for CMPHR_SPEC { type Ux = u32 ; }
#[doc = "`read()` method returns [`cmphr::R`](R) reader structure"] impl crate :: Readable for CMPHR_SPEC { }
#[doc = "`write(|w| ..)` method takes [`cmphr::W`](W) writer structure"] impl crate :: Writable for CMPHR_SPEC { type Safety = crate :: Unsafe ; }
#[doc = "`reset()` method sets CMPHR to value 0"] impl crate :: Resettable for CMPHR_SPEC { } } }
#[no_mangle] static mut DEVICE_PERIPHERALS : bool = false ;
#[doc = r" All the peripherals."]
#[allow (non_snake_case)] pub struct Peripherals {
#[doc = "SYS"] pub SYS : SYS ,
#[doc = "ADC"] pub ADC : ADC ,
#[doc = "GPIOA"] pub GPIOA : GPIOA ,
#[doc = "GPIOB"] pub GPIOB : GPIOB ,
#[doc = "TMR0"] pub TMR0 : TMR0 ,
#[doc = "TMR1"] pub TMR1 : TMR1 ,
#[doc = "TMR2"] pub TMR2 : TMR2 ,
#[doc = "TMR3"] pub TMR3 : TMR3 ,
#[doc = "UART0"] pub UART0 : UART0 ,
#[doc = "UART1"] pub UART1 : UART1 ,
#[doc = "UART2"] pub UART2 : UART2 ,
#[doc = "UART3"] pub UART3 : UART3 ,
#[doc = "SPI0"] pub SPI0 : SPI0 ,
#[doc = "SPI1"] pub SPI1 : SPI1 ,
#[doc = "I2C"] pub I2C : I2C ,
#[doc = "PWMx"] pub PWMX : PWMX ,
#[doc = "USB"] pub USB : USB ,
#[doc = "USB2"] pub USB2 : USB2 ,
#[doc = "PFIC"] pub PFIC : PFIC ,
#[doc = "Systick"] pub SYSTICK : SYSTICK , } impl Peripherals {
#[doc = r" Returns all the peripherals *once*."]
#[cfg (feature = "critical-section")]
#[inline] pub fn take () -> Option < Self > { critical_section :: with (| _ | { if unsafe { DEVICE_PERIPHERALS } { return None } Some (unsafe { Peripherals :: steal () }) }) }
#[doc = r" Unchecked version of `Peripherals::take`."]
#[doc = r""]
#[doc = r" # Safety"]
#[doc = r""]
#[doc = r" Each of the returned peripherals must be used at most once."]
#[inline] pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { SYS : SYS :: steal () , ADC : ADC :: steal () , GPIOA : GPIOA :: steal () , GPIOB : GPIOB :: steal () , TMR0 : TMR0 :: steal () , TMR1 : TMR1 :: steal () , TMR2 : TMR2 :: steal () , TMR3 : TMR3 :: steal () , UART0 : UART0 :: steal () , UART1 : UART1 :: steal () , UART2 : UART2 :: steal () , UART3 : UART3 :: steal () , SPI0 : SPI0 :: steal () , SPI1 : SPI1 :: steal () , I2C : I2C :: steal () , PWMX : PWMX :: steal () , USB : USB :: steal () , USB2 : USB2 :: steal () , PFIC : PFIC :: steal () , SYSTICK : SYSTICK :: steal () , } } }